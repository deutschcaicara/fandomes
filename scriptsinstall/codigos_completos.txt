##### [ .env ] #####
API_KEY=CHAVESEGURA123
MONGO_URI=mongodb://localhost:27017
STRIPE_PUBLIC_KEY=pk_test_51R8LuZP7KDkOXQSM3KJGRFGSlWP8WxD7yAmORxeNfe6pjg1ucx0x7utE02uJMZQJYtfco3lGU5lwZvnKNTuZnWkh00gjuR1tG4
STRIPE_SECRET_KEY=sk_test_51R8LuZP7KDkOXQSM8P3wDqrygSmFoOMzj2Q6m93VlViknpk4prFzuUa9OiDnUdtuIilQLOwcN7x3dyPxCnzl4uZa00NpfVILCA
STRIPE_WEBHOOK_SECRET=whsec_Lj0mUYVFOtrat0wzwmrsgwRmj0fbzyOX
API_KEY=famdomes_master_key
WHATSAPP_API_URL=https://graph.facebook.com/v21.0/113932041697185/messages
WHATSAPP_TOKEN=Bearer EAAI8vbmFTOsBO8ZCwL8VNSSOB6BsbLQozBptFLuOp6zftSkC2Il0r08NdXaxTAIEwqRAjPY98UAB2yNUSwtijFZCm50AIZAm9u2o0elTZADqI34FQZB9ZCNQZCenSwKZC7xem7EJSyP3MNuw8fuXY2LoL9AYneEgoIQ1Ngi0j4DhT53TZBTkGU9wtK6BPjz
WHATSAPP_VERIFY_TOKEN=famdomes_verifica_2024
ROCKETCHAT_TOKEN=XUodf0pje4em5R-okPBIww_8df0QrR9GeQ26jbrrA7E
ROCKETCHAT_USER_ID=nhgxCi4za4G8zCaAB
ROCKETCHAT_URL=http://144.22.142.138:3000
GOOGLE_CLIENT_ID=105232892206-ioli1uphdvlbj98csf1lp65irtnheptf.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
OLLAMA_API_URL=https://goat-musical-early.ngrok-free.app/api/generate
OLLAMA_MODEL=gemma3

##### [ app/config.py ] #####
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")
OLLAMA_API_URL = os.getenv("OLLAMA_URL")
API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")


##### [ app/main.py ] #####
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from routes import ia_comandos


API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("üì• Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp/") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in")
    )
    if is_webhook_externo:
        return await call_next(request)

    chave = request.headers.get("X-API-Key") or request.headers.get("X-API-KEY")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


##### [ app/models/atendimento.py ] #####
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str


##### [ app/models/intents.py ] #####
INTENTS = {
    "ver_agendamento": ["consulta", "marcada", "quando", "hor√°rio"],
    "confirmar_pagamento": ["paguei", "comprei", "recebi", "cad√™"],
    "cancelar_atendimento": ["cancelar", "desistir"],
    "preciso_ajuda": ["socorro", "urgente", "n√£o aguento"],
    "duvida_geral": ["funciona", "o que √©", "como"]
}


##### [ app/models/pagamentos.py ] #####
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str


##### [ app/routes/agendamento.py ] #####
# routes/agendamento.py

from fastapi import APIRouter
from utils.agenda import buscar_proximo_horario
from datetime import datetime

router = APIRouter()

# Simulador de banco tempor√°rio
consultas_agendadas = []

@router.post("/agendar")
def agendar_consulta(telefone: str, nome: str):
    horario = buscar_proximo_horario()
    if not horario:
        return {"erro": "Sem hor√°rios dispon√≠veis"}

    consulta = {
        "nome": nome,
        "telefone": telefone,
        "horario": horario,
        "duracao_min": 20
    }

    consultas_agendadas.append(consulta)

    print(f"[AGENDAMENTO FEITO] {nome} - {telefone} - {horario}")
    print(f"[AVISO M√âDICO] Nova consulta marcada: {nome} √†s {horario}")
    print(f"[MSG PACIENTE] Sua consulta foi marcada para {horario}. O profissional ir√° te chamar por v√≠deo ou mensagem nesse hor√°rio.")

    return {"status": "ok", "horario": horario}


##### [ app/routes/followup.py ] #####


##### [ app/routes/ia.py ] #####
from fastapi import APIRouter, Request
import httpx
import os

router = APIRouter()

OLLAMA_URL = os.getenv("OLLAMA_API_URL", "http://localhost:11434/api/generate")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

@router.post("/ia-in")
async def ia_input(request: Request):
    try:
        dados = await request.json()
        pergunta = dados.get("pergunta")
        telefone = dados.get("telefone")
        nome = dados.get("nome")

        if not pergunta or not telefone:
            return {"erro": "Pergunta ou telefone ausente"}

        payload = {
            "model": OLLAMA_MODEL,
            "prompt": pergunta
        }

        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(OLLAMA_URL, json=payload)

        if response.status_code != 200:
            return {"erro": "Erro na chamada ao modelo IA", "status": response.status_code, "retorno": response.text}

        # Junta as respostas parciais em uma s√≥ string se vier em streaming
        try:
            respostas = response.text.splitlines()
            completo = "".join([eval(linha).get("response", "") for linha in respostas if linha.strip()])
        except:
            completo = response.text

        print(f"üì• Pergunta: {pergunta}\nü§ñ Resposta: {completo}")

        return {
            "status": "ok",
            "resposta": completo,
            "telefone": telefone,
            "nome": nome
        }

    except Exception as e:
        return {"erro": "Erro interno no endpoint IA", "detalhe": str(e)}

##### [ app/routes/ia_comandos.py ] #####
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from utils.followup import iniciar_sessao
import uuid

router = APIRouter()

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)
        payment_id = str(uuid.uuid4())
        link = f"https://famdomes.com.br/pagar/{payment_id}"
        enviar_mensagem(dados.telefone, f"Para agendar sua consulta, clique aqui e realize o pagamento:\n{link}")
        return {"status": "agendamento_iniciado", "link_pagamento": link}

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in cmd:
        horario = consultar_horario()
        enviar_mensagem(dados.telefone, f"Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando n√£o reconhecido.")


##### [ app/routes/pagamentos.py ] #####
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}


##### [ app/routes/painel.py ] #####
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sess√£o est√° confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}


##### [ app/routes/rocketchat.py ] #####
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda n√£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }


##### [ app/routes/stripe.py ] #####
# routes/stripe.py

import stripe
from fastapi import APIRouter, Request
from pydantic import BaseModel
from utils.followup import iniciar_sessao, marcar_pagamento
from config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET

stripe.api_key = STRIPE_SECRET_KEY

router = APIRouter()

class CheckoutData(BaseModel):
    nome: str
    telefone: str

@router.post("/criar-checkout")
def criar_checkout(data: CheckoutData):
    iniciar_sessao(data.telefone, data.nome)

    session = stripe.checkout.Session.create(
        payment_method_types=["card"],
        line_items=[{
            "price_data": {
                "currency": "brl",
                "product_data": {"name": "Consulta FAMDOMES"},
                "unit_amount": 10000  # R$100,00
            },
            "quantity": 1
        }],
        mode="payment",
        success_url="https://famdomes.com.br/sucesso",
        cancel_url="https://famdomes.com.br/cancelado",
        metadata={"telefone": data.telefone}
    )
    return {"checkout_url": session.url}

@router.post("/webhook-stripe")
async def webhook_stripe(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, STRIPE_WEBHOOK_SECRET
        )
    except Exception:
        return {"status": "erro"}

    if event["type"] == "checkout.session.completed":
        telefone = event["data"]["object"]["metadata"]["telefone"]
        marcar_pagamento(telefone)

    return {"status": "ok"}


##### [ app/routes/stripe_webhook.py ] #####
# routes/stripe_webhook.py

from fastapi import APIRouter, Request, Header, HTTPException
import stripe
import json

router = APIRouter()

# üîí Substitua pela sua real chave de verifica√ß√£o
STRIPE_WEBHOOK_SECRET = "whsec_Lj0mUYVFOtrat0wzwmrsgwRmj0fbzyOX"

@router.post("/webhook/stripe")
async def stripe_webhook(
    request: Request,
    stripe_signature: str = Header(None)
):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
    except ValueError as e:
        raise HTTPException(status_code=400, detail=f"Payload inv√°lido: {str(e)}")
    except stripe.error.SignatureVerificationError as e:
        raise HTTPException(status_code=400, detail=f"Assinatura inv√°lida: {str(e)}")

    if event['type'] == 'checkout.session.completed':
        session = event['data']['object']
        telefone = session['metadata'].get("telefone")
        nome = session['metadata'].get("nome")
        payment_id = session.get("id")

        # üß† Aqui entrar√° a l√≥gica de:
        # - salvar no "banco" (ou JSON/localfile) que foi pago
        # - preparar dados para o pr√≥ximo passo: agendamento
        print(f"[Pagamento confirmado] Nome: {nome}, Tel: {telefone}, PaymentID: {payment_id}")

    return {"status": "ok"}


##### [ app/routes/whatsapp.py ] #####
from fastapi import APIRouter, Request, Response
import httpx
from datetime import datetime
from pymongo import MongoClient
from dotenv import load_dotenv
import os

from app.utils.ollama import chamar_ollama
from app.utils.risco import analisar_risco
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI, WHATSAPP_FAMILIAR, WHATSAPP_VERIFY_TOKEN
from app.models.intents import INTENTS

# Inicializa√ß√µes
load_dotenv()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]
acompanhamentos = mongo["famdomes"]["acompanhamentos"]
router = APIRouter()

def detectar_intent(texto: str) -> str:
    for intent, gatilhos in INTENTS.items():
        if any(g.lower() in texto.lower() for g in gatilhos):
            return intent
    return "desconhecida"

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    try:
        data = await request.json()
        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]
        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        intent = detectar_intent(mensagem)
        resposta = await chamar_ollama(mensagem)
        risco = analisar_risco(resposta)

        colecao.insert_one({
            "telefone": telefone,
            "mensagem": mensagem,
            "resposta": resposta,
            "intent": intent,
            "risco": risco,
            "criado_em": datetime.utcnow()
        })

        print(f"[ALERTA FAMDOMES] Nova mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta IA: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        acompanhamento_existente = acompanhamentos.find_one({"telefone": telefone})
        if risco and WHATSAPP_FAMILIAR and not acompanhamento_existente:
            alerta_payload = {
                "messaging_product": "whatsapp",
                "to": WHATSAPP_FAMILIAR,
                "type": "text",
                "text": {
                    "body": f"‚ö†Ô∏è Alerta FAMDOMES: Detec√ß√£o de risco na conversa com {telefone}. Um profissional j√° est√° sendo alertado."
                }
            }
            alerta_headers = {
                "Authorization": f"Bearer {WHATSAPP_TOKEN}"
            }
            async with httpx.AsyncClient() as client:
                await client.post(
                    WHATSAPP_API_URL,
                    json=alerta_payload,
                    headers=alerta_headers
                )

        return {"status": "ok"}

    except Exception as e:
        print("‚ùå ERRO:", str(e))
        return {"erro": str(e)}

##### [ app/utils/agenda.py ] #####
# utils/agenda.py

from datetime import datetime, timedelta

# Agenda base: todos os dias √∫teis de 9h √†s 18h, de 20 em 20 minutos
disponibilidade = {}

def inicializar_agenda():
    hoje = datetime.now().replace(minute=0, second=0, microsecond=0)
    for i in range(7):  # 7 dias para frente
        dia = (hoje + timedelta(days=i)).date()
        disponibilidade[str(dia)] = [f"{h:02d}:{m:02d}" for h in range(9, 18) for m in range(0, 60, 20)]

def buscar_proximo_horario():
    for dia, horarios in disponibilidade.items():
        if horarios:
            horario = horarios.pop(0)
            return f"{dia} {horario}"
    return None
def proximo_horario_disponivel():
    agora = datetime.now()
    minuto_corrigido = (agora.minute // 20 + 1) * 20
    proximo = agora.replace(minute=0, second=0, microsecond=0) + timedelta(minutes=minuto_corrigido)
    return proximo

def agendar_consulta(telefone, nome, email):
    horario = proximo_horario_disponivel()
    print(f"üìÖ Consulta agendada para {nome} ({telefone}) em {horario}")
    return horario
def cancelar_consulta(telefone):
    print(f"üóëÔ∏è Cancelando consulta para: {telefone}")
def consultar_horario():
    return "Amanh√£ √†s 15:00"


##### [ app/utils/db.py ] #####
# utils/db.py

from datetime import datetime, timedelta

# Simula pr√≥xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula grava√ß√£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} √†s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO M√âDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")


##### [ app/utils/followup.py ] #####
# utils/followup.py

from datetime import datetime, timedelta
from utils.db import get_agenda_disponivel, registrar_consulta, avisar_profissional, avisar_paciente

# Banco local de sess√µes abertas
sess√µes = {}

# In√≠cio do atendimento
def iniciar_sessao(telefone: str, nome: str):
    sess√µes[telefone] = {
        "nome": nome,
        "inicio": datetime.now(),
        "status": "pendente_pagamento"
    }
    print(f"[SESS√ÉO] Iniciada com {nome} ({telefone})")

# Confirmou pagamento
def marcar_pagamento(telefone: str):
    if telefone in sess√µes:
        sess√µes[telefone]["status"] = "pago"
        print(f"[PAGAMENTO] Confirmado para {telefone}")

        horario = get_agenda_disponivel()
        registrar_consulta(telefone, horario)
        avisar_profissional(telefone, horario)
        avisar_paciente(telefone, horario)

# Verifica abandono
def checar_followup():
    agora = datetime.now()
    mensagens = []

    for tel, sessao in sess√µes.items():
        if sessao["status"] == "pendente_pagamento":
            tempo = agora - sessao["inicio"]
            if tempo > timedelta(minutes=10):
                msg = (
                    f"[FOLLOW-UP] {sessao['nome']} ({tel}) n√£o finalizou o pagamento.\n"
                    "Deseja ajuda para concluir ou tem alguma d√∫vida? Estou aqui para te apoiar."
                )
                mensagens.append(msg)

    return mensagens


##### [ app/utils/mensageria.py ] #####
# utils/mensageria.py

def enviar_mensagem(telefone, mensagem):
    print(f"üì≤ Enviando para {telefone}: {mensagem}")


##### [ app/utils/ollama.py ] #####
import httpx
from app.config import OLLAMA_API_URL

async def chamar_ollama(prompt: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(OLLAMA_API_URL, json={"prompt": prompt})
        data = response.json()
        return data.get("response", "")


##### [ app/utils/risco.py ] #####
def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suic√≠dio", "morrer", "n√£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)


