
# Arquivo: ./utils/faq_respostas.py
# ===========================================================
# Arquivo: utils/faq_respostas.py
# (Baseado no arquivo original fornecido, com chaves normalizadas)
# ===========================================================

# Dicion√°rio com perguntas frequentes e suas respostas.
# As chaves est√£o em min√∫sculas e sem acentos/pontua√ß√£o para facilitar a busca.
FAQ_RESPOSTAS = {
    "dependencia quimica": (
        "Depend√™ncia qu√≠mica √© uma doen√ßa cr√¥nica caracterizada pelo uso compulsivo de subst√¢ncias, "
        "apesar das consequ√™ncias negativas, afetando o c√©rebro e o comportamento."
    ),
    "identificar dependencia": (
        "Sinais comuns incluem: aumento da toler√¢ncia (precisar de mais para o mesmo efeito), sintomas de abstin√™ncia ao parar/diminuir, "
        "perda de controle sobre o uso, gastar muito tempo obtendo/usando/recuperando-se da subst√¢ncia, "
        "neglig√™ncia de responsabilidades e continuar usando apesar dos problemas causados."
    ),
    "tipos de internacao": (
        "Existem tr√™s tipos principais de interna√ß√£o previstos em lei:\n"
        "1.  **Volunt√°ria:** Quando a pr√≥pria pessoa busca ajuda e concorda com a interna√ß√£o.\n"
        "2.  **Involunt√°ria:** Solicitada por um familiar ou respons√°vel legal, sem o consentimento da pessoa, mas *obrigatoriamente* com um laudo m√©dico detalhado atestando a necessidade (risco para si ou outros).\n"
        "3.  **Compuls√≥ria:** Determinada pela Justi√ßa, geralmente em casos mais complexos e ap√≥s avalia√ß√£o m√©dica."
    ),
    "como funciona o tratamento": (
        "O tratamento em uma cl√≠nica geralmente √© multidisciplinar e inclui:\n"
        "-   **Desintoxica√ß√£o:** Fase inicial para lidar com a abstin√™ncia f√≠sica, com supervis√£o m√©dica.\n"
        "-   **Terapias:** Individual e em grupo (como Terapia Cognitivo-Comportamental - TCC, Entrevista Motivacional) para entender as causas, mudar comportamentos e prevenir reca√≠das.\n"
        "-   **Acompanhamento M√©dico e Psiqui√°trico:** Para tratar a depend√™ncia e poss√≠veis outras condi√ß√µes (comorbidades).\n"
        "-   **Grupos de Apoio:** Incentivo √† participa√ß√£o em grupos como Narc√≥ticos An√¥nimos (N.A.) ou Alco√≥licos An√¥nimos (A.A.).\n"
        "-   **Atividades Terap√™uticas:** Ocupacionais, f√≠sicas, etc., para reestrutura√ß√£o da rotina."
    ),
    "duracao do tratamento": (
        "A dura√ß√£o varia muito. Interna√ß√µes podem durar de 1 a 6 meses, ou at√© mais, dependendo da gravidade, do tipo de subst√¢ncia e da resposta individual. O tratamento ambulatorial (consultas regulares sem interna√ß√£o) pode ser mais longo. O importante √© entender que a recupera√ß√£o √© um processo cont√≠nuo, mesmo ap√≥s a alta."
    ),
    "custo do tratamento": (
        "Os valores de uma interna√ß√£o ou tratamento particular variam bastante dependendo da cl√≠nica, estrutura, servi√ßos inclu√≠dos, tipo de acomoda√ß√£o e tempo de perman√™ncia. Para ter uma proposta adequada ao seu caso, precisamos primeiro entender a situa√ß√£o na consulta inicial de avalia√ß√£o."
    ),
    "o que fazer se a pessoa nao aceita ajuda": (
        "√â um desafio comum e muito dif√≠cil para a fam√≠lia. Se a pessoa n√£o reconhece o problema ou recusa ajuda, mas est√° colocando a si mesma ou outros em risco grave, a interna√ß√£o involunt√°ria pode ser uma op√ß√£o legal, mas requer um laudo m√©dico detalhado. O primeiro passo √© buscar orienta√ß√£o profissional, como na nossa consulta inicial, para avaliar a situa√ß√£o e os caminhos poss√≠veis."
    ),
    "como a familia pode ajudar": (
        "A fam√≠lia √© fundamental na recupera√ß√£o! Algumas formas de ajudar s√£o:\n"
        "-   Buscar conhecimento sobre depend√™ncia qu√≠mica para entender a doen√ßa.\n"
        "-   Oferecer apoio emocional, mas sem facilitar o uso (evitar acobertar, dar dinheiro que possa ser usado para drogas, etc.).\n"
        "-   Estabelecer limites claros e consistentes.\n"
        "-   Participar de grupos de apoio para familiares (como Al-Anon, Nar-Anon) e/ou terapia familiar.\n"
        "-   Incentivar a busca e a manuten√ß√£o do tratamento pela pessoa."
    ),
    "o que e caps": (
        "CAPS √© a sigla para Centro de Aten√ß√£o Psicossocial. S√£o unidades p√∫blicas do SUS que oferecem atendimento em sa√∫de mental. Existem diferentes tipos, como o CAPS AD, especializado em √°lcool e outras drogas. O tratamento no CAPS √© gratuito e geralmente ambulatorial (a pessoa vai ao centro durante o dia), sendo uma alternativa importante, especialmente quando a interna√ß√£o n√£o √© necess√°ria ou vi√°vel."
    ),
    "como agendar consulta": (
        "Para agendar a consulta inicial online, que tem o valor de R$100, basta me confirmar seu interesse. Se voc√™ confirmar, eu te enviarei um link seguro para realizar o pagamento. Ap√≥s a confirma√ß√£o do pagamento, o hor√°rio ser√° agendado e voc√™ receber√° todas as instru√ß√µes."
    ),
    "qual o preco da consulta": (
        "A consulta inicial de avalia√ß√£o online tem o valor de R$100. Ela √© realizada por um profissional especializado para entender em detalhes a situa√ß√£o, oferecer orienta√ß√µes e, se for o caso, indicar o tratamento mais adequado, seja ele ambulatorial ou interna√ß√£o."
    ),
    "consulta online funciona": (
        "Sim, a consulta online √© muito eficaz para a avalia√ß√£o inicial e orienta√ß√£o. Ela permite que um profissional especializado analise o caso com privacidade e comodidade, entenda a necessidade, forne√ßa direcionamento e, se necess√°rio, um laudo para encaminhamento. Caso uma interven√ß√£o presencial seja indicada, como uma interna√ß√£o, o profissional far√° essa recomenda√ß√£o durante a consulta."
    )
    # Adicionar mais FAQs conforme necess√°rio
}


# Arquivo: ./utils/questionario_pos_pagamento.py
# ===========================================================
# Arquivo: utils/questionario_pos_pagamento.py
# ===========================================================
import asyncio
# Ajuste o import se mensageria.py estiver em um diret√≥rio diferente
from .mensageria import enviar_mensagem
import logging

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Defini√ß√£o das Perguntas ---

# Perguntas Fatuais (Originais ou Adaptadas)
PERGUNTAS_FACTUAIS = [
    "Vamos come√ßar com algumas perguntas r√°pidas para ajudar nosso m√©dico a entender melhor. Qual o nome completo da pessoa que ser√° avaliada?",
    "Qual a idade aproximada dela?",
    "Qual o seu grau de parentesco com essa pessoa (voc√™ √© filho(a), esposa(o), irm√£o(√£), amigo(a), ou a pr√≥pria pessoa)?",
    "Quais s√£o as principais subst√¢ncias que ela est√° usando atualmente (por exemplo: √°lcool, coca√≠na, crack, maconha, medicamentos controlados sem prescri√ß√£o)?",
    "H√° quanto tempo, aproximadamente, esse uso se tornou um problema ou se intensificou?",
    "A pessoa j√° passou por algum tipo de tratamento para depend√™ncia qu√≠mica antes? Se sim, qual(is) e quando?",
    "Al√©m da depend√™ncia, existe alguma outra condi√ß√£o de sa√∫de importante, f√≠sica ou mental (como diabetes, press√£o alta, depress√£o, ansiedade, esquizofrenia), que devemos saber?",
    "Em qual cidade e estado a pessoa se encontra neste momento?"
]

# Perguntas Emocionais (Adicionadas para a Trilha Emocional)
PERGUNTAS_EMOCIONAIS = [
    "Pensando na situa√ß√£o atual, quais s√£o as maiores preocupa√ß√µes ou medos que voc√™ (ou a pessoa a ser avaliada, se n√£o for voc√™) tem enfrentado recentemente?",
    "Olhando para frente, o que voc√™ (ou a pessoa) mais deseja ou espera alcan√ßar ao buscar ajuda ou iniciar um tratamento?",
    "Em rela√ß√£o aos sentimentos, existe algum que tem sido muito presente ultimamente por causa dessa situa√ß√£o (por exemplo: culpa, vergonha, raiva, medo, frustra√ß√£o, tristeza, mas tamb√©m esperan√ßa ou al√≠vio)?",
    "De que forma voc√™ percebe que essa situa√ß√£o tem impactado o dia a dia, o trabalho/estudos e os relacionamentos familiares?"
]

# Combina as perguntas na ordem desejada para o question√°rio completo
# Pode ajustar a ordem se preferir intercalar fatuais e emocionais
QUESTIONARIO_COMPLETO_POS_PAGAMENTO = PERGUNTAS_FACTUAIS + PERGUNTAS_EMOCIONAIS

# --- Fun√ß√£o para Iniciar o Question√°rio ---

async def iniciar_questionario_pos_pagamento(telefone: str):
    """
    Envia a primeira pergunta do question√°rio p√≥s-pagamento.
    A l√≥gica de salvar o question√°rio no contexto e enviar as perguntas
    subsequentes √© gerenciada por nlp.py.
    """
    total_perguntas = len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO)
    logging.info(f"QUESTIONARIO: üìã Preparando para iniciar ({total_perguntas} perguntas) para {telefone}")

    # Verifica se a lista de perguntas n√£o est√° vazia
    if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
        # Pega a primeira pergunta da lista combinada
        primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
        try:
            # Envia a primeira pergunta para o usu√°rio
            await enviar_mensagem(telefone, primeira_pergunta)
            logging.info(f"QUESTIONARIO: Enviada primeira pergunta para {telefone}.")
            # A continua√ß√£o do fluxo (salvar contexto, enviar pr√≥ximas perguntas)
            # ser√° tratada em nlp.py quando a resposta do usu√°rio chegar.
        except Exception as e:
            logging.error(f"QUESTIONARIO: ‚ùå Erro ao enviar a primeira pergunta para {telefone}: {e}")
            # Considerar o que fazer neste caso: tentar novamente? Notificar? Mudar estado?
    else:
        # Loga um aviso se a lista de perguntas estiver vazia
        logging.warning(f"QUESTIONARIO: ‚ö†Ô∏è Nenhuma pergunta definida. Question√°rio n√£o iniciado para {telefone}.")


# Arquivo: ./utils/ollama.py
# ===========================================================
# Arquivo: utils/ollama.py
# ===========================================================
import httpx
import logging
import json
import re
# Ajuste o import se config.py estiver em um diret√≥rio diferente
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str | None, dict | None, list | None]:
    """
    Chama a API do Ollama com o prompt fornecido.
    Tenta extrair um JSON do final da resposta.

    Args:
        prompt (str): O prompt completo a ser enviado para a IA.
        telefone (str): O n√∫mero de telefone do usu√°rio (para logging).

    Returns:
        tuple[str | None, dict | None, list | None]:
            - resposta_textual (str | None): A parte textual da resposta da IA.
            - json_extraido (dict | None): O dicion√°rio JSON extra√≠do do final, ou None.
            - tokens (list | None): Informa√ß√µes sobre tokens (se a API retornar, atualmente None).
    """
    # Valida√ß√£o inicial
    if not OLLAMA_API_URL or not OLLAMA_MODEL:
        logging.error("‚ùå OLLAMA: Configura√ß√µes (OLLAMA_API_URL ou OLLAMA_MODEL) ausentes.")
        return "‚ö†Ô∏è Desculpe, estou com problemas t√©cnicos para acessar minha intelig√™ncia. Tente novamente mais tarde.", None, None

    # Payload para a API do Ollama
    payload = {
        "model": OLLAMA_MODEL, # Modelo configurado
        "prompt": prompt,
        "stream": False, # N√£o usar streaming para facilitar extra√ß√£o do JSON
        # "options": {"temperature": 0.7} # Exemplo de op√ß√µes de gera√ß√£o
        # Tenta for√ßar JSON se o prompt explicitamente pedir (pode ser ajustado)
        "format": "json" if "json" in prompt.lower()[-150:] else None # Verifica s√≥ o final do prompt por "json"
    }
    # Remove format se for None para n√£o enviar chave vazia
    if payload["format"] is None:
        del payload["format"]

    headers = {"Content-Type": "application/json"}
    resposta_textual = None
    json_extraido = None
    tokens = None # Placeholder para informa√ß√µes de tokens

    try:
        # Usar httpx para chamadas HTTP ass√≠ncronas
        # Timeout aumentado para 45 segundos para dar tempo √† IA
        async with httpx.AsyncClient(timeout=45.0) as client:
            logging.info(f"OLLAMA: Enviando prompt (modelo: {OLLAMA_MODEL}) para {telefone}...")
            # Faz a requisi√ß√£o POST para a API do Ollama
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            # Levanta uma exce√ß√£o para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            dados = response.json()
            logging.info(f"OLLAMA: ‚úÖ Resposta recebida da IA para {telefone}.")
            # logging.debug(f"OLLAMA: Resposta completa: {dados}") # Log detalhado opcional

            # Extrai a resposta principal do JSON retornado pela API
            resposta_bruta = dados.get("response", "").strip()
            # TODO: Extrair informa√ß√µes de tokens se dispon√≠veis em 'dados' (ex: dados.get("eval_count"), etc.)
            # tokens = {"eval_count": dados.get("eval_count"), ...}

            # Verifica se a resposta n√£o est√° vazia
            if not resposta_bruta:
                logging.warning(f"OLLAMA: ‚ö†Ô∏è Resposta vazia para {telefone}.")
                return None, None, tokens

            # Tenta extrair JSON do final da resposta bruta
            # Primeiro tenta com ```json ... ``` (com ou sem espa√ßo antes do {)
            match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```$", resposta_bruta, re.IGNORECASE | re.DOTALL)
            if not match: # Se n√£o encontrar, tenta apenas com { ... } no final
                 match = re.search(r"(\{[\s\S]*?\})$", resposta_bruta, re.DOTALL)

            if match:
                # Se encontrou um padr√£o JSON, extrai o conte√∫do
                json_str = match.group(1)
                try:
                    # Tenta converter a string JSON em um dicion√°rio Python
                    json_extraido = json.loads(json_str)
                    # Remove a parte JSON (e os ``` se presentes) da resposta textual
                    resposta_textual = resposta_bruta[:match.start()].strip()
                    logging.info(f"OLLAMA: JSON extra√≠do com sucesso para {telefone}.")
                except json.JSONDecodeError as json_err:
                    # Se o JSON for inv√°lido, loga um aviso e trata a resposta inteira como texto
                    logging.warning(f"OLLAMA: ‚ö†Ô∏è JSON inv√°lido no final da resposta para {telefone}: {json_err}. Retornando resposta bruta como textual.")
                    resposta_textual = resposta_bruta
                    json_extraido = None
            else:
                # Se n√£o encontrou JSON no final, toda a resposta √© considerada textual
                logging.info(f"OLLAMA: Nenhum JSON encontrado no final da resposta para {telefone}.")
                resposta_textual = resposta_bruta
                json_extraido = None

            # Garante que a resposta textual n√£o seja vazia se o JSON foi extra√≠do com sucesso
            if not resposta_textual and json_extraido is not None:
                 resposta_textual = "Ok." # Retorna um texto m√≠nimo

            return resposta_textual, json_extraido, tokens

    # Tratamento de exce√ß√µes espec√≠ficas do httpx e gen√©ricas
    except httpx.TimeoutException as e:
        logging.error(f"OLLAMA: ‚ùå Erro: Timeout ao chamar para {telefone} ({str(e)})")
        # Retorna uma mensagem de erro amig√°vel para o usu√°rio
        return "‚ö†Ô∏è Desculpe, demorei muito para pensar. Poderia tentar de novo?", None, None
    except httpx.HTTPStatusError as e:
        # Loga o erro HTTP e retorna mensagem de erro
        logging.error(f"OLLAMA: ‚ùå Erro HTTP {e.response.status_code} para {telefone}: {e.response.text}")
        return f"‚ö†Ô∏è Ocorreu um erro de comunica√ß√£o com a intelig√™ncia artificial ({e.response.status_code}). Por favor, tente mais tarde.", None, None
    except Exception as e:
        # Loga qualquer outro erro inesperado
        logging.exception(f"OLLAMA: ‚ùå Erro desconhecido ao chamar para {telefone}:")
        return "‚ö†Ô∏è Ocorreu um erro inesperado ao processar sua solicita√ß√£o. Tente novamente mais tarde.", None, None


# Arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura ‚Äì certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"‚ùå ERRO ao carregar prompt mestre: {e}")
        return (
            "Voc√™ √© um assistente virtual especializado em sa√∫de mental e depend√™ncia qu√≠mica. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usu√°rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"‚ùå ERRO ao buscar hist√≥rico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar hist√≥rico."
    else:
        trecho_historico = "Hist√≥rico indispon√≠vel (sem conex√£o DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Hist√≥rico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usu√°rio:
{pergunta_atual.strip()}
---
Instru√ß√µes para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no m√°ximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt constru√≠do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Arquivo: ./utils/mensageria.py
# ===========================================================
# Arquivo: utils/mensageria.py
# ===========================================================
import httpx
# Ajuste o import se config.py estiver em um diret√≥rio diferente
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """
    Envia uma mensagem de texto simples via WhatsApp Cloud API.

    Args:
        telefone (str): N√∫mero de telefone do destinat√°rio (formato internacional, ex: 55119XXXXXXXX).
        mensagem (str): O texto da mensagem a ser enviada.

    Returns:
        dict: Um dicion√°rio com o status do envio ('enviado', 'erro_api', etc.) e detalhes.
    """
    # Verifica se as configura√ß√µes essenciais da API est√£o presentes
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO MENSAGERIA: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"status": "erro_config", "erro": "Configura√ß√£o da API do WhatsApp incompleta."}
    # Verifica se telefone e mensagem n√£o est√£o vazios
    if not telefone or not mensagem:
        logging.warning("‚ö†Ô∏è MENSAGERIA: Tentativa de enviar mensagem vazia ou sem destinat√°rio.")
        return {"status": "erro_input", "erro": "Telefone ou mensagem ausente."}

    # Payload da requisi√ß√£o para a API do WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone, # N√∫mero do destinat√°rio
        "type": "text",
        "text": {
            "preview_url": False, # Desabilita preview de links (geralmente bom para bots)
            "body": mensagem # O conte√∫do da mensagem
        }
    }
    # Cabe√ßalhos da requisi√ß√£o, incluindo o token de autoriza√ß√£o
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Define um timeout razo√°vel para a chamada da API externa
    timeout = httpx.Timeout(20.0, connect=5.0) # Timeout aumentado ligeiramente

    try:
        # Usa httpx para fazer a chamada POST ass√≠ncrona
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            # Levanta uma exce√ß√£o para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            # Log de sucesso
            logging.info(f"‚úÖ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}") # Log detalhado opcional
            # Retorna status de sucesso e detalhes da resposta da API
            return {"status": "enviado", "code": response.status_code, "retorno": response.json()} # Retorna JSON

    # Tratamento de exce√ß√µes espec√≠ficas do httpx
    except httpx.HTTPStatusError as e:
        # Erro retornado pela API do WhatsApp (ex: n√∫mero inv√°lido, token expirado)
        logging.error(f"‚ùå ERRO HTTP MENSAGERIA para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        # Erro de timeout ao tentar conectar ou receber resposta da API
        logging.error(f"‚ùå ERRO MENSAGERIA: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        # Erro de conex√£o (ex: DNS, rede)
        logging.error(f"‚ùå ERRO MENSAGERIA: Erro de Conex√£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    # Tratamento de qualquer outra exce√ß√£o inesperada
    except Exception as e:
        logging.exception(f"‚ùå ERRO MENSAGERIA: Erro inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


# Arquivo: ./utils/contexto.py
# ===========================================================
# Arquivo: utils/contexto.py
# (v5 - Adicionado estado AGUARDANDO_RESPOSTA_QUALIFICACAO)
# ===========================================================
from pymongo import MongoClient
# Ajuste o import se config.py estiver em um diret√≥rio diferente
from app.config import MONGO_URI
from datetime import datetime
import logging

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Estados Poss√≠veis da Conversa (Baseado no Mapeamento) ---
ESTADOS_CONVERSA = [
    "INICIAL",
    "IDENTIFICANDO_NECESSIDADE", # Recebe a 1a resposta do usu√°rio
    "AGUARDANDO_RESPOSTA_QUALIFICACAO", # Estado ap√≥s enviar a pergunta combinada (emocional + para quem)
    "EXPLICANDO_CONSULTA",
    "CONFIRMANDO_INTERESSE_AGENDAMENTO",
    "GERANDO_LINK_PAGAMENTO",
    "AGUARDANDO_PAGAMENTO",
    "PAGAMENTO_CONFIRMADO",
    "CONFIRMANDO_AGENDAMENTO",
    "INICIANDO_QUESTIONARIO",
    "COLETANDO_RESPOSTA_QUESTIONARIO",
    "FINALIZANDO_ONBOARDING",
    "SUPORTE_FAQ",
    "RESPONDENDO_COM_IA",
    "VERIFICANDO_SATISFACAO_RESPOSTA",
    "RISCO_DETECTADO",
    "PEDIDO_ATENDENTE_HUMANO",
    "NOTIFICANDO_EQUIPE", # Estado transit√≥rio antes de AGUARDANDO_ATENDENTE
    "AGUARDANDO_ATENDENTE"
]
# -------------------------------------------------------------

# Vari√°veis globais para conex√£o com DB (inicializadas no bloco try)
mongo = None
db = None
contextos_db = None
respostas_ia_db = None

try:
    # Estabelece conex√£o com MongoDB
    if MONGO_URI:
        mongo = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000) # Timeout de conex√£o
        # For√ßa a conex√£o para verificar se est√° funcionando
        mongo.server_info()
        db = mongo["famdomes"] # Nome do banco de dados
        contextos_db = db["contexto_conversa"] # Cole√ß√£o para contextos
        respostas_ia_db = db["respostas_ia"] # Cole√ß√£o para hist√≥rico de intera√ß√µes
        # Cria √≠ndices se n√£o existirem (melhora performance de busca)
        contextos_db.create_index("telefone", unique=True)
        respostas_ia_db.create_index("telefone")
        respostas_ia_db.create_index("criado_em")
        logging.info("Conex√£o com MongoDB estabelecida e √≠ndices verificados/criados.")
    else:
        logging.error("‚ùå MONGO_URI n√£o definido. N√£o foi poss√≠vel conectar ao MongoDB.")
except Exception as e:
    # Loga erro se a conex√£o falhar
    logging.error(f"‚ùå ERRO ao conectar com MongoDB ou criar √≠ndices: {e}")
    mongo = None
    db = None
    contextos_db = None
    respostas_ia_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Salva ou atualiza o contexto da conversa para um telefone.
    Inclui o estado atual da conversa e metadados.
    """
    # Valida√ß√£o inicial
    if contextos_db is None or not telefone or not isinstance(dados_atualizacao, dict):
        logging.error(f"‚ùå Falha ao salvar contexto para {telefone}: DB indispon√≠vel ou dados inv√°lidos.")
        return False
    try:
        # Garante que o estado seja v√°lido, se fornecido
        if "estado" in dados_atualizacao and dados_atualizacao["estado"] not in ESTADOS_CONVERSA:
            logging.warning(f"‚ö†Ô∏è Tentativa de salvar estado inv√°lido '{dados_atualizacao['estado']}' para {telefone}. Usando estado anterior ou INICIAL.")
            contexto_atual = obter_contexto(telefone) # Busca contexto atual para pegar estado v√°lido
            dados_atualizacao["estado"] = contexto_atual.get("estado", "INICIAL") # Mant√©m o atual ou vai para INICIAL

        # Recupera o contexto anterior para mesclar metadados
        contexto_anterior = contextos_db.find_one({"telefone": telefone}) or {}

        # üîÅ Fundir metadados (meta_conversa) de forma inteligente
        meta_conversa_atualizada = contexto_anterior.get("meta_conversa", {})
        if "meta_conversa" in dados_atualizacao:
            meta_nova = dados_atualizacao["meta_conversa"]
            meta_conversa_atualizada = atualizar_meta_conversa(meta_conversa_atualizada, meta_nova)
        # Garante que a meta_conversa final esteja nos dados a serem salvos
        dados_atualizacao["meta_conversa"] = meta_conversa_atualizada


        # Prepara o $set, garantindo que n√£o sobrescreva campos imut√°veis como telefone ou _id
        update_set = {k: v for k, v in dados_atualizacao.items() if k not in ['telefone', '_id', 'criado_em']}

        # Opera√ß√£o de update/insert (upsert) no MongoDB
        result = contextos_db.update_one(
            {"telefone": telefone}, # Filtro para encontrar o documento
            {
                "$set": update_set, # Campos a serem atualizados ou adicionados
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da √∫ltima modifica√ß√£o
                # Define campos apenas na inser√ß√£o (se o documento n√£o existir)
                "$setOnInsert": {
                    "telefone": telefone,
                    "criado_em": datetime.utcnow(), # Timestamp de cria√ß√£o
                    "estado": dados_atualizacao.get("estado", "INICIAL") # Garante estado inicial no upsert
                 }
            },
            upsert=True # Cria o documento se n√£o existir
        )
        # Log de sucesso
        if result.upserted_id:
            logging.info(f"üìå Novo contexto criado para {telefone}. Estado inicial: {dados_atualizacao.get('estado', 'INICIAL')}")
        elif result.modified_count > 0:
            logging.info(f"üìå Contexto atualizado para {telefone}. Novo estado: {dados_atualizacao.get('estado', 'N/A')}")
        else:
            # Se n√£o modificou, pode ser que os dados sejam os mesmos
            logging.info(f"üìå Contexto para {telefone} n√£o modificado (dados iguais?). Estado: {dados_atualizacao.get('estado', 'N/A')}")

        return True
    except Exception as e:
        # Log de erro cr√≠tico com traceback
        logging.exception(f"‚ùå ERRO CR√çTICO ao salvar contexto para {telefone}:")
        return False

def atualizar_meta_conversa(meta_antiga: dict, meta_nova: dict) -> dict:
    """
    Mescla campos do novo JSON (meta_nova) com os anteriores (meta_antiga).
    Prioriza dados novos, mas n√£o sobrescreve dados antigos com valores vazios ou nulos.
    Listas s√£o concatenadas e duplicatas removidas (se poss√≠vel).
    """
    # Garante que ambos sejam dicion√°rios
    if not isinstance(meta_antiga, dict): meta_antiga = {}
    if not isinstance(meta_nova, dict): meta_nova = {}

    resultado = meta_antiga.copy() # Come√ßa com os dados antigos

    for chave, valor_novo in meta_nova.items():
        # Ignora chaves com valores nulos ou vazios no novo dict,
        # a menos que a chave n√£o exista no antigo (para permitir adicionar chaves vazias)
        if valor_novo is None or valor_novo == "" or (isinstance(valor_novo, list) and not valor_novo):
             if chave not in resultado: # Se a chave √© nova, adiciona mesmo se vazia/nula
                 resultado[chave] = valor_novo
             continue # Caso contr√°rio (chave j√° existe), ignora para n√£o sobrescrever dado existente com vazio

        valor_antigo = resultado.get(chave)

        # Se for uma lista, combina e remove duplicatas (se os itens forem hashable)
        if isinstance(valor_novo, list):
            lista_antiga = valor_antigo if isinstance(valor_antigo, list) else []
            try:
                # Tenta converter para set para remover duplicatas (pode falhar se lista contiver dicts)
                resultado[chave] = list(set(lista_antiga + valor_novo))
            except TypeError:
                # Se n√£o puder usar set (ex: lista de dicts), apenas concatena itens √∫nicos
                resultado[chave] = lista_antiga + [item for item in valor_novo if item not in lista_antiga] # Evita duplicatas simples
        # Se o valor antigo n√£o existe, ou √© considerado "vazio", atualiza com o novo
        elif valor_antigo is None or valor_antigo == "" or valor_antigo == "desconhecido":
             resultado[chave] = valor_novo
        # Se ambos existem e n√£o s√£o listas, o novo valor geralmente prevalece
        # Exce√ß√£o: n√£o sobrescrever um valor espec√≠fico com 'desconhecido'
        elif valor_novo != "desconhecido":
             resultado[chave] = valor_novo
        # Se valor_novo √© 'desconhecido' e j√° existe um valor antigo, mant√©m o antigo

    return resultado


def obter_contexto(telefone: str) -> dict:
    """Obt√©m o contexto completo da conversa para um telefone."""
    # Valida√ß√£o inicial
    if contextos_db is None or not telefone:
        logging.warning(f"Tentativa de obter contexto sem DB ou telefone para {telefone}.")
        return {"estado": "INICIAL", "meta_conversa": {}} # Retorna um contexto padr√£o m√≠nimo
    try:
        # Busca o contexto no MongoDB
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            # Garante que sempre tenha 'estado' e 'meta_conversa' para evitar erros posteriores
            if "estado" not in contexto or not contexto["estado"]:
                contexto["estado"] = "INICIAL"
            if "meta_conversa" not in contexto or not isinstance(contexto["meta_conversa"], dict):
                contexto["meta_conversa"] = {}
            # Remove o _id do MongoDB para evitar problemas de serializa√ß√£o se necess√°rio
            contexto.pop('_id', None)
            return contexto
        else:
            # Se n√£o encontrou, retorna um contexto inicial padr√£o
            logging.info(f"Nenhum contexto encontrado para {telefone}, retornando padr√£o INICIAL.")
            return {"estado": "INICIAL", "meta_conversa": {}, "telefone": telefone}
    except Exception as e:
        # Log de erro e retorna padr√£o seguro
        logging.error(f"‚ùå ERRO ao obter contexto para {telefone}: {e}")
        return {"estado": "INICIAL", "meta_conversa": {}, "erro": "Falha ao buscar contexto"}

def limpar_contexto(telefone: str) -> bool:
    """Remove o contexto de conversa e hist√≥rico de IA para um telefone."""
    deleted_context = False
    deleted_history = False

    # Limpa contexto da conversa
    if contextos_db is not None and telefone:
        try:
            result_context = contextos_db.delete_one({"telefone": telefone})
            deleted_context = result_context.deleted_count > 0
            if deleted_context:
                 logging.info(f"üóëÔ∏è Contexto da conversa limpo para {telefone}.")
            else:
                 logging.info(f"Nenhum contexto de conversa encontrado para limpar para {telefone}.")
        except Exception as e:
            logging.error(f"‚ùå ERRO ao limpar contexto da conversa para {telefone}: {e}")

    # Limpa hist√≥rico de IA associado
    if respostas_ia_db is not None and telefone:
        try:
            result_history = respostas_ia_db.delete_many({"telefone": telefone})
            deleted_history = result_history.deleted_count > 0
            if deleted_history:
                 logging.info(f"üóëÔ∏è Hist√≥rico de IA ({result_history.deleted_count} registros) limpo para {telefone}.")
        except Exception as e:
            logging.error(f"‚ùå ERRO ao limpar hist√≥rico de IA para {telefone}: {e}")

    # Retorna True se pelo menos um dos dois foi limpo com sucesso
    return deleted_context or deleted_history


def salvar_resposta_ia(telefone: str, canal: str, mensagem_usuario: str, resposta_gerada: str, intent: str, entidades: dict, risco: bool, sentimento: str | None = None):
    """Salva a intera√ß√£o (mensagem do usu√°rio e resposta da IA) no hist√≥rico."""
    # Valida√ß√£o inicial
    if respostas_ia_db is None:
        logging.error("‚ùå Falha ao salvar resposta IA: DB indispon√≠vel.")
        return
    try:
        # Garante que entidades seja um dicion√°rio, mesmo que vazio
        entidades_validas = entidades if isinstance(entidades, dict) else {}

        # Cria o documento para inserir no hist√≥rico
        doc = {
            "telefone": telefone,
            "canal": canal,
            "mensagem_usuario": mensagem_usuario,
            "resposta_gerada": resposta_gerada,
            "intent": intent,
            "entidades": entidades_validas, # Dados extra√≠dos pela IA (ex: nome, subst√¢ncia)
            "risco": risco, # Resultado da an√°lise de risco
            "sentimento_detectado": sentimento, # [Trilha Emocional] Sentimento da mensagem do usu√°rio
            "criado_em": datetime.utcnow() # Timestamp da intera√ß√£o
        }
        # Insere o documento na cole√ß√£o de hist√≥rico
        respostas_ia_db.insert_one(doc)
        logging.info(f"üíæ Intera√ß√£o salva no hist√≥rico de IA para {telefone}.")
    except Exception as e:
        # Log de erro
        logging.error(f"‚ùå ERRO ao salvar resposta IA no hist√≥rico: {e}")


# Arquivo: ./utils/nlp.py
# ===========================================================
# Arquivo: utils/nlp.py
# (v7 - Implementada a nova estrat√©gia de fluxo inicial)
# ===========================================================
import logging
import json
import re
import os # Importado para carregar prompt
from datetime import datetime

# Ajuste os imports conforme a estrutura do seu projeto
from app.utils.ollama import chamar_ollama
# Acesso direto √†s vari√°veis globais de contexto.py para DB
from app.utils.contexto import (
    obter_contexto, salvar_contexto, salvar_resposta_ia,
    respostas_ia_db # Acesso √† cole√ß√£o do hist√≥rico
)
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.utils.risco import analisar_risco
from app.routes.ia import processar_comando # Para a√ß√µes como agendar
from app.config import (
    WHATSAPP_FAMILIAR, BASE_DIR, # Importa o n√∫mero para notifica√ß√£o e diret√≥rio base
    ROCKETCHAT_URL, ROCKETCHAT_TOKEN, ROCKETCHAT_USER_ID, # Configs para RocketChat
    OLLAMA_API_URL # Necess√°rio para checar se Ollama est√° configurado
)
from app.utils.mensageria import enviar_mensagem # Para enviar notifica√ß√µes
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO # Importa a lista correta
import httpx # Para notifica√ß√£o RocketChat

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes e Textos Padr√£o ---
# MENSAGEM_INICIAL = '''üß† Ol√°! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Nova vers√£o da estrat√©gia
MENSAGEM_INICIAL = '''üß† Ol√°! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Mantendo a original por enquanto, ajustar se necess√°rio
# Mensagem combinada (Valida√ß√£o + Emocional + Qualifica√ß√£o) - A valida√ß√£o ser√° adicionada dinamicamente
PERGUNTA_COMBINADA_TEMPLATE = "Como voc√™ est√° se sentindo com toda essa situa√ß√£o neste momento? E s√≥ para eu direcionar melhor, a ajuda que voc√™ busca √© para voc√™ mesmo ou para outra pessoa (ex: filho, esposa, irm√£o)?"
RESPOSTA_EXPLICACAO_CONSULTA = '''üë®‚Äç‚öïÔ∏è A consulta m√©dica do FAMDOMES √© online, com um profissional que entende profundamente casos de depend√™ncia qu√≠mica e sofrimento familiar.

üìå Ela serve para avaliar a situa√ß√£o, oferecer um laudo se necess√°rio, orientar o melhor caminho e ‚Äî se for o caso ‚Äî encaminhar para uma cl√≠nica parceira com seguran√ßa e sigilo.

üí≥ O valor √© R$100 e pode ser pago online de forma r√°pida.

Posso te enviar o link para agendar agora?'''
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informa√ß√µes, elas s√£o muito importantes para a consulta."
MENSAGEM_ERRO_PADRAO = "ü§ñ Desculpe, n√£o consegui processar sua mensagem agora. Poderia tentar novamente ou reformular?"
MENSAGEM_ERRO_IA = "ü§ñ Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
MENSAGEM_RISCO_DIRECIONAMENTO = "Percebi que voc√™ pode estar passando por um momento muito dif√≠cil. Se precisar de ajuda urgente, ligue para o CVV (188) ou SAMU (192). N√£o hesite em buscar apoio."
MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO = "Entendido. J√° notifiquei nossa equipe. Algu√©m entrar√° em contato com voc√™ por aqui assim que poss√≠vel."

RESPOSTAS_AFIRMATIVAS = ["sim", "claro", "quero", "vamos", "ok", "pode ser", "t√° bom", "aceito", "sim por favor", "sim quero", "com certeza", "t√¥ dentro", "pode sim", "por favor", "gostaria", "desejo"]
RESPOSTAS_NEGATIVAS = ["n√£o", "nao", "agora n√£o", "talvez depois", "ainda n√£o", "obrigado n√£o", "n√£o quero", "nao quero"]
PALAVRAS_CHAVE_HUMANO = ["humano", "atendente", "pessoa", "falar com alguem", "algu√©m", "falar com um especialista", "falar com vc", "falar contigo"]
# ----------------------------------

# --- Fun√ß√µes Auxiliares Implementadas ---

async def analisar_sentimento(texto: str, telefone: str) -> str | None:
    """
    [Trilha Emocional] Analisa o sentimento do texto usando Ollama.
    Retorna 'positivo', 'negativo', 'neutro' ou None em caso de erro.
    """
    if not OLLAMA_API_URL:
        logging.warning("NLP: An√°lise de sentimento pulada - OLLAMA_API_URL n√£o configurado.")
        return "neutro"

    logging.info(f"NLP: [Trilha Emocional] Analisando sentimento para {telefone}: '{texto[:30]}...'")
    prompt_sentimento = f"""
    Analise o sentimento predominante na seguinte mensagem do usu√°rio.
    Responda APENAS com uma das seguintes palavras: 'positivo', 'negativo', 'neutro'.

    Mensagem: "{texto}"

    Sentimento:"""
    try:
        resposta_txt, _, _ = await chamar_ollama(prompt_sentimento, telefone)
        if resposta_txt:
            sentimento_retornado = resposta_txt.strip().lower().replace(".", "")
            if sentimento_retornado in ["positivo", "negativo", "neutro"]:
                logging.info(f"NLP: Sentimento detectado pela IA para {telefone}: {sentimento_retornado}")
                return sentimento_retornado
            else:
                logging.warning(f"NLP: Sentimento retornado pela IA n√£o reconhecido ('{sentimento_retornado}'). Usando 'neutro'.")
                return "neutro"
        else:
            logging.warning(f"NLP: IA n√£o retornou resposta para an√°lise de sentimento de {telefone}. Usando 'neutro'.")
            return "neutro"
    except Exception as e:
        logging.error(f"NLP: Erro ao chamar IA para an√°lise de sentimento de {telefone}: {e}")
        return None

async def buscar_historico_formatado(telefone: str, limite: int = 5) -> str:
     """ Busca e formata o hist√≥rico recente do MongoDB para o prompt da IA. """
     if respostas_ia_db is None:
         logging.warning(f"NLP: Hist√≥rico indispon√≠vel para {telefone} (DB n√£o conectado).")
         return "Hist√≥rico indispon√≠vel (DB n√£o conectado)."
     logging.debug(f"NLP: Buscando hist√≥rico para {telefone} (limite: {limite})")
     try:
         historico_cursor = respostas_ia_db.find(
             {"telefone": telefone},
             {"mensagem_usuario": 1, "resposta_gerada": 1, "_id": 0}
         ).sort("criado_em", -1).limit(limite)
         historico_lista = list(historico_cursor)
         historico_lista.reverse()
         if not historico_lista:
             return "Nenhuma conversa anterior registrada."
         historico_formatado = ""
         for item in historico_lista:
             if msg_usr := item.get("mensagem_usuario"):
                 historico_formatado += f"Usu√°rio: {msg_usr}\n"
             if msg_bot := item.get("resposta_gerada"):
                 if len(msg_bot) > 150:
                      msg_bot = msg_bot[:150] + "..."
                 historico_formatado += f"Assistente: {msg_bot}\n"
         return historico_formatado.strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao buscar hist√≥rico para {telefone}: {e}")
         return "Erro ao carregar hist√≥rico."

async def construir_prompt_para_ia(telefone: str, pergunta_atual: str, estado: str, meta_conversa: dict) -> str:
     """
     Constr√≥i o prompt para o Ollama, incorporando estado, hist√≥rico e contexto emocional.
     Carrega o prompt mestre do arquivo PROMPT_MESTRE.txt.
     """
     historico_recente_formatado = await buscar_historico_formatado(telefone)
     sentimento_anterior = meta_conversa.get("ultimo_sentimento_detectado", None)
     prompt_mestre_path = os.path.join(BASE_DIR, "PROMPT_MESTRE.txt")
     try:
         with open(prompt_mestre_path, "r", encoding="utf-8") as f:
             PROMPT_MESTRE = f.read().strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao carregar prompt mestre de {prompt_mestre_path}: {e}. Usando prompt padr√£o.")
         PROMPT_MESTRE = """Voc√™ √© Domo, um assistente virtual emp√°tico da FAMDOMES. Responda com clareza e empatia."""

     meta_filtrada = {
         k: v for k, v in meta_conversa.items()
         if k not in ['questionario_completo', 'historico_recente_formatado'] and not k.startswith('sentimento_q')
     }

     prompt_final = f"""{PROMPT_MESTRE}

     ---
     Contexto da Conversa Atual:
     Telefone: {telefone}
     Estado da Conversa: {estado}
     Sentimento Percebido na √öltima Intera√ß√£o: {sentimento_anterior or 'N/A'}
     Dados Conhecidos (meta_conversa): {json.dumps(meta_filtrada, indent=2, ensure_ascii=False, default=str)}
     ---
     Hist√≥rico Recente da Conversa:
     {historico_recente_formatado}
     ---
     Nova Mensagem do Usu√°rio:
     {pergunta_atual.strip()}
     ---
     Instru√ß√µes para sua Resposta OBRIGAT√ìRIAS:
     1. Analise a 'Nova Mensagem do Usu√°rio' considerando o 'Contexto da Conversa Atual'.
     2. Responda em portugu√™s brasileiro, de forma EMP√ÅTICA e ACOLHEDORA, especialmente se o sentimento detectado for negativo.
     3. Mantenha o foco nos servi√ßos da FAMDOMES (consulta, tratamento de depend√™ncia qu√≠mica).
     4. Siga o fluxo indicado pelo 'Estado da Conversa'. Se for 'SUPORTE_FAQ', responda a d√∫vida. Se for 'AGUARDANDO_RESPOSTA_QUALIFICACAO', processe a resposta e siga para explicar a consulta ou responder d√∫vidas. Se for outro estado, guie o usu√°rio para o pr√≥ximo passo l√≥gico.
     5. Use no m√°ximo 400 caracteres na sua resposta textual.
     6. AO FINAL DA SUA RESPOSTA DE TEXTO, inclua OBRIGATORIAMENTE um JSON V√ÅLIDO contendo:
        - "intent": A inten√ß√£o principal que voc√™ identificou na mensagem do usu√°rio (ex: "duvida_preco", "confirmou_agendamento", "relato_sentimento", "pergunta_tratamento", "resposta_qualificacao", "desconhecida").
        - "sentimento_detectado": O sentimento predominante na mensagem do usu√°rio (ex: "positivo", "negativo", "neutro", "ansioso", "esperan√ßoso", "frustrado", "confuso").
        - "entidades": Um dicion√°rio com quaisquer entidades relevantes extra√≠das (ex: {{"nome_paciente": "Carlos", "substancia": "√°lcool", "para_quem": "filho"}}). Se n√£o houver, use {{}}.
     Exemplo de JSON OBRIGAT√ìRIO no final:
     ```json
     {{"intent": "duvida_preco", "sentimento_detectado": "ansioso", "entidades": {{}} }}
     ```
     Outro Exemplo:
     ```json
     {{"intent": "resposta_qualificacao", "sentimento_detectado": "negativo", "entidades": {{"para_quem": "filho"}} }}
     ```
     ---
     Assistente (responda aqui e adicione o JSON obrigat√≥rio no final):"""
     logging.info(f"NLP: Prompt constru√≠do para {telefone} (Estado: {estado}). Tamanho: {len(prompt_final)} chars.")
     return prompt_final

async def notificar_risco(telefone: str, mensagem: str, analise: dict):
    """ Envia notifica√ß√£o de risco para o n√∫mero configurado. """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    alerta = f"‚ö†Ô∏è ALERTA DE RISCO ({timestamp}) ‚ö†Ô∏è\n\nTelefone: {telefone}\nMensagem: \"{mensagem}\"\nAn√°lise: {analise}\n\nRevis√£o humana URGENTE necess√°ria."
    logging.warning(f"NLP: Enviando alerta de risco para {WHATSAPP_FAMILIAR}...")
    if WHATSAPP_FAMILIAR:
        try:
            resultado_envio = await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)
            if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                 logging.info(f"NLP: ‚úÖ Alerta de risco enviado com sucesso para {WHATSAPP_FAMILIAR}.")
            else:
                 logging.error(f"NLP: ‚ùå Falha ao enviar alerta de risco para {WHATSAPP_FAMILIAR}: {resultado_envio.get('erro', resultado_envio)}")
        except Exception as e:
            logging.error(f"NLP: ‚ùå Exce√ß√£o ao tentar enviar alerta de risco: {e}")
    else:
        logging.warning("NLP: WHATSAPP_FAMILIAR n√£o configurado. N√£o foi poss√≠vel enviar alerta de risco.")

async def notificar_escalacao_humana(telefone: str, contexto: dict):
    """ Envia notifica√ß√£o para a equipe sobre pedido de atendente humano via RocketChat. """
    if not ROCKETCHAT_URL or not ROCKETCHAT_TOKEN or not ROCKETCHAT_USER_ID:
        logging.error("NLP: ‚ùå Configura√ß√µes do RocketChat incompletas. N√£o √© poss√≠vel notificar a equipe.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    estado_anterior = contexto.get("estado", "N/A")
    nome_contato = contexto.get("meta_conversa", {}).get("nome_paciente", contexto.get("nome", "Desconhecido"))
    respostas_recentes = {k: v for k, v in contexto.get('meta_conversa', {}).items() if k.startswith('resposta_q')}
    contexto_resumido = json.dumps(respostas_recentes, indent=2, ensure_ascii=False, default=str)
    if len(contexto_resumido) > 1000:
        contexto_resumido = contexto_resumido[:1000] + "\n... (truncado)"

    mensagem_notificacao = (
        f"üôã **Pedido de Atendimento Humano** ({timestamp}) üôã\n\n"
        f"**Telefone:** {telefone}\n"
        f"**Nome Contato:** {nome_contato}\n"
        f"**Estado Anterior:** {estado_anterior}\n\n"
        f"**√öltimas Respostas (Question√°rio/Meta):**\n"
        f"```json\n{contexto_resumido}\n```\n\n"
        f"Por favor, assumir a conversa."
    )
    logging.warning(f"NLP: üôã PEDIDO HUMANO ({timestamp}) - Telefone: {telefone} | Notificando equipe via RocketChat...")

    headers = {
        "X-Auth-Token": ROCKETCHAT_TOKEN,
        "X-User-Id": ROCKETCHAT_USER_ID,
        "Content-Type": "application/json"
    }
    room_id_destino = os.getenv("ROCKETCHAT_ROOM_ID_SUPORTE", "GENERAL")
    payload = {"message": {"rid": room_id_destino, "msg": mensagem_notificacao}}
    post_message_url = f"{ROCKETCHAT_URL}/api/v1/chat.postMessage"

    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            response = await client.post(post_message_url, headers=headers, json=payload)
            response.raise_for_status()
            resposta_api = response.json()
            if resposta_api.get("success"):
                logging.info(f"NLP: ‚úÖ Notifica√ß√£o de escala√ß√£o enviada com sucesso para RocketChat (Sala: {room_id_destino}).")
            else:
                logging.error(f"NLP: ‚ùå Falha ao enviar notifica√ß√£o para RocketChat (Sala: {room_id_destino}). Resposta API: {resposta_api}")
    except httpx.HTTPStatusError as e:
        logging.error(f"NLP: ‚ùå Erro HTTP {e.response.status_code} ao enviar para RocketChat: {e.response.text}")
    except httpx.RequestError as e:
        logging.error(f"NLP: ‚ùå Erro de conex√£o ao enviar para RocketChat: {e}")
    except Exception as e:
        logging.exception("NLP: ‚ùå Erro inesperado ao enviar notifica√ß√£o para RocketChat:")


# --- Fun√ß√£o Principal de Processamento ---

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    """
    Processa a mensagem do usu√°rio com base no estado atual da conversa,
    realiza an√°lise de sentimento/risco, atualiza o estado e retorna a resposta.
    """
    global meta_conversa
    logging.info(f"NLP: üîÑ Processando mensagem de {telefone}...")
    contexto = obter_contexto(telefone)
    estado_atual = contexto.get("estado", "INICIAL")
    meta_conversa = contexto.get("meta_conversa", {})
    texto_mensagem = mensagem.strip()
    texto_lower = texto_mensagem.lower()

    if not isinstance(meta_conversa, dict):
        logging.warning(f"NLP: Meta conversa para {telefone} n√£o era um dicion√°rio. Resetando para {{}}.")
        meta_conversa = {}

    logging.info(f"NLP: üìû Telefone: {telefone} | Estado Atual: {estado_atual} | Mensagem: '{texto_mensagem[:50]}...'")

    # --- 1. An√°lise de Risco ---
    analise_risco_resultado = analisar_risco(texto_mensagem)
    risco_detectado = analise_risco_resultado.get("risco_vida") or analise_risco_resultado.get("urgencia_medica")

    if risco_detectado:
        logging.warning(f"NLP: üö® RISCO DETECTADO para {telefone}! An√°lise: {analise_risco_resultado}")
        novo_estado = "RISCO_DETECTADO"
        resposta_final = MENSAGEM_RISCO_DIRECIONAMENTO
        meta_conversa["ultimo_risco"] = datetime.utcnow().isoformat()
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "risco_detectado", meta_conversa, True, None)
        await notificar_risco(telefone, texto_mensagem, analise_risco_resultado)
        return {"resposta": resposta_final, "estado": novo_estado}

    # --- 2. Verifica√ß√£o de Comandos Especiais ---
    if texto_lower == "melancia vermelha":
        logging.info(f"NLP: Comando 'melancia vermelha' recebido de {telefone}. Resetando contexto.")
        limpar_contexto(telefone)
        resposta_final = MENSAGEM_INICIAL # Envia apenas a sauda√ß√£o inicial ap√≥s reset
        novo_estado = "IDENTIFICANDO_NECESSIDADE" # Espera a primeira resposta do usu√°rio
        intent = "reset_comando_e_inicio"
        meta_conversa = {}
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": {}})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, {}, False, None)
        return {"resposta": resposta_final, "estado": novo_estado}

    if any(palavra in texto_lower for palavra in PALAVRAS_CHAVE_HUMANO):
         logging.info(f"NLP: Pedido de atendente humano detectado para {telefone}.")
         estado_antes_pedido = estado_atual
         novo_estado = "AGUARDANDO_ATENDENTE"
         resposta_final = MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO
         contexto_para_notificacao = contexto.copy()
         contexto_para_notificacao["estado"] = estado_antes_pedido
         salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
         salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "pedido_humano", meta_conversa, False, None)
         await notificar_escalacao_humana(telefone, contexto_para_notificacao)
         return {"resposta": resposta_final, "estado": novo_estado}

    # --- 3. L√≥gica Baseada no Estado Atual ---
    resposta_final = MENSAGEM_ERRO_PADRAO
    novo_estado = estado_atual
    intent = "desconhecida"
    entidades = {}
    sentimento = await analisar_sentimento(texto_mensagem, telefone)
    if meta_conversa is not None:
        meta_conversa["ultimo_sentimento_detectado"] = sentimento
    else:
        meta_conversa = {"ultimo_sentimento_detectado": sentimento}

    try:
        # L√≥gica para estado INICIAL (Bot acabou de enviar a sauda√ß√£o)
        # N√£o deveria receber mensagem do usu√°rio neste estado, mas por seguran√ßa:
        if estado_atual == "INICIAL":
            logging.warning(f"NLP: Mensagem recebida no estado INICIAL de {telefone}. Tratando como IDENTIFICANDO_NECESSIDADE.")
            estado_atual = "IDENTIFICANDO_NECESSIDADE" # For√ßa a transi√ß√£o

        # L√≥gica para IDENTIFICANDO_NECESSIDADE (Usu√°rio respondeu √† sauda√ß√£o inicial)
        if estado_atual == "IDENTIFICANDO_NECESSIDADE":
            # Valida√ß√£o simples (pode ser melhorada com IA se necess√°rio)
            validacao = "Entendi. " # Valida√ß√£o gen√©rica inicial
            if sentimento == "negativo":
                validacao = "Sinto muito que esteja se sentindo assim. "
            elif sentimento == "positivo":
                 validacao = "Que bom ouvir isso. "

            # Constr√≥i a pergunta combinada
            resposta_final = validacao + PERGUNTA_COMBINADA_TEMPLATE
            novo_estado = "AGUARDANDO_RESPOSTA_QUALIFICACAO"
            intent = "primeira_resposta_usuario" # Intent da mensagem recebida (pode ser refinado)

        # L√≥gica para AGUARDANDO_RESPOSTA_QUALIFICACAO (Usu√°rio respondeu √† pergunta combinada)
        elif estado_atual == "AGUARDANDO_RESPOSTA_QUALIFICACAO":
            logging.info(f"NLP: Processando resposta de qualifica√ß√£o de {telefone}.")
            meta_conversa["sentimento_resposta_qualificacao"] = sentimento
            # Tenta extrair para quem √© a ajuda usando IA ou regras simples
            # Exemplo com regras simples (melhorar com IA/extra√ß√£o de entidades no prompt)
            para_quem = "desconhecido"
            if "filho" in texto_lower or "filha" in texto_lower:
                para_quem = "filho(a)"
            elif "esposo" in texto_lower or "marido" in texto_lower:
                para_quem = "esposo"
            elif "esposa" in texto_lower or "mulher" in texto_lower:
                 para_quem = "esposa"
            elif "irm√£o" in texto_lower or "irma" in texto_lower:
                 para_quem = "irmao(a)"
            elif "amigo" in texto_lower or "amiga" in texto_lower:
                 para_quem = "amigo(a)"
            elif "para mim" in texto_lower or "eu mesmo" in texto_lower or "pra mim" in texto_lower:
                 para_quem = "proprio_usuario"
            meta_conversa["para_quem"] = para_quem
            entidades["para_quem"] = para_quem # Salva entidade espec√≠fica desta intera√ß√£o

            # Valida√ß√£o da resposta emocional
            agradecimento = "Obrigado por compartilhar." if sentimento != "negativo" else "Agrade√ßo a confian√ßa em compartilhar."

            # Decide o pr√≥ximo passo
            # Se perguntou pre√ßo especificamente, responde primeiro
            if "pre√ßo" in texto_lower or "valor" in texto_lower or "custo" in texto_lower:
                 resposta_final = f"{agradecimento} A consulta inicial online tem o valor de R$100. Ela √© importante para avaliar o caso e definir o melhor caminho. Gostaria que eu explicasse mais sobre como ela funciona?"
                 novo_estado = "SUPORTE_FAQ" # Fica em suporte ap√≥s responder pre√ßo
                 intent = "resposta_qualificacao_com_preco"
            else:
                 # Se n√£o pediu pre√ßo, explica a consulta
                 if para_quem != "desconhecido" and para_quem != "proprio_usuario":
                      resposta_final = f"{agradecimento} Entendi que a busca √© para {para_quem}. Para esses casos, o primeiro passo recomendado √© a nossa consulta inicial online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 else: # Se for para o pr√≥prio usu√°rio ou desconhecido
                      resposta_final = f"{agradecimento} Sabendo que a ajuda √© para voc√™ (ou se ainda n√£o tiver certeza, a consulta ajuda a definir), o caminho inicial que oferecemos √© a consulta de avalia√ß√£o online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 novo_estado = "EXPLICANDO_CONSULTA"
                 intent = "resposta_qualificacao_segue_fluxo"


        # L√≥gica para EXPLICANDO_CONSULTA (Usu√°rio respondeu √† explica√ß√£o da consulta)
        elif estado_atual == "EXPLICANDO_CONSULTA":
             if texto_lower in RESPOSTAS_AFIRMATIVAS:
                 logging.info(f"NLP: Usu√°rio {telefone} confirmou interesse em agendar.")
                 meta_conversa["sentimento_confirmacao_agendamento"] = sentimento
                 try:
                     nome_cliente = contexto.get("nome", meta_conversa.get("nome_paciente", "Cliente"))
                     resultado_comando = await processar_comando({
                         "telefone": telefone,
                         "nome": nome_cliente,
                         "comando": "quero agendar"
                     })
                     resposta_final = resultado_comando.get("mensagem", "Link para pagamento enviado!")
                     if resultado_comando.get("status") == "link_gerado":
                          novo_estado = "AGUARDANDO_PAGAMENTO"
                          intent = "confirmou_agendamento"
                     else:
                          resposta_final = resultado_comando.get("mensagem", MENSAGEM_ERRO_PADRAO)
                          novo_estado = "EXPLICANDO_CONSULTA"
                          intent = "erro_gerar_link"
                 except Exception as e:
                     logging.error(f"NLP: Erro ao processar comando 'quero agendar' para {telefone}: {e}")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     novo_estado = "EXPLICANDO_CONSULTA"
                     intent = "erro_processar_comando"

             elif texto_lower in RESPOSTAS_NEGATIVAS:
                 logging.info(f"NLP: Usu√°rio {telefone} recusou o agendamento por enquanto.")
                 meta_conversa["sentimento_recusa_agendamento"] = sentimento
                 resposta_final = "Entendido. Sem problemas. Se mudar de ideia ou tiver mais alguma d√∫vida, estou √† disposi√ß√£o!"
                 novo_estado = "SUPORTE_FAQ"
                 intent = "recusou_agendamento"
             else:
                 logging.info(f"NLP: Resposta n√£o conclusiva em EXPLICANDO_CONSULTA para {telefone}. Usando IA.")
                 novo_estado = "SUPORTE_FAQ"
                 # IA ser√° chamada no fallback

        # L√≥gica para AGUARDANDO_PAGAMENTO
        elif estado_atual == "AGUARDANDO_PAGAMENTO":
             logging.info(f"NLP: Mensagem recebida de {telefone} enquanto aguarda pagamento. Encaminhando para IA.")
             resposta_final = "Recebi sua mensagem enquanto aguardo a confirma√ß√£o do pagamento. Se tiver alguma d√∫vida sobre o processo ou outra quest√£o, pode perguntar."
             novo_estado = "SUPORTE_FAQ"
             # IA ser√° chamada no fallback

        # L√≥gica para CONFIRMANDO_AGENDAMENTO
        elif estado_atual == "CONFIRMANDO_AGENDAMENTO":
             logging.info(f"NLP: Iniciando question√°rio p√≥s-pagamento para {telefone}")
             meta_conversa["questionario_completo"] = QUESTIONARIO_COMPLETO_POS_PAGAMENTO
             meta_conversa["num_pergunta_atual"] = 0
             if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 proxima_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta_final = proxima_pergunta
                 novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                 intent = "iniciou_questionario"
                 salvar_contexto(telefone, {
                     "estado": novo_estado,
                     "meta_conversa": meta_conversa,
                     "ultima_resposta_bot": resposta_final
                 })
                 salvar_resposta_ia(telefone, canal, "Sistema: Iniciou Question√°rio", resposta_final, intent, meta_conversa, False, None)
                 return {"resposta": resposta_final, "estado": novo_estado}
             else:
                 logging.warning(f"NLP: Question√°rio p√≥s-pagamento vazio para {telefone}. Finalizando onboarding.")
                 resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                 novo_estado = "FINALIZANDO_ONBOARDING"
                 intent = "questionario_vazio"


        # L√≥gica para COLETANDO_RESPOSTA_QUESTIONARIO
        elif estado_atual == "COLETANDO_RESPOSTA_QUESTIONARIO":
             num_pergunta_respondida_idx = meta_conversa.get("num_pergunta_atual", 0)
             perguntas_questionario = meta_conversa.get("questionario_completo", [])

             if not isinstance(perguntas_questionario, list):
                 logging.error(f"NLP: Erro: 'questionario_completo' n√£o √© uma lista no contexto de {telefone}")
                 perguntas_questionario = []

             if num_pergunta_respondida_idx < len(perguntas_questionario):
                 pergunta_respondida_texto = perguntas_questionario[num_pergunta_respondida_idx]
                 chave_resposta = f"resposta_q{num_pergunta_respondida_idx+1}"
                 chave_sentimento = f"sentimento_q{num_pergunta_respondida_idx+1}"
                 meta_conversa[chave_resposta] = texto_mensagem
                 meta_conversa[chave_sentimento] = sentimento
                 logging.info(f"NLP: Resposta Q{num_pergunta_respondida_idx+1} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}. Sentimento: {sentimento}")

                 num_proxima_pergunta_idx = num_pergunta_respondida_idx + 1
                 meta_conversa["num_pergunta_atual"] = num_proxima_pergunta_idx

                 if num_proxima_pergunta_idx < len(perguntas_questionario):
                     proxima_pergunta_texto = perguntas_questionario[num_proxima_pergunta_idx]
                     resposta_final = proxima_pergunta_texto
                     novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                     intent = f"respondeu_questionario_{num_pergunta_respondida_idx+1}"
                 else:
                     resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                     novo_estado = "FINALIZANDO_ONBOARDING"
                     intent = "finalizou_questionario"
                     meta_conversa.pop("num_pergunta_atual", None)
                     meta_conversa.pop("questionario_completo", None)
                     logging.info(f"NLP: Question√°rio finalizado para {telefone}.")
             else:
                 logging.error(f"NLP: Erro de l√≥gica no question√°rio para {telefone}. Estado: {estado_atual}, Contador: {num_pergunta_respondida_idx}, Total Perguntas: {len(perguntas_questionario)}")
                 resposta_final = MENSAGEM_ERRO_PADRAO
                 novo_estado = "SUPORTE_FAQ"
                 intent = "erro_logica_questionario"


        # --- 4. Fallback com IA ---
        if novo_estado == estado_atual and estado_atual not in ["RISCO_DETECTADO", "AGUARDANDO_ATENDENTE", "FINALIZANDO_ONBOARDING", "CONFIRMANDO_AGENDAMENTO"]:
            logging.info(f"NLP: Nenhuma regra espec√≠fica tratou a mensagem de {telefone} no estado {estado_atual}. Usando IA como fallback.")

            faq_key_norm = texto_lower.replace("?", "").replace(".", "").replace("!", "").strip()
            matched_faq_key = None
            if faq_key_norm in FAQ_RESPOSTAS:
                matched_faq_key = faq_key_norm
            else:
                for key in FAQ_RESPOSTAS:
                    if key in faq_key_norm:
                        matched_faq_key = key
                        break

            if matched_faq_key:
                 logging.info(f"NLP: Respondendo com FAQ para chave: {matched_faq_key}")
                 resposta_final = FAQ_RESPOSTAS[matched_faq_key]
                 novo_estado = "SUPORTE_FAQ"
                 intent = f"faq_{matched_faq_key.replace(' ', '_')}"
            else:
                 if not OLLAMA_API_URL:
                     logging.error("NLP: ‚ùå Fallback para IA falhou - OLLAMA_API_URL n√£o configurado.")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     intent = "erro_config_ia"
                     novo_estado = "SUPORTE_FAQ"
                 else:
                     logging.info(f"NLP: Chamando Ollama para {telefone}...")
                     prompt = await construir_prompt_para_ia(telefone, texto_mensagem, estado_atual, meta_conversa)
                     resposta_textual_ia, json_extraido_ia, tokens_ollama = await chamar_ollama(prompt, telefone)

                     if resposta_textual_ia is None or "‚ö†Ô∏è" in resposta_textual_ia:
                         resposta_final = resposta_textual_ia or MENSAGEM_ERRO_IA
                         intent = "erro_ia_fallback"
                         novo_estado = "SUPORTE_FAQ"
                     else:
                         resposta_final = resposta_textual_ia

                         if json_extraido_ia and isinstance(json_extraido_ia, dict):
                             logging.info(f"NLP: JSON extra√≠do da IA: {json_extraido_ia}")
                             intent = json_extraido_ia.get("intent", "ia_generica")
                             entidades_ia = json_extraido_ia.get("entidades", {})
                             if isinstance(entidades_ia, dict):
                                  meta_conversa = atualizar_meta_conversa(meta_conversa, entidades_ia)
                                  entidades = entidades_ia
                             else:
                                  logging.warning(f"NLP: Entidades retornadas pela IA n√£o s√£o um dicion√°rio: {entidades_ia}")

                             sentimento_ia = json_extraido_ia.get("sentimento_detectado")
                             if sentimento_ia and isinstance(sentimento_ia, str):
                                  sentimento = sentimento_ia
                                  meta_conversa["ultimo_sentimento_detectado"] = sentimento
                             else:
                                  logging.warning(f"NLP: Sentimento retornado pela IA inv√°lido ou ausente: {sentimento_ia}. Usando sentimento analisado anteriormente: {sentimento}")
                         else:
                              logging.warning("NLP: ‚ö†Ô∏è IA n√£o retornou JSON reconhec√≠vel no final da resposta.")
                              intent = "ia_generica_sem_json"

                         novo_estado = "SUPORTE_FAQ"

    except Exception as e:
        logging.exception(f"NLP: ‚ùå ERRO INESPERADO durante processamento da mensagem para {telefone}:")
        resposta_final = MENSAGEM_ERRO_PADRAO
        intent = "erro_processamento_geral"
        novo_estado = estado_atual

    # --- 5. Atualizar Contexto e Salvar Hist√≥rico ---
    meta_conversa_final = meta_conversa if isinstance(meta_conversa, dict) else {}
    contexto_para_salvar = {
        "estado": novo_estado,
        "ultima_resposta_bot": resposta_final,
        "meta_conversa": meta_conversa_final
    }

    salvar_contexto(telefone, contexto_para_salvar)
    salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, entidades, risco_detectado, sentimento)

    logging.info(f"NLP: ‚úÖ Processamento conclu√≠do para {telefone}. Novo estado: {novo_estado}. Resposta: '{resposta_final[:50]}...'")
    return {"resposta": resposta_final, "estado": novo_estado}


# Arquivo: ./utils/risco.py
# ===========================================================
# Arquivo: utils/risco.py
# ===========================================================
import logging

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Listas de Palavras-Chave para Detec√ß√£o de Risco ---

# Lista de palavras/frases cr√≠ticas indicando risco de vida (suic√≠dio, automutila√ß√£o)
# ATEN√á√ÉO: Esta lista √© um ponto de partida e deve ser refinada com cuidado.
PALAVRAS_CRITICAS_VIDA = [
    "suic√≠dio", "me matar", "quero morrer", "n√£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperan√ßa", "adeus mundo", "n√£o quero viver",
    "me cortar", "me machucar", "automutila√ß√£o", "tirar minha vida", "fim da linha",
    "n√£o vejo sa√≠da", "desistir de tudo"
]

# Lista de palavras/frases que indicam URG√äNCIA M√âDICA (Overdose, sintomas graves)
PALAVRAS_URGENCIA_MEDICA = [
    "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
    "desmaiado", "convuls√£o", "sangrando muito", "veneno", "infarto", "avc",
    "muita dor", "sem ar", "falta de ar", "alucina√ß√£o grave", "del√≠rio intenso",
    "tomou muito rem√©dio", "ingeriu subst√¢ncia"
]

# --- Fun√ß√£o de An√°lise de Risco ---

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (risco de vida, urg√™ncia m√©dica).
    Retorna um dicion√°rio com booleanos para 'risco_vida' e 'urgencia_medica'.

    Args:
        texto (str): O texto da mensagem do usu√°rio a ser analisada.

    Returns:
        dict: Dicion√°rio contendo:
            - 'risco_vida' (bool): True se detectar palavras cr√≠ticas de risco de vida.
            - 'urgencia_medica' (bool): True se detectar palavras de urg√™ncia m√©dica.
    """
    # Retorna False para ambos se o texto for vazio ou nulo
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    # Converte o texto para min√∫sculas para compara√ß√£o case-insensitive
    texto_lower = texto.lower()

    # Verifica se alguma palavra/frase da lista de risco de vida est√° presente no texto
    # Usar busca de substring para pegar varia√ß√µes (ex: "quero me matar agora")
    risco_vida_detectado = any(palavra in texto_lower for palavra in PALAVRAS_CRITICAS_VIDA)

    # Verifica se alguma palavra/frase da lista de urg√™ncia m√©dica est√° presente no texto
    urgencia_medica_detectada = any(palavra in texto_lower for palavra in PALAVRAS_URGENCIA_MEDICA)

    # Loga um aviso se algum risco for detectado (o log principal ser√° feito em nlp.py)
    # if risco_vida_detectado:
    #     logging.debug(f"RISCO: Risco de vida potencialmente detectado em '{texto[:50]}...'")
    # if urgencia_medica_detectada:
    #     logging.debug(f"RISCO: Urg√™ncia m√©dica potencialmente detectada em '{texto[:50]}...'")

    # Retorna o dicion√°rio com os resultados da an√°lise
    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }

# Arquivo: ./utils/agenda.py
# ===========================================================
# Arquivo: utils/agenda.py
# (Implementa√ß√£o das fun√ß√µes de agendamento com DB)
# ===========================================================
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure, DuplicateKeyError
# Ajuste o import se config.py estiver em um diret√≥rio diferente
from app.config import MONGO_URI
import logging
import pytz # Para lidar com fusos hor√°rios corretamente

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes de Configura√ß√£o da Agenda ---
DURACAO_CONSULTA_MINUTOS = 20 # Dura√ß√£o de cada bloco de consulta
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias √∫teis)
HORARIO_OPERACAO_INICIO = 9 # Hor√°rio de in√≠cio das consultas (9:00)
HORARIO_OPERACAO_FIM = 18  # Hor√°rio de fim (n√£o agenda √†s 18:00, √∫ltimo bloco come√ßa antes)
DIAS_UTEIS = [0, 1, 2, 3, 4] # 0=Segunda, 1=Ter√ßa, ..., 4=Sexta
FUSO_HORARIO_LOCAL = 'America/Sao_Paulo' # Fuso hor√°rio de opera√ß√£o

# --- Conex√£o com MongoDB ---
mongo_agenda = None
db_agenda = None
consultas_db = None

try:
    # Estabelece conex√£o com MongoDB
    if MONGO_URI:
        mongo_agenda = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_agenda.server_info() # Testa a conex√£o
        db_agenda = mongo_agenda["famdomes"] # Nome do banco de dados
        consultas_db = db_agenda["consultas_agendadas"] # Cole√ß√£o para agendamentos
        # Cria √≠ndice √∫nico para garantir que n√£o haja duas consultas no mesmo hor√°rio (UTC)
        consultas_db.create_index("horario_utc", unique=True)
        consultas_db.create_index("telefone") # √çndice para busca por telefone
        consultas_db.create_index([("status", 1), ("horario_utc", 1)]) # √çndice composto
        logging.info("AGENDA: Conex√£o com MongoDB estabelecida e √≠ndices verificados/criados.")
    else:
        logging.error("AGENDA: ‚ùå MONGO_URI n√£o definido. N√£o foi poss√≠vel conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"AGENDA: ‚ùå Falha na conex√£o com MongoDB: {e}")
except Exception as e:
    logging.error(f"AGENDA: ‚ùå ERRO ao conectar com MongoDB ou criar √≠ndices: {e}")
    mongo_agenda = None
    db_agenda = None
    consultas_db = None

# --- Fun√ß√µes Auxiliares ---

def _proximo_horario_util(inicio_base_utc: datetime) -> datetime:
    """
    Avan√ßa o hor√°rio UTC para o pr√≥ximo bloco de X minutos dispon√≠vel
    dentro do hor√°rio de opera√ß√£o e dias √∫teis definidos.
    """
    horario_utc = inicio_base_utc.replace(tzinfo=timezone.utc) # Garante que est√° ciente do fuso UTC
    tz_local = pytz.timezone(FUSO_HORARIO_LOCAL)

    while True:
        # Arredonda para o in√≠cio do pr√≥ximo bloco de N minutos (para cima)
        minutos_atuais = horario_utc.minute
        minutos_para_proximo_bloco = (DURACAO_CONSULTA_MINUTOS - (minutos_atuais % DURACAO_CONSULTA_MINUTOS)) % DURACAO_CONSULTA_MINUTOS
        if minutos_para_proximo_bloco == 0 and (horario_utc.second > 0 or horario_utc.microsecond > 0):
            # Se j√° est√° no in√≠cio do bloco mas tem segundos, avan√ßa um bloco inteiro
             horario_utc += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        elif minutos_para_proximo_bloco > 0 :
            # Avan√ßa para o in√≠cio do pr√≥ximo bloco
            horario_utc += timedelta(minutes=minutos_para_proximo_bloco)

        # Zera segundos e microssegundos
        horario_utc = horario_utc.replace(second=0, microsecond=0)

        # Converte para o fuso local para verificar hor√°rio de opera√ß√£o e dia da semana
        horario_local = horario_utc.astimezone(tz_local)

        # Verifica se est√° dentro do hor√°rio de opera√ß√£o
        if horario_local.hour < HORARIO_OPERACAO_INICIO:
            # Se for antes do in√≠cio, ajusta para o in√≠cio do dia no fuso local e converte de volta para UTC
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo hor√°rio

        if horario_local.hour >= HORARIO_OPERACAO_FIM:
            # Se for depois do fim, avan√ßa para o dia seguinte e ajusta para o in√≠cio
            horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo hor√°rio

        # Verifica se √© dia √∫til (no fuso local)
        if horario_local.weekday() not in DIAS_UTEIS:
            # Se n√£o for dia √∫til, avan√ßa para o pr√≥ximo dia e ajusta para o in√≠cio
            # Loop para garantir que caia em um dia √∫til
            while horario_local.weekday() not in DIAS_UTEIS:
                 horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo hor√°rio

        # Se passou por todas as verifica√ß√µes, o hor√°rio √© v√°lido
        return horario_utc

def formatar_horario_local(horario_utc: datetime | None, fuso_destino: str = FUSO_HORARIO_LOCAL) -> str:
    """Formata um hor√°rio UTC para uma string leg√≠vel no fuso hor√°rio local."""
    if not horario_utc or not isinstance(horario_utc, datetime):
        return "Indispon√≠vel"
    try:
        # Garante que o datetime de entrada est√° ciente do fuso (UTC)
        if horario_utc.tzinfo is None:
            horario_utc = pytz.utc.localize(horario_utc)

        tz_destino = pytz.timezone(fuso_destino)
        horario_local = horario_utc.astimezone(tz_destino)
        # Formato: DD/MM/AAAA HH:MM (ex: 05/08/2025 14:30)
        return horario_local.strftime("%d/%m/%Y %H:%M")
    except ImportError:
        logging.warning("AGENDA: Biblioteca pytz n√£o instalada. Usando formata√ß√£o UTC.")
        return horario_utc.strftime("%d/%m/%Y %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"AGENDA: Erro ao formatar hor√°rio {horario_utc} para fuso {fuso_destino}: {e}")
        return "Erro na formata√ß√£o"

# --- Fun√ß√µes Principais da Agenda ---

def agendar_consulta(telefone: str, nome: str, email: str | None = None) -> datetime | None:
    """
    Encontra o pr√≥ximo hor√°rio livre e tenta agendar a consulta.
    Retorna o datetime UTC do hor√°rio agendado ou None se n√£o conseguir.
    """
    if consultas_db is None:
        logging.error("AGENDA: ‚ùå N√£o √© poss√≠vel agendar: Sem conex√£o com DB.")
        return None

    # Usar UTC para armazenamento e l√≥gica interna
    agora_utc = datetime.now(timezone.utc)
    # Come√ßa a procurar X minutos √† frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        # Encontra o pr√≥ximo bloco de hor√°rio v√°lido (dia √∫til, hor√°rio de opera√ß√£o)
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Tenta inserir o agendamento no hor√°rio encontrado
        consulta_doc = {
            "telefone": telefone,
            "nome": nome,
            "email": email,
            "horario_utc": horario_tentativa_utc, # Armazena em UTC
            "status": "agendado", # Status inicial
            "criado_em": agora_utc
        }
        try:
            # Tenta inserir o documento. Se o hor√°rio j√° estiver ocupado,
            # o √≠ndice √∫nico ("horario_utc") causar√° um DuplicateKeyError.
            result = consultas_db.insert_one(consulta_doc)
            if result.inserted_id:
                horario_formatado = formatar_horario_local(horario_tentativa_utc)
                logging.info(f"AGENDA: ‚úÖ Consulta marcada para {nome} ({telefone}) em {horario_formatado} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna o hor√°rio em UTC
            else:
                # Caso improv√°vel de falha na inser√ß√£o sem exce√ß√£o
                logging.error(f"AGENDA: ‚ùå Falha desconhecida ao inserir agendamento para {horario_tentativa_utc}.")
                return None

        except DuplicateKeyError:
            # Hor√°rio ocupado, avan√ßa a procura para depois deste bloco
            logging.debug(f"AGENDA: Hor√°rio {horario_tentativa_utc.isoformat()} UTC ocupado. Tentando pr√≥ximo.")
            inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avan√ßa 1 min para recalcular pr√≥ximo bloco
            continue # Tenta o pr√≥ximo hor√°rio

        except Exception as e:
            # Outro erro durante a inser√ß√£o
            logging.error(f"AGENDA: ‚ùå ERRO ao tentar inserir agendamento para {horario_tentativa_utc}: {e}")
            return None # Falha no agendamento

    # Se o loop terminar sem encontrar hor√°rio
    logging.warning(f"AGENDA: ‚ö†Ô∏è N√£o foram encontrados hor√°rios dispon√≠veis para {telefone} ({nome}) ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def cancelar_consulta(telefone: str) -> int:
    """
    Cancela todas as consultas futuras com status 'agendado' para um telefone.
    Retorna o n√∫mero de consultas canceladas.
    """
    if consultas_db is None:
        logging.error("AGENDA: ‚ùå N√£o √© poss√≠vel cancelar: Sem conex√£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Filtro para encontrar consultas futuras e agendadas do telefone
        filtro = {
            "telefone": telefone,
            "horario_utc": {"$gt": agora_utc}, # Apenas hor√°rios futuros
            "status": "agendado" # Apenas consultas que ainda est√£o agendadas
        }
        # Atualiza o status para 'cancelado_usuario' em vez de deletar (mant√©m hist√≥rico)
        resultado = consultas_db.update_many(
            filtro,
            {"$set": {"status": "cancelado_usuario", "cancelado_em": agora_utc}}
        )

        canceladas = resultado.modified_count
        if canceladas > 0:
            logging.info(f"AGENDA: üóëÔ∏è Cancelada(s) {canceladas} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"AGENDA: Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return canceladas
    except Exception as e:
        logging.error(f"AGENDA: ‚ùå ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """
    Consulta o pr√≥ximo hor√°rio dispon√≠vel sem agendar.
    Retorna o datetime UTC do hor√°rio ou None se n√£o encontrar/erro.
    """
    if consultas_db is None:
        logging.error("AGENDA: ‚ùå N√£o √© poss√≠vel consultar hor√°rio: Sem conex√£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    # Come√ßa a procurar um pouco √† frente
    inicio_procura_utc = agora_utc + timedelta(minutes=5) # Pequena margem

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            # Verifica se existe alguma consulta agendada ou confirmada para este hor√°rio
            filtro_conflito = {
                "horario_utc": horario_tentativa_utc,
                "status": {"$in": ["agendado", "confirmado"]} # Considera ambos como ocupados
            }
            conflito = consultas_db.find_one(filtro_conflito)
            if not conflito:
                # Encontrou hor√°rio livre
                logging.info(f"AGENDA: Pr√≥ximo hor√°rio dispon√≠vel encontrado: {formatar_horario_local(horario_tentativa_utc)} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna hor√°rio em UTC
            else:
                # Hor√°rio ocupado, avan√ßa para o pr√≥ximo bloco
                logging.debug(f"AGENDA: Hor√°rio {horario_tentativa_utc.isoformat()} UTC ocupado (Status: {conflito.get('status')}). Tentando pr√≥ximo.")
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avan√ßa 1 min
                continue
        except Exception as e:
            logging.error(f"AGENDA: ‚ùå ERRO ao consultar pr√≥ximo hor√°rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro na consulta

    # Se o loop terminar
    logging.warning(f"AGENDA: ‚ö†Ô∏è Nenhum hor√°rio dispon√≠vel encontrado na consulta ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

# Arquivo: ./utils/leads.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )

# Arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Arquivo: ./utils/followup.py
# ===========================================================
# Arquivo: utils/followup.py
# (Implementa√ß√£o das fun√ß√µes de acompanhamento de pagamento)
# ===========================================================
from datetime import datetime, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure
# Ajuste o import se config.py estiver em um diret√≥rio diferente
from app.config import MONGO_URI
# Importa a fun√ß√£o de agendamento para ser chamada ap√≥s o pagamento
# Ajuste o import se agenda.py estiver em um diret√≥rio diferente
from app.utils.agenda import agendar_consulta, formatar_horario_local
import logging

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Conex√£o com MongoDB ---
mongo_followup = None
db_followup = None
pagamentos_db = None # Cole√ß√£o para rastrear status de pagamento

try:
    # Estabelece conex√£o com MongoDB
    if MONGO_URI:
        mongo_followup = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_followup.server_info() # Testa a conex√£o
        db_followup = mongo_followup["famdomes"] # Nome do banco de dados
        pagamentos_db = db_followup["pagamentos"] # Cole√ß√£o para pagamentos
        # Cria √≠ndices se n√£o existirem
        pagamentos_db.create_index("telefone")
        pagamentos_db.create_index("id_sessao_stripe", sparse=True, unique=True) # ID da sess√£o deve ser √∫nico
        pagamentos_db.create_index("status")
        pagamentos_db.create_index("criado_em")
        logging.info("FOLLOWUP: Conex√£o com MongoDB estabelecida para Pagamentos.")
    else:
        logging.error("FOLLOWUP: ‚ùå MONGO_URI n√£o definido. N√£o foi poss√≠vel conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"FOLLOWUP: ‚ùå Falha na conex√£o com MongoDB: {e}")
except Exception as e:
    logging.error(f"FOLLOWUP: ‚ùå ERRO ao conectar com MongoDB ou criar √≠ndices: {e}")
    mongo_followup = None
    db_followup = None
    pagamentos_db = None

# --- Fun√ß√µes de Follow-up ---

def iniciar_sessao(telefone: str, nome: str, id_sessao_stripe: str | None = None):
    """
    Registra o in√≠cio de uma tentativa de pagamento no banco de dados.
    Chamado quando o link de pagamento √© gerado. Usa update_one com upsert=True
    para criar ou atualizar o registro baseado no id_sessao_stripe, se fornecido.

    Args:
        telefone (str): Telefone do usu√°rio.
        nome (str): Nome do usu√°rio.
        id_sessao_stripe (str | None): ID da sess√£o de checkout do Stripe.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ‚ùå Falha ao iniciar sess√£o: DB indispon√≠vel.")
        return

    try:
        agora = datetime.now(timezone.utc)
        # Filtro: usa id_sessao_stripe se dispon√≠vel, sen√£o cria um novo (ou atualiza baseado em telefone?)
        # √â mais seguro basear no id_sessao_stripe para evitar sobrescrever sess√µes ativas
        filtro = {"id_sessao_stripe": id_sessao_stripe} if id_sessao_stripe else {"telefone": telefone, "status": "link_gerado"} # Se sem ID, atualiza √∫ltimo link gerado

        update_data = {
            "$set": {
                "telefone": telefone,
                "nome": nome,
                "status": "link_gerado", # Garante o status correto
                "ultima_atualizacao": agora
            },
            "$setOnInsert": { # Define apenas na cria√ß√£o
                 "id_sessao_stripe": id_sessao_stripe, # S√≥ define ID na cria√ß√£o se filtro n√£o o usou
                 "criado_em": agora
            }
        }
        # Se o filtro usou id_sessao_stripe, garante que ele seja definido no $set tamb√©m
        if id_sessao_stripe:
            update_data["$set"]["id_sessao_stripe"] = id_sessao_stripe


        result = pagamentos_db.update_one(filtro, update_data, upsert=True)

        if result.upserted_id:
            logging.info(f"FOLLOWUP: üìç Nova sess√£o de pagamento iniciada para {telefone} ({nome}). Sess√£o: {id_sessao_stripe or 'N/A'}.")
        elif result.modified_count > 0:
             logging.info(f"FOLLOWUP: üìç Sess√£o de pagamento atualizada para {telefone} ({nome}). Sess√£o: {id_sessao_stripe or 'N/A'}.")
        else:
             logging.info(f"FOLLOWUP: üìç Sess√£o de pagamento para {telefone} ({nome}) n√£o modificada (Sess√£o: {id_sessao_stripe or 'N/A'}).")

    except Exception as e:
        logging.exception(f"FOLLOWUP: ‚ùå ERRO ao iniciar/atualizar sess√£o de pagamento para {telefone}:")

def marcar_pagamento(
    telefone: str | None = None,
    id_sessao_stripe: str | None = None,
    email_cliente: str | None = None,
    nome_cliente: str | None = None
) -> tuple[datetime | None, str | None]:
    """
    Marca um pagamento como conclu√≠do no banco de dados e tenta agendar a consulta.
    Chamado pelo webhook do Stripe ap√≥s 'checkout.session.completed'.

    Args:
        telefone (str | None): Telefone do usu√°rio (vindo dos metadados do Stripe).
        id_sessao_stripe (str | None): ID da sess√£o de checkout do Stripe.
        email_cliente (str | None): Email do cliente (vindo da sess√£o Stripe).
        nome_cliente (str | None): Nome do cliente (vindo da sess√£o Stripe ou metadados).

    Returns:
        tuple[datetime | None, str | None]:
            - horario_agendado_utc: O hor√°rio UTC da consulta agendada, ou None se falhar.
            - nome_final: O nome usado para o agendamento.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ‚ùå Falha ao marcar pagamento: DB indispon√≠vel.")
        return None, None

    # Precisa do id_sessao para garantir que estamos atualizando o pagamento correto
    if not id_sessao_stripe:
        logging.error("FOLLOWUP: ‚ùå Falha ao marcar pagamento: ID da sess√£o Stripe ausente.")
        # Poderia tentar buscar por telefone, mas √© arriscado se houver links antigos
        return None, None

    # Monta o filtro para encontrar o registro da sess√£o de pagamento pelo ID
    filtro = {"id_sessao_stripe": id_sessao_stripe}

    try:
        agora_utc = datetime.now(timezone.utc)
        # Dados para atualizar o registro
        update_data = {
            "$set": {
                "status": "pago", # Marca como pago
                "pago_em": agora_utc,
                "ultima_atualizacao": agora_utc,
                "email_stripe": email_cliente,
                # Atualiza telefone e nome se vieram do Stripe (podem ter sido preenchidos l√°)
                "telefone": telefone if telefone else "$telefone", # Mant√©m o original se n√£o veio
                "nome": nome_cliente if nome_cliente else "$nome" # Mant√©m o original se n√£o veio
            }
        }

        # Encontra e atualiza o registro do pagamento
        # Retorna o documento AP√ìS a atualiza√ß√£o para pegar os dados mais recentes
        pagamento_atualizado = pagamentos_db.find_one_and_update(
            filtro,
            update_data,
            return_document=ReturnDocument.AFTER # Pega o documento atualizado
        )

        if pagamento_atualizado:
            logging.info(f"FOLLOWUP: üí∞ Pagamento confirmado para sess√£o {id_sessao_stripe} (Telefone: {pagamento_atualizado.get('telefone')}).")
            # Usa os dados atualizados para agendar
            tel_para_agendar = pagamento_atualizado.get('telefone')
            nome_para_agendar = pagamento_atualizado.get('nome', 'Cliente')
            email_para_agendar = pagamento_atualizado.get('email_stripe') # Usa o email do Stripe

            # Verifica se temos telefone para agendar
            if not tel_para_agendar:
                 logging.error(f"FOLLOWUP: ‚ùå Telefone ausente no registro de pagamento {id_sessao_stripe} ap√≥s atualiza√ß√£o. N√£o √© poss√≠vel agendar.")
                 return None, nome_para_agendar # Retorna nome para poss√≠vel notifica√ß√£o

            # --- Tenta Agendar a Consulta ---
            logging.info(f"FOLLOWUP: Tentando agendar consulta para {nome_para_agendar} ({tel_para_agendar})...")
            horario_agendado_utc = agendar_consulta(
                telefone=tel_para_agendar,
                nome=nome_para_agendar,
                email=email_para_agendar
            )

            if horario_agendado_utc:
                logging.info(f"FOLLOWUP: ‚úÖ Consulta agendada com sucesso para {tel_para_agendar} em {formatar_horario_local(horario_agendado_utc)}.")
                # Salva o hor√°rio agendado no registro de pagamento
                pagamentos_db.update_one(
                    {"_id": pagamento_atualizado["_id"]},
                    {"$set": {"horario_consulta_agendada_utc": horario_agendado_utc, "status": "agendado"}} # Atualiza status final
                )
                return horario_agendado_utc, nome_para_agendar
            else:
                logging.error(f"FOLLOWUP: ‚ùå Falha ao agendar consulta para {tel_para_agendar} ap√≥s pagamento.")
                # O pagamento foi marcado, mas o agendamento falhou. Requer aten√ß√£o manual.
                pagamentos_db.update_one(
                     {"_id": pagamento_atualizado["_id"]},
                     {"$set": {"status": "pago_erro_agendamento"}} # Marca status especial
                )
                return None, nome_para_agendar # Retorna None para hor√°rio, mas nome para poss√≠vel notifica√ß√£o
        else:
            logging.warning(f"FOLLOWUP: ‚ö†Ô∏è Nenhum registro de pagamento encontrado para ID Sess√£o Stripe: {id_sessao_stripe}. Pagamento pode j√° ter sido processado ou ID inv√°lido.")
            return None, None

    except Exception as e:
        logging.exception(f"FOLLOWUP: ‚ùå ERRO CR√çTICO ao marcar pagamento/agendar para ID Sess√£o {id_sessao_stripe}:")
        return None, None

# TODO: Adicionar fun√ß√£o para checar follow-ups (ex: pagamentos com link_gerado > X horas) se necess√°rio.
# async def checar_followups(): ...


# Arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Arquivo: ./routes/resetar.py
from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone √© obrigat√≥rio.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")

# Arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sess√£o est√° confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from app.utils.nlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado

# Arquivo: ./routes/stripe.py
# ===========================================================
# Arquivo: routes/stripe.py
# (Implementa√ß√£o do webhook do Stripe)
# ===========================================================
from fastapi import APIRouter, Request, Header, HTTPException, BackgroundTasks
import stripe # Importa a biblioteca do Stripe
import logging

# Ajuste os imports conforme a estrutura do seu projeto
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
# Importa fun√ß√µes de followup e agenda
from app.utils.followup import marcar_pagamento
from app.utils.agenda import formatar_horario_local
# Importa fun√ß√£o para salvar contexto e enviar mensagem
from app.utils.contexto import salvar_contexto
from app.utils.mensageria import enviar_mensagem

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este m√≥dulo
router = APIRouter(prefix="/webhook", tags=["Stripe"]) # Adiciona prefixo e tag

# Define a chave secreta do Stripe (carregada da configura√ß√£o)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("STRIPE Route: Chave secreta do Stripe configurada.")
else:
    logging.error("STRIPE Route: ‚ùå Chave secreta do Stripe (STRIPE_SECRET_KEY) n√£o configurada. Webhook n√£o funcionar√°.")
    # A aplica√ß√£o pode iniciar, mas o webhook falhar√°

@router.post("/stripe/", summary="Recebe eventos do webhook do Stripe")
async def stripe_webhook(request: Request, background_tasks: BackgroundTasks, stripe_signature: str = Header(None)):
    """
    Endpoint para receber eventos do Stripe via webhook.
    Verifica a assinatura e processa eventos relevantes (ex: checkout.session.completed).
    Processa a l√≥gica principal em background.
    """
    # Verifica se a chave do webhook est√° configurada
    if not STRIPE_WEBHOOK_SECRET:
        logging.error("STRIPE Route: ‚ùå Chave secreta do webhook Stripe (STRIPE_WEBHOOK_SECRET) n√£o configurada.")
        raise HTTPException(status_code=500, detail="Configura√ß√£o de webhook incompleta no servidor.")

    # Obt√©m o corpo bruto da requisi√ß√£o
    payload = await request.body()

    # Verifica a assinatura do webhook para garantir que veio do Stripe
    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
        logging.info(f"STRIPE Route: Evento recebido tipo: {event['type']} (ID: {event['id']})")
    except ValueError as e:
        # Payload inv√°lido
        logging.error(f"STRIPE Route: ‚ùå Erro ao decodificar payload do webhook: {e}")
        raise HTTPException(status_code=400, detail="Payload inv√°lido.")
    except stripe.error.SignatureVerificationError as e:
        # Assinatura inv√°lida
        logging.error(f"STRIPE Route: ‚ùå Erro na verifica√ß√£o da assinatura do webhook: {e}")
        raise HTTPException(status_code=400, detail="Assinatura inv√°lida.")
    except Exception as e:
        logging.exception("STRIPE Route: ‚ùå Erro inesperado ao construir evento do webhook:")
        raise HTTPException(status_code=500, detail="Erro interno ao processar webhook.")

    # --- Processamento do Evento (em Background) ---
    # Adiciona a tarefa de processar o evento em background
    background_tasks.add_task(processar_evento_stripe, event)

    # Retorna 200 OK imediatamente para o Stripe
    return {"status": "recebido"}

async def processar_evento_stripe(event: dict):
    """
    Fun√ß√£o executada em background para processar o evento do Stripe.
    """
    event_type = event["type"]
    session = event["data"]["object"] # O objeto da sess√£o de checkout

    logging.info(f"STRIPE BG Task: Processando evento tipo: {event_type} (Sess√£o ID: {session.get('id', 'N/A')})")

    # --- Evento: Checkout Conclu√≠do com Sucesso ---
    if event_type == "checkout.session.completed":
        # Extrai metadados e informa√ß√µes do cliente da sess√£o Stripe
        metadata = session.get("metadata", {})
        telefone_cliente = metadata.get("telefone")
        nome_cliente_meta = metadata.get("nome") # Nome dos metadados (pode ser mais confi√°vel)

        customer_details = session.get("customer_details", {})
        email_cliente = customer_details.get("email")
        nome_cliente_stripe = customer_details.get("name") # Nome direto do Stripe

        # Usa o nome dos metadados como prioridade, sen√£o o do Stripe
        nome_final = nome_cliente_meta or nome_cliente_stripe or "Cliente"

        id_sessao_stripe = session.get("id")

        # Verifica se temos o telefone (essencial para continuar)
        if not telefone_cliente:
            logging.error(f"STRIPE BG Task: ‚ùå Evento {event_type} (Sess√£o: {id_sessao_stripe}) sem 'telefone' nos metadados. N√£o √© poss√≠vel prosseguir.")
            return # Aborta o processamento

        logging.info(f"STRIPE BG Task: Checkout conclu√≠do para {nome_final} ({telefone_cliente}). Sess√£o: {id_sessao_stripe}")

        # Tenta marcar o pagamento e agendar a consulta
        horario_agendado_utc, nome_agendado = await asyncio.to_thread(
             marcar_pagamento, # Executa a fun√ß√£o s√≠ncrona em uma thread separada
             telefone=telefone_cliente,
             id_sessao_stripe=id_sessao_stripe,
             email_cliente=email_cliente,
             nome_cliente=nome_final
        )
        # horario_agendado_utc, nome_agendado = marcar_pagamento( # Se marcar_pagamento fosse async
        #     telefone=telefone_cliente,
        #     id_sessao_stripe=id_sessao_stripe,
        #     email_cliente=email_cliente,
        #     nome_cliente=nome_final
        # )


        if horario_agendado_utc:
            # Agendamento bem-sucedido!
            horario_formatado = formatar_horario_local(horario_agendado_utc)
            # Monta mensagem de confirma√ß√£o para o paciente
            msg_paciente = (
                f"‚úÖ Ol√° {nome_agendado}, pagamento confirmado!\n\n"
                f"Sua consulta inicial est√° agendada para:\n"
                f"üóìÔ∏è **{horario_formatado}** (Hor√°rio de Bras√≠lia).\n\n"
                f"O profissional entrar√° em contato com voc√™ por aqui neste hor√°rio. At√© l√°!"
            )
            # Envia a confirma√ß√£o para o paciente
            await enviar_mensagem(telefone_cliente, msg_paciente)

            # Monta notifica√ß√£o para o m√©dico/equipe (opcional)
            # TODO: Definir n√∫mero/canal do m√©dico em config.py
            numero_medico = os.getenv("WHATSAPP_MEDICO_AVISO")
            if numero_medico:
                msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento confirmado:\n\nPaciente: {nome_agendado}\nTelefone: {telefone_cliente}\nHor√°rio: {horario_formatado}"
                await enviar_mensagem(numero_medico, msg_medico)

            # --- ATUALIZA O ESTADO DA CONVERSA ---
            # Muda o estado para iniciar o question√°rio na pr√≥xima intera√ß√£o
            logging.info(f"STRIPE BG Task: Atualizando estado para CONFIRMANDO_AGENDAMENTO para {telefone_cliente}")
            salvar_contexto(telefone_cliente, {
                "estado": "CONFIRMANDO_AGENDAMENTO",
                "nome": nome_agendado, # Salva/Atualiza o nome no contexto
                "meta_conversa": {"email_cliente": email_cliente} # Salva email na meta
            })

        else:
            # Falha no agendamento ap√≥s pagamento
            logging.error(f"STRIPE BG Task: ‚ùå Pagamento confirmado para {telefone_cliente}, mas FALHA AO AGENDAR consulta.")
            # Envia mensagem de erro para o paciente
            msg_erro_agendamento = (
                f"‚ö†Ô∏è Ol√° {nome_agendado}, seu pagamento foi confirmado, mas houve um problema ao agendar automaticamente sua consulta.\n\n"
                f"N√£o se preocupe, nossa equipe j√° foi notificada e entrar√° em contato em breve para finalizar o agendamento manualmente. Obrigado pela compreens√£o."
            )
            await enviar_mensagem(telefone_cliente, msg_erro_agendamento)
            # TODO: Notificar equipe interna sobre a falha no agendamento autom√°tico

    # --- Outros Eventos (Opcional) ---
    # elif event_type == "checkout.session.async_payment_failed":
    #     logging.warning(f"STRIPE BG Task: Pagamento ass√≠ncrono falhou para sess√£o {session.get('id')}")
    #     # L√≥gica para lidar com falha (ex: notificar usu√°rio)
    # elif event_type == "checkout.session.expired":
    #      logging.info(f"STRIPE BG Task: Sess√£o de checkout expirada: {session.get('id')}")
         # L√≥gica para lidar com expira√ß√£o (ex: marcar no DB)

    else:
        # Evento n√£o tratado
        logging.info(f"STRIPE BG Task: Evento tipo '{event_type}' n√£o tratado.")

    logging.info(f"STRIPE BG Task: Processamento do evento conclu√≠do.")

# Importar asyncio e json se n√£o estiverem importados
import asyncio
import json
import os # Para getenv

# Arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda n√£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Arquivo: ./routes/agendamento.py
# ===========================================================
# Arquivo: routes/agendamento.py
# (Corrigido para importar a fun√ß√£o correta de agenda.py)
# ===========================================================
from fastapi import APIRouter, HTTPException
import logging

# Ajuste o import conforme a estrutura do seu projeto
# Importa a fun√ß√£o correta para consultar o pr√≥ximo hor√°rio
from app.utils.agenda import consultar_proximo_horario_disponivel, formatar_horario_local

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este m√≥dulo
router = APIRouter(prefix="/agenda", tags=["Agendamento"]) # Adiciona prefixo e tag

@router.get("/proximo", summary="Consulta o pr√≥ximo hor√°rio de agendamento dispon√≠vel")
async def proximo_agendamento_disponivel():
    """
    Endpoint para verificar o pr√≥ximo hor√°rio livre na agenda.
    Retorna o hor√°rio formatado ou uma mensagem indicando indisponibilidade.
    """
    logging.info("AGENDAMENTO Route: Consultando pr√≥ximo hor√°rio dispon√≠vel...")
    try:
        # Chama a fun√ß√£o correta para obter o pr√≥ximo hor√°rio UTC
        horario_utc = consultar_proximo_horario_disponivel()

        if horario_utc:
            # Formata o hor√°rio para o fuso local
            horario_formatado = formatar_horario_local(horario_utc)
            logging.info(f"AGENDAMENTO Route: Pr√≥ximo hor√°rio encontrado: {horario_formatado}")
            return {"proximo_horario_disponivel": horario_formatado, "horario_utc": horario_utc.isoformat()}
        else:
            # Se a fun√ß√£o retornar None (sem hor√°rio ou erro no DB)
            logging.info("AGENDAMENTO Route: Nenhum hor√°rio dispon√≠vel encontrado.")
            return {"proximo_horario_disponivel": None, "mensagem": "Nenhum hor√°rio dispon√≠vel encontrado no momento."}
    except Exception as e:
        # Captura qualquer erro inesperado durante a consulta
        logging.exception("AGENDAMENTO Route: ‚ùå Erro inesperado ao consultar pr√≥ximo hor√°rio:")
        raise HTTPException(status_code=500, detail="Erro interno ao consultar a agenda.")


# Arquivo: ./routes/whatsapp.py
# ===========================================================
# Arquivo: routes/whatsapp.py
# (Recebe webhooks do WhatsApp e chama nlp.py)
# ===========================================================
from fastapi import APIRouter, Request, Response, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
import logging

# Ajuste os imports conforme a estrutura do seu projeto
# Assume que est√£o em app/
from app.config import WHATSAPP_VERIFY_TOKEN
from app.utils.mensageria import enviar_mensagem
from app.utils.nlp import processar_mensagem # Fun√ß√£o principal de processamento
from app.utils.contexto import limpar_contexto # Para o comando de reset

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este m√≥dulo
router = APIRouter(prefix="/chat", tags=["WhatsApp"]) # Adiciona prefixo e tag

@router.get("/webhook/whatsapp/", summary="Verifica o webhook do WhatsApp")
async def verificar_webhook(request: Request):
    """
    Endpoint GET para verificar o webhook do WhatsApp durante a configura√ß√£o na plataforma Meta.
    Responde ao desafio 'hub.challenge'.
    """
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    # Verifica se o modo e o token de verifica√ß√£o correspondem ao esperado
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        logging.info("WHATSAPP Route: ‚úÖ Webhook verificado com sucesso!")
        # Retorna o desafio para confirmar a verifica√ß√£o
        return Response(content=challenge, media_type="text/plain", status_code=200)
    else:
        # Se a verifica√ß√£o falhar, retorna um erro 403 (Proibido)
        logging.warning("WHATSAPP Route: ‚ö†Ô∏è Falha na verifica√ß√£o do webhook. Token inv√°lido ou modo incorreto.")
        return Response(content="Falha na verifica√ß√£o", status_code=403)

@router.post("/webhook/whatsapp/", summary="Recebe mensagens do WhatsApp")
async def receber_mensagem_whatsapp(request: Request, background_tasks: BackgroundTasks):
    """
    Endpoint POST para receber notifica√ß√µes de mensagens do WhatsApp via webhook.
    Processa a mensagem em background para responder rapidamente √† Meta.
    """
    try:
        # Obt√©m o corpo JSON da requisi√ß√£o de forma ass√≠ncrona
        data = await request.json()
        # logging.debug(f"WHATSAPP Route: Webhook recebido: {json.dumps(data, indent=2)}") # Log detalhado opcional

        # Extrai as informa√ß√µes relevantes da estrutura do webhook
        # Adapte essa extra√ß√£o se a estrutura do payload do webhook mudar
        entry = data.get("entry", [])
        if not entry:
            logging.info("WHATSAPP Route: Webhook recebido sem 'entry'. Ignorando.")
            return Response(status_code=200) # Responde OK para Meta

        changes = entry[0].get("changes", [])
        if not changes:
            logging.info("WHATSAPP Route: Webhook recebido sem 'changes'. Ignorando.")
            return Response(status_code=200)

        value = changes[0].get("value", {})
        messages = value.get("messages", [])
        contacts = value.get("contacts", [])
        statuses = value.get("statuses", []) # Captura eventos de status

        # Prioriza o processamento de mensagens de texto
        if messages and "text" in messages[0] and contacts:
            # Extrai os dados da mensagem e do contato
            mensagem_atual = messages[0]["text"]["body"]
            telefone_usuario = messages[0]["from"]
            # Tenta pegar o nome do perfil, se n√£o existir usa o telefone
            nome_usuario = contacts[0].get("profile", {}).get("name", telefone_usuario)

            logging.info(f"WHATSAPP Route: Recebida mensagem de {nome_usuario} ({telefone_usuario})")
            logging.debug(f"WHATSAPP Route: Mensagem: {mensagem_atual}") # Debug para ver a msg

            # Adiciona o processamento da mensagem √† fila de background tasks
            # Isso permite retornar 200 OK rapidamente para a Meta
            background_tasks.add_task(processar_e_responder, telefone_usuario, nome_usuario, mensagem_atual)

            # Retorna 200 OK imediatamente
            return Response(status_code=200)

        # Loga eventos de status (entrega, leitura) - opcional
        elif statuses:
            for status_info in statuses:
                status_type = status_info.get("status")
                recipient_id = status_info.get("recipient_id")
                message_id = status_info.get("id")
                timestamp = status_info.get("timestamp")
                logging.debug(f"WHATSAPP Route: Status recebido para {recipient_id} (Msg ID: {message_id}): {status_type} @ {timestamp}")
            return Response(status_code=200)

        else:
            # Se n√£o for mensagem de texto ou status conhecido, ignora
            logging.info("WHATSAPP Route: üì≠ Evento ignorado ‚Äì sem mensagem de texto v√°lida ou status conhecido.")
            return Response(status_code=200)

    # Tratamento de exce√ß√µes gerais durante o processamento inicial do webhook
    except json.JSONDecodeError:
        logging.error("WHATSAPP Route: ‚ùå Erro ao decodificar JSON do webhook.")
        # Retorna 400 Bad Request se o JSON for inv√°lido
        return Response(content="JSON inv√°lido", status_code=400)
    except Exception as e:
        # Loga o erro detalhado que causou a falha
        logging.exception(f"WHATSAPP Route: ‚ùå ERRO CR√çTICO inicial no webhook:")
        # Retorna um erro 500 (Internal Server Error) para a API do WhatsApp
        # Isso pode fazer com que a Meta tente reenviar o webhook
        return Response(content="Erro interno no servidor", status_code=500)


async def processar_e_responder(telefone: str, nome: str, mensagem: str):
    """
    Fun√ß√£o executada em background para processar a mensagem e enviar a resposta.
    """
    try:
        logging.info(f"WHATSAPP BG Task: Iniciando processamento para {telefone}...")
        # --- Tratamento de Comando Especial (Reset) ---
        if mensagem.strip().lower() == "melancia vermelha":
            logging.info(f"WHATSAPP BG Task: Comando de reset 'melancia vermelha' recebido de {telefone}. Limpando contexto...")
            sucesso_limpeza = limpar_contexto(telefone)
            if sucesso_limpeza:
                # Envia confirma√ß√£o de reset (opcional)
                await enviar_mensagem(telefone, "üîÑ Sua conversa foi reiniciada. Pode come√ßar de novo quando quiser.")
            else:
                # Envia mensagem de erro se a limpeza falhar (opcional)
                await enviar_mensagem(telefone, "‚ö†Ô∏è Ocorreu um erro ao tentar reiniciar a conversa. Por favor, tente novamente.")
            logging.info(f"WHATSAPP BG Task: Reset conclu√≠do para {telefone}.")
            return # Finaliza a task de background

        # --- Processamento Normal da Mensagem ---
        # Chama a fun√ß√£o principal em nlp.py para processar a mensagem
        resultado_processamento = await processar_mensagem(
            mensagem=mensagem,
            telefone=telefone,
            canal="whatsapp" # Define o canal
        )

        # Obt√©m a resposta a ser enviada ao usu√°rio
        resposta_para_usuario = resultado_processamento.get("resposta")

        # Envia a resposta de volta ao usu√°rio via WhatsApp
        if resposta_para_usuario:
            logging.info(f"WHATSAPP BG Task: Enviando resposta para {telefone}...")
            await enviar_mensagem(telefone, resposta_para_usuario)
        else:
            # Se nlp.py n√£o retornar uma resposta (o que n√£o deveria acontecer)
            logging.warning(f"WHATSAPP BG Task: Fun√ß√£o processar_mensagem n√£o retornou 'resposta' para {telefone}. Enviando erro padr√£o.")
            await enviar_mensagem(telefone, "Desculpe, n√£o consegui processar sua solicita√ß√£o no momento.")

        logging.info(f"WHATSAPP BG Task: Processamento e resposta conclu√≠dos para {telefone}.")

    except Exception as e:
        # Loga qualquer erro que ocorra durante o processamento em background
        logging.exception(f"WHATSAPP BG Task: ‚ùå ERRO durante processamento para {telefone}:")
        # Considerar enviar uma mensagem de erro para o usu√°rio aqui tamb√©m?
        # await enviar_mensagem(telefone, "Desculpe, ocorreu um erro interno ao processar sua mensagem.")

# Importar json se n√£o estiver importado
import json

# Arquivo: ./routes/ia.py
# ===========================================================
# Arquivo: routes/ia.py
# (Cont√©m a l√≥gica para processar comandos espec√≠ficos como agendar)
# ===========================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import logging
import stripe # Importa a biblioteca do Stripe
from datetime import datetime, timedelta # Para expira√ß√£o da sess√£o

# Ajuste os imports das fun√ß√µes utilit√°rias conforme a estrutura do seu projeto
# Assume que est√£o em app/utils/
from app.utils.agenda import (
    agendar_consulta,
    cancelar_consulta,
    consultar_proximo_horario_disponivel,
    formatar_horario_local
)
from app.utils.mensageria import enviar_mensagem
# Assume que followup.py existe e tem iniciar_sessao (se usado)
# from app.utils.followup import iniciar_sessao
# Assume que config.py existe e tem a chave do Stripe
from app.config import STRIPE_SECRET_KEY

# Configura√ß√£o b√°sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este m√≥dulo
router = APIRouter()

# Define a chave secreta do Stripe (carregada da configura√ß√£o)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("IA Route: Chave secreta do Stripe configurada.")
else:
    logging.warning("IA Route: ‚ö†Ô∏è Chave secreta do Stripe (STRIPE_SECRET_KEY) n√£o configurada.")
    # Considerar levantar um erro ou desabilitar funcionalidade de pagamento

# Modelo Pydantic para validar a entrada da API /ia-comando (se usada)
class ComandoIAInput(BaseModel):
    telefone: str
    nome: str
    comando: str # Ex: "quero agendar", "ver hor√°rio", "cancelar"

# --- Endpoint da API (Opcional) ---
@router.post("/ia-comando", summary="Processa comandos espec√≠ficos da IA", tags=["IA"])
async def processar_comando_post(dados: ComandoIAInput):
    """
    Recebe um comando espec√≠fico (agendar, cancelar, ver hor√°rio)
    e executa a a√ß√£o correspondente. (Endpoint HTTP opcional)
    """
    # Verifica se a API do Stripe est√° configurada antes de prosseguir com agendamento
    if "agendar" in dados.comando.lower() and not STRIPE_SECRET_KEY:
         logging.error("IA Route: ‚ùå Tentativa de agendamento via API sem STRIPE_SECRET_KEY.")
         raise HTTPException(status_code=503, detail="Funcionalidade de pagamento indispon√≠vel.")

    # Chama a fun√ß√£o principal que processa o comando
    resultado = await processar_comando(dados.dict())
    # Retorna o resultado da fun√ß√£o
    return resultado

# --- Fun√ß√£o Principal de Processamento de Comandos ---
# Esta fun√ß√£o √© chamada pelo endpoint acima e tamb√©m diretamente por nlp.py

async def processar_comando(dados: dict) -> dict:
    """
    Processa comandos espec√≠ficos vindos da intera√ß√£o do usu√°rio ou da IA.

    Args:
        dados (dict): Dicion√°rio contendo 'telefone', 'nome' e 'comando'.

    Returns:
        dict: Dicion√°rio com o status da opera√ß√£o e mensagens relevantes.
    """
    telefone = dados.get("telefone")
    nome = dados.get("nome", "Cliente") # Usa 'Cliente' como nome padr√£o
    comando = dados.get("comando", "").lower() # Pega o comando e converte para min√∫sculas

    # Valida√ß√£o b√°sica de entrada
    if not telefone or not comando:
        logging.warning("IA Route: Comando recebido sem telefone ou comando.")
        # Retorna um erro ou uma resposta padr√£o indicando falha
        # N√£o levanta HTTPException aqui pois pode ser chamado internamente por nlp.py
        return {"status": "erro_input", "mensagem": "Dados insuficientes para processar comando."}

    logging.info(f"IA Route: Processando comando '{comando}' para {telefone} ({nome})...")

    # --- L√≥gica para Comando "agendar" ---
    if "agendar" in comando:
        # Verifica novamente se Stripe est√° configurado
        if not STRIPE_SECRET_KEY:
            logging.error("IA Route: ‚ùå Tentativa de agendamento sem STRIPE_SECRET_KEY configurada.")
            msg_erro = "Desculpe, a op√ß√£o de agendamento online n√£o est√° dispon√≠vel no momento."
            # N√£o envia mensagem aqui, pois nlp.py tratar√° a resposta
            # await enviar_mensagem(telefone, msg_erro)
            return {"status": "erro_config_stripe", "mensagem": msg_erro}

        # TODO: Descomentar se a fun√ß√£o iniciar_sessao for usada para tracking
        # Inicia a sess√£o de pagamento/follow-up (se aplic√°vel)
        # iniciar_sessao(telefone, nome) # Registra a tentativa no DB de follow-up

        try:
            # Cria uma sess√£o de checkout no Stripe
            logging.info(f"IA Route: Criando sess√£o Stripe Checkout para {telefone}...")
            # Define o URL base (pode vir do .env)
            base_url = os.getenv("APP_BASE_URL", "[https://famdomes.com.br](https://famdomes.com.br)") # Exemplo
            success_url = f"{base_url}/sucesso?session_id={{CHECKOUT_SESSION_ID}}"
            cancel_url = f"{base_url}/cancelado"

            session = stripe.checkout.Session.create(
                payment_method_types=["card", "boleto"], # Aceita cart√£o e boleto
                line_items=[{
                    "price_data": {
                        "currency": "brl", # Moeda brasileira
                        "product_data": {"name": "Consulta Inicial FAMDOMES"}, # Nome do produto
                        "unit_amount": 10000, # Pre√ßo em centavos (R$ 100,00)
                    },
                    "quantity": 1, # Quantidade
                }],
                mode="payment", # Modo de pagamento √∫nico
                # URLs para redirecionamento ap√≥s sucesso ou cancelamento
                success_url=success_url,
                cancel_url=cancel_url,
                # Metadados para identificar o cliente no webhook
                metadata={
                    "telefone": telefone,
                    "nome": nome
                },
                # Configura√ß√£o para Boleto (opcional, mas recomendada)
                payment_intent_data={
                     # 'setup_future_usage': 'off_session' # Pode n√£o ser necess√°rio para pagamentos √∫nicos
                },
                # Expira√ß√£o da sess√£o de checkout (ex: 2 horas)
                expires_at=int((datetime.now() + timedelta(hours=2)).timestamp())
            )
            logging.info(f"IA Route: Sess√£o Stripe criada com ID: {session.id} para {telefone}")

            # Monta a mensagem com o link de pagamento para o usu√°rio
            msg_link = f"‚úÖ √ìtimo! Para agendar sua consulta inicial (valor R$100,00), por favor, realize o pagamento seguro atrav√©s deste link:\n{session.url}\n\nO link expira em breve."
            # A mensagem ser√° enviada por nlp.py, aqui apenas retornamos os dados
            # await enviar_mensagem(telefone, msg_link)
            # Retorna o status e a URL de checkout
            return {"status": "link_gerado", "checkout_url": session.url, "mensagem": msg_link}

        except stripe.error.StripeError as e:
             # Erro espec√≠fico do Stripe
             logging.error(f"IA Route: ‚ùå Erro Stripe ao criar checkout para {telefone}: {e}")
             msg_erro = "‚ùå Desculpe, ocorreu um erro ao tentar gerar o link de pagamento com nosso parceiro. Por favor, tente novamente mais tarde ou entre em contato conosco."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_stripe", "mensagem": msg_erro}
        except Exception as e:
             # Outro erro inesperado
             logging.exception(f"IA Route: ‚ùå Erro inesperado ao criar checkout para {telefone}:")
             msg_erro = "‚ùå Desculpe, ocorreu um erro inesperado ao gerar seu link de pagamento. Tente novamente mais tarde."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_desconhecido", "mensagem": msg_erro}

    # --- L√≥gica para Comando "cancelar" ---
    elif "cancelar" in comando:
        logging.info(f"IA Route: Processando cancelamento de consulta para {telefone}...")
        # Chama a fun√ß√£o para cancelar consultas futuras
        # TODO: Implementar a fun√ß√£o cancelar_consulta em utils/agenda.py
        consultas_canceladas = cancelar_consulta(telefone) # Assume que retorna int
        if consultas_canceladas > 0:
            msg = f"‚úÖ Sua(s) {consultas_canceladas} consulta(s) futura(s) foi(ram) cancelada(s) com sucesso."
            # await enviar_mensagem(telefone, msg)
            return {"status": "consulta_cancelada", "quantidade": consultas_canceladas, "mensagem": msg}
        else:
            msg = "N√£o encontrei nenhuma consulta futura agendada para cancelar em seu nome."
            # await enviar_mensagem(telefone, msg)
            return {"status": "nenhuma_consulta_encontrada", "mensagem": msg}

    # --- L√≥gica para Comando "hor√°rio" ou "dispon√≠vel" ---
    elif "hor√°rio" in comando or "dispon√≠vel" in comando or "disponivel" in comando:
        logging.info(f"IA Route: Consultando pr√≥ximo hor√°rio dispon√≠vel para {telefone}...")
        # Chama a fun√ß√£o para consultar o pr√≥ximo hor√°rio livre
        # TODO: Implementar consultar_proximo_horario_disponivel e formatar_horario_local em utils/agenda.py
        proximo_horario_utc = consultar_proximo_horario_disponivel() # Assume que retorna datetime UTC ou None
        if proximo_horario_utc:
            # Formata o hor√°rio para o fuso local antes de enviar
            horario_formatado = formatar_horario_local(proximo_horario_utc, 'America/Sao_Paulo') # Exemplo de fuso
            msg = f"üìÖ O pr√≥ximo hor√°rio dispon√≠vel para agendamento √©: {horario_formatado} (Hor√°rio de Bras√≠lia)."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_enviado", "horario_utc": proximo_horario_utc.isoformat(), "horario_formatado": horario_formatado, "mensagem": msg}
        else:
            msg = "üìÖ Desculpe, n√£o consegui encontrar um hor√°rio dispon√≠vel no momento. Por favor, tente novamente mais tarde."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_indisponivel", "mensagem": msg}

    # --- Comando Desconhecido ---
    else:
        logging.warning(f"IA Route: Comando IA desconhecido recebido de {telefone}: '{comando}'")
        # Mensagem padr√£o para comandos n√£o reconhecidos
        msg = "ü§ñ Desculpe, n√£o entendi o que voc√™ deseja fazer. Voc√™ pode me pedir para 'agendar consulta', 'cancelar consulta' ou 'ver pr√≥ximo hor√°rio dispon√≠vel'."
        # await enviar_mensagem(telefone, msg)
        return {"status": "comando_desconhecido", "mensagem": msg}

# Adicionar import timedelta se n√£o estiver presente
from datetime import timedelta


# Arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Arquivo: ./main.py
# ===========================================================
# Arquivo: main.py
# (Ponto de entrada da aplica√ß√£o FastAPI - Corrigido)
# ===========================================================
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
import time # Para medir tempo de resposta
import sys # Para verificar o caminho

# Adiciona o diret√≥rio pai ao sys.path para garantir imports corretos
# Isso √© √∫til se voc√™ executar uvicorn de dentro do diret√≥rio 'app'
# import os
# sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Importa configura√ß√µes (executa o logging inicial de config.py)
# Assume que config.py est√° em app/config.py ou ajusta o import
try:
    from app.config import API_KEY
except ModuleNotFoundError:
     # Tenta importar como se estivesse na raiz
     from config import API_KEY


# Importa os roteadores dos diferentes m√≥dulos
# Garante que todos os roteadores usados est√£o importados
try:
    from app.routes import whatsapp, ia, stripe, agendamento #, painel, resetar # Adicionar outros conforme necess√°rio
except ModuleNotFoundError:
    # Tenta importar como se estivesse na raiz
    from routes import whatsapp, ia, stripe, agendamento

# Configura√ß√£o do Logging (pode ser feita aqui centralmente)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s')
# Define um logger espec√≠fico para a aplica√ß√£o principal
logger = logging.getLogger(__name__)

# Cria a inst√¢ncia da aplica√ß√£o FastAPI
app = FastAPI(
    title="FAMDOMES API",
    description="API para gerenciar o chatbot FAMDOMES via WhatsApp, IA e pagamentos.",
    version="1.0.0"
)

# --- Middlewares ---

# Middleware CORS (Cross-Origin Resource Sharing) - Permite acesso de diferentes origens (ex: frontend)
# Ajuste as origins permitidas conforme necess√°rio
origins = [
    "http://localhost",
    "http://localhost:3000", # Exemplo para frontend React/Vue
    "https://famdomes.com.br", # Dom√≠nio de produ√ß√£o
    # Adicionar outros dom√≠nios permitidos
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"], # Permite todos os m√©todos (GET, POST, etc.)
    allow_headers=["*"], # Permite todos os cabe√ßalhos
)

# Middleware para logar requisi√ß√µes e medir tempo de resposta
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    logger.info(f"Requisi√ß√£o recebida: {request.method} {request.url.path}")
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        logger.info(f"Requisi√ß√£o conclu√≠da: {request.method} {request.url.path} - Status: {response.status_code} - Tempo: {process_time:.4f}s")
    except Exception as e:
         process_time = time.time() - start_time
         logger.exception(f"Erro durante requisi√ß√£o {request.method} {request.url.path} ap√≥s {process_time:.4f}s:")
         # Retorna uma resposta de erro gen√©rica para n√£o expor detalhes
         response = JSONResponse(status_code=500, content={"detail": "Erro interno no servidor"})
    return response


# Middleware de Autentica√ß√£o por Chave de API (Opcional - Descomentar para ativar)
# @app.middleware("http")
# async def autenticar_chave_api(request: Request, call_next):
#     path = str(request.url.path)
#     # Lista de rotas p√∫blicas que n√£o exigem chave de API
#     rotas_publicas = [
#         "/docs", # Documenta√ß√£o Swagger/OpenAPI
#         "/openapi.json",
#         "/chat/webhook/whatsapp/", # Webhook do WhatsApp
#         "/webhook/stripe/", # Webhook do Stripe
#         "/agenda/proximo", # Endpoint p√∫blico de agendamento
#         # Adicionar outras rotas p√∫blicas se houver (ex: /health)
#     ]
#     # Verifica se a rota atual come√ßa com algum dos prefixos p√∫blicos
#     is_public = any(path.startswith(public_path) for public_path in rotas_publicas)
#     is_root = path == "/"
#     # Se for rota p√∫blica ou a raiz, permite o acesso sem chave
#     if is_public or is_root:
#         response = await call_next(request)
#         return response
#     # Para rotas n√£o p√∫blicas, verifica a chave de API no cabe√ßalho
#     chave_recebida = request.headers.get("X-API-Key") # Nome do cabe√ßalho
#     if not API_KEY:
#          logger.warning("API_KEY n√£o configurada no servidor, mas autentica√ß√£o est√° ativa.")
#          response = await call_next(request) # Permite por enquanto, mas loga
#          return response
#     if chave_recebida != API_KEY:
#         logger.warning(f"Acesso negado para {request.method} {path}. Chave API inv√°lida ou ausente.")
#         return JSONResponse(status_code=403, content={"detail": "Acesso n√£o autorizado"})
#     # Se a chave for v√°lida, processa a requisi√ß√£o
#     logger.debug(f"Acesso autorizado com chave API para {request.method} {path}")
#     response = await call_next(request)
#     return response

# --- Inclus√£o dos Roteadores ---
# Inclui os roteadores definidos nos arquivos de rotas
# Garante que todos os roteadores necess√°rios est√£o inclu√≠dos
logger.info("Incluindo roteadores...")
try:
    app.include_router(whatsapp.router) # Roteador para /chat/webhook/whatsapp/
    logger.info(" - Roteador WhatsApp inclu√≠do.")
    app.include_router(ia.router)       # Roteador para /ia-comando (e outros de IA)
    logger.info(" - Roteador IA inclu√≠do.")
    app.include_router(stripe.router)   # Roteador para /webhook/stripe/
    logger.info(" - Roteador Stripe inclu√≠do.")
    app.include_router(agendamento.router) # Roteador para /agenda/proximo
    logger.info(" - Roteador Agendamento inclu√≠do.")
    # Adicione outros roteadores aqui, se criados e importados:
    # app.include_router(painel.router)
    # logger.info(" - Roteador Painel inclu√≠do.")
    # app.include_router(resetar.router)
    # logger.info(" - Roteador Resetar inclu√≠do.")
    logger.info("Roteadores inclu√≠dos com sucesso.")
except NameError as e:
     logger.error(f"Erro ao incluir roteadores: Roteador n√£o importado corretamente? {e}")
     # Levantar exce√ß√£o pode ser apropriado aqui para impedir inicializa√ß√£o incompleta
     # raise e
except Exception as e:
     logger.exception("Erro inesperado ao incluir roteadores:")
     # raise e


# --- Rota Raiz (Opcional) ---
@app.get("/", tags=["Root"], summary="Verifica status da API")
async def read_root():
    """ Rota raiz simples para verificar se a API est√° online. """
    return {"message": "Bem-vindo √† API FAMDOMES!"}

# --- Execu√ß√£o (se rodar diretamente com uvicorn main:app) ---
# if __name__ == "__main__":
#     import uvicorn
#     logger.info("Iniciando servidor Uvicorn diretamente...")
#     uvicorn.run(app, host="0.0.0.0", port=8000)


# Arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Arquivo: ./models/leads.py
from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"

# Arquivo: ./config.py
# ===========================================================
# Arquivo: config.py
# (Baseado no arquivo original fornecido)
# ===========================================================
import os
from dotenv import load_dotenv
import logging # Adicionado para logar carregamento

# Carrega vari√°veis de ambiente do arquivo .env
load_dotenv()

# --- Configura√ß√µes do Banco de Dados ---
MONGO_URI = os.getenv("MONGO_URI") # String de conex√£o do MongoDB

# --- Configura√ß√µes de Pagamento (Stripe) ---
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY") # Chave secreta do Stripe
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET") # Chave secreta do webhook do Stripe

# --- Configura√ß√µes da IA (Ollama) ---
OLLAMA_API_URL = os.getenv("OLLAMA_API_URL", "http://localhost:11434") # URL base da API do Ollama (com default)
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3") # Modelo padr√£o do Ollama a ser usado

# --- Configura√ß√µes da API Interna ---
API_KEY = os.getenv("API_KEY") # Chave para proteger endpoints internos da API (se houver)

# --- Configura√ß√µes do WhatsApp Cloud API ---
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL") # URL da API do WhatsApp (ex: https://graph.facebook.com/v19.0/MEU_PHONE_ID/messages)
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN") # Token de acesso permanente ou tempor√°rio da API
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN") # Token de verifica√ß√£o do webhook do WhatsApp
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR") # N√∫mero de telefone para receber alertas de risco (formato internacional)

# --- Configura√ß√µes do RocketChat (Opcional, se usado para escala√ß√£o) ---
ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL") # URL da inst√¢ncia do RocketChat
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN") # Token de API do RocketChat
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID") # ID do usu√°rio bot no RocketChat

# --- Configura√ß√µes do Google (Opcional, se usado para OAuth ou outras APIs) ---
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# --- Diret√≥rio Base da Aplica√ß√£o ---
# Obt√©m o diret√≥rio onde este arquivo config.py est√° localizado
# √ötil para construir caminhos para outros arquivos (ex: prompts)
# Ajuste o __file__ se a estrutura for diferente (ex: app/config.py)
try:
    # Assume que este arquivo est√° em app/config.py
    # BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Diret√≥rio pai (app)
    # Ou se estiver na raiz do projeto:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback se __file__ n√£o estiver definido (ex: execu√ß√£o interativa)
    BASE_DIR = os.getcwd()


# --- Valida√ß√µes e Logging ---
# Configura√ß√£o b√°sica de logging (pode ser movida para main.py)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

print("Carregando configura√ß√µes...") # Usar logging.info seria melhor
logging.info("Carregando configura√ß√µes...")

# Valida√ß√µes essenciais
essential_vars = {
    "MONGO_URI": MONGO_URI,
    "OLLAMA_API_URL": OLLAMA_API_URL,
    "WHATSAPP_API_URL": WHATSAPP_API_URL,
    "WHATSAPP_TOKEN": WHATSAPP_TOKEN,
    "WHATSAPP_VERIFY_TOKEN": WHATSAPP_VERIFY_TOKEN,
    "STRIPE_SECRET_KEY": STRIPE_SECRET_KEY,
    "STRIPE_WEBHOOK_SECRET": STRIPE_WEBHOOK_SECRET,
}

missing_vars = [name for name, value in essential_vars.items() if not value]
if missing_vars:
    logging.error(f"‚ùå ERRO FATAL: Vari√°veis de ambiente essenciais n√£o definidas: {', '.join(missing_vars)}")
    # Considerar levantar uma exce√ß√£o para impedir a inicializa√ß√£o da aplica√ß√£o
    # raise ValueError(f"Vari√°veis de ambiente essenciais n√£o definidas: {', '.join(missing_vars)}")
else:
    logging.info("‚úÖ Vari√°veis de ambiente essenciais carregadas.")

# Log informativo das configura√ß√µes (sem expor segredos completos)
logging.info(f" - MONGO_URI: {'Definido' if MONGO_URI else 'N√£o definido'}")
logging.info(f" - OLLAMA_API_URL: {OLLAMA_API_URL}")
logging.info(f" - OLLAMA_MODEL: {OLLAMA_MODEL}")
logging.info(f" - WHATSAPP_API_URL: {'Definido' if WHATSAPP_API_URL else 'N√£o definido'}")
logging.info(f" - WHATSAPP_TOKEN: {'Definido' if WHATSAPP_TOKEN else 'N√£o definido'}")
logging.info(f" - WHATSAPP_VERIFY_TOKEN: {'Definido' if WHATSAPP_VERIFY_TOKEN else 'N√£o definido'}")
logging.info(f" - WHATSAPP_FAMILIAR: {WHATSAPP_FAMILIAR if WHATSAPP_FAMILIAR else 'N√£o definido'}")
logging.info(f" - STRIPE_SECRET_KEY: {'Definido' if STRIPE_SECRET_KEY else 'N√£o definido'}")
logging.info(f" - STRIPE_WEBHOOK_SECRET: {'Definido' if STRIPE_WEBHOOK_SECRET else 'N√£o definido'}")
logging.info(f" - BASE_DIR: {BASE_DIR}")

