
# Arquivo: app/fandomes.txt

# Arquivo: app/utils/faq_respostas.py
# ===========================================================
# Arquivo: utils/faq_respostas.py
# (Baseado no arquivo original fornecido, com chaves normalizadas)
# ===========================================================

# Dicionário com perguntas frequentes e suas respostas.
# As chaves estão em minúsculas e sem acentos/pontuação para facilitar a busca.
FAQ_RESPOSTAS = {
    "dependencia quimica": (
        "Dependência química é uma doença crônica caracterizada pelo uso compulsivo de substâncias, "
        "apesar das consequências negativas, afetando o cérebro e o comportamento."
    ),
    "identificar dependencia": (
        "Sinais comuns incluem: aumento da tolerância (precisar de mais para o mesmo efeito), sintomas de abstinência ao parar/diminuir, "
        "perda de controle sobre o uso, gastar muito tempo obtendo/usando/recuperando-se da substância, "
        "negligência de responsabilidades e continuar usando apesar dos problemas causados."
    ),
    "tipos de internacao": (
        "Existem três tipos principais de internação previstos em lei:\n"
        "1.  **Voluntária:** Quando a própria pessoa busca ajuda e concorda com a internação.\n"
        "2.  **Involuntária:** Solicitada por um familiar ou responsável legal, sem o consentimento da pessoa, mas *obrigatoriamente* com um laudo médico detalhado atestando a necessidade (risco para si ou outros).\n"
        "3.  **Compulsória:** Determinada pela Justiça, geralmente em casos mais complexos e após avaliação médica."
    ),
    "como funciona o tratamento": (
        "O tratamento em uma clínica geralmente é multidisciplinar e inclui:\n"
        "-   **Desintoxicação:** Fase inicial para lidar com a abstinência física, com supervisão médica.\n"
        "-   **Terapias:** Individual e em grupo (como Terapia Cognitivo-Comportamental - TCC, Entrevista Motivacional) para entender as causas, mudar comportamentos e prevenir recaídas.\n"
        "-   **Acompanhamento Médico e Psiquiátrico:** Para tratar a dependência e possíveis outras condições (comorbidades).\n"
        "-   **Grupos de Apoio:** Incentivo à participação em grupos como Narcóticos Anônimos (N.A.) ou Alcoólicos Anônimos (A.A.).\n"
        "-   **Atividades Terapêuticas:** Ocupacionais, físicas, etc., para reestruturação da rotina."
    ),
    "duracao do tratamento": (
        "A duração varia muito. Internações podem durar de 1 a 6 meses, ou até mais, dependendo da gravidade, do tipo de substância e da resposta individual. O tratamento ambulatorial (consultas regulares sem internação) pode ser mais longo. O importante é entender que a recuperação é um processo contínuo, mesmo após a alta."
    ),
    "custo do tratamento": (
        "Os valores de uma internação ou tratamento particular variam bastante dependendo da clínica, estrutura, serviços incluídos, tipo de acomodação e tempo de permanência. Para ter uma proposta adequada ao seu caso, precisamos primeiro entender a situação na consulta inicial de avaliação."
    ),
    "o que fazer se a pessoa nao aceita ajuda": (
        "É um desafio comum e muito difícil para a família. Se a pessoa não reconhece o problema ou recusa ajuda, mas está colocando a si mesma ou outros em risco grave, a internação involuntária pode ser uma opção legal, mas requer um laudo médico detalhado. O primeiro passo é buscar orientação profissional, como na nossa consulta inicial, para avaliar a situação e os caminhos possíveis."
    ),
    "como a familia pode ajudar": (
        "A família é fundamental na recuperação! Algumas formas de ajudar são:\n"
        "-   Buscar conhecimento sobre dependência química para entender a doença.\n"
        "-   Oferecer apoio emocional, mas sem facilitar o uso (evitar acobertar, dar dinheiro que possa ser usado para drogas, etc.).\n"
        "-   Estabelecer limites claros e consistentes.\n"
        "-   Participar de grupos de apoio para familiares (como Al-Anon, Nar-Anon) e/ou terapia familiar.\n"
        "-   Incentivar a busca e a manutenção do tratamento pela pessoa."
    ),
    "o que e caps": (
        "CAPS é a sigla para Centro de Atenção Psicossocial. São unidades públicas do SUS que oferecem atendimento em saúde mental. Existem diferentes tipos, como o CAPS AD, especializado em álcool e outras drogas. O tratamento no CAPS é gratuito e geralmente ambulatorial (a pessoa vai ao centro durante o dia), sendo uma alternativa importante, especialmente quando a internação não é necessária ou viável."
    ),
    "como agendar consulta": (
        "Para agendar a consulta inicial online, que tem o valor de R$100, basta me confirmar seu interesse. Se você confirmar, eu te enviarei um link seguro para realizar o pagamento. Após a confirmação do pagamento, o horário será agendado e você receberá todas as instruções."
    ),
    "qual o preco da consulta": (
        "A consulta inicial de avaliação online tem o valor de R$100. Ela é realizada por um profissional especializado para entender em detalhes a situação, oferecer orientações e, se for o caso, indicar o tratamento mais adequado, seja ele ambulatorial ou internação."
    ),
    "consulta online funciona": (
        "Sim, a consulta online é muito eficaz para a avaliação inicial e orientação. Ela permite que um profissional especializado analise o caso com privacidade e comodidade, entenda a necessidade, forneça direcionamento e, se necessário, um laudo para encaminhamento. Caso uma intervenção presencial seja indicada, como uma internação, o profissional fará essa recomendação durante a consulta."
    )
    # Adicionar mais FAQs conforme necessário
}


# Arquivo: app/utils/questionario_pos_pagamento.py
# ===========================================================
# Arquivo: utils/questionario_pos_pagamento.py
# Define as perguntas e a introdução para o questionário pós-pagamento.
# ===========================================================
import asyncio
import logging
# Ajuste o import se mensageria.py estiver em um diretório diferente
# from .mensageria import enviar_mensagem # A função de envio agora é feita pelo Agente DomoTriagem

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Textos do Questionário ---

INTRODUCAO_QUESTIONARIO = "Ótimo! Pagamento confirmado e consulta agendada. ✅\n\nPara que o profissional possa aproveitar ao máximo o tempo da consulta e já ter um bom entendimento do caso, preciso fazer algumas perguntas rápidas agora. Leva só alguns minutos."

# Perguntas Fatuais (Originais ou Adaptadas)
PERGUNTAS_FACTUAIS = [
    "Vamos começar com algumas perguntas rápidas para ajudar nosso profissional a entender melhor. Qual o nome completo da pessoa que será avaliada?",
    "Qual a idade aproximada dela?",
    "Qual o seu grau de parentesco com essa pessoa (você é filho(a), esposa(o), irmão(ã), amigo(a), ou a própria pessoa)?",
    "Quais são as principais substâncias que ela está usando atualmente (por exemplo: álcool, cocaína, crack, maconha, medicamentos controlados sem prescrição)?",
    "Há quanto tempo, aproximadamente, esse uso se tornou um problema ou se intensificou?",
    "A pessoa já passou por algum tipo de tratamento para dependência química antes? Se sim, qual(is) e quando?",
    "Além da dependência, existe alguma outra condição de saúde importante, física ou mental (como diabetes, pressão alta, depressão, ansiedade, esquizofrenia), que devemos saber?",
    "Em qual cidade e estado a pessoa se encontra neste momento?"
]

# Perguntas Emocionais (Adicionadas para a Trilha Emocional)
PERGUNTAS_EMOCIONAIS = [
    "Pensando na situação atual, quais são as maiores preocupações ou medos que você (ou a pessoa a ser avaliada, se não for você) tem enfrentado recentemente?",
    "Olhando para frente, o que você (ou a pessoa) mais deseja ou espera alcançar ao buscar ajuda ou iniciar um tratamento?",
    "Em relação aos sentimentos, existe algum que tem sido muito presente ultimamente por causa dessa situação (por exemplo: culpa, vergonha, raiva, medo, frustração, tristeza, mas também esperança ou alívio)?",
    "De que forma você percebe que essa situação tem impactado o dia a dia, o trabalho/estudos e os relacionamentos familiares?"
]

# Combina as perguntas na ordem desejada para o questionário completo
# Pode ajustar a ordem se preferir intercalar fatuais e emocionais
# Exemplo: Intercalando
QUESTIONARIO_COMPLETO_POS_PAGAMENTO = []
len_fat = len(PERGUNTAS_FACTUAIS)
len_emo = len(PERGUNTAS_EMOCIONAIS)
max_len = max(len_fat, len_emo)

for i in range(max_len):
    if i < len_fat:
        QUESTIONARIO_COMPLETO_POS_PAGAMENTO.append(PERGUNTAS_FACTUAIS[i])
    if i < len_emo:
        QUESTIONARIO_COMPLETO_POS_PAGAMENTO.append(PERGUNTAS_EMOCIONAIS[i])

# --- Função para Iniciar o Questionário (NÃO MAIS NECESSÁRIA DIRETAMENTE) ---
# A lógica de iniciar e conduzir o questionário agora reside no Agente DomoTriagem.
# Esta função pode ser removida ou mantida apenas para referência.

# async def iniciar_questionario_pos_pagamento(telefone: str):
#     """
#     [DEPRECATED] A lógica agora está no Agente DomoTriagem.
#     Esta função enviava a primeira pergunta do questionário.
#     """
#     total_perguntas = len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO)
#     logging.info(f"[DEPRECATED] QUESTIONARIO: Preparando para iniciar ({total_perguntas} perguntas) para {telefone}")
#
#     if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
#         primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
#         mensagem_inicial = f"{INTRODUCAO_QUESTIONARIO}\n\n{primeira_pergunta}"
#         try:
#             # O envio agora é feito pelo Agente DomoTriagem
#             # await enviar_mensagem(telefone, mensagem_inicial)
#             logging.info(f"[DEPRECATED] QUESTIONARIO: Primeira pergunta seria enviada para {telefone}.")
#             # O estado seria atualizado para algo como "COLETANDO_RESPOSTA_QUESTIONARIO"
#         except Exception as e:
#             logging.error(f"[DEPRECATED] QUESTIONARIO: Erro ao tentar enviar primeira pergunta para {telefone}: {e}")
#     else:
#         logging.warning(f"[DEPRECATED] QUESTIONARIO: Nenhuma pergunta definida. Questionário não iniciado para {telefone}.")


# Arquivo: app/utils/ollama.py
# ===========================================================
# Arquivo: utils/ollama.py
# ===========================================================
import httpx
import logging
import json
import re
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str | None, dict | None, list | None]:
    """
    Chama a API do Ollama com o prompt fornecido.
    Tenta extrair um JSON do final da resposta.

    Args:
        prompt (str): O prompt completo a ser enviado para a IA.
        telefone (str): O número de telefone do usuário (para logging).

    Returns:
        tuple[str | None, dict | None, list | None]:
            - resposta_textual (str | None): A parte textual da resposta da IA.
            - json_extraido (dict | None): O dicionário JSON extraído do final, ou None.
            - tokens (list | None): Informações sobre tokens (se a API retornar, atualmente None).
    """
    # Validação inicial
    if not OLLAMA_API_URL or not OLLAMA_MODEL:
        logging.error("❌ OLLAMA: Configurações (OLLAMA_API_URL ou OLLAMA_MODEL) ausentes.")
        return "⚠️ Desculpe, estou com problemas técnicos para acessar minha inteligência. Tente novamente mais tarde.", None, None

    # Payload para a API do Ollama
    payload = {
        "model": OLLAMA_MODEL, # Modelo configurado
        "prompt": prompt,
        "stream": False, # Não usar streaming para facilitar extração do JSON
        # "options": {"temperature": 0.7} # Exemplo de opções de geração
        # Tenta forçar JSON se o prompt explicitamente pedir (pode ser ajustado)
        "format": "json" if "json" in prompt.lower()[-150:] else None # Verifica só o final do prompt por "json"
    }
    # Remove format se for None para não enviar chave vazia
    if payload["format"] is None:
        del payload["format"]

    headers = {"Content-Type": "application/json"}
    resposta_textual = None
    json_extraido = None
    tokens = None # Placeholder para informações de tokens

    try:
        # Usar httpx para chamadas HTTP assíncronas
        # Timeout aumentado para 45 segundos para dar tempo à IA
        async with httpx.AsyncClient(timeout=45.0) as client:
            logging.info(f"OLLAMA: Enviando prompt (modelo: {OLLAMA_MODEL}) para {telefone}...")
            # Faz a requisição POST para a API do Ollama
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            # Levanta uma exceção para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            dados = response.json()
            logging.info(f"OLLAMA: ✅ Resposta recebida da IA para {telefone}.")
            # logging.debug(f"OLLAMA: Resposta completa: {dados}") # Log detalhado opcional

            # Extrai a resposta principal do JSON retornado pela API
            resposta_bruta = dados.get("response", "").strip()
            # TODO: Extrair informações de tokens se disponíveis em 'dados' (ex: dados.get("eval_count"), etc.)
            # tokens = {"eval_count": dados.get("eval_count"), ...}

            # Verifica se a resposta não está vazia
            if not resposta_bruta:
                logging.warning(f"OLLAMA: ⚠️ Resposta vazia para {telefone}.")
                return None, None, tokens

            # Tenta extrair JSON do final da resposta bruta
            # Primeiro tenta com ```json ... ``` (com ou sem espaço antes do {)
            match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```$", resposta_bruta, re.IGNORECASE | re.DOTALL)
            if not match: # Se não encontrar, tenta apenas com { ... } no final
                 match = re.search(r"(\{[\s\S]*?\})$", resposta_bruta, re.DOTALL)

            if match:
                # Se encontrou um padrão JSON, extrai o conteúdo
                json_str = match.group(1)
                try:
                    # Tenta converter a string JSON em um dicionário Python
                    json_extraido = json.loads(json_str)
                    # Remove a parte JSON (e os ``` se presentes) da resposta textual
                    resposta_textual = resposta_bruta[:match.start()].strip()
                    logging.info(f"OLLAMA: JSON extraído com sucesso para {telefone}.")
                except json.JSONDecodeError as json_err:
                    # Se o JSON for inválido, loga um aviso e trata a resposta inteira como texto
                    logging.warning(f"OLLAMA: ⚠️ JSON inválido no final da resposta para {telefone}: {json_err}. Retornando resposta bruta como textual.")
                    resposta_textual = resposta_bruta
                    json_extraido = None
            else:
                # Se não encontrou JSON no final, toda a resposta é considerada textual
                logging.info(f"OLLAMA: Nenhum JSON encontrado no final da resposta para {telefone}.")
                resposta_textual = resposta_bruta
                json_extraido = None

            # Garante que a resposta textual não seja vazia se o JSON foi extraído com sucesso
            if not resposta_textual and json_extraido is not None:
                 resposta_textual = "Ok." # Retorna um texto mínimo

            return resposta_textual, json_extraido, tokens

    # Tratamento de exceções específicas do httpx e genéricas
    except httpx.TimeoutException as e:
        logging.error(f"OLLAMA: ❌ Erro: Timeout ao chamar para {telefone} ({str(e)})")
        # Retorna uma mensagem de erro amigável para o usuário
        return "⚠️ Desculpe, demorei muito para pensar. Poderia tentar de novo?", None, None
    except httpx.HTTPStatusError as e:
        # Loga o erro HTTP e retorna mensagem de erro
        logging.error(f"OLLAMA: ❌ Erro HTTP {e.response.status_code} para {telefone}: {e.response.text}")
        return f"⚠️ Ocorreu um erro de comunicação com a inteligência artificial ({e.response.status_code}). Por favor, tente mais tarde.", None, None
    except Exception as e:
        # Loga qualquer outro erro inesperado
        logging.exception(f"OLLAMA: ❌ Erro desconhecido ao chamar para {telefone}:")
        return "⚠️ Ocorreu um erro inesperado ao processar sua solicitação. Tente novamente mais tarde.", None, None


# Arquivo: app/utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura – certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        return (
            "Você é um assistente virtual especializado em saúde mental e dependência química. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Histórico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usuário:
{pergunta_atual.strip()}
---
Instruções para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no máximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Arquivo: app/utils/mensageria.py
# ===========================================================
# Arquivo: utils/mensageria.py
# Envio robusto de mensagens via WhatsApp Cloud API
# ===========================================================
from __future__ import annotations

import httpx
import logging
from typing import Any, Dict
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN

logger = logging.getLogger("famdomes.mensageria")

HEADERS = {
    "Authorization": f"Bearer {WHATSAPP_TOKEN}",
    "Content-Type": "application/json",
}
TIMEOUT = httpx.Timeout(timeout=20.0, connect=5.0)


async def enviar_mensagem(telefone: str, mensagem: str) -> Dict[str, Any]:
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logger.error("❌ MENSAGERIA: API URL ou Token não configurados.")
        return {"status": "erro_config", "erro": "WhatsApp API não configurada"}

    if not telefone or not mensagem:
        logger.warning("⚠️ MENSAGERIA: Telefone ou mensagem vazios.")
        return {"status": "erro_input", "erro": "Telefone ou mensagem ausente"}

    payload: Dict[str, Any] = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem},
    }

    try:
        url = str(WHATSAPP_API_URL)  # 🔧 cast definitivo
        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            resp = await client.post(url, json=payload, headers=HEADERS)
            resp.raise_for_status()

        logger.info("✅ Mensagem enviada a %s (HTTP %s)", telefone, resp.status_code)
        return {"status": "enviado", "code": resp.status_code, "retorno": resp.json()}

    except httpx.HTTPStatusError as exc:
        logger.error("❌ WHATSAPP %s – %s", exc.response.status_code, exc.response.text)
        return {"status": "erro_api", "code": exc.response.status_code, "erro": exc.response.text}
    except httpx.TimeoutException as exc:
        logger.error("⏰ Timeout WhatsApp: %s", exc)
        return {"status": "erro_timeout", "erro": str(exc)}
    except httpx.RequestError as exc:
        logger.error("🌐 Erro de conexão WhatsApp: %s", exc)
        return {"status": "erro_conexao", "erro": str(exc)}
    except Exception as exc:  # pragma: no cover
        logger.exception("💥 Erro inesperado WhatsApp: %s", exc)
        return {"status": "erro_desconhecido", "erro": str(exc)}

# Arquivo: app/utils/contexto.py
# ===========================================================
# Arquivo: utils/contexto.py
# Persiste contexto de conversa + histórico da IA no MongoDB
# - CORRIGIDO: Verificação de conexão com DB/Coleção usando 'is not None'.
# - CORRIGIDO: Tratamento específico para erro de conflito de nome de índice (Code 85).
# - Adicionado salvamento de intent detectada.
# - Adicionado salvamento de texto do usuário.
# - Adicionado salvamento de texto do bot.
# - Funções para obter e limpar contexto mantidas.
# - Salvar flags de follow-up dentro de meta_conversa.
# ===========================================================
from __future__ import annotations

import logging
from datetime import datetime, timezone
from pymongo import MongoClient, ASCENDING, IndexModel
from pymongo.errors import ConnectionFailure, OperationFailure # Import OperationFailure
from typing import Dict, Any, Optional

# Importar configurações de forma segura
try:
    from app.config import MONGO_URI
except ImportError:
    import os
    MONGO_URI = os.getenv("MONGO_URI")
    if not MONGO_URI:
        logging.critical("CONTEXTO: Falha ao importar MONGO_URI de app.config e variável de ambiente MONGO_URI não definida.")
        MONGO_URI = None

logger = logging.getLogger("famdomes.contexto")

# --- Conexão e Configuração do Banco de Dados ---
mongo_client: Optional[MongoClient] = None
db: Optional[Any] = None # Tipo genérico para Database
contextos_db: Optional[Any] = None # Tipo genérico para Collection
respostas_ia_db: Optional[Any] = None # Tipo genérico para Collection

def conectar_db():
    """Estabelece conexão com o MongoDB e configura coleções e índices."""
    global mongo_client, db, contextos_db, respostas_ia_db

    # CORREÇÃO: Verifica todos os objetos comparando com None
    if mongo_client is not None and db is not None and contextos_db is not None and respostas_ia_db is not None:
        logger.debug("CONTEXTO: Conexão com MongoDB já estabelecida.")
        return

    if MONGO_URI is None:
        logger.error("CONTEXTO: ❌ MONGO_URI não definido. Não é possível conectar ao MongoDB.")
        return

    try:
        logger.info(f"CONTEXTO: Tentando conectar ao MongoDB em {MONGO_URI[:20]}...")
        mongo_client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000, connectTimeoutMS=5000, socketTimeoutMS=10000)
        mongo_client.server_info()
        db = mongo_client["famdomes"] # Ajuste o nome do DB se necessário
        contextos_db = db["contextos"]
        respostas_ia_db = db["respostas_ia"]

        # --- Criação de Índices ---
        indexes_contextos = [
            IndexModel([("tel", ASCENDING)], name="tel_unique_idx", unique=True),
            IndexModel([("ts", ASCENDING)], name="ts_idx"),
            IndexModel([("estado", ASCENDING)], name="estado_idx")
        ]
        indexes_respostas = [
            IndexModel([("telefone", ASCENDING)], name="telefone_idx"),
            IndexModel([("criado_em", ASCENDING)], name="criado_em_idx")
        ]

        # Tenta criar os índices para 'contextos'
        try:
            contextos_db.create_indexes(indexes_contextos)
            logger.info("CONTEXTO: Índices da coleção 'contextos' verificados/criados.")
        except OperationFailure as e:
            if e.code == 85:
                logger.info("CONTEXTO: Índices para 'contextos' já existem (possivelmente com nomes diferentes).")
            else:
                logger.warning(f"CONTEXTO: Aviso durante criação de índices para 'contextos': {e}")
        except Exception as e:
             logger.warning(f"CONTEXTO: Erro inesperado ao criar índices para 'contextos': {e}")

        # Tenta criar os índices para 'respostas_ia'
        try:
            respostas_ia_db.create_indexes(indexes_respostas)
            logger.info("CONTEXTO: Índices da coleção 'respostas_ia' verificados/criados.")
        except OperationFailure as e:
            if e.code == 85:
                logger.info("CONTEXTO: Índices para 'respostas_ia' já existem (possivelmente com nomes diferentes).")
            else:
                logger.warning(f"CONTEXTO: Aviso durante criação de índices para 'respostas_ia': {e}")
        except Exception as e:
             logger.warning(f"CONTEXTO: Erro inesperado ao criar índices para 'respostas_ia': {e}")

        logger.info("CONTEXTO: ✅ Conexão com MongoDB estabelecida e configuração de índices concluída.")

    except ConnectionFailure as e:
        logger.error(f"CONTEXTO: ❌ Falha na conexão com MongoDB: {e}")
        mongo_client = db = contextos_db = respostas_ia_db = None
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO inesperado ao conectar/configurar MongoDB: {e}")
        mongo_client = db = contextos_db = respostas_ia_db = None

# Tenta conectar na inicialização do módulo
conectar_db()

# ----------------------------------------------------------------------
def salvar_contexto(
    telefone: str,
    *,
    texto_usuario: Optional[str] = None,
    estado: Optional[str] = None,
    meta_conversa: Optional[Dict[str, Any]] = None,
    intent_detectada: Optional[str] = None,
    ultimo_texto_bot: Optional[str] = None,
    incrementar_interacoes: bool = True
) -> bool:
    """
    Atualiza (ou cria) o documento de contexto para um telefone no MongoDB.
    Retorna True se a operação foi bem-sucedida.
    """
    # Verifica se a coleção está disponível
    if contextos_db is None:
        logger.error(f"CONTEXTO: Falha ao salvar contexto para {telefone}. Coleção 'contextos' indisponível.")
        conectar_db() # Tenta reconectar
        if contextos_db is None: return False

    set_fields: Dict[str, Any] = {"ts": datetime.now(timezone.utc)}
    if texto_usuario is not None: set_fields["ultimo_texto_usuario"] = texto_usuario
    if estado is not None: set_fields["estado"] = estado
    if meta_conversa is not None: set_fields["meta_conversa"] = meta_conversa
    if intent_detectada is not None: set_fields["ultima_intent_detectada"] = intent_detectada
    if ultimo_texto_bot is not None: set_fields["ultimo_texto_bot"] = ultimo_texto_bot

    update_operation: Dict[str, Any] = {}
    if set_fields: update_operation["$set"] = set_fields
    if incrementar_interacoes: update_operation["$inc"] = {"interacoes": 1}

    agora = datetime.now(timezone.utc)
    set_on_insert_data = {
        "tel": telefone,
        "criado_em": agora,
        "estado": "INICIAL", # Define um padrão inicial
        "interacoes": 0 # Define um padrão inicial
    }
    # Sobrescreve padrões se valores forem fornecidos na primeira vez
    if estado is not None: set_on_insert_data["estado"] = estado
    if incrementar_interacoes: set_on_insert_data["interacoes"] = 1

    # Remove campos do $setOnInsert se eles já estiverem sendo definidos em $set ou $inc
    if "$set" in update_operation and "estado" in update_operation["$set"]:
         if "estado" in set_on_insert_data: del set_on_insert_data["estado"]
    if "$inc" in update_operation and "interacoes" in update_operation["$inc"]:
         if "interacoes" in set_on_insert_data: del set_on_insert_data["interacoes"]

    if set_on_insert_data:
        update_operation["$setOnInsert"] = set_on_insert_data

    if not update_operation.get("$set") and not update_operation.get("$inc") and not update_operation.get("$setOnInsert"):
         logger.debug(f"CONTEXTO: Nenhuma operação de atualização para salvar contexto de {telefone}.")
         return True

    try:
        result = contextos_db.update_one({"tel": telefone}, update_operation, upsert=True)
        logger.debug(f"CONTEXTO: Resultado do update para {telefone}: matched={result.matched_count}, modified={result.modified_count}, upserted_id={result.upserted_id}")
        if result.modified_count > 0 or result.upserted_id is not None:
             log_estado = estado if estado is not None else '(estado inalterado)'
             logger.info(f"CONTEXTO: Contexto salvo/atualizado para {telefone}. Estado: {log_estado}")
             return True
        else:
             logger.info(f"CONTEXTO: Contexto para {telefone} não modificado.")
             return True
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO ao salvar contexto para {telefone}: {e}")
        return False

# ----------------------------------------------------------------------
def obter_contexto(telefone: str) -> Dict[str, Any]:
    """
    Recupera o documento de contexto atual para um telefone do MongoDB.
    Retorna um dicionário com valores padrão se não encontrado ou erro.
    """
    # Verifica se a coleção está disponível
    if contextos_db is None:
        logger.error(f"CONTEXTO: Falha ao obter contexto para {telefone}. Coleção 'contextos' indisponível.")
        conectar_db() # Tenta reconectar
        if contextos_db is None: return {"estado": "INICIAL", "meta_conversa": {}, "interacoes": 0, "tel": telefone}

    try:
        doc = contextos_db.find_one({"tel": telefone}, {"_id": 0})
        if doc:
            logger.debug(f"CONTEXTO: Contexto encontrado para {telefone}. Estado: {doc.get('estado')}")
            doc.setdefault("estado", "INICIAL")
            doc.setdefault("meta_conversa", {})
            doc.setdefault("interacoes", 0)
            doc.setdefault("tel", telefone)
            return doc
        else:
            logger.info(f"CONTEXTO: Nenhum contexto encontrado para {telefone}. Retornando padrão.")
            return {"estado": "INICIAL", "meta_conversa": {}, "interacoes": 0, "tel": telefone}
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO ao obter contexto para {telefone}: {e}")
        return {"estado": "INICIAL", "meta_conversa": {}, "interacoes": 0, "tel": telefone}

# ----------------------------------------------------------------------
def salvar_resposta_ia(
    telefone: str,
    canal: str,
    mensagem_usuario: str,
    resposta_gerada: str,
    intent: str,
    entidades: Optional[Dict[str, Any]] = None,
    risco_detectado: bool = False,
    sentimento_detectado: Optional[Dict[str, float]] = None,
    nome_agente: Optional[str] = None,
    enviado_por_humano: bool = False # Novo campo para diferenciar msg humana
) -> bool:
    """
    Grava um registro da interação na coleção de histórico `respostas_ia`.
    Retorna True se a inserção foi bem-sucedida.
    """
    # Verifica se a coleção está disponível
    if respostas_ia_db is None:
        logger.error(f"CONTEXTO: Falha ao salvar resposta IA para {telefone}. Coleção 'respostas_ia' indisponível.")
        conectar_db() # Tenta reconectar
        if respostas_ia_db is None: return False

    entidades_validas = entidades if isinstance(entidades, dict) else {}
    sentimento_valido = sentimento_detectado if isinstance(sentimento_detectado, dict) else None

    documento = {
        "telefone": telefone,
        "canal": canal,
        "mensagem_usuario": mensagem_usuario,
        "resposta_gerada": resposta_gerada,
        "intent_detectada": intent,
        "entidades_extraidas": entidades_validas,
        "risco_detectado": bool(risco_detectado),
        "sentimento_detectado": sentimento_valido,
        "nome_agente": nome_agente,
        "enviado_por_humano": enviado_por_humano, # Salva o novo campo
        "criado_em": datetime.now(timezone.utc),
    }

    try:
        result = respostas_ia_db.insert_one(documento)
        if result.inserted_id:
            logger.debug(f"CONTEXTO: Resposta IA salva no histórico para {telefone} (Intent: {intent}, Humano: {enviado_por_humano}).")
            return True
        else:
            logger.error(f"CONTEXTO: ❌ Falha desconhecida ao inserir resposta IA no histórico para {telefone} (inserted_id nulo).")
            return False
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO ao salvar resposta IA no histórico para {telefone}: {e}")
        return False

# ----------------------------------------------------------------------
def limpar_contexto(telefone: str) -> bool:
    """
    Remove o documento de contexto e todos os registros de histórico
    associados a um telefone específico do MongoDB.
    Retorna True se algo foi apagado.
    """
    # Verifica se as coleções estão disponíveis
    if contextos_db is None or respostas_ia_db is None:
        logger.error(f"CONTEXTO: Falha ao limpar contexto para {telefone}. Coleções indisponíveis.")
        conectar_db() # Tenta reconectar
        if contextos_db is None or respostas_ia_db is None: return False

    contexto_apagado = False
    historico_apagado = False
    sucesso_geral = True

    try:
        logger.debug(f"CONTEXTO: Tentando remover contexto para {telefone}...")
        result_ctx = contextos_db.delete_one({"tel": telefone})
        if result_ctx.deleted_count > 0:
            contexto_apagado = True
            logger.info(f"CONTEXTO: Documento de contexto removido para {telefone}.")
        else:
            logger.info(f"CONTEXTO: Nenhum documento de contexto encontrado para remover para {telefone}.")
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO ao remover contexto para {telefone}: {e}")
        sucesso_geral = False

    try:
        logger.debug(f"CONTEXTO: Tentando remover histórico para {telefone}...")
        result_hist = respostas_ia_db.delete_many({"telefone": telefone})
        if result_hist.deleted_count > 0:
            historico_apagado = True
            logger.info(f"CONTEXTO: {result_hist.deleted_count} registro(s) de histórico removido(s) para {telefone}.")
        else:
             logger.info(f"CONTEXTO: Nenhum registro de histórico encontrado para remover para {telefone}.")
    except Exception as e:
        logger.exception(f"CONTEXTO: ❌ ERRO ao remover histórico para {telefone}: {e}")
        sucesso_geral = False

    return sucesso_geral and (contexto_apagado or historico_apagado)


# Arquivo: app/utils/offnlp.py
# ===========================================================
# Arquivo: utils/nlp.py
# (v7 - Implementada a nova estratégia de fluxo inicial)
# ===========================================================
import logging
import json
import re
import os # Importado para carregar prompt
from datetime import datetime

# Ajuste os imports conforme a estrutura do seu projeto
from app.utils.ollama import chamar_ollama
# Acesso direto às variáveis globais de contexto.py para DB
from app.utils.contexto import (
    obter_contexto, salvar_contexto, salvar_resposta_ia,
    respostas_ia_db # Acesso à coleção do histórico
)
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.utils.risco import analisar_risco
from app.routes.ia import processar_comando # Para ações como agendar
from app.config import (
    WHATSAPP_FAMILIAR, BASE_DIR, # Importa o número para notificação e diretório base
    ROCKETCHAT_URL, ROCKETCHAT_TOKEN, ROCKETCHAT_USER_ID, # Configs para RocketChat
    OLLAMA_API_URL # Necessário para checar se Ollama está configurado
)
from app.utils.mensageria import enviar_mensagem # Para enviar notificações
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO # Importa a lista correta
import httpx # Para notificação RocketChat

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes e Textos Padrão ---
# MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Nova versão da estratégia
MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Mantendo a original por enquanto, ajustar se necessário
# Mensagem combinada (Validação + Emocional + Qualificação) - A validação será adicionada dinamicamente
PERGUNTA_COMBINADA_TEMPLATE = "Como você está se sentindo com toda essa situação neste momento? E só para eu direcionar melhor, a ajuda que você busca é para você mesmo ou para outra pessoa (ex: filho, esposa, irmão)?"
RESPOSTA_EXPLICACAO_CONSULTA = '''👨‍⚕️ A consulta médica do FAMDOMES é online, com um profissional que entende profundamente casos de dependência química e sofrimento familiar.

📌 Ela serve para avaliar a situação, oferecer um laudo se necessário, orientar o melhor caminho e — se for o caso — encaminhar para uma clínica parceira com segurança e sigilo.

💳 O valor é R$100 e pode ser pago online de forma rápida.

Posso te enviar o link para agendar agora?'''
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informações, elas são muito importantes para a consulta."
MENSAGEM_ERRO_PADRAO = "🤖 Desculpe, não consegui processar sua mensagem agora. Poderia tentar novamente ou reformular?"
MENSAGEM_ERRO_IA = "🤖 Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
MENSAGEM_RISCO_DIRECIONAMENTO = "Percebi que você pode estar passando por um momento muito difícil. Se precisar de ajuda urgente, ligue para o CVV (188) ou SAMU (192). Não hesite em buscar apoio."
MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO = "Entendido. Já notifiquei nossa equipe. Alguém entrará em contato com você por aqui assim que possível."

RESPOSTAS_AFIRMATIVAS = ["sim", "claro", "quero", "vamos", "ok", "pode ser", "tá bom", "aceito", "sim por favor", "sim quero", "com certeza", "tô dentro", "pode sim", "por favor", "gostaria", "desejo"]
RESPOSTAS_NEGATIVAS = ["não", "nao", "agora não", "talvez depois", "ainda não", "obrigado não", "não quero", "nao quero"]
PALAVRAS_CHAVE_HUMANO = ["humano", "atendente", "pessoa", "falar com alguem", "alguém", "falar com um especialista", "falar com vc", "falar contigo"]
# ----------------------------------

# --- Funções Auxiliares Implementadas ---

async def analisar_sentimento(texto: str, telefone: str) -> str | None:
    """
    [Trilha Emocional] Analisa o sentimento do texto usando Ollama.
    Retorna 'positivo', 'negativo', 'neutro' ou None em caso de erro.
    """
    if not OLLAMA_API_URL:
        logging.warning("NLP: Análise de sentimento pulada - OLLAMA_API_URL não configurado.")
        return "neutro"

    logging.info(f"NLP: [Trilha Emocional] Analisando sentimento para {telefone}: '{texto[:30]}...'")
    prompt_sentimento = f"""
    Analise o sentimento predominante na seguinte mensagem do usuário.
    Responda APENAS com uma das seguintes palavras: 'positivo', 'negativo', 'neutro'.

    Mensagem: "{texto}"

    Sentimento:"""
    try:
        resposta_txt, _, _ = await chamar_ollama(prompt_sentimento, telefone)
        if resposta_txt:
            sentimento_retornado = resposta_txt.strip().lower().replace(".", "")
            if sentimento_retornado in ["positivo", "negativo", "neutro"]:
                logging.info(f"NLP: Sentimento detectado pela IA para {telefone}: {sentimento_retornado}")
                return sentimento_retornado
            else:
                logging.warning(f"NLP: Sentimento retornado pela IA não reconhecido ('{sentimento_retornado}'). Usando 'neutro'.")
                return "neutro"
        else:
            logging.warning(f"NLP: IA não retornou resposta para análise de sentimento de {telefone}. Usando 'neutro'.")
            return "neutro"
    except Exception as e:
        logging.error(f"NLP: Erro ao chamar IA para análise de sentimento de {telefone}: {e}")
        return None

async def buscar_historico_formatado(telefone: str, limite: int = 5) -> str:
     """ Busca e formata o histórico recente do MongoDB para o prompt da IA. """
     if respostas_ia_db is None:
         logging.warning(f"NLP: Histórico indisponível para {telefone} (DB não conectado).")
         return "Histórico indisponível (DB não conectado)."
     logging.debug(f"NLP: Buscando histórico para {telefone} (limite: {limite})")
     try:
         historico_cursor = respostas_ia_db.find(
             {"telefone": telefone},
             {"mensagem_usuario": 1, "resposta_gerada": 1, "_id": 0}
         ).sort("criado_em", -1).limit(limite)
         historico_lista = list(historico_cursor)
         historico_lista.reverse()
         if not historico_lista:
             return "Nenhuma conversa anterior registrada."
         historico_formatado = ""
         for item in historico_lista:
             if msg_usr := item.get("mensagem_usuario"):
                 historico_formatado += f"Usuário: {msg_usr}\n"
             if msg_bot := item.get("resposta_gerada"):
                 if len(msg_bot) > 150:
                      msg_bot = msg_bot[:150] + "..."
                 historico_formatado += f"Assistente: {msg_bot}\n"
         return historico_formatado.strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao buscar histórico para {telefone}: {e}")
         return "Erro ao carregar histórico."

async def construir_prompt_para_ia(telefone: str, pergunta_atual: str, estado: str, meta_conversa: dict) -> str:
     """
     Constrói o prompt para o Ollama, incorporando estado, histórico e contexto emocional.
     Carrega o prompt mestre do arquivo PROMPT_MESTRE.txt.
     """
     historico_recente_formatado = await buscar_historico_formatado(telefone)
     sentimento_anterior = meta_conversa.get("ultimo_sentimento_detectado", None)
     prompt_mestre_path = os.path.join(BASE_DIR, "PROMPT_MESTRE.txt")
     try:
         with open(prompt_mestre_path, "r", encoding="utf-8") as f:
             PROMPT_MESTRE = f.read().strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao carregar prompt mestre de {prompt_mestre_path}: {e}. Usando prompt padrão.")
         PROMPT_MESTRE = """Você é Domo, um assistente virtual empático da FAMDOMES. Responda com clareza e empatia."""

     meta_filtrada = {
         k: v for k, v in meta_conversa.items()
         if k not in ['questionario_completo', 'historico_recente_formatado'] and not k.startswith('sentimento_q')
     }

     prompt_final = f"""{PROMPT_MESTRE}

     ---
     Contexto da Conversa Atual:
     Telefone: {telefone}
     Estado da Conversa: {estado}
     Sentimento Percebido na Última Interação: {sentimento_anterior or 'N/A'}
     Dados Conhecidos (meta_conversa): {json.dumps(meta_filtrada, indent=2, ensure_ascii=False, default=str)}
     ---
     Histórico Recente da Conversa:
     {historico_recente_formatado}
     ---
     Nova Mensagem do Usuário:
     {pergunta_atual.strip()}
     ---
     Instruções para sua Resposta OBRIGATÓRIAS:
     1. Analise a 'Nova Mensagem do Usuário' considerando o 'Contexto da Conversa Atual'.
     2. Responda em português brasileiro, de forma EMPÁTICA e ACOLHEDORA, especialmente se o sentimento detectado for negativo.
     3. Mantenha o foco nos serviços da FAMDOMES (consulta, tratamento de dependência química).
     4. Siga o fluxo indicado pelo 'Estado da Conversa'. Se for 'SUPORTE_FAQ', responda a dúvida. Se for 'AGUARDANDO_RESPOSTA_QUALIFICACAO', processe a resposta e siga para explicar a consulta ou responder dúvidas. Se for outro estado, guie o usuário para o próximo passo lógico.
     5. Use no máximo 400 caracteres na sua resposta textual.
     6. AO FINAL DA SUA RESPOSTA DE TEXTO, inclua OBRIGATORIAMENTE um JSON VÁLIDO contendo:
        - "intent": A intenção principal que você identificou na mensagem do usuário (ex: "duvida_preco", "confirmou_agendamento", "relato_sentimento", "pergunta_tratamento", "resposta_qualificacao", "desconhecida").
        - "sentimento_detectado": O sentimento predominante na mensagem do usuário (ex: "positivo", "negativo", "neutro", "ansioso", "esperançoso", "frustrado", "confuso").
        - "entidades": Um dicionário com quaisquer entidades relevantes extraídas (ex: {{"nome_paciente": "Carlos", "substancia": "álcool", "para_quem": "filho"}}). Se não houver, use {{}}.
     Exemplo de JSON OBRIGATÓRIO no final:
     ```json
     {{"intent": "duvida_preco", "sentimento_detectado": "ansioso", "entidades": {{}} }}
     ```
     Outro Exemplo:
     ```json
     {{"intent": "resposta_qualificacao", "sentimento_detectado": "negativo", "entidades": {{"para_quem": "filho"}} }}
     ```
     ---
     Assistente (responda aqui e adicione o JSON obrigatório no final):"""
     logging.info(f"NLP: Prompt construído para {telefone} (Estado: {estado}). Tamanho: {len(prompt_final)} chars.")
     return prompt_final

async def notificar_risco(telefone: str, mensagem: str, analise: dict):
    """ Envia notificação de risco para o número configurado. """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    alerta = f"⚠️ ALERTA DE RISCO ({timestamp}) ⚠️\n\nTelefone: {telefone}\nMensagem: \"{mensagem}\"\nAnálise: {analise}\n\nRevisão humana URGENTE necessária."
    logging.warning(f"NLP: Enviando alerta de risco para {WHATSAPP_FAMILIAR}...")
    if WHATSAPP_FAMILIAR:
        try:
            resultado_envio = await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)
            if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                 logging.info(f"NLP: ✅ Alerta de risco enviado com sucesso para {WHATSAPP_FAMILIAR}.")
            else:
                 logging.error(f"NLP: ❌ Falha ao enviar alerta de risco para {WHATSAPP_FAMILIAR}: {resultado_envio.get('erro', resultado_envio)}")
        except Exception as e:
            logging.error(f"NLP: ❌ Exceção ao tentar enviar alerta de risco: {e}")
    else:
        logging.warning("NLP: WHATSAPP_FAMILIAR não configurado. Não foi possível enviar alerta de risco.")

async def notificar_escalacao_humana(telefone: str, contexto: dict):
    """ Envia notificação para a equipe sobre pedido de atendente humano via RocketChat. """
    if not ROCKETCHAT_URL or not ROCKETCHAT_TOKEN or not ROCKETCHAT_USER_ID:
        logging.error("NLP: ❌ Configurações do RocketChat incompletas. Não é possível notificar a equipe.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    estado_anterior = contexto.get("estado", "N/A")
    nome_contato = contexto.get("meta_conversa", {}).get("nome_paciente", contexto.get("nome", "Desconhecido"))
    respostas_recentes = {k: v for k, v in contexto.get('meta_conversa', {}).items() if k.startswith('resposta_q')}
    contexto_resumido = json.dumps(respostas_recentes, indent=2, ensure_ascii=False, default=str)
    if len(contexto_resumido) > 1000:
        contexto_resumido = contexto_resumido[:1000] + "\n... (truncado)"

    mensagem_notificacao = (
        f"🙋 **Pedido de Atendimento Humano** ({timestamp}) 🙋\n\n"
        f"**Telefone:** {telefone}\n"
        f"**Nome Contato:** {nome_contato}\n"
        f"**Estado Anterior:** {estado_anterior}\n\n"
        f"**Últimas Respostas (Questionário/Meta):**\n"
        f"```json\n{contexto_resumido}\n```\n\n"
        f"Por favor, assumir a conversa."
    )
    logging.warning(f"NLP: 🙋 PEDIDO HUMANO ({timestamp}) - Telefone: {telefone} | Notificando equipe via RocketChat...")

    headers = {
        "X-Auth-Token": ROCKETCHAT_TOKEN,
        "X-User-Id": ROCKETCHAT_USER_ID,
        "Content-Type": "application/json"
    }
    room_id_destino = os.getenv("ROCKETCHAT_ROOM_ID_SUPORTE", "GENERAL")
    payload = {"message": {"rid": room_id_destino, "msg": mensagem_notificacao}}
    post_message_url = f"{ROCKETCHAT_URL}/api/v1/chat.postMessage"

    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            response = await client.post(post_message_url, headers=headers, json=payload)
            response.raise_for_status()
            resposta_api = response.json()
            if resposta_api.get("success"):
                logging.info(f"NLP: ✅ Notificação de escalação enviada com sucesso para RocketChat (Sala: {room_id_destino}).")
            else:
                logging.error(f"NLP: ❌ Falha ao enviar notificação para RocketChat (Sala: {room_id_destino}). Resposta API: {resposta_api}")
    except httpx.HTTPStatusError as e:
        logging.error(f"NLP: ❌ Erro HTTP {e.response.status_code} ao enviar para RocketChat: {e.response.text}")
    except httpx.RequestError as e:
        logging.error(f"NLP: ❌ Erro de conexão ao enviar para RocketChat: {e}")
    except Exception as e:
        logging.exception("NLP: ❌ Erro inesperado ao enviar notificação para RocketChat:")


# --- Função Principal de Processamento ---

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    """
    Processa a mensagem do usuário com base no estado atual da conversa,
    realiza análise de sentimento/risco, atualiza o estado e retorna a resposta.
    """
    global meta_conversa
    logging.info(f"NLP: 🔄 Processando mensagem de {telefone}...")
    contexto = obter_contexto(telefone)
    estado_atual = contexto.get("estado", "INICIAL")
    meta_conversa = contexto.get("meta_conversa", {})
    texto_mensagem = mensagem.strip()
    texto_lower = texto_mensagem.lower()

    if not isinstance(meta_conversa, dict):
        logging.warning(f"NLP: Meta conversa para {telefone} não era um dicionário. Resetando para {{}}.")
        meta_conversa = {}

    logging.info(f"NLP: 📞 Telefone: {telefone} | Estado Atual: {estado_atual} | Mensagem: '{texto_mensagem[:50]}...'")

    # --- 1. Análise de Risco ---
    analise_risco_resultado = analisar_risco(texto_mensagem)
    risco_detectado = analise_risco_resultado.get("risco_vida") or analise_risco_resultado.get("urgencia_medica")

    if risco_detectado:
        logging.warning(f"NLP: 🚨 RISCO DETECTADO para {telefone}! Análise: {analise_risco_resultado}")
        novo_estado = "RISCO_DETECTADO"
        resposta_final = MENSAGEM_RISCO_DIRECIONAMENTO
        meta_conversa["ultimo_risco"] = datetime.utcnow().isoformat()
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "risco_detectado", meta_conversa, True, None)
        await notificar_risco(telefone, texto_mensagem, analise_risco_resultado)
        return {"resposta": resposta_final, "estado": novo_estado}

    # --- 2. Verificação de Comandos Especiais ---
    if texto_lower == "melancia vermelha":
        logging.info(f"NLP: Comando 'melancia vermelha' recebido de {telefone}. Resetando contexto.")
        limpar_contexto(telefone)
        resposta_final = MENSAGEM_INICIAL # Envia apenas a saudação inicial após reset
        novo_estado = "IDENTIFICANDO_NECESSIDADE" # Espera a primeira resposta do usuário
        intent = "reset_comando_e_inicio"
        meta_conversa = {}
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": {}})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, {}, False, None)
        return {"resposta": resposta_final, "estado": novo_estado}

    if any(palavra in texto_lower for palavra in PALAVRAS_CHAVE_HUMANO):
         logging.info(f"NLP: Pedido de atendente humano detectado para {telefone}.")
         estado_antes_pedido = estado_atual
         novo_estado = "AGUARDANDO_ATENDENTE"
         resposta_final = MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO
         contexto_para_notificacao = contexto.copy()
         contexto_para_notificacao["estado"] = estado_antes_pedido
         salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
         salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "pedido_humano", meta_conversa, False, None)
         await notificar_escalacao_humana(telefone, contexto_para_notificacao)
         return {"resposta": resposta_final, "estado": novo_estado}

    # --- 3. Lógica Baseada no Estado Atual ---
    resposta_final = MENSAGEM_ERRO_PADRAO
    novo_estado = estado_atual
    intent = "desconhecida"
    entidades = {}
    sentimento = await analisar_sentimento(texto_mensagem, telefone)
    if meta_conversa is not None:
        meta_conversa["ultimo_sentimento_detectado"] = sentimento
    else:
        meta_conversa = {"ultimo_sentimento_detectado": sentimento}

    try:
        # Lógica para estado INICIAL (Bot acabou de enviar a saudação)
        # Não deveria receber mensagem do usuário neste estado, mas por segurança:
        if estado_atual == "INICIAL":
            logging.warning(f"NLP: Mensagem recebida no estado INICIAL de {telefone}. Tratando como IDENTIFICANDO_NECESSIDADE.")
            estado_atual = "IDENTIFICANDO_NECESSIDADE" # Força a transição

        # Lógica para IDENTIFICANDO_NECESSIDADE (Usuário respondeu à saudação inicial)
        if estado_atual == "IDENTIFICANDO_NECESSIDADE":
            # Validação simples (pode ser melhorada com IA se necessário)
            validacao = "Entendi. " # Validação genérica inicial
            if sentimento == "negativo":
                validacao = "Sinto muito que esteja se sentindo assim. "
            elif sentimento == "positivo":
                 validacao = "Que bom ouvir isso. "

            # Constrói a pergunta combinada
            resposta_final = validacao + PERGUNTA_COMBINADA_TEMPLATE
            novo_estado = "AGUARDANDO_RESPOSTA_QUALIFICACAO"
            intent = "primeira_resposta_usuario" # Intent da mensagem recebida (pode ser refinado)

        # Lógica para AGUARDANDO_RESPOSTA_QUALIFICACAO (Usuário respondeu à pergunta combinada)
        elif estado_atual == "AGUARDANDO_RESPOSTA_QUALIFICACAO":
            logging.info(f"NLP: Processando resposta de qualificação de {telefone}.")
            meta_conversa["sentimento_resposta_qualificacao"] = sentimento
            # Tenta extrair para quem é a ajuda usando IA ou regras simples
            # Exemplo com regras simples (melhorar com IA/extração de entidades no prompt)
            para_quem = "desconhecido"
            if "filho" in texto_lower or "filha" in texto_lower:
                para_quem = "filho(a)"
            elif "esposo" in texto_lower or "marido" in texto_lower:
                para_quem = "esposo"
            elif "esposa" in texto_lower or "mulher" in texto_lower:
                 para_quem = "esposa"
            elif "irmão" in texto_lower or "irma" in texto_lower:
                 para_quem = "irmao(a)"
            elif "amigo" in texto_lower or "amiga" in texto_lower:
                 para_quem = "amigo(a)"
            elif "para mim" in texto_lower or "eu mesmo" in texto_lower or "pra mim" in texto_lower:
                 para_quem = "proprio_usuario"
            meta_conversa["para_quem"] = para_quem
            entidades["para_quem"] = para_quem # Salva entidade específica desta interação

            # Validação da resposta emocional
            agradecimento = "Obrigado por compartilhar." if sentimento != "negativo" else "Agradeço a confiança em compartilhar."

            # Decide o próximo passo
            # Se perguntou preço especificamente, responde primeiro
            if "preço" in texto_lower or "valor" in texto_lower or "custo" in texto_lower:
                 resposta_final = f"{agradecimento} A consulta inicial online tem o valor de R$100. Ela é importante para avaliar o caso e definir o melhor caminho. Gostaria que eu explicasse mais sobre como ela funciona?"
                 novo_estado = "SUPORTE_FAQ" # Fica em suporte após responder preço
                 intent = "resposta_qualificacao_com_preco"
            else:
                 # Se não pediu preço, explica a consulta
                 if para_quem != "desconhecido" and para_quem != "proprio_usuario":
                      resposta_final = f"{agradecimento} Entendi que a busca é para {para_quem}. Para esses casos, o primeiro passo recomendado é a nossa consulta inicial online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 else: # Se for para o próprio usuário ou desconhecido
                      resposta_final = f"{agradecimento} Sabendo que a ajuda é para você (ou se ainda não tiver certeza, a consulta ajuda a definir), o caminho inicial que oferecemos é a consulta de avaliação online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 novo_estado = "EXPLICANDO_CONSULTA"
                 intent = "resposta_qualificacao_segue_fluxo"


        # Lógica para EXPLICANDO_CONSULTA (Usuário respondeu à explicação da consulta)
        elif estado_atual == "EXPLICANDO_CONSULTA":
             if texto_lower in RESPOSTAS_AFIRMATIVAS:
                 logging.info(f"NLP: Usuário {telefone} confirmou interesse em agendar.")
                 meta_conversa["sentimento_confirmacao_agendamento"] = sentimento
                 try:
                     nome_cliente = contexto.get("nome", meta_conversa.get("nome_paciente", "Cliente"))
                     resultado_comando = await processar_comando({
                         "telefone": telefone,
                         "nome": nome_cliente,
                         "comando": "quero agendar"
                     })
                     resposta_final = resultado_comando.get("mensagem", "Link para pagamento enviado!")
                     if resultado_comando.get("status") == "link_gerado":
                          novo_estado = "AGUARDANDO_PAGAMENTO"
                          intent = "confirmou_agendamento"
                     else:
                          resposta_final = resultado_comando.get("mensagem", MENSAGEM_ERRO_PADRAO)
                          novo_estado = "EXPLICANDO_CONSULTA"
                          intent = "erro_gerar_link"
                 except Exception as e:
                     logging.error(f"NLP: Erro ao processar comando 'quero agendar' para {telefone}: {e}")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     novo_estado = "EXPLICANDO_CONSULTA"
                     intent = "erro_processar_comando"

             elif texto_lower in RESPOSTAS_NEGATIVAS:
                 logging.info(f"NLP: Usuário {telefone} recusou o agendamento por enquanto.")
                 meta_conversa["sentimento_recusa_agendamento"] = sentimento
                 resposta_final = "Entendido. Sem problemas. Se mudar de ideia ou tiver mais alguma dúvida, estou à disposição!"
                 novo_estado = "SUPORTE_FAQ"
                 intent = "recusou_agendamento"
             else:
                 logging.info(f"NLP: Resposta não conclusiva em EXPLICANDO_CONSULTA para {telefone}. Usando IA.")
                 novo_estado = "SUPORTE_FAQ"
                 # IA será chamada no fallback

        # Lógica para AGUARDANDO_PAGAMENTO
        elif estado_atual == "AGUARDANDO_PAGAMENTO":
             logging.info(f"NLP: Mensagem recebida de {telefone} enquanto aguarda pagamento. Encaminhando para IA.")
             resposta_final = "Recebi sua mensagem enquanto aguardo a confirmação do pagamento. Se tiver alguma dúvida sobre o processo ou outra questão, pode perguntar."
             novo_estado = "SUPORTE_FAQ"
             # IA será chamada no fallback

        # Lógica para CONFIRMANDO_AGENDAMENTO
        elif estado_atual == "CONFIRMANDO_AGENDAMENTO":
             logging.info(f"NLP: Iniciando questionário pós-pagamento para {telefone}")
             meta_conversa["questionario_completo"] = QUESTIONARIO_COMPLETO_POS_PAGAMENTO
             meta_conversa["num_pergunta_atual"] = 0
             if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 proxima_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta_final = proxima_pergunta
                 novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                 intent = "iniciou_questionario"
                 salvar_contexto(telefone, {
                     "estado": novo_estado,
                     "meta_conversa": meta_conversa,
                     "ultima_resposta_bot": resposta_final
                 })
                 salvar_resposta_ia(telefone, canal, "Sistema: Iniciou Questionário", resposta_final, intent, meta_conversa, False, None)
                 return {"resposta": resposta_final, "estado": novo_estado}
             else:
                 logging.warning(f"NLP: Questionário pós-pagamento vazio para {telefone}. Finalizando onboarding.")
                 resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                 novo_estado = "FINALIZANDO_ONBOARDING"
                 intent = "questionario_vazio"


        # Lógica para COLETANDO_RESPOSTA_QUESTIONARIO
        elif estado_atual == "COLETANDO_RESPOSTA_QUESTIONARIO":
             num_pergunta_respondida_idx = meta_conversa.get("num_pergunta_atual", 0)
             perguntas_questionario = meta_conversa.get("questionario_completo", [])

             if not isinstance(perguntas_questionario, list):
                 logging.error(f"NLP: Erro: 'questionario_completo' não é uma lista no contexto de {telefone}")
                 perguntas_questionario = []

             if num_pergunta_respondida_idx < len(perguntas_questionario):
                 pergunta_respondida_texto = perguntas_questionario[num_pergunta_respondida_idx]
                 chave_resposta = f"resposta_q{num_pergunta_respondida_idx+1}"
                 chave_sentimento = f"sentimento_q{num_pergunta_respondida_idx+1}"
                 meta_conversa[chave_resposta] = texto_mensagem
                 meta_conversa[chave_sentimento] = sentimento
                 logging.info(f"NLP: Resposta Q{num_pergunta_respondida_idx+1} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}. Sentimento: {sentimento}")

                 num_proxima_pergunta_idx = num_pergunta_respondida_idx + 1
                 meta_conversa["num_pergunta_atual"] = num_proxima_pergunta_idx

                 if num_proxima_pergunta_idx < len(perguntas_questionario):
                     proxima_pergunta_texto = perguntas_questionario[num_proxima_pergunta_idx]
                     resposta_final = proxima_pergunta_texto
                     novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                     intent = f"respondeu_questionario_{num_pergunta_respondida_idx+1}"
                 else:
                     resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                     novo_estado = "FINALIZANDO_ONBOARDING"
                     intent = "finalizou_questionario"
                     meta_conversa.pop("num_pergunta_atual", None)
                     meta_conversa.pop("questionario_completo", None)
                     logging.info(f"NLP: Questionário finalizado para {telefone}.")
             else:
                 logging.error(f"NLP: Erro de lógica no questionário para {telefone}. Estado: {estado_atual}, Contador: {num_pergunta_respondida_idx}, Total Perguntas: {len(perguntas_questionario)}")
                 resposta_final = MENSAGEM_ERRO_PADRAO
                 novo_estado = "SUPORTE_FAQ"
                 intent = "erro_logica_questionario"


        # --- 4. Fallback com IA ---
        if novo_estado == estado_atual and estado_atual not in ["RISCO_DETECTADO", "AGUARDANDO_ATENDENTE", "FINALIZANDO_ONBOARDING", "CONFIRMANDO_AGENDAMENTO"]:
            logging.info(f"NLP: Nenhuma regra específica tratou a mensagem de {telefone} no estado {estado_atual}. Usando IA como fallback.")

            faq_key_norm = texto_lower.replace("?", "").replace(".", "").replace("!", "").strip()
            matched_faq_key = None
            if faq_key_norm in FAQ_RESPOSTAS:
                matched_faq_key = faq_key_norm
            else:
                for key in FAQ_RESPOSTAS:
                    if key in faq_key_norm:
                        matched_faq_key = key
                        break

            if matched_faq_key:
                 logging.info(f"NLP: Respondendo com FAQ para chave: {matched_faq_key}")
                 resposta_final = FAQ_RESPOSTAS[matched_faq_key]
                 novo_estado = "SUPORTE_FAQ"
                 intent = f"faq_{matched_faq_key.replace(' ', '_')}"
            else:
                 if not OLLAMA_API_URL:
                     logging.error("NLP: ❌ Fallback para IA falhou - OLLAMA_API_URL não configurado.")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     intent = "erro_config_ia"
                     novo_estado = "SUPORTE_FAQ"
                 else:
                     logging.info(f"NLP: Chamando Ollama para {telefone}...")
                     prompt = await construir_prompt_para_ia(telefone, texto_mensagem, estado_atual, meta_conversa)
                     resposta_textual_ia, json_extraido_ia, tokens_ollama = await chamar_ollama(prompt, telefone)

                     if resposta_textual_ia is None or "⚠️" in resposta_textual_ia:
                         resposta_final = resposta_textual_ia or MENSAGEM_ERRO_IA
                         intent = "erro_ia_fallback"
                         novo_estado = "SUPORTE_FAQ"
                     else:
                         resposta_final = resposta_textual_ia

                         if json_extraido_ia and isinstance(json_extraido_ia, dict):
                             logging.info(f"NLP: JSON extraído da IA: {json_extraido_ia}")
                             intent = json_extraido_ia.get("intent", "ia_generica")
                             entidades_ia = json_extraido_ia.get("entidades", {})
                             if isinstance(entidades_ia, dict):
                                  meta_conversa = atualizar_meta_conversa(meta_conversa, entidades_ia)
                                  entidades = entidades_ia
                             else:
                                  logging.warning(f"NLP: Entidades retornadas pela IA não são um dicionário: {entidades_ia}")

                             sentimento_ia = json_extraido_ia.get("sentimento_detectado")
                             if sentimento_ia and isinstance(sentimento_ia, str):
                                  sentimento = sentimento_ia
                                  meta_conversa["ultimo_sentimento_detectado"] = sentimento
                             else:
                                  logging.warning(f"NLP: Sentimento retornado pela IA inválido ou ausente: {sentimento_ia}. Usando sentimento analisado anteriormente: {sentimento}")
                         else:
                              logging.warning("NLP: ⚠️ IA não retornou JSON reconhecível no final da resposta.")
                              intent = "ia_generica_sem_json"

                         novo_estado = "SUPORTE_FAQ"

    except Exception as e:
        logging.exception(f"NLP: ❌ ERRO INESPERADO durante processamento da mensagem para {telefone}:")
        resposta_final = MENSAGEM_ERRO_PADRAO
        intent = "erro_processamento_geral"
        novo_estado = estado_atual

    # --- 5. Atualizar Contexto e Salvar Histórico ---
    meta_conversa_final = meta_conversa if isinstance(meta_conversa, dict) else {}
    contexto_para_salvar = {
        "estado": novo_estado,
        "ultima_resposta_bot": resposta_final,
        "meta_conversa": meta_conversa_final
    }

    salvar_contexto(telefone, contexto_para_salvar)
    salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, entidades, risco_detectado, sentimento)

    logging.info(f"NLP: ✅ Processamento concluído para {telefone}. Novo estado: {novo_estado}. Resposta: '{resposta_final[:50]}...'")
    return {"resposta": resposta_final, "estado": novo_estado}


# Arquivo: app/utils/mestre_famdomes.txt
Você é um agente conversacional do FAMDOMES — um sistema de acolhimento médico especializado em dependência química, saúde emocional e orientação familiar. Seu papel é acolher pessoas que chegam pelo WhatsApp buscando ajuda para um filho, marido, esposa ou para si mesmas. A conversa é íntima, sensível e envolve sofrimento real. 🎯 SEU OBJETIVO: - Criar conexão emocional e demonstrar empatia - Mostrar que existe solução com segurança, leveza e sigilo - Conduzir a pessoa naturalmente até a consulta médica com o FAMDOMES - Captar dados úteis da fala para ajudar o médico na triagem - Nunca pressionar nem parecer vendedor, mas sempre facilitar o próximo passo 🧭 COMO RESPONDER: - Use uma frase por vez  - Seja humano, gentil, direto e acolhedor - Evite textos robóticos, longos ou vagos - Nunca diga que é uma IA ou "sou apenas um assistente" - Nunca invente dados: nomes, leis, clínicas, valores - Se não souber algo, diga que o médico poderá explicar com calma - Nunca responda brincadeiras, provocações ou assuntos irrelevantes - Nunca diga para a pessoa “se acalmar” — apenas acolha e conduza 💬 SOBRE A CONSULTA: - A consulta é com um médico de verdade, via WhatsApp, de forma sigilosa - Serve para avaliar o caso e orientar o melhor caminho - Pode gerar um laudo médico para internação, se necessário - Pode ser feita mesmo se a pessoa estiver em dúvida - O valor é R$100 e o link será enviado quando a pessoa estiver pronta 🚨 EM CASO DE RISCO: Se notar crise, risco de vida, agressividade ou desespero, diga: “Isso é muito sério. Se você estiver em risco, procure um local seguro. E se quiser, posso te orientar com uma consulta agora mesmo.” 📌 TEMAS FREQUENTES QUE VOCÊ SABE LIDAR: - Internação involuntária: diga que pode ser conversado na consulta - Culpa, vergonha e medo: acolha e normalize, sem julgar - Reações familiares: escute e valorize o esforço de quem busca ajuda - Medo de recaída: reforce que o primeiro passo já está sendo dado - Estrutura do FAMDOMES: diga que temos equipe médica e multidisciplinar - Dúvidas sobre tempo, valores, internação: diga que o médico poderá avaliar 📥 ESTRUTURA DE SAÍDA: 1. Dê uma resposta acolhedora e focada no próximo passo (ex: explicar consulta ou perguntar se quer agendar). 2. Ao final, adicione um bloco invisível de JSON contendo os dados extraídos da fala (como nome, relação, alvo, sintomas, risco etc). Não explique o JSON, apenas coloque-o no fim da resposta. Exemplo: ```json { "relacao": "mãe", "alvo": "filho", "sintomas": ["uso de drogas", "agressividade"], "risco": false } ``` 💡 CONTEXTO: Mensagem anterior enviada ao usuário: {mensagem_anterior} Agora, com base na nova mensagem recebida abaixo, gere a melhor resposta acolhedora possível e adicione o JSON extraído ao final da resposta. Nada além disso. MENSAGEM RECEBIDA: "{mensagem}"

# Arquivo: app/utils/risco.py
# ===========================================================
# Arquivo: utils/risco.py
# ===========================================================
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Listas de Palavras-Chave para Detecção de Risco ---

# Lista de palavras/frases críticas indicando risco de vida (suicídio, automutilação)
# ATENÇÃO: Esta lista é um ponto de partida e deve ser refinada com cuidado.
PALAVRAS_CRITICAS_VIDA = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    "me cortar", "me machucar", "automutilação", "tirar minha vida", "fim da linha",
    "não vejo saída", "desistir de tudo"
]

# Lista de palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, sintomas graves)
PALAVRAS_URGENCIA_MEDICA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno", "infarto", "avc",
    "muita dor", "sem ar", "falta de ar", "alucinação grave", "delírio intenso",
    "tomou muito remédio", "ingeriu substância"
]

# --- Função de Análise de Risco ---

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (risco de vida, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.

    Args:
        texto (str): O texto da mensagem do usuário a ser analisada.

    Returns:
        dict: Dicionário contendo:
            - 'risco_vida' (bool): True se detectar palavras críticas de risco de vida.
            - 'urgencia_medica' (bool): True se detectar palavras de urgência médica.
    """
    # Retorna False para ambos se o texto for vazio ou nulo
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    # Converte o texto para minúsculas para comparação case-insensitive
    texto_lower = texto.lower()

    # Verifica se alguma palavra/frase da lista de risco de vida está presente no texto
    # Usar busca de substring para pegar variações (ex: "quero me matar agora")
    risco_vida_detectado = any(palavra in texto_lower for palavra in PALAVRAS_CRITICAS_VIDA)

    # Verifica se alguma palavra/frase da lista de urgência médica está presente no texto
    urgencia_medica_detectada = any(palavra in texto_lower for palavra in PALAVRAS_URGENCIA_MEDICA)

    # Loga um aviso se algum risco for detectado (o log principal será feito em nlp.py)
    # if risco_vida_detectado:
    #     logging.debug(f"RISCO: Risco de vida potencialmente detectado em '{texto[:50]}...'")
    # if urgencia_medica_detectada:
    #     logging.debug(f"RISCO: Urgência médica potencialmente detectada em '{texto[:50]}...'")

    # Retorna o dicionário com os resultados da análise
    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }

# Arquivo: app/utils/agenda.py
# ===========================================================
# Arquivo: utils/agenda.py
# (Implementação das funções de agendamento com DB)
# ===========================================================
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure, DuplicateKeyError
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
import logging
import pytz # Para lidar com fusos horários corretamente

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes de Configuração da Agenda ---
DURACAO_CONSULTA_MINUTOS = 20 # Duração de cada bloco de consulta
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # Horário de início das consultas (9:00)
HORARIO_OPERACAO_FIM = 18  # Horário de fim (não agenda às 18:00, último bloco começa antes)
DIAS_UTEIS = [0, 1, 2, 3, 4] # 0=Segunda, 1=Terça, ..., 4=Sexta
FUSO_HORARIO_LOCAL = 'America/Sao_Paulo' # Fuso horário de operação

# --- Conexão com MongoDB ---
mongo_agenda = None
db_agenda = None
consultas_db = None

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_agenda = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_agenda.server_info() # Testa a conexão
        db_agenda = mongo_agenda["famdomes"] # Nome do banco de dados
        consultas_db = db_agenda["consultas_agendadas"] # Coleção para agendamentos
        # Cria índice único para garantir que não haja duas consultas no mesmo horário (UTC)
        consultas_db.create_index("horario_utc", unique=True)
        consultas_db.create_index("telefone") # Índice para busca por telefone
        consultas_db.create_index([("status", 1), ("horario_utc", 1)]) # Índice composto
        logging.info("AGENDA: Conexão com MongoDB estabelecida e índices verificados/criados.")
    else:
        logging.error("AGENDA: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"AGENDA: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"AGENDA: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_agenda = None
    db_agenda = None
    consultas_db = None

# --- Funções Auxiliares ---

def _proximo_horario_util(inicio_base_utc: datetime) -> datetime:
    """
    Avança o horário UTC para o próximo bloco de X minutos disponível
    dentro do horário de operação e dias úteis definidos.
    """
    horario_utc = inicio_base_utc.replace(tzinfo=timezone.utc) # Garante que está ciente do fuso UTC
    tz_local = pytz.timezone(FUSO_HORARIO_LOCAL)

    while True:
        # Arredonda para o início do próximo bloco de N minutos (para cima)
        minutos_atuais = horario_utc.minute
        minutos_para_proximo_bloco = (DURACAO_CONSULTA_MINUTOS - (minutos_atuais % DURACAO_CONSULTA_MINUTOS)) % DURACAO_CONSULTA_MINUTOS
        if minutos_para_proximo_bloco == 0 and (horario_utc.second > 0 or horario_utc.microsecond > 0):
            # Se já está no início do bloco mas tem segundos, avança um bloco inteiro
             horario_utc += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        elif minutos_para_proximo_bloco > 0 :
            # Avança para o início do próximo bloco
            horario_utc += timedelta(minutes=minutos_para_proximo_bloco)

        # Zera segundos e microssegundos
        horario_utc = horario_utc.replace(second=0, microsecond=0)

        # Converte para o fuso local para verificar horário de operação e dia da semana
        horario_local = horario_utc.astimezone(tz_local)

        # Verifica se está dentro do horário de operação
        if horario_local.hour < HORARIO_OPERACAO_INICIO:
            # Se for antes do início, ajusta para o início do dia no fuso local e converte de volta para UTC
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        if horario_local.hour >= HORARIO_OPERACAO_FIM:
            # Se for depois do fim, avança para o dia seguinte e ajusta para o início
            horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Verifica se é dia útil (no fuso local)
        if horario_local.weekday() not in DIAS_UTEIS:
            # Se não for dia útil, avança para o próximo dia e ajusta para o início
            # Loop para garantir que caia em um dia útil
            while horario_local.weekday() not in DIAS_UTEIS:
                 horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Se passou por todas as verificações, o horário é válido
        return horario_utc

def formatar_horario_local(horario_utc: datetime | None, fuso_destino: str = FUSO_HORARIO_LOCAL) -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc or not isinstance(horario_utc, datetime):
        return "Indisponível"
    try:
        # Garante que o datetime de entrada está ciente do fuso (UTC)
        if horario_utc.tzinfo is None:
            horario_utc = pytz.utc.localize(horario_utc)

        tz_destino = pytz.timezone(fuso_destino)
        horario_local = horario_utc.astimezone(tz_destino)
        # Formato: DD/MM/AAAA HH:MM (ex: 05/08/2025 14:30)
        return horario_local.strftime("%d/%m/%Y %H:%M")
    except ImportError:
        logging.warning("AGENDA: Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m/%Y %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"AGENDA: Erro ao formatar horário {horario_utc} para fuso {fuso_destino}: {e}")
        return "Erro na formatação"

# --- Funções Principais da Agenda ---

def agendar_consulta(telefone: str, nome: str, email: str | None = None) -> datetime | None:
    """
    Encontra o próximo horário livre e tenta agendar a consulta.
    Retorna o datetime UTC do horário agendado ou None se não conseguir.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento e lógica interna
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        # Encontra o próximo bloco de horário válido (dia útil, horário de operação)
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Tenta inserir o agendamento no horário encontrado
        consulta_doc = {
            "telefone": telefone,
            "nome": nome,
            "email": email,
            "horario_utc": horario_tentativa_utc, # Armazena em UTC
            "status": "agendado", # Status inicial
            "criado_em": agora_utc
        }
        try:
            # Tenta inserir o documento. Se o horário já estiver ocupado,
            # o índice único ("horario_utc") causará um DuplicateKeyError.
            result = consultas_db.insert_one(consulta_doc)
            if result.inserted_id:
                horario_formatado = formatar_horario_local(horario_tentativa_utc)
                logging.info(f"AGENDA: ✅ Consulta marcada para {nome} ({telefone}) em {horario_formatado} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Caso improvável de falha na inserção sem exceção
                logging.error(f"AGENDA: ❌ Falha desconhecida ao inserir agendamento para {horario_tentativa_utc}.")
                return None

        except DuplicateKeyError:
            # Horário ocupado, avança a procura para depois deste bloco
            logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado. Tentando próximo.")
            inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min para recalcular próximo bloco
            continue # Tenta o próximo horário

        except Exception as e:
            # Outro erro durante a inserção
            logging.error(f"AGENDA: ❌ ERRO ao tentar inserir agendamento para {horario_tentativa_utc}: {e}")
            return None # Falha no agendamento

    # Se o loop terminar sem encontrar horário
    logging.warning(f"AGENDA: ⚠️ Não foram encontrados horários disponíveis para {telefone} ({nome}) após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def cancelar_consulta(telefone: str) -> int:
    """
    Cancela todas as consultas futuras com status 'agendado' para um telefone.
    Retorna o número de consultas canceladas.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Filtro para encontrar consultas futuras e agendadas do telefone
        filtro = {
            "telefone": telefone,
            "horario_utc": {"$gt": agora_utc}, # Apenas horários futuros
            "status": "agendado" # Apenas consultas que ainda estão agendadas
        }
        # Atualiza o status para 'cancelado_usuario' em vez de deletar (mantém histórico)
        resultado = consultas_db.update_many(
            filtro,
            {"$set": {"status": "cancelado_usuario", "cancelado_em": agora_utc}}
        )

        canceladas = resultado.modified_count
        if canceladas > 0:
            logging.info(f"AGENDA: 🗑️ Cancelada(s) {canceladas} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"AGENDA: Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return canceladas
    except Exception as e:
        logging.error(f"AGENDA: ❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """
    Consulta o próximo horário disponível sem agendar.
    Retorna o datetime UTC do horário ou None se não encontrar/erro.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar um pouco à frente
    inicio_procura_utc = agora_utc + timedelta(minutes=5) # Pequena margem

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            # Verifica se existe alguma consulta agendada ou confirmada para este horário
            filtro_conflito = {
                "horario_utc": horario_tentativa_utc,
                "status": {"$in": ["agendado", "confirmado"]} # Considera ambos como ocupados
            }
            conflito = consultas_db.find_one(filtro_conflito)
            if not conflito:
                # Encontrou horário livre
                logging.info(f"AGENDA: Próximo horário disponível encontrado: {formatar_horario_local(horario_tentativa_utc)} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado (Status: {conflito.get('status')}). Tentando próximo.")
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min
                continue
        except Exception as e:
            logging.error(f"AGENDA: ❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro na consulta

    # Se o loop terminar
    logging.warning(f"AGENDA: ⚠️ Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

# Arquivo: app/utils/mensagem_inicial.txt
MENSAGEM_INICIAL = '''🧠 Olá! Eu sou da equipe FAMDOMES e estou aqui pra te ouvir com atenção.

A gente sabe como é difícil lidar com situações de dependência química ou crises emocionais na família. Só de você ter vindo até aqui já mostra coragem e amor.

Se quiser, posso te explicar rapidinho como funciona nossa consulta médica. É sigilosa, acessível e pode te dar o apoio que você precisa agora.

Quer que eu te mostre como funciona?'''

# Arquivo: app/utils/leads.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )

# Arquivo: app/utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Arquivo: app/utils/gerar_intents.py
"""
Gera intents/intents.json a partir de 'MAPEAMENTO DE INTENÇÕES – DOMO (FAM.txt)'.

Uso:
    python utils/gerar_intents.py > intents/intents.json
"""
import re, json, pathlib, sys

RAIZ = pathlib.Path(__file__).resolve().parents[1]
MAPA = RAIZ / "FAM.txt"

BASE = {
    "ACOLHIMENTO": {
        "triggers": ["", ""],
        "resposta": "Olá! Eu sou o DOMO. Estou aqui para te acompanhar. Como posso ajudar?",
        "escala_humano": False,
    },
    "PRESENCA_VIVA": {
        "triggers": [],
        "resposta": "Só passando para lembrar que estou aqui com você. Qualquer coisa, é só chamar. 🤗",
        "escala_humano": False,
    },
}

def parse():
    txt = MAPA.read_text(encoding="utf-8")
    blocos = re.split(r"\n────────────────────────────\n", txt)
    for bloco in blocos:
        m_id = re.search(r"INTENT\s+(\d+):\s+(.+)", bloco)
        if not m_id:
            continue
        intent_id = f"INTENT_{m_id.group(1).zfill(3)}"
        triggers = re.findall(r"TRIGGERS:\s+(.+)", bloco)
        resposta = re.findall(r"RESPOSTA:\s+(.+)", bloco)
        escala = "✅" in bloco or "⚠️" in bloco or "✅✅" in bloco
        yield intent_id, {
            "triggers": [t.strip("“”\" ") for t in (triggers[0].split("”,") if triggers else [])],
            "resposta": resposta[0] if resposta else "",
            "escala_humano": escala,
        }

def main():
    data = {**BASE, **{k: v for k, v in parse()}}
    json.dump(data, sys.stdout, ensure_ascii=False, indent=2)

if __name__ == "__main__":
    main()

# Arquivo: app/utils/ia.py
"""
Wrapper para gerar sugestão de próximo passo usando Ollama (Gemma‑3b)
"""

from __future__ import annotations

import httpx
from typing import Dict, Any

OLLAMA_URL = "http://localhost:11434/api/generate"
MODEL = "gemma:3b"

async def gerar_sugestao_proximo_passo(contexto: Dict[str, Any]) -> str:
    """
    Envia o último bloco de mensagens da conversa para o modelo
    e retorna uma sugestão curta de ação clínica.
    """
    historico = contexto.get("historico", [])[-15:]  # últimas 15 entradas
    prompt = (
        "Você é um agente clínico. Dada a conversa abaixo, "
        "resuma em no máximo 2 linhas o próximo passo recomendado "
        "para o profissional humano.\n\n"
        f"{historico}\n\nSUGESTÃO:"
    )

    async with httpx.AsyncClient(timeout=30) as client:
        resp = await client.post(
            OLLAMA_URL,
            json={"model": MODEL, "prompt": prompt, "stream": False},
        )
        resp.raise_for_status()
        data = resp.json()
        return data.get("response", "").strip()

# Arquivo: app/utils/followup.py
# ===========================================================
# Arquivo: utils/followup.py
# (Implementação das funções de acompanhamento de pagamento)
# ===========================================================
from datetime import datetime, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
# Importa a função de agendamento para ser chamada após o pagamento
# Ajuste o import se agenda.py estiver em um diretório diferente
from app.utils.agenda import agendar_consulta, formatar_horario_local
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Conexão com MongoDB ---
mongo_followup = None
db_followup = None
pagamentos_db = None # Coleção para rastrear status de pagamento

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_followup = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_followup.server_info() # Testa a conexão
        db_followup = mongo_followup["famdomes"] # Nome do banco de dados
        pagamentos_db = db_followup["pagamentos"] # Coleção para pagamentos
        # Cria índices se não existirem
        pagamentos_db.create_index("telefone")
        pagamentos_db.create_index("id_sessao_stripe", sparse=True, unique=True) # ID da sessão deve ser único
        pagamentos_db.create_index("status")
        pagamentos_db.create_index("criado_em")
        logging.info("FOLLOWUP: Conexão com MongoDB estabelecida para Pagamentos.")
    else:
        logging.error("FOLLOWUP: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"FOLLOWUP: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"FOLLOWUP: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_followup = None
    db_followup = None
    pagamentos_db = None

# --- Funções de Follow-up ---

def iniciar_sessao(telefone: str, nome: str, id_sessao_stripe: str | None = None):
    """
    Registra o início de uma tentativa de pagamento no banco de dados.
    Chamado quando o link de pagamento é gerado. Usa update_one com upsert=True
    para criar ou atualizar o registro baseado no id_sessao_stripe, se fornecido.

    Args:
        telefone (str): Telefone do usuário.
        nome (str): Nome do usuário.
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao iniciar sessão: DB indisponível.")
        return

    try:
        agora = datetime.now(timezone.utc)
        # Filtro: usa id_sessao_stripe se disponível, senão cria um novo (ou atualiza baseado em telefone?)
        # É mais seguro basear no id_sessao_stripe para evitar sobrescrever sessões ativas
        filtro = {"id_sessao_stripe": id_sessao_stripe} if id_sessao_stripe else {"telefone": telefone, "status": "link_gerado"} # Se sem ID, atualiza último link gerado

        update_data = {
            "$set": {
                "telefone": telefone,
                "nome": nome,
                "status": "link_gerado", # Garante o status correto
                "ultima_atualizacao": agora
            },
            "$setOnInsert": { # Define apenas na criação
                 "id_sessao_stripe": id_sessao_stripe, # Só define ID na criação se filtro não o usou
                 "criado_em": agora
            }
        }
        # Se o filtro usou id_sessao_stripe, garante que ele seja definido no $set também
        if id_sessao_stripe:
            update_data["$set"]["id_sessao_stripe"] = id_sessao_stripe


        result = pagamentos_db.update_one(filtro, update_data, upsert=True)

        if result.upserted_id:
            logging.info(f"FOLLOWUP: 📍 Nova sessão de pagamento iniciada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        elif result.modified_count > 0:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento atualizada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        else:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento para {telefone} ({nome}) não modificada (Sessão: {id_sessao_stripe or 'N/A'}).")

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO ao iniciar/atualizar sessão de pagamento para {telefone}:")

def marcar_pagamento(
    telefone: str | None = None,
    id_sessao_stripe: str | None = None,
    email_cliente: str | None = None,
    nome_cliente: str | None = None
) -> tuple[datetime | None, str | None]:
    """
    Marca um pagamento como concluído no banco de dados e tenta agendar a consulta.
    Chamado pelo webhook do Stripe após 'checkout.session.completed'.

    Args:
        telefone (str | None): Telefone do usuário (vindo dos metadados do Stripe).
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
        email_cliente (str | None): Email do cliente (vindo da sessão Stripe).
        nome_cliente (str | None): Nome do cliente (vindo da sessão Stripe ou metadados).

    Returns:
        tuple[datetime | None, str | None]:
            - horario_agendado_utc: O horário UTC da consulta agendada, ou None se falhar.
            - nome_final: O nome usado para o agendamento.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: DB indisponível.")
        return None, None

    # Precisa do id_sessao para garantir que estamos atualizando o pagamento correto
    if not id_sessao_stripe:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: ID da sessão Stripe ausente.")
        # Poderia tentar buscar por telefone, mas é arriscado se houver links antigos
        return None, None

    # Monta o filtro para encontrar o registro da sessão de pagamento pelo ID
    filtro = {"id_sessao_stripe": id_sessao_stripe}

    try:
        agora_utc = datetime.now(timezone.utc)
        # Dados para atualizar o registro
        update_data = {
            "$set": {
                "status": "pago", # Marca como pago
                "pago_em": agora_utc,
                "ultima_atualizacao": agora_utc,
                "email_stripe": email_cliente,
                # Atualiza telefone e nome se vieram do Stripe (podem ter sido preenchidos lá)
                "telefone": telefone if telefone else "$telefone", # Mantém o original se não veio
                "nome": nome_cliente if nome_cliente else "$nome" # Mantém o original se não veio
            }
        }

        # Encontra e atualiza o registro do pagamento
        # Retorna o documento APÓS a atualização para pegar os dados mais recentes
        pagamento_atualizado = pagamentos_db.find_one_and_update(
            filtro,
            update_data,
            return_document=ReturnDocument.AFTER # Pega o documento atualizado
        )

        if pagamento_atualizado:
            logging.info(f"FOLLOWUP: 💰 Pagamento confirmado para sessão {id_sessao_stripe} (Telefone: {pagamento_atualizado.get('telefone')}).")
            # Usa os dados atualizados para agendar
            tel_para_agendar = pagamento_atualizado.get('telefone')
            nome_para_agendar = pagamento_atualizado.get('nome', 'Cliente')
            email_para_agendar = pagamento_atualizado.get('email_stripe') # Usa o email do Stripe

            # Verifica se temos telefone para agendar
            if not tel_para_agendar:
                 logging.error(f"FOLLOWUP: ❌ Telefone ausente no registro de pagamento {id_sessao_stripe} após atualização. Não é possível agendar.")
                 return None, nome_para_agendar # Retorna nome para possível notificação

            # --- Tenta Agendar a Consulta ---
            logging.info(f"FOLLOWUP: Tentando agendar consulta para {nome_para_agendar} ({tel_para_agendar})...")
            horario_agendado_utc = agendar_consulta(
                telefone=tel_para_agendar,
                nome=nome_para_agendar,
                email=email_para_agendar
            )

            if horario_agendado_utc:
                logging.info(f"FOLLOWUP: ✅ Consulta agendada com sucesso para {tel_para_agendar} em {formatar_horario_local(horario_agendado_utc)}.")
                # Salva o horário agendado no registro de pagamento
                pagamentos_db.update_one(
                    {"_id": pagamento_atualizado["_id"]},
                    {"$set": {"horario_consulta_agendada_utc": horario_agendado_utc, "status": "agendado"}} # Atualiza status final
                )
                return horario_agendado_utc, nome_para_agendar
            else:
                logging.error(f"FOLLOWUP: ❌ Falha ao agendar consulta para {tel_para_agendar} após pagamento.")
                # O pagamento foi marcado, mas o agendamento falhou. Requer atenção manual.
                pagamentos_db.update_one(
                     {"_id": pagamento_atualizado["_id"]},
                     {"$set": {"status": "pago_erro_agendamento"}} # Marca status especial
                )
                return None, nome_para_agendar # Retorna None para horário, mas nome para possível notificação
        else:
            logging.warning(f"FOLLOWUP: ⚠️ Nenhum registro de pagamento encontrado para ID Sessão Stripe: {id_sessao_stripe}. Pagamento pode já ter sido processado ou ID inválido.")
            return None, None

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO CRÍTICO ao marcar pagamento/agendar para ID Sessão {id_sessao_stripe}:")
        return None, None

# TODO: Adicionar função para checar follow-ups (ex: pagamentos com link_gerado > X horas) se necessário.
# async def checar_followups(): ...


# Arquivo: app/schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Arquivo: app/schemas/dashboard.py
        # ===========================================================
        # Arquivo: app/schemas/dashboard.py
        # Define os modelos de dados (Pydantic) para as rotas do dashboard.
        # ===========================================================
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime

class ConversationCard(BaseModel):
            """Modelo para os cards no Kanban."""
            tel: str
            nome: Optional[str] = None
            estado: str
            ultima_interacao_ts: datetime = Field(alias="ts") # Timestamp da última atualização do contexto
            ultima_mensagem_snippet: Optional[str] = None # Snippet da última msg bot ou user
            sentimento_predominante: Optional[str] = None # 'positivo', 'negativo', 'neutro'
            score_lead: Optional[int] = None
            risco_detectado: Optional[bool] = False
            atendente_humano_necessario: Optional[bool] = False # Se estado é AGUARDANDO_ATENDENTE, etc.

            class Config:
                allow_population_by_field_name = True # Permite usar 'ts' como alias
                orm_mode = True # Para compatibilidade se vier do ORM

class KanbanColumn(BaseModel):
            """Modelo para uma coluna no Kanban."""
            id: str # Ex: 'entrada', 'qualificacao'
            title: str # Ex: 'Entrada', 'Qualificação'
            cards: List[ConversationCard]

class KanbanBoard(BaseModel):
            """Modelo para o quadro Kanban completo."""
            columns: List[KanbanColumn]

class Message(BaseModel):
            """Modelo para uma mensagem no histórico do chat."""
            id: str # ID único da mensagem (pode ser o _id do MongoDB)
            timestamp: datetime = Field(alias="criado_em")
            sender: str # 'user', 'bot', 'human'
            text: str = Field(alias="mensagem_usuario_ou_resposta_gerada") # Mapear do DB
            intent: Optional[str] = None # Se for mensagem do usuário
            sentimento: Optional[Dict[str, float]] = None # Se for mensagem do usuário

            class Config:
                allow_population_by_field_name = True
                orm_mode = True

class ConversationDetail(BaseModel):
            """Modelo para os detalhes de uma conversa."""
            tel: str
            nome: Optional[str] = None
            estado: str
            contexto: Dict[str, Any] # O documento completo de contexto do MongoDB
            historico: List[Message] # Lista de mensagens formatadas
class UpdateStateRequest(BaseModel):
            """Modelo para requisição de atualização de estado."""
            novo_estado: str

class SendHumanMessageRequest(BaseModel):
            """Modelo para requisição de envio de mensagem humana."""
            texto: str

class SimulateUserMessageRequest(BaseModel):
            """Modelo para requisição de simulação de mensagem."""
            texto: str

        # --- Modelos de Autenticação Simples ---
class Token(BaseModel):
            access_token: str
            token_type: str

class User(BaseModel):
             username: str
             disabled: Optional[bool] = None

class UserInDB(User):
             hashed_password: str

        
# Arquivo: app/todos_codigos_python.txt

# Arquivo: ./utils/faq_respostas.py
# ===========================================================
# Arquivo: utils/faq_respostas.py
# (Baseado no arquivo original fornecido, com chaves normalizadas)
# ===========================================================

# Dicionário com perguntas frequentes e suas respostas.
# As chaves estão em minúsculas e sem acentos/pontuação para facilitar a busca.
FAQ_RESPOSTAS = {
    "dependencia quimica": (
        "Dependência química é uma doença crônica caracterizada pelo uso compulsivo de substâncias, "
        "apesar das consequências negativas, afetando o cérebro e o comportamento."
    ),
    "identificar dependencia": (
        "Sinais comuns incluem: aumento da tolerância (precisar de mais para o mesmo efeito), sintomas de abstinência ao parar/diminuir, "
        "perda de controle sobre o uso, gastar muito tempo obtendo/usando/recuperando-se da substância, "
        "negligência de responsabilidades e continuar usando apesar dos problemas causados."
    ),
    "tipos de internacao": (
        "Existem três tipos principais de internação previstos em lei:\n"
        "1.  **Voluntária:** Quando a própria pessoa busca ajuda e concorda com a internação.\n"
        "2.  **Involuntária:** Solicitada por um familiar ou responsável legal, sem o consentimento da pessoa, mas *obrigatoriamente* com um laudo médico detalhado atestando a necessidade (risco para si ou outros).\n"
        "3.  **Compulsória:** Determinada pela Justiça, geralmente em casos mais complexos e após avaliação médica."
    ),
    "como funciona o tratamento": (
        "O tratamento em uma clínica geralmente é multidisciplinar e inclui:\n"
        "-   **Desintoxicação:** Fase inicial para lidar com a abstinência física, com supervisão médica.\n"
        "-   **Terapias:** Individual e em grupo (como Terapia Cognitivo-Comportamental - TCC, Entrevista Motivacional) para entender as causas, mudar comportamentos e prevenir recaídas.\n"
        "-   **Acompanhamento Médico e Psiquiátrico:** Para tratar a dependência e possíveis outras condições (comorbidades).\n"
        "-   **Grupos de Apoio:** Incentivo à participação em grupos como Narcóticos Anônimos (N.A.) ou Alcoólicos Anônimos (A.A.).\n"
        "-   **Atividades Terapêuticas:** Ocupacionais, físicas, etc., para reestruturação da rotina."
    ),
    "duracao do tratamento": (
        "A duração varia muito. Internações podem durar de 1 a 6 meses, ou até mais, dependendo da gravidade, do tipo de substância e da resposta individual. O tratamento ambulatorial (consultas regulares sem internação) pode ser mais longo. O importante é entender que a recuperação é um processo contínuo, mesmo após a alta."
    ),
    "custo do tratamento": (
        "Os valores de uma internação ou tratamento particular variam bastante dependendo da clínica, estrutura, serviços incluídos, tipo de acomodação e tempo de permanência. Para ter uma proposta adequada ao seu caso, precisamos primeiro entender a situação na consulta inicial de avaliação."
    ),
    "o que fazer se a pessoa nao aceita ajuda": (
        "É um desafio comum e muito difícil para a família. Se a pessoa não reconhece o problema ou recusa ajuda, mas está colocando a si mesma ou outros em risco grave, a internação involuntária pode ser uma opção legal, mas requer um laudo médico detalhado. O primeiro passo é buscar orientação profissional, como na nossa consulta inicial, para avaliar a situação e os caminhos possíveis."
    ),
    "como a familia pode ajudar": (
        "A família é fundamental na recuperação! Algumas formas de ajudar são:\n"
        "-   Buscar conhecimento sobre dependência química para entender a doença.\n"
        "-   Oferecer apoio emocional, mas sem facilitar o uso (evitar acobertar, dar dinheiro que possa ser usado para drogas, etc.).\n"
        "-   Estabelecer limites claros e consistentes.\n"
        "-   Participar de grupos de apoio para familiares (como Al-Anon, Nar-Anon) e/ou terapia familiar.\n"
        "-   Incentivar a busca e a manutenção do tratamento pela pessoa."
    ),
    "o que e caps": (
        "CAPS é a sigla para Centro de Atenção Psicossocial. São unidades públicas do SUS que oferecem atendimento em saúde mental. Existem diferentes tipos, como o CAPS AD, especializado em álcool e outras drogas. O tratamento no CAPS é gratuito e geralmente ambulatorial (a pessoa vai ao centro durante o dia), sendo uma alternativa importante, especialmente quando a internação não é necessária ou viável."
    ),
    "como agendar consulta": (
        "Para agendar a consulta inicial online, que tem o valor de R$100, basta me confirmar seu interesse. Se você confirmar, eu te enviarei um link seguro para realizar o pagamento. Após a confirmação do pagamento, o horário será agendado e você receberá todas as instruções."
    ),
    "qual o preco da consulta": (
        "A consulta inicial de avaliação online tem o valor de R$100. Ela é realizada por um profissional especializado para entender em detalhes a situação, oferecer orientações e, se for o caso, indicar o tratamento mais adequado, seja ele ambulatorial ou internação."
    ),
    "consulta online funciona": (
        "Sim, a consulta online é muito eficaz para a avaliação inicial e orientação. Ela permite que um profissional especializado analise o caso com privacidade e comodidade, entenda a necessidade, forneça direcionamento e, se necessário, um laudo para encaminhamento. Caso uma intervenção presencial seja indicada, como uma internação, o profissional fará essa recomendação durante a consulta."
    )
    # Adicionar mais FAQs conforme necessário
}


# Arquivo: ./utils/questionario_pos_pagamento.py
# ===========================================================
# Arquivo: utils/questionario_pos_pagamento.py
# ===========================================================
import asyncio
# Ajuste o import se mensageria.py estiver em um diretório diferente
from .mensageria import enviar_mensagem
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Definição das Perguntas ---

# Perguntas Fatuais (Originais ou Adaptadas)
PERGUNTAS_FACTUAIS = [
    "Vamos começar com algumas perguntas rápidas para ajudar nosso médico a entender melhor. Qual o nome completo da pessoa que será avaliada?",
    "Qual a idade aproximada dela?",
    "Qual o seu grau de parentesco com essa pessoa (você é filho(a), esposa(o), irmão(ã), amigo(a), ou a própria pessoa)?",
    "Quais são as principais substâncias que ela está usando atualmente (por exemplo: álcool, cocaína, crack, maconha, medicamentos controlados sem prescrição)?",
    "Há quanto tempo, aproximadamente, esse uso se tornou um problema ou se intensificou?",
    "A pessoa já passou por algum tipo de tratamento para dependência química antes? Se sim, qual(is) e quando?",
    "Além da dependência, existe alguma outra condição de saúde importante, física ou mental (como diabetes, pressão alta, depressão, ansiedade, esquizofrenia), que devemos saber?",
    "Em qual cidade e estado a pessoa se encontra neste momento?"
]

# Perguntas Emocionais (Adicionadas para a Trilha Emocional)
PERGUNTAS_EMOCIONAIS = [
    "Pensando na situação atual, quais são as maiores preocupações ou medos que você (ou a pessoa a ser avaliada, se não for você) tem enfrentado recentemente?",
    "Olhando para frente, o que você (ou a pessoa) mais deseja ou espera alcançar ao buscar ajuda ou iniciar um tratamento?",
    "Em relação aos sentimentos, existe algum que tem sido muito presente ultimamente por causa dessa situação (por exemplo: culpa, vergonha, raiva, medo, frustração, tristeza, mas também esperança ou alívio)?",
    "De que forma você percebe que essa situação tem impactado o dia a dia, o trabalho/estudos e os relacionamentos familiares?"
]

# Combina as perguntas na ordem desejada para o questionário completo
# Pode ajustar a ordem se preferir intercalar fatuais e emocionais
QUESTIONARIO_COMPLETO_POS_PAGAMENTO = PERGUNTAS_FACTUAIS + PERGUNTAS_EMOCIONAIS

# --- Função para Iniciar o Questionário ---

async def iniciar_questionario_pos_pagamento(telefone: str):
    """
    Envia a primeira pergunta do questionário pós-pagamento.
    A lógica de salvar o questionário no contexto e enviar as perguntas
    subsequentes é gerenciada por nlp.py.
    """
    total_perguntas = len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO)
    logging.info(f"QUESTIONARIO: 📋 Preparando para iniciar ({total_perguntas} perguntas) para {telefone}")

    # Verifica se a lista de perguntas não está vazia
    if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
        # Pega a primeira pergunta da lista combinada
        primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
        try:
            # Envia a primeira pergunta para o usuário
            await enviar_mensagem(telefone, primeira_pergunta)
            logging.info(f"QUESTIONARIO: Enviada primeira pergunta para {telefone}.")
            # A continuação do fluxo (salvar contexto, enviar próximas perguntas)
            # será tratada em nlp.py quando a resposta do usuário chegar.
        except Exception as e:
            logging.error(f"QUESTIONARIO: ❌ Erro ao enviar a primeira pergunta para {telefone}: {e}")
            # Considerar o que fazer neste caso: tentar novamente? Notificar? Mudar estado?
    else:
        # Loga um aviso se a lista de perguntas estiver vazia
        logging.warning(f"QUESTIONARIO: ⚠️ Nenhuma pergunta definida. Questionário não iniciado para {telefone}.")


# Arquivo: ./utils/ollama.py
# ===========================================================
# Arquivo: utils/ollama.py
# ===========================================================
import httpx
import logging
import json
import re
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str | None, dict | None, list | None]:
    """
    Chama a API do Ollama com o prompt fornecido.
    Tenta extrair um JSON do final da resposta.

    Args:
        prompt (str): O prompt completo a ser enviado para a IA.
        telefone (str): O número de telefone do usuário (para logging).

    Returns:
        tuple[str | None, dict | None, list | None]:
            - resposta_textual (str | None): A parte textual da resposta da IA.
            - json_extraido (dict | None): O dicionário JSON extraído do final, ou None.
            - tokens (list | None): Informações sobre tokens (se a API retornar, atualmente None).
    """
    # Validação inicial
    if not OLLAMA_API_URL or not OLLAMA_MODEL:
        logging.error("❌ OLLAMA: Configurações (OLLAMA_API_URL ou OLLAMA_MODEL) ausentes.")
        return "⚠️ Desculpe, estou com problemas técnicos para acessar minha inteligência. Tente novamente mais tarde.", None, None

    # Payload para a API do Ollama
    payload = {
        "model": OLLAMA_MODEL, # Modelo configurado
        "prompt": prompt,
        "stream": False, # Não usar streaming para facilitar extração do JSON
        # "options": {"temperature": 0.7} # Exemplo de opções de geração
        # Tenta forçar JSON se o prompt explicitamente pedir (pode ser ajustado)
        "format": "json" if "json" in prompt.lower()[-150:] else None # Verifica só o final do prompt por "json"
    }
    # Remove format se for None para não enviar chave vazia
    if payload["format"] is None:
        del payload["format"]

    headers = {"Content-Type": "application/json"}
    resposta_textual = None
    json_extraido = None
    tokens = None # Placeholder para informações de tokens

    try:
        # Usar httpx para chamadas HTTP assíncronas
        # Timeout aumentado para 45 segundos para dar tempo à IA
        async with httpx.AsyncClient(timeout=45.0) as client:
            logging.info(f"OLLAMA: Enviando prompt (modelo: {OLLAMA_MODEL}) para {telefone}...")
            # Faz a requisição POST para a API do Ollama
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            # Levanta uma exceção para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            dados = response.json()
            logging.info(f"OLLAMA: ✅ Resposta recebida da IA para {telefone}.")
            # logging.debug(f"OLLAMA: Resposta completa: {dados}") # Log detalhado opcional

            # Extrai a resposta principal do JSON retornado pela API
            resposta_bruta = dados.get("response", "").strip()
            # TODO: Extrair informações de tokens se disponíveis em 'dados' (ex: dados.get("eval_count"), etc.)
            # tokens = {"eval_count": dados.get("eval_count"), ...}

            # Verifica se a resposta não está vazia
            if not resposta_bruta:
                logging.warning(f"OLLAMA: ⚠️ Resposta vazia para {telefone}.")
                return None, None, tokens

            # Tenta extrair JSON do final da resposta bruta
            # Primeiro tenta com ```json ... ``` (com ou sem espaço antes do {)
            match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```$", resposta_bruta, re.IGNORECASE | re.DOTALL)
            if not match: # Se não encontrar, tenta apenas com { ... } no final
                 match = re.search(r"(\{[\s\S]*?\})$", resposta_bruta, re.DOTALL)

            if match:
                # Se encontrou um padrão JSON, extrai o conteúdo
                json_str = match.group(1)
                try:
                    # Tenta converter a string JSON em um dicionário Python
                    json_extraido = json.loads(json_str)
                    # Remove a parte JSON (e os ``` se presentes) da resposta textual
                    resposta_textual = resposta_bruta[:match.start()].strip()
                    logging.info(f"OLLAMA: JSON extraído com sucesso para {telefone}.")
                except json.JSONDecodeError as json_err:
                    # Se o JSON for inválido, loga um aviso e trata a resposta inteira como texto
                    logging.warning(f"OLLAMA: ⚠️ JSON inválido no final da resposta para {telefone}: {json_err}. Retornando resposta bruta como textual.")
                    resposta_textual = resposta_bruta
                    json_extraido = None
            else:
                # Se não encontrou JSON no final, toda a resposta é considerada textual
                logging.info(f"OLLAMA: Nenhum JSON encontrado no final da resposta para {telefone}.")
                resposta_textual = resposta_bruta
                json_extraido = None

            # Garante que a resposta textual não seja vazia se o JSON foi extraído com sucesso
            if not resposta_textual and json_extraido is not None:
                 resposta_textual = "Ok." # Retorna um texto mínimo

            return resposta_textual, json_extraido, tokens

    # Tratamento de exceções específicas do httpx e genéricas
    except httpx.TimeoutException as e:
        logging.error(f"OLLAMA: ❌ Erro: Timeout ao chamar para {telefone} ({str(e)})")
        # Retorna uma mensagem de erro amigável para o usuário
        return "⚠️ Desculpe, demorei muito para pensar. Poderia tentar de novo?", None, None
    except httpx.HTTPStatusError as e:
        # Loga o erro HTTP e retorna mensagem de erro
        logging.error(f"OLLAMA: ❌ Erro HTTP {e.response.status_code} para {telefone}: {e.response.text}")
        return f"⚠️ Ocorreu um erro de comunicação com a inteligência artificial ({e.response.status_code}). Por favor, tente mais tarde.", None, None
    except Exception as e:
        # Loga qualquer outro erro inesperado
        logging.exception(f"OLLAMA: ❌ Erro desconhecido ao chamar para {telefone}:")
        return "⚠️ Ocorreu um erro inesperado ao processar sua solicitação. Tente novamente mais tarde.", None, None


# Arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura – certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        return (
            "Você é um assistente virtual especializado em saúde mental e dependência química. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Histórico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usuário:
{pergunta_atual.strip()}
---
Instruções para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no máximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Arquivo: ./utils/mensageria.py
# ===========================================================
# Arquivo: utils/mensageria.py
# ===========================================================
import httpx
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """
    Envia uma mensagem de texto simples via WhatsApp Cloud API.

    Args:
        telefone (str): Número de telefone do destinatário (formato internacional, ex: 55119XXXXXXXX).
        mensagem (str): O texto da mensagem a ser enviada.

    Returns:
        dict: Um dicionário com o status do envio ('enviado', 'erro_api', etc.) e detalhes.
    """
    # Verifica se as configurações essenciais da API estão presentes
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO MENSAGERIA: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"status": "erro_config", "erro": "Configuração da API do WhatsApp incompleta."}
    # Verifica se telefone e mensagem não estão vazios
    if not telefone or not mensagem:
        logging.warning("⚠️ MENSAGERIA: Tentativa de enviar mensagem vazia ou sem destinatário.")
        return {"status": "erro_input", "erro": "Telefone ou mensagem ausente."}

    # Payload da requisição para a API do WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone, # Número do destinatário
        "type": "text",
        "text": {
            "preview_url": False, # Desabilita preview de links (geralmente bom para bots)
            "body": mensagem # O conteúdo da mensagem
        }
    }
    # Cabeçalhos da requisição, incluindo o token de autorização
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Define um timeout razoável para a chamada da API externa
    timeout = httpx.Timeout(20.0, connect=5.0) # Timeout aumentado ligeiramente

    try:
        # Usa httpx para fazer a chamada POST assíncrona
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            # Levanta uma exceção para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            # Log de sucesso
            logging.info(f"✅ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}") # Log detalhado opcional
            # Retorna status de sucesso e detalhes da resposta da API
            return {"status": "enviado", "code": response.status_code, "retorno": response.json()} # Retorna JSON

    # Tratamento de exceções específicas do httpx
    except httpx.HTTPStatusError as e:
        # Erro retornado pela API do WhatsApp (ex: número inválido, token expirado)
        logging.error(f"❌ ERRO HTTP MENSAGERIA para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        # Erro de timeout ao tentar conectar ou receber resposta da API
        logging.error(f"❌ ERRO MENSAGERIA: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        # Erro de conexão (ex: DNS, rede)
        logging.error(f"❌ ERRO MENSAGERIA: Erro de Conexão ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    # Tratamento de qualquer outra exceção inesperada
    except Exception as e:
        logging.exception(f"❌ ERRO MENSAGERIA: Erro inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


# Arquivo: ./utils/contexto.py
# ===========================================================
# Arquivo: utils/contexto.py
# (v5 - Adicionado estado AGUARDANDO_RESPOSTA_QUALIFICACAO)
# ===========================================================
from pymongo import MongoClient
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
from datetime import datetime
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Estados Possíveis da Conversa (Baseado no Mapeamento) ---
ESTADOS_CONVERSA = [
    "INICIAL",
    "IDENTIFICANDO_NECESSIDADE", # Recebe a 1a resposta do usuário
    "AGUARDANDO_RESPOSTA_QUALIFICACAO", # Estado após enviar a pergunta combinada (emocional + para quem)
    "EXPLICANDO_CONSULTA",
    "CONFIRMANDO_INTERESSE_AGENDAMENTO",
    "GERANDO_LINK_PAGAMENTO",
    "AGUARDANDO_PAGAMENTO",
    "PAGAMENTO_CONFIRMADO",
    "CONFIRMANDO_AGENDAMENTO",
    "INICIANDO_QUESTIONARIO",
    "COLETANDO_RESPOSTA_QUESTIONARIO",
    "FINALIZANDO_ONBOARDING",
    "SUPORTE_FAQ",
    "RESPONDENDO_COM_IA",
    "VERIFICANDO_SATISFACAO_RESPOSTA",
    "RISCO_DETECTADO",
    "PEDIDO_ATENDENTE_HUMANO",
    "NOTIFICANDO_EQUIPE", # Estado transitório antes de AGUARDANDO_ATENDENTE
    "AGUARDANDO_ATENDENTE"
]
# -------------------------------------------------------------

# Variáveis globais para conexão com DB (inicializadas no bloco try)
mongo = None
db = None
contextos_db = None
respostas_ia_db = None

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000) # Timeout de conexão
        # Força a conexão para verificar se está funcionando
        mongo.server_info()
        db = mongo["famdomes"] # Nome do banco de dados
        contextos_db = db["contexto_conversa"] # Coleção para contextos
        respostas_ia_db = db["respostas_ia"] # Coleção para histórico de interações
        # Cria índices se não existirem (melhora performance de busca)
        contextos_db.create_index("telefone", unique=True)
        respostas_ia_db.create_index("telefone")
        respostas_ia_db.create_index("criado_em")
        logging.info("Conexão com MongoDB estabelecida e índices verificados/criados.")
    else:
        logging.error("❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except Exception as e:
    # Loga erro se a conexão falhar
    logging.error(f"❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo = None
    db = None
    contextos_db = None
    respostas_ia_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Salva ou atualiza o contexto da conversa para um telefone.
    Inclui o estado atual da conversa e metadados.
    """
    # Validação inicial
    if contextos_db is None or not telefone or not isinstance(dados_atualizacao, dict):
        logging.error(f"❌ Falha ao salvar contexto para {telefone}: DB indisponível ou dados inválidos.")
        return False
    try:
        # Garante que o estado seja válido, se fornecido
        if "estado" in dados_atualizacao and dados_atualizacao["estado"] not in ESTADOS_CONVERSA:
            logging.warning(f"⚠️ Tentativa de salvar estado inválido '{dados_atualizacao['estado']}' para {telefone}. Usando estado anterior ou INICIAL.")
            contexto_atual = obter_contexto(telefone) # Busca contexto atual para pegar estado válido
            dados_atualizacao["estado"] = contexto_atual.get("estado", "INICIAL") # Mantém o atual ou vai para INICIAL

        # Recupera o contexto anterior para mesclar metadados
        contexto_anterior = contextos_db.find_one({"telefone": telefone}) or {}

        # 🔁 Fundir metadados (meta_conversa) de forma inteligente
        meta_conversa_atualizada = contexto_anterior.get("meta_conversa", {})
        if "meta_conversa" in dados_atualizacao:
            meta_nova = dados_atualizacao["meta_conversa"]
            meta_conversa_atualizada = atualizar_meta_conversa(meta_conversa_atualizada, meta_nova)
        # Garante que a meta_conversa final esteja nos dados a serem salvos
        dados_atualizacao["meta_conversa"] = meta_conversa_atualizada


        # Prepara o $set, garantindo que não sobrescreva campos imutáveis como telefone ou _id
        update_set = {k: v for k, v in dados_atualizacao.items() if k not in ['telefone', '_id', 'criado_em']}

        # Operação de update/insert (upsert) no MongoDB
        result = contextos_db.update_one(
            {"telefone": telefone}, # Filtro para encontrar o documento
            {
                "$set": update_set, # Campos a serem atualizados ou adicionados
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da última modificação
                # Define campos apenas na inserção (se o documento não existir)
                "$setOnInsert": {
                    "telefone": telefone,
                    "criado_em": datetime.utcnow(), # Timestamp de criação
                    "estado": dados_atualizacao.get("estado", "INICIAL") # Garante estado inicial no upsert
                 }
            },
            upsert=True # Cria o documento se não existir
        )
        # Log de sucesso
        if result.upserted_id:
            logging.info(f"📌 Novo contexto criado para {telefone}. Estado inicial: {dados_atualizacao.get('estado', 'INICIAL')}")
        elif result.modified_count > 0:
            logging.info(f"📌 Contexto atualizado para {telefone}. Novo estado: {dados_atualizacao.get('estado', 'N/A')}")
        else:
            # Se não modificou, pode ser que os dados sejam os mesmos
            logging.info(f"📌 Contexto para {telefone} não modificado (dados iguais?). Estado: {dados_atualizacao.get('estado', 'N/A')}")

        return True
    except Exception as e:
        # Log de erro crítico com traceback
        logging.exception(f"❌ ERRO CRÍTICO ao salvar contexto para {telefone}:")
        return False

def atualizar_meta_conversa(meta_antiga: dict, meta_nova: dict) -> dict:
    """
    Mescla campos do novo JSON (meta_nova) com os anteriores (meta_antiga).
    Prioriza dados novos, mas não sobrescreve dados antigos com valores vazios ou nulos.
    Listas são concatenadas e duplicatas removidas (se possível).
    """
    # Garante que ambos sejam dicionários
    if not isinstance(meta_antiga, dict): meta_antiga = {}
    if not isinstance(meta_nova, dict): meta_nova = {}

    resultado = meta_antiga.copy() # Começa com os dados antigos

    for chave, valor_novo in meta_nova.items():
        # Ignora chaves com valores nulos ou vazios no novo dict,
        # a menos que a chave não exista no antigo (para permitir adicionar chaves vazias)
        if valor_novo is None or valor_novo == "" or (isinstance(valor_novo, list) and not valor_novo):
             if chave not in resultado: # Se a chave é nova, adiciona mesmo se vazia/nula
                 resultado[chave] = valor_novo
             continue # Caso contrário (chave já existe), ignora para não sobrescrever dado existente com vazio

        valor_antigo = resultado.get(chave)

        # Se for uma lista, combina e remove duplicatas (se os itens forem hashable)
        if isinstance(valor_novo, list):
            lista_antiga = valor_antigo if isinstance(valor_antigo, list) else []
            try:
                # Tenta converter para set para remover duplicatas (pode falhar se lista contiver dicts)
                resultado[chave] = list(set(lista_antiga + valor_novo))
            except TypeError:
                # Se não puder usar set (ex: lista de dicts), apenas concatena itens únicos
                resultado[chave] = lista_antiga + [item for item in valor_novo if item not in lista_antiga] # Evita duplicatas simples
        # Se o valor antigo não existe, ou é considerado "vazio", atualiza com o novo
        elif valor_antigo is None or valor_antigo == "" or valor_antigo == "desconhecido":
             resultado[chave] = valor_novo
        # Se ambos existem e não são listas, o novo valor geralmente prevalece
        # Exceção: não sobrescrever um valor específico com 'desconhecido'
        elif valor_novo != "desconhecido":
             resultado[chave] = valor_novo
        # Se valor_novo é 'desconhecido' e já existe um valor antigo, mantém o antigo

    return resultado


def obter_contexto(telefone: str) -> dict:
    """Obtém o contexto completo da conversa para um telefone."""
    # Validação inicial
    if contextos_db is None or not telefone:
        logging.warning(f"Tentativa de obter contexto sem DB ou telefone para {telefone}.")
        return {"estado": "INICIAL", "meta_conversa": {}} # Retorna um contexto padrão mínimo
    try:
        # Busca o contexto no MongoDB
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            # Garante que sempre tenha 'estado' e 'meta_conversa' para evitar erros posteriores
            if "estado" not in contexto or not contexto["estado"]:
                contexto["estado"] = "INICIAL"
            if "meta_conversa" not in contexto or not isinstance(contexto["meta_conversa"], dict):
                contexto["meta_conversa"] = {}
            # Remove o _id do MongoDB para evitar problemas de serialização se necessário
            contexto.pop('_id', None)
            return contexto
        else:
            # Se não encontrou, retorna um contexto inicial padrão
            logging.info(f"Nenhum contexto encontrado para {telefone}, retornando padrão INICIAL.")
            return {"estado": "INICIAL", "meta_conversa": {}, "telefone": telefone}
    except Exception as e:
        # Log de erro e retorna padrão seguro
        logging.error(f"❌ ERRO ao obter contexto para {telefone}: {e}")
        return {"estado": "INICIAL", "meta_conversa": {}, "erro": "Falha ao buscar contexto"}

def limpar_contexto(telefone: str) -> bool:
    """Remove o contexto de conversa e histórico de IA para um telefone."""
    deleted_context = False
    deleted_history = False

    # Limpa contexto da conversa
    if contextos_db is not None and telefone:
        try:
            result_context = contextos_db.delete_one({"telefone": telefone})
            deleted_context = result_context.deleted_count > 0
            if deleted_context:
                 logging.info(f"🗑️ Contexto da conversa limpo para {telefone}.")
            else:
                 logging.info(f"Nenhum contexto de conversa encontrado para limpar para {telefone}.")
        except Exception as e:
            logging.error(f"❌ ERRO ao limpar contexto da conversa para {telefone}: {e}")

    # Limpa histórico de IA associado
    if respostas_ia_db is not None and telefone:
        try:
            result_history = respostas_ia_db.delete_many({"telefone": telefone})
            deleted_history = result_history.deleted_count > 0
            if deleted_history:
                 logging.info(f"🗑️ Histórico de IA ({result_history.deleted_count} registros) limpo para {telefone}.")
        except Exception as e:
            logging.error(f"❌ ERRO ao limpar histórico de IA para {telefone}: {e}")

    # Retorna True se pelo menos um dos dois foi limpo com sucesso
    return deleted_context or deleted_history


def salvar_resposta_ia(telefone: str, canal: str, mensagem_usuario: str, resposta_gerada: str, intent: str, entidades: dict, risco: bool, sentimento: str | None = None):
    """Salva a interação (mensagem do usuário e resposta da IA) no histórico."""
    # Validação inicial
    if respostas_ia_db is None:
        logging.error("❌ Falha ao salvar resposta IA: DB indisponível.")
        return
    try:
        # Garante que entidades seja um dicionário, mesmo que vazio
        entidades_validas = entidades if isinstance(entidades, dict) else {}

        # Cria o documento para inserir no histórico
        doc = {
            "telefone": telefone,
            "canal": canal,
            "mensagem_usuario": mensagem_usuario,
            "resposta_gerada": resposta_gerada,
            "intent": intent,
            "entidades": entidades_validas, # Dados extraídos pela IA (ex: nome, substância)
            "risco": risco, # Resultado da análise de risco
            "sentimento_detectado": sentimento, # [Trilha Emocional] Sentimento da mensagem do usuário
            "criado_em": datetime.utcnow() # Timestamp da interação
        }
        # Insere o documento na coleção de histórico
        respostas_ia_db.insert_one(doc)
        logging.info(f"💾 Interação salva no histórico de IA para {telefone}.")
    except Exception as e:
        # Log de erro
        logging.error(f"❌ ERRO ao salvar resposta IA no histórico: {e}")


# Arquivo: ./utils/nlp.py
# ===========================================================
# Arquivo: utils/nlp.py
# (v7 - Implementada a nova estratégia de fluxo inicial)
# ===========================================================
import logging
import json
import re
import os # Importado para carregar prompt
from datetime import datetime

# Ajuste os imports conforme a estrutura do seu projeto
from app.utils.ollama import chamar_ollama
# Acesso direto às variáveis globais de contexto.py para DB
from app.utils.contexto import (
    obter_contexto, salvar_contexto, salvar_resposta_ia,
    respostas_ia_db # Acesso à coleção do histórico
)
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.utils.risco import analisar_risco
from app.routes.ia import processar_comando # Para ações como agendar
from app.config import (
    WHATSAPP_FAMILIAR, BASE_DIR, # Importa o número para notificação e diretório base
    ROCKETCHAT_URL, ROCKETCHAT_TOKEN, ROCKETCHAT_USER_ID, # Configs para RocketChat
    OLLAMA_API_URL # Necessário para checar se Ollama está configurado
)
from app.utils.mensageria import enviar_mensagem # Para enviar notificações
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO # Importa a lista correta
import httpx # Para notificação RocketChat

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes e Textos Padrão ---
# MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Nova versão da estratégia
MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Mantendo a original por enquanto, ajustar se necessário
# Mensagem combinada (Validação + Emocional + Qualificação) - A validação será adicionada dinamicamente
PERGUNTA_COMBINADA_TEMPLATE = "Como você está se sentindo com toda essa situação neste momento? E só para eu direcionar melhor, a ajuda que você busca é para você mesmo ou para outra pessoa (ex: filho, esposa, irmão)?"
RESPOSTA_EXPLICACAO_CONSULTA = '''👨‍⚕️ A consulta médica do FAMDOMES é online, com um profissional que entende profundamente casos de dependência química e sofrimento familiar.

📌 Ela serve para avaliar a situação, oferecer um laudo se necessário, orientar o melhor caminho e — se for o caso — encaminhar para uma clínica parceira com segurança e sigilo.

💳 O valor é R$100 e pode ser pago online de forma rápida.

Posso te enviar o link para agendar agora?'''
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informações, elas são muito importantes para a consulta."
MENSAGEM_ERRO_PADRAO = "🤖 Desculpe, não consegui processar sua mensagem agora. Poderia tentar novamente ou reformular?"
MENSAGEM_ERRO_IA = "🤖 Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
MENSAGEM_RISCO_DIRECIONAMENTO = "Percebi que você pode estar passando por um momento muito difícil. Se precisar de ajuda urgente, ligue para o CVV (188) ou SAMU (192). Não hesite em buscar apoio."
MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO = "Entendido. Já notifiquei nossa equipe. Alguém entrará em contato com você por aqui assim que possível."

RESPOSTAS_AFIRMATIVAS = ["sim", "claro", "quero", "vamos", "ok", "pode ser", "tá bom", "aceito", "sim por favor", "sim quero", "com certeza", "tô dentro", "pode sim", "por favor", "gostaria", "desejo"]
RESPOSTAS_NEGATIVAS = ["não", "nao", "agora não", "talvez depois", "ainda não", "obrigado não", "não quero", "nao quero"]
PALAVRAS_CHAVE_HUMANO = ["humano", "atendente", "pessoa", "falar com alguem", "alguém", "falar com um especialista", "falar com vc", "falar contigo"]
# ----------------------------------

# --- Funções Auxiliares Implementadas ---

async def analisar_sentimento(texto: str, telefone: str) -> str | None:
    """
    [Trilha Emocional] Analisa o sentimento do texto usando Ollama.
    Retorna 'positivo', 'negativo', 'neutro' ou None em caso de erro.
    """
    if not OLLAMA_API_URL:
        logging.warning("NLP: Análise de sentimento pulada - OLLAMA_API_URL não configurado.")
        return "neutro"

    logging.info(f"NLP: [Trilha Emocional] Analisando sentimento para {telefone}: '{texto[:30]}...'")
    prompt_sentimento = f"""
    Analise o sentimento predominante na seguinte mensagem do usuário.
    Responda APENAS com uma das seguintes palavras: 'positivo', 'negativo', 'neutro'.

    Mensagem: "{texto}"

    Sentimento:"""
    try:
        resposta_txt, _, _ = await chamar_ollama(prompt_sentimento, telefone)
        if resposta_txt:
            sentimento_retornado = resposta_txt.strip().lower().replace(".", "")
            if sentimento_retornado in ["positivo", "negativo", "neutro"]:
                logging.info(f"NLP: Sentimento detectado pela IA para {telefone}: {sentimento_retornado}")
                return sentimento_retornado
            else:
                logging.warning(f"NLP: Sentimento retornado pela IA não reconhecido ('{sentimento_retornado}'). Usando 'neutro'.")
                return "neutro"
        else:
            logging.warning(f"NLP: IA não retornou resposta para análise de sentimento de {telefone}. Usando 'neutro'.")
            return "neutro"
    except Exception as e:
        logging.error(f"NLP: Erro ao chamar IA para análise de sentimento de {telefone}: {e}")
        return None

async def buscar_historico_formatado(telefone: str, limite: int = 5) -> str:
     """ Busca e formata o histórico recente do MongoDB para o prompt da IA. """
     if respostas_ia_db is None:
         logging.warning(f"NLP: Histórico indisponível para {telefone} (DB não conectado).")
         return "Histórico indisponível (DB não conectado)."
     logging.debug(f"NLP: Buscando histórico para {telefone} (limite: {limite})")
     try:
         historico_cursor = respostas_ia_db.find(
             {"telefone": telefone},
             {"mensagem_usuario": 1, "resposta_gerada": 1, "_id": 0}
         ).sort("criado_em", -1).limit(limite)
         historico_lista = list(historico_cursor)
         historico_lista.reverse()
         if not historico_lista:
             return "Nenhuma conversa anterior registrada."
         historico_formatado = ""
         for item in historico_lista:
             if msg_usr := item.get("mensagem_usuario"):
                 historico_formatado += f"Usuário: {msg_usr}\n"
             if msg_bot := item.get("resposta_gerada"):
                 if len(msg_bot) > 150:
                      msg_bot = msg_bot[:150] + "..."
                 historico_formatado += f"Assistente: {msg_bot}\n"
         return historico_formatado.strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao buscar histórico para {telefone}: {e}")
         return "Erro ao carregar histórico."

async def construir_prompt_para_ia(telefone: str, pergunta_atual: str, estado: str, meta_conversa: dict) -> str:
     """
     Constrói o prompt para o Ollama, incorporando estado, histórico e contexto emocional.
     Carrega o prompt mestre do arquivo PROMPT_MESTRE.txt.
     """
     historico_recente_formatado = await buscar_historico_formatado(telefone)
     sentimento_anterior = meta_conversa.get("ultimo_sentimento_detectado", None)
     prompt_mestre_path = os.path.join(BASE_DIR, "PROMPT_MESTRE.txt")
     try:
         with open(prompt_mestre_path, "r", encoding="utf-8") as f:
             PROMPT_MESTRE = f.read().strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao carregar prompt mestre de {prompt_mestre_path}: {e}. Usando prompt padrão.")
         PROMPT_MESTRE = """Você é Domo, um assistente virtual empático da FAMDOMES. Responda com clareza e empatia."""

     meta_filtrada = {
         k: v for k, v in meta_conversa.items()
         if k not in ['questionario_completo', 'historico_recente_formatado'] and not k.startswith('sentimento_q')
     }

     prompt_final = f"""{PROMPT_MESTRE}

     ---
     Contexto da Conversa Atual:
     Telefone: {telefone}
     Estado da Conversa: {estado}
     Sentimento Percebido na Última Interação: {sentimento_anterior or 'N/A'}
     Dados Conhecidos (meta_conversa): {json.dumps(meta_filtrada, indent=2, ensure_ascii=False, default=str)}
     ---
     Histórico Recente da Conversa:
     {historico_recente_formatado}
     ---
     Nova Mensagem do Usuário:
     {pergunta_atual.strip()}
     ---
     Instruções para sua Resposta OBRIGATÓRIAS:
     1. Analise a 'Nova Mensagem do Usuário' considerando o 'Contexto da Conversa Atual'.
     2. Responda em português brasileiro, de forma EMPÁTICA e ACOLHEDORA, especialmente se o sentimento detectado for negativo.
     3. Mantenha o foco nos serviços da FAMDOMES (consulta, tratamento de dependência química).
     4. Siga o fluxo indicado pelo 'Estado da Conversa'. Se for 'SUPORTE_FAQ', responda a dúvida. Se for 'AGUARDANDO_RESPOSTA_QUALIFICACAO', processe a resposta e siga para explicar a consulta ou responder dúvidas. Se for outro estado, guie o usuário para o próximo passo lógico.
     5. Use no máximo 400 caracteres na sua resposta textual.
     6. AO FINAL DA SUA RESPOSTA DE TEXTO, inclua OBRIGATORIAMENTE um JSON VÁLIDO contendo:
        - "intent": A intenção principal que você identificou na mensagem do usuário (ex: "duvida_preco", "confirmou_agendamento", "relato_sentimento", "pergunta_tratamento", "resposta_qualificacao", "desconhecida").
        - "sentimento_detectado": O sentimento predominante na mensagem do usuário (ex: "positivo", "negativo", "neutro", "ansioso", "esperançoso", "frustrado", "confuso").
        - "entidades": Um dicionário com quaisquer entidades relevantes extraídas (ex: {{"nome_paciente": "Carlos", "substancia": "álcool", "para_quem": "filho"}}). Se não houver, use {{}}.
     Exemplo de JSON OBRIGATÓRIO no final:
     ```json
     {{"intent": "duvida_preco", "sentimento_detectado": "ansioso", "entidades": {{}} }}
     ```
     Outro Exemplo:
     ```json
     {{"intent": "resposta_qualificacao", "sentimento_detectado": "negativo", "entidades": {{"para_quem": "filho"}} }}
     ```
     ---
     Assistente (responda aqui e adicione o JSON obrigatório no final):"""
     logging.info(f"NLP: Prompt construído para {telefone} (Estado: {estado}). Tamanho: {len(prompt_final)} chars.")
     return prompt_final

async def notificar_risco(telefone: str, mensagem: str, analise: dict):
    """ Envia notificação de risco para o número configurado. """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    alerta = f"⚠️ ALERTA DE RISCO ({timestamp}) ⚠️\n\nTelefone: {telefone}\nMensagem: \"{mensagem}\"\nAnálise: {analise}\n\nRevisão humana URGENTE necessária."
    logging.warning(f"NLP: Enviando alerta de risco para {WHATSAPP_FAMILIAR}...")
    if WHATSAPP_FAMILIAR:
        try:
            resultado_envio = await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)
            if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                 logging.info(f"NLP: ✅ Alerta de risco enviado com sucesso para {WHATSAPP_FAMILIAR}.")
            else:
                 logging.error(f"NLP: ❌ Falha ao enviar alerta de risco para {WHATSAPP_FAMILIAR}: {resultado_envio.get('erro', resultado_envio)}")
        except Exception as e:
            logging.error(f"NLP: ❌ Exceção ao tentar enviar alerta de risco: {e}")
    else:
        logging.warning("NLP: WHATSAPP_FAMILIAR não configurado. Não foi possível enviar alerta de risco.")

async def notificar_escalacao_humana(telefone: str, contexto: dict):
    """ Envia notificação para a equipe sobre pedido de atendente humano via RocketChat. """
    if not ROCKETCHAT_URL or not ROCKETCHAT_TOKEN or not ROCKETCHAT_USER_ID:
        logging.error("NLP: ❌ Configurações do RocketChat incompletas. Não é possível notificar a equipe.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    estado_anterior = contexto.get("estado", "N/A")
    nome_contato = contexto.get("meta_conversa", {}).get("nome_paciente", contexto.get("nome", "Desconhecido"))
    respostas_recentes = {k: v for k, v in contexto.get('meta_conversa', {}).items() if k.startswith('resposta_q')}
    contexto_resumido = json.dumps(respostas_recentes, indent=2, ensure_ascii=False, default=str)
    if len(contexto_resumido) > 1000:
        contexto_resumido = contexto_resumido[:1000] + "\n... (truncado)"

    mensagem_notificacao = (
        f"🙋 **Pedido de Atendimento Humano** ({timestamp}) 🙋\n\n"
        f"**Telefone:** {telefone}\n"
        f"**Nome Contato:** {nome_contato}\n"
        f"**Estado Anterior:** {estado_anterior}\n\n"
        f"**Últimas Respostas (Questionário/Meta):**\n"
        f"```json\n{contexto_resumido}\n```\n\n"
        f"Por favor, assumir a conversa."
    )
    logging.warning(f"NLP: 🙋 PEDIDO HUMANO ({timestamp}) - Telefone: {telefone} | Notificando equipe via RocketChat...")

    headers = {
        "X-Auth-Token": ROCKETCHAT_TOKEN,
        "X-User-Id": ROCKETCHAT_USER_ID,
        "Content-Type": "application/json"
    }
    room_id_destino = os.getenv("ROCKETCHAT_ROOM_ID_SUPORTE", "GENERAL")
    payload = {"message": {"rid": room_id_destino, "msg": mensagem_notificacao}}
    post_message_url = f"{ROCKETCHAT_URL}/api/v1/chat.postMessage"

    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            response = await client.post(post_message_url, headers=headers, json=payload)
            response.raise_for_status()
            resposta_api = response.json()
            if resposta_api.get("success"):
                logging.info(f"NLP: ✅ Notificação de escalação enviada com sucesso para RocketChat (Sala: {room_id_destino}).")
            else:
                logging.error(f"NLP: ❌ Falha ao enviar notificação para RocketChat (Sala: {room_id_destino}). Resposta API: {resposta_api}")
    except httpx.HTTPStatusError as e:
        logging.error(f"NLP: ❌ Erro HTTP {e.response.status_code} ao enviar para RocketChat: {e.response.text}")
    except httpx.RequestError as e:
        logging.error(f"NLP: ❌ Erro de conexão ao enviar para RocketChat: {e}")
    except Exception as e:
        logging.exception("NLP: ❌ Erro inesperado ao enviar notificação para RocketChat:")


# --- Função Principal de Processamento ---

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    """
    Processa a mensagem do usuário com base no estado atual da conversa,
    realiza análise de sentimento/risco, atualiza o estado e retorna a resposta.
    """
    global meta_conversa
    logging.info(f"NLP: 🔄 Processando mensagem de {telefone}...")
    contexto = obter_contexto(telefone)
    estado_atual = contexto.get("estado", "INICIAL")
    meta_conversa = contexto.get("meta_conversa", {})
    texto_mensagem = mensagem.strip()
    texto_lower = texto_mensagem.lower()

    if not isinstance(meta_conversa, dict):
        logging.warning(f"NLP: Meta conversa para {telefone} não era um dicionário. Resetando para {{}}.")
        meta_conversa = {}

    logging.info(f"NLP: 📞 Telefone: {telefone} | Estado Atual: {estado_atual} | Mensagem: '{texto_mensagem[:50]}...'")

    # --- 1. Análise de Risco ---
    analise_risco_resultado = analisar_risco(texto_mensagem)
    risco_detectado = analise_risco_resultado.get("risco_vida") or analise_risco_resultado.get("urgencia_medica")

    if risco_detectado:
        logging.warning(f"NLP: 🚨 RISCO DETECTADO para {telefone}! Análise: {analise_risco_resultado}")
        novo_estado = "RISCO_DETECTADO"
        resposta_final = MENSAGEM_RISCO_DIRECIONAMENTO
        meta_conversa["ultimo_risco"] = datetime.utcnow().isoformat()
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "risco_detectado", meta_conversa, True, None)
        await notificar_risco(telefone, texto_mensagem, analise_risco_resultado)
        return {"resposta": resposta_final, "estado": novo_estado}

    # --- 2. Verificação de Comandos Especiais ---
    if texto_lower == "melancia vermelha":
        logging.info(f"NLP: Comando 'melancia vermelha' recebido de {telefone}. Resetando contexto.")
        limpar_contexto(telefone)
        resposta_final = MENSAGEM_INICIAL # Envia apenas a saudação inicial após reset
        novo_estado = "IDENTIFICANDO_NECESSIDADE" # Espera a primeira resposta do usuário
        intent = "reset_comando_e_inicio"
        meta_conversa = {}
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": {}})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, {}, False, None)
        return {"resposta": resposta_final, "estado": novo_estado}

    if any(palavra in texto_lower for palavra in PALAVRAS_CHAVE_HUMANO):
         logging.info(f"NLP: Pedido de atendente humano detectado para {telefone}.")
         estado_antes_pedido = estado_atual
         novo_estado = "AGUARDANDO_ATENDENTE"
         resposta_final = MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO
         contexto_para_notificacao = contexto.copy()
         contexto_para_notificacao["estado"] = estado_antes_pedido
         salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
         salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "pedido_humano", meta_conversa, False, None)
         await notificar_escalacao_humana(telefone, contexto_para_notificacao)
         return {"resposta": resposta_final, "estado": novo_estado}

    # --- 3. Lógica Baseada no Estado Atual ---
    resposta_final = MENSAGEM_ERRO_PADRAO
    novo_estado = estado_atual
    intent = "desconhecida"
    entidades = {}
    sentimento = await analisar_sentimento(texto_mensagem, telefone)
    if meta_conversa is not None:
        meta_conversa["ultimo_sentimento_detectado"] = sentimento
    else:
        meta_conversa = {"ultimo_sentimento_detectado": sentimento}

    try:
        # Lógica para estado INICIAL (Bot acabou de enviar a saudação)
        # Não deveria receber mensagem do usuário neste estado, mas por segurança:
        if estado_atual == "INICIAL":
            logging.warning(f"NLP: Mensagem recebida no estado INICIAL de {telefone}. Tratando como IDENTIFICANDO_NECESSIDADE.")
            estado_atual = "IDENTIFICANDO_NECESSIDADE" # Força a transição

        # Lógica para IDENTIFICANDO_NECESSIDADE (Usuário respondeu à saudação inicial)
        if estado_atual == "IDENTIFICANDO_NECESSIDADE":
            # Validação simples (pode ser melhorada com IA se necessário)
            validacao = "Entendi. " # Validação genérica inicial
            if sentimento == "negativo":
                validacao = "Sinto muito que esteja se sentindo assim. "
            elif sentimento == "positivo":
                 validacao = "Que bom ouvir isso. "

            # Constrói a pergunta combinada
            resposta_final = validacao + PERGUNTA_COMBINADA_TEMPLATE
            novo_estado = "AGUARDANDO_RESPOSTA_QUALIFICACAO"
            intent = "primeira_resposta_usuario" # Intent da mensagem recebida (pode ser refinado)

        # Lógica para AGUARDANDO_RESPOSTA_QUALIFICACAO (Usuário respondeu à pergunta combinada)
        elif estado_atual == "AGUARDANDO_RESPOSTA_QUALIFICACAO":
            logging.info(f"NLP: Processando resposta de qualificação de {telefone}.")
            meta_conversa["sentimento_resposta_qualificacao"] = sentimento
            # Tenta extrair para quem é a ajuda usando IA ou regras simples
            # Exemplo com regras simples (melhorar com IA/extração de entidades no prompt)
            para_quem = "desconhecido"
            if "filho" in texto_lower or "filha" in texto_lower:
                para_quem = "filho(a)"
            elif "esposo" in texto_lower or "marido" in texto_lower:
                para_quem = "esposo"
            elif "esposa" in texto_lower or "mulher" in texto_lower:
                 para_quem = "esposa"
            elif "irmão" in texto_lower or "irma" in texto_lower:
                 para_quem = "irmao(a)"
            elif "amigo" in texto_lower or "amiga" in texto_lower:
                 para_quem = "amigo(a)"
            elif "para mim" in texto_lower or "eu mesmo" in texto_lower or "pra mim" in texto_lower:
                 para_quem = "proprio_usuario"
            meta_conversa["para_quem"] = para_quem
            entidades["para_quem"] = para_quem # Salva entidade específica desta interação

            # Validação da resposta emocional
            agradecimento = "Obrigado por compartilhar." if sentimento != "negativo" else "Agradeço a confiança em compartilhar."

            # Decide o próximo passo
            # Se perguntou preço especificamente, responde primeiro
            if "preço" in texto_lower or "valor" in texto_lower or "custo" in texto_lower:
                 resposta_final = f"{agradecimento} A consulta inicial online tem o valor de R$100. Ela é importante para avaliar o caso e definir o melhor caminho. Gostaria que eu explicasse mais sobre como ela funciona?"
                 novo_estado = "SUPORTE_FAQ" # Fica em suporte após responder preço
                 intent = "resposta_qualificacao_com_preco"
            else:
                 # Se não pediu preço, explica a consulta
                 if para_quem != "desconhecido" and para_quem != "proprio_usuario":
                      resposta_final = f"{agradecimento} Entendi que a busca é para {para_quem}. Para esses casos, o primeiro passo recomendado é a nossa consulta inicial online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 else: # Se for para o próprio usuário ou desconhecido
                      resposta_final = f"{agradecimento} Sabendo que a ajuda é para você (ou se ainda não tiver certeza, a consulta ajuda a definir), o caminho inicial que oferecemos é a consulta de avaliação online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 novo_estado = "EXPLICANDO_CONSULTA"
                 intent = "resposta_qualificacao_segue_fluxo"


        # Lógica para EXPLICANDO_CONSULTA (Usuário respondeu à explicação da consulta)
        elif estado_atual == "EXPLICANDO_CONSULTA":
             if texto_lower in RESPOSTAS_AFIRMATIVAS:
                 logging.info(f"NLP: Usuário {telefone} confirmou interesse em agendar.")
                 meta_conversa["sentimento_confirmacao_agendamento"] = sentimento
                 try:
                     nome_cliente = contexto.get("nome", meta_conversa.get("nome_paciente", "Cliente"))
                     resultado_comando = await processar_comando({
                         "telefone": telefone,
                         "nome": nome_cliente,
                         "comando": "quero agendar"
                     })
                     resposta_final = resultado_comando.get("mensagem", "Link para pagamento enviado!")
                     if resultado_comando.get("status") == "link_gerado":
                          novo_estado = "AGUARDANDO_PAGAMENTO"
                          intent = "confirmou_agendamento"
                     else:
                          resposta_final = resultado_comando.get("mensagem", MENSAGEM_ERRO_PADRAO)
                          novo_estado = "EXPLICANDO_CONSULTA"
                          intent = "erro_gerar_link"
                 except Exception as e:
                     logging.error(f"NLP: Erro ao processar comando 'quero agendar' para {telefone}: {e}")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     novo_estado = "EXPLICANDO_CONSULTA"
                     intent = "erro_processar_comando"

             elif texto_lower in RESPOSTAS_NEGATIVAS:
                 logging.info(f"NLP: Usuário {telefone} recusou o agendamento por enquanto.")
                 meta_conversa["sentimento_recusa_agendamento"] = sentimento
                 resposta_final = "Entendido. Sem problemas. Se mudar de ideia ou tiver mais alguma dúvida, estou à disposição!"
                 novo_estado = "SUPORTE_FAQ"
                 intent = "recusou_agendamento"
             else:
                 logging.info(f"NLP: Resposta não conclusiva em EXPLICANDO_CONSULTA para {telefone}. Usando IA.")
                 novo_estado = "SUPORTE_FAQ"
                 # IA será chamada no fallback

        # Lógica para AGUARDANDO_PAGAMENTO
        elif estado_atual == "AGUARDANDO_PAGAMENTO":
             logging.info(f"NLP: Mensagem recebida de {telefone} enquanto aguarda pagamento. Encaminhando para IA.")
             resposta_final = "Recebi sua mensagem enquanto aguardo a confirmação do pagamento. Se tiver alguma dúvida sobre o processo ou outra questão, pode perguntar."
             novo_estado = "SUPORTE_FAQ"
             # IA será chamada no fallback

        # Lógica para CONFIRMANDO_AGENDAMENTO
        elif estado_atual == "CONFIRMANDO_AGENDAMENTO":
             logging.info(f"NLP: Iniciando questionário pós-pagamento para {telefone}")
             meta_conversa["questionario_completo"] = QUESTIONARIO_COMPLETO_POS_PAGAMENTO
             meta_conversa["num_pergunta_atual"] = 0
             if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 proxima_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta_final = proxima_pergunta
                 novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                 intent = "iniciou_questionario"
                 salvar_contexto(telefone, {
                     "estado": novo_estado,
                     "meta_conversa": meta_conversa,
                     "ultima_resposta_bot": resposta_final
                 })
                 salvar_resposta_ia(telefone, canal, "Sistema: Iniciou Questionário", resposta_final, intent, meta_conversa, False, None)
                 return {"resposta": resposta_final, "estado": novo_estado}
             else:
                 logging.warning(f"NLP: Questionário pós-pagamento vazio para {telefone}. Finalizando onboarding.")
                 resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                 novo_estado = "FINALIZANDO_ONBOARDING"
                 intent = "questionario_vazio"


        # Lógica para COLETANDO_RESPOSTA_QUESTIONARIO
        elif estado_atual == "COLETANDO_RESPOSTA_QUESTIONARIO":
             num_pergunta_respondida_idx = meta_conversa.get("num_pergunta_atual", 0)
             perguntas_questionario = meta_conversa.get("questionario_completo", [])

             if not isinstance(perguntas_questionario, list):
                 logging.error(f"NLP: Erro: 'questionario_completo' não é uma lista no contexto de {telefone}")
                 perguntas_questionario = []

             if num_pergunta_respondida_idx < len(perguntas_questionario):
                 pergunta_respondida_texto = perguntas_questionario[num_pergunta_respondida_idx]
                 chave_resposta = f"resposta_q{num_pergunta_respondida_idx+1}"
                 chave_sentimento = f"sentimento_q{num_pergunta_respondida_idx+1}"
                 meta_conversa[chave_resposta] = texto_mensagem
                 meta_conversa[chave_sentimento] = sentimento
                 logging.info(f"NLP: Resposta Q{num_pergunta_respondida_idx+1} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}. Sentimento: {sentimento}")

                 num_proxima_pergunta_idx = num_pergunta_respondida_idx + 1
                 meta_conversa["num_pergunta_atual"] = num_proxima_pergunta_idx

                 if num_proxima_pergunta_idx < len(perguntas_questionario):
                     proxima_pergunta_texto = perguntas_questionario[num_proxima_pergunta_idx]
                     resposta_final = proxima_pergunta_texto
                     novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                     intent = f"respondeu_questionario_{num_pergunta_respondida_idx+1}"
                 else:
                     resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                     novo_estado = "FINALIZANDO_ONBOARDING"
                     intent = "finalizou_questionario"
                     meta_conversa.pop("num_pergunta_atual", None)
                     meta_conversa.pop("questionario_completo", None)
                     logging.info(f"NLP: Questionário finalizado para {telefone}.")
             else:
                 logging.error(f"NLP: Erro de lógica no questionário para {telefone}. Estado: {estado_atual}, Contador: {num_pergunta_respondida_idx}, Total Perguntas: {len(perguntas_questionario)}")
                 resposta_final = MENSAGEM_ERRO_PADRAO
                 novo_estado = "SUPORTE_FAQ"
                 intent = "erro_logica_questionario"


        # --- 4. Fallback com IA ---
        if novo_estado == estado_atual and estado_atual not in ["RISCO_DETECTADO", "AGUARDANDO_ATENDENTE", "FINALIZANDO_ONBOARDING", "CONFIRMANDO_AGENDAMENTO"]:
            logging.info(f"NLP: Nenhuma regra específica tratou a mensagem de {telefone} no estado {estado_atual}. Usando IA como fallback.")

            faq_key_norm = texto_lower.replace("?", "").replace(".", "").replace("!", "").strip()
            matched_faq_key = None
            if faq_key_norm in FAQ_RESPOSTAS:
                matched_faq_key = faq_key_norm
            else:
                for key in FAQ_RESPOSTAS:
                    if key in faq_key_norm:
                        matched_faq_key = key
                        break

            if matched_faq_key:
                 logging.info(f"NLP: Respondendo com FAQ para chave: {matched_faq_key}")
                 resposta_final = FAQ_RESPOSTAS[matched_faq_key]
                 novo_estado = "SUPORTE_FAQ"
                 intent = f"faq_{matched_faq_key.replace(' ', '_')}"
            else:
                 if not OLLAMA_API_URL:
                     logging.error("NLP: ❌ Fallback para IA falhou - OLLAMA_API_URL não configurado.")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     intent = "erro_config_ia"
                     novo_estado = "SUPORTE_FAQ"
                 else:
                     logging.info(f"NLP: Chamando Ollama para {telefone}...")
                     prompt = await construir_prompt_para_ia(telefone, texto_mensagem, estado_atual, meta_conversa)
                     resposta_textual_ia, json_extraido_ia, tokens_ollama = await chamar_ollama(prompt, telefone)

                     if resposta_textual_ia is None or "⚠️" in resposta_textual_ia:
                         resposta_final = resposta_textual_ia or MENSAGEM_ERRO_IA
                         intent = "erro_ia_fallback"
                         novo_estado = "SUPORTE_FAQ"
                     else:
                         resposta_final = resposta_textual_ia

                         if json_extraido_ia and isinstance(json_extraido_ia, dict):
                             logging.info(f"NLP: JSON extraído da IA: {json_extraido_ia}")
                             intent = json_extraido_ia.get("intent", "ia_generica")
                             entidades_ia = json_extraido_ia.get("entidades", {})
                             if isinstance(entidades_ia, dict):
                                  meta_conversa = atualizar_meta_conversa(meta_conversa, entidades_ia)
                                  entidades = entidades_ia
                             else:
                                  logging.warning(f"NLP: Entidades retornadas pela IA não são um dicionário: {entidades_ia}")

                             sentimento_ia = json_extraido_ia.get("sentimento_detectado")
                             if sentimento_ia and isinstance(sentimento_ia, str):
                                  sentimento = sentimento_ia
                                  meta_conversa["ultimo_sentimento_detectado"] = sentimento
                             else:
                                  logging.warning(f"NLP: Sentimento retornado pela IA inválido ou ausente: {sentimento_ia}. Usando sentimento analisado anteriormente: {sentimento}")
                         else:
                              logging.warning("NLP: ⚠️ IA não retornou JSON reconhecível no final da resposta.")
                              intent = "ia_generica_sem_json"

                         novo_estado = "SUPORTE_FAQ"

    except Exception as e:
        logging.exception(f"NLP: ❌ ERRO INESPERADO durante processamento da mensagem para {telefone}:")
        resposta_final = MENSAGEM_ERRO_PADRAO
        intent = "erro_processamento_geral"
        novo_estado = estado_atual

    # --- 5. Atualizar Contexto e Salvar Histórico ---
    meta_conversa_final = meta_conversa if isinstance(meta_conversa, dict) else {}
    contexto_para_salvar = {
        "estado": novo_estado,
        "ultima_resposta_bot": resposta_final,
        "meta_conversa": meta_conversa_final
    }

    salvar_contexto(telefone, contexto_para_salvar)
    salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, entidades, risco_detectado, sentimento)

    logging.info(f"NLP: ✅ Processamento concluído para {telefone}. Novo estado: {novo_estado}. Resposta: '{resposta_final[:50]}...'")
    return {"resposta": resposta_final, "estado": novo_estado}


# Arquivo: ./utils/risco.py
# ===========================================================
# Arquivo: utils/risco.py
# ===========================================================
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Listas de Palavras-Chave para Detecção de Risco ---

# Lista de palavras/frases críticas indicando risco de vida (suicídio, automutilação)
# ATENÇÃO: Esta lista é um ponto de partida e deve ser refinada com cuidado.
PALAVRAS_CRITICAS_VIDA = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    "me cortar", "me machucar", "automutilação", "tirar minha vida", "fim da linha",
    "não vejo saída", "desistir de tudo"
]

# Lista de palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, sintomas graves)
PALAVRAS_URGENCIA_MEDICA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno", "infarto", "avc",
    "muita dor", "sem ar", "falta de ar", "alucinação grave", "delírio intenso",
    "tomou muito remédio", "ingeriu substância"
]

# --- Função de Análise de Risco ---

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (risco de vida, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.

    Args:
        texto (str): O texto da mensagem do usuário a ser analisada.

    Returns:
        dict: Dicionário contendo:
            - 'risco_vida' (bool): True se detectar palavras críticas de risco de vida.
            - 'urgencia_medica' (bool): True se detectar palavras de urgência médica.
    """
    # Retorna False para ambos se o texto for vazio ou nulo
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    # Converte o texto para minúsculas para comparação case-insensitive
    texto_lower = texto.lower()

    # Verifica se alguma palavra/frase da lista de risco de vida está presente no texto
    # Usar busca de substring para pegar variações (ex: "quero me matar agora")
    risco_vida_detectado = any(palavra in texto_lower for palavra in PALAVRAS_CRITICAS_VIDA)

    # Verifica se alguma palavra/frase da lista de urgência médica está presente no texto
    urgencia_medica_detectada = any(palavra in texto_lower for palavra in PALAVRAS_URGENCIA_MEDICA)

    # Loga um aviso se algum risco for detectado (o log principal será feito em nlp.py)
    # if risco_vida_detectado:
    #     logging.debug(f"RISCO: Risco de vida potencialmente detectado em '{texto[:50]}...'")
    # if urgencia_medica_detectada:
    #     logging.debug(f"RISCO: Urgência médica potencialmente detectada em '{texto[:50]}...'")

    # Retorna o dicionário com os resultados da análise
    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }

# Arquivo: ./utils/agenda.py
# ===========================================================
# Arquivo: utils/agenda.py
# (Implementação das funções de agendamento com DB)
# ===========================================================
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure, DuplicateKeyError
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
import logging
import pytz # Para lidar com fusos horários corretamente

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes de Configuração da Agenda ---
DURACAO_CONSULTA_MINUTOS = 20 # Duração de cada bloco de consulta
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # Horário de início das consultas (9:00)
HORARIO_OPERACAO_FIM = 18  # Horário de fim (não agenda às 18:00, último bloco começa antes)
DIAS_UTEIS = [0, 1, 2, 3, 4] # 0=Segunda, 1=Terça, ..., 4=Sexta
FUSO_HORARIO_LOCAL = 'America/Sao_Paulo' # Fuso horário de operação

# --- Conexão com MongoDB ---
mongo_agenda = None
db_agenda = None
consultas_db = None

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_agenda = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_agenda.server_info() # Testa a conexão
        db_agenda = mongo_agenda["famdomes"] # Nome do banco de dados
        consultas_db = db_agenda["consultas_agendadas"] # Coleção para agendamentos
        # Cria índice único para garantir que não haja duas consultas no mesmo horário (UTC)
        consultas_db.create_index("horario_utc", unique=True)
        consultas_db.create_index("telefone") # Índice para busca por telefone
        consultas_db.create_index([("status", 1), ("horario_utc", 1)]) # Índice composto
        logging.info("AGENDA: Conexão com MongoDB estabelecida e índices verificados/criados.")
    else:
        logging.error("AGENDA: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"AGENDA: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"AGENDA: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_agenda = None
    db_agenda = None
    consultas_db = None

# --- Funções Auxiliares ---

def _proximo_horario_util(inicio_base_utc: datetime) -> datetime:
    """
    Avança o horário UTC para o próximo bloco de X minutos disponível
    dentro do horário de operação e dias úteis definidos.
    """
    horario_utc = inicio_base_utc.replace(tzinfo=timezone.utc) # Garante que está ciente do fuso UTC
    tz_local = pytz.timezone(FUSO_HORARIO_LOCAL)

    while True:
        # Arredonda para o início do próximo bloco de N minutos (para cima)
        minutos_atuais = horario_utc.minute
        minutos_para_proximo_bloco = (DURACAO_CONSULTA_MINUTOS - (minutos_atuais % DURACAO_CONSULTA_MINUTOS)) % DURACAO_CONSULTA_MINUTOS
        if minutos_para_proximo_bloco == 0 and (horario_utc.second > 0 or horario_utc.microsecond > 0):
            # Se já está no início do bloco mas tem segundos, avança um bloco inteiro
             horario_utc += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        elif minutos_para_proximo_bloco > 0 :
            # Avança para o início do próximo bloco
            horario_utc += timedelta(minutes=minutos_para_proximo_bloco)

        # Zera segundos e microssegundos
        horario_utc = horario_utc.replace(second=0, microsecond=0)

        # Converte para o fuso local para verificar horário de operação e dia da semana
        horario_local = horario_utc.astimezone(tz_local)

        # Verifica se está dentro do horário de operação
        if horario_local.hour < HORARIO_OPERACAO_INICIO:
            # Se for antes do início, ajusta para o início do dia no fuso local e converte de volta para UTC
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        if horario_local.hour >= HORARIO_OPERACAO_FIM:
            # Se for depois do fim, avança para o dia seguinte e ajusta para o início
            horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Verifica se é dia útil (no fuso local)
        if horario_local.weekday() not in DIAS_UTEIS:
            # Se não for dia útil, avança para o próximo dia e ajusta para o início
            # Loop para garantir que caia em um dia útil
            while horario_local.weekday() not in DIAS_UTEIS:
                 horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Se passou por todas as verificações, o horário é válido
        return horario_utc

def formatar_horario_local(horario_utc: datetime | None, fuso_destino: str = FUSO_HORARIO_LOCAL) -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc or not isinstance(horario_utc, datetime):
        return "Indisponível"
    try:
        # Garante que o datetime de entrada está ciente do fuso (UTC)
        if horario_utc.tzinfo is None:
            horario_utc = pytz.utc.localize(horario_utc)

        tz_destino = pytz.timezone(fuso_destino)
        horario_local = horario_utc.astimezone(tz_destino)
        # Formato: DD/MM/AAAA HH:MM (ex: 05/08/2025 14:30)
        return horario_local.strftime("%d/%m/%Y %H:%M")
    except ImportError:
        logging.warning("AGENDA: Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m/%Y %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"AGENDA: Erro ao formatar horário {horario_utc} para fuso {fuso_destino}: {e}")
        return "Erro na formatação"

# --- Funções Principais da Agenda ---

def agendar_consulta(telefone: str, nome: str, email: str | None = None) -> datetime | None:
    """
    Encontra o próximo horário livre e tenta agendar a consulta.
    Retorna o datetime UTC do horário agendado ou None se não conseguir.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento e lógica interna
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        # Encontra o próximo bloco de horário válido (dia útil, horário de operação)
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Tenta inserir o agendamento no horário encontrado
        consulta_doc = {
            "telefone": telefone,
            "nome": nome,
            "email": email,
            "horario_utc": horario_tentativa_utc, # Armazena em UTC
            "status": "agendado", # Status inicial
            "criado_em": agora_utc
        }
        try:
            # Tenta inserir o documento. Se o horário já estiver ocupado,
            # o índice único ("horario_utc") causará um DuplicateKeyError.
            result = consultas_db.insert_one(consulta_doc)
            if result.inserted_id:
                horario_formatado = formatar_horario_local(horario_tentativa_utc)
                logging.info(f"AGENDA: ✅ Consulta marcada para {nome} ({telefone}) em {horario_formatado} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Caso improvável de falha na inserção sem exceção
                logging.error(f"AGENDA: ❌ Falha desconhecida ao inserir agendamento para {horario_tentativa_utc}.")
                return None

        except DuplicateKeyError:
            # Horário ocupado, avança a procura para depois deste bloco
            logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado. Tentando próximo.")
            inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min para recalcular próximo bloco
            continue # Tenta o próximo horário

        except Exception as e:
            # Outro erro durante a inserção
            logging.error(f"AGENDA: ❌ ERRO ao tentar inserir agendamento para {horario_tentativa_utc}: {e}")
            return None # Falha no agendamento

    # Se o loop terminar sem encontrar horário
    logging.warning(f"AGENDA: ⚠️ Não foram encontrados horários disponíveis para {telefone} ({nome}) após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def cancelar_consulta(telefone: str) -> int:
    """
    Cancela todas as consultas futuras com status 'agendado' para um telefone.
    Retorna o número de consultas canceladas.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Filtro para encontrar consultas futuras e agendadas do telefone
        filtro = {
            "telefone": telefone,
            "horario_utc": {"$gt": agora_utc}, # Apenas horários futuros
            "status": "agendado" # Apenas consultas que ainda estão agendadas
        }
        # Atualiza o status para 'cancelado_usuario' em vez de deletar (mantém histórico)
        resultado = consultas_db.update_many(
            filtro,
            {"$set": {"status": "cancelado_usuario", "cancelado_em": agora_utc}}
        )

        canceladas = resultado.modified_count
        if canceladas > 0:
            logging.info(f"AGENDA: 🗑️ Cancelada(s) {canceladas} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"AGENDA: Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return canceladas
    except Exception as e:
        logging.error(f"AGENDA: ❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """
    Consulta o próximo horário disponível sem agendar.
    Retorna o datetime UTC do horário ou None se não encontrar/erro.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar um pouco à frente
    inicio_procura_utc = agora_utc + timedelta(minutes=5) # Pequena margem

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            # Verifica se existe alguma consulta agendada ou confirmada para este horário
            filtro_conflito = {
                "horario_utc": horario_tentativa_utc,
                "status": {"$in": ["agendado", "confirmado"]} # Considera ambos como ocupados
            }
            conflito = consultas_db.find_one(filtro_conflito)
            if not conflito:
                # Encontrou horário livre
                logging.info(f"AGENDA: Próximo horário disponível encontrado: {formatar_horario_local(horario_tentativa_utc)} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado (Status: {conflito.get('status')}). Tentando próximo.")
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min
                continue
        except Exception as e:
            logging.error(f"AGENDA: ❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro na consulta

    # Se o loop terminar
    logging.warning(f"AGENDA: ⚠️ Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

# Arquivo: ./utils/leads.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )

# Arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Arquivo: ./utils/followup.py
# ===========================================================
# Arquivo: utils/followup.py
# (Implementação das funções de acompanhamento de pagamento)
# ===========================================================
from datetime import datetime, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
# Importa a função de agendamento para ser chamada após o pagamento
# Ajuste o import se agenda.py estiver em um diretório diferente
from app.utils.agenda import agendar_consulta, formatar_horario_local
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Conexão com MongoDB ---
mongo_followup = None
db_followup = None
pagamentos_db = None # Coleção para rastrear status de pagamento

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_followup = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_followup.server_info() # Testa a conexão
        db_followup = mongo_followup["famdomes"] # Nome do banco de dados
        pagamentos_db = db_followup["pagamentos"] # Coleção para pagamentos
        # Cria índices se não existirem
        pagamentos_db.create_index("telefone")
        pagamentos_db.create_index("id_sessao_stripe", sparse=True, unique=True) # ID da sessão deve ser único
        pagamentos_db.create_index("status")
        pagamentos_db.create_index("criado_em")
        logging.info("FOLLOWUP: Conexão com MongoDB estabelecida para Pagamentos.")
    else:
        logging.error("FOLLOWUP: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"FOLLOWUP: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"FOLLOWUP: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_followup = None
    db_followup = None
    pagamentos_db = None

# --- Funções de Follow-up ---

def iniciar_sessao(telefone: str, nome: str, id_sessao_stripe: str | None = None):
    """
    Registra o início de uma tentativa de pagamento no banco de dados.
    Chamado quando o link de pagamento é gerado. Usa update_one com upsert=True
    para criar ou atualizar o registro baseado no id_sessao_stripe, se fornecido.

    Args:
        telefone (str): Telefone do usuário.
        nome (str): Nome do usuário.
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao iniciar sessão: DB indisponível.")
        return

    try:
        agora = datetime.now(timezone.utc)
        # Filtro: usa id_sessao_stripe se disponível, senão cria um novo (ou atualiza baseado em telefone?)
        # É mais seguro basear no id_sessao_stripe para evitar sobrescrever sessões ativas
        filtro = {"id_sessao_stripe": id_sessao_stripe} if id_sessao_stripe else {"telefone": telefone, "status": "link_gerado"} # Se sem ID, atualiza último link gerado

        update_data = {
            "$set": {
                "telefone": telefone,
                "nome": nome,
                "status": "link_gerado", # Garante o status correto
                "ultima_atualizacao": agora
            },
            "$setOnInsert": { # Define apenas na criação
                 "id_sessao_stripe": id_sessao_stripe, # Só define ID na criação se filtro não o usou
                 "criado_em": agora
            }
        }
        # Se o filtro usou id_sessao_stripe, garante que ele seja definido no $set também
        if id_sessao_stripe:
            update_data["$set"]["id_sessao_stripe"] = id_sessao_stripe


        result = pagamentos_db.update_one(filtro, update_data, upsert=True)

        if result.upserted_id:
            logging.info(f"FOLLOWUP: 📍 Nova sessão de pagamento iniciada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        elif result.modified_count > 0:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento atualizada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        else:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento para {telefone} ({nome}) não modificada (Sessão: {id_sessao_stripe or 'N/A'}).")

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO ao iniciar/atualizar sessão de pagamento para {telefone}:")

def marcar_pagamento(
    telefone: str | None = None,
    id_sessao_stripe: str | None = None,
    email_cliente: str | None = None,
    nome_cliente: str | None = None
) -> tuple[datetime | None, str | None]:
    """
    Marca um pagamento como concluído no banco de dados e tenta agendar a consulta.
    Chamado pelo webhook do Stripe após 'checkout.session.completed'.

    Args:
        telefone (str | None): Telefone do usuário (vindo dos metadados do Stripe).
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
        email_cliente (str | None): Email do cliente (vindo da sessão Stripe).
        nome_cliente (str | None): Nome do cliente (vindo da sessão Stripe ou metadados).

    Returns:
        tuple[datetime | None, str | None]:
            - horario_agendado_utc: O horário UTC da consulta agendada, ou None se falhar.
            - nome_final: O nome usado para o agendamento.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: DB indisponível.")
        return None, None

    # Precisa do id_sessao para garantir que estamos atualizando o pagamento correto
    if not id_sessao_stripe:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: ID da sessão Stripe ausente.")
        # Poderia tentar buscar por telefone, mas é arriscado se houver links antigos
        return None, None

    # Monta o filtro para encontrar o registro da sessão de pagamento pelo ID
    filtro = {"id_sessao_stripe": id_sessao_stripe}

    try:
        agora_utc = datetime.now(timezone.utc)
        # Dados para atualizar o registro
        update_data = {
            "$set": {
                "status": "pago", # Marca como pago
                "pago_em": agora_utc,
                "ultima_atualizacao": agora_utc,
                "email_stripe": email_cliente,
                # Atualiza telefone e nome se vieram do Stripe (podem ter sido preenchidos lá)
                "telefone": telefone if telefone else "$telefone", # Mantém o original se não veio
                "nome": nome_cliente if nome_cliente else "$nome" # Mantém o original se não veio
            }
        }

        # Encontra e atualiza o registro do pagamento
        # Retorna o documento APÓS a atualização para pegar os dados mais recentes
        pagamento_atualizado = pagamentos_db.find_one_and_update(
            filtro,
            update_data,
            return_document=ReturnDocument.AFTER # Pega o documento atualizado
        )

        if pagamento_atualizado:
            logging.info(f"FOLLOWUP: 💰 Pagamento confirmado para sessão {id_sessao_stripe} (Telefone: {pagamento_atualizado.get('telefone')}).")
            # Usa os dados atualizados para agendar
            tel_para_agendar = pagamento_atualizado.get('telefone')
            nome_para_agendar = pagamento_atualizado.get('nome', 'Cliente')
            email_para_agendar = pagamento_atualizado.get('email_stripe') # Usa o email do Stripe

            # Verifica se temos telefone para agendar
            if not tel_para_agendar:
                 logging.error(f"FOLLOWUP: ❌ Telefone ausente no registro de pagamento {id_sessao_stripe} após atualização. Não é possível agendar.")
                 return None, nome_para_agendar # Retorna nome para possível notificação

            # --- Tenta Agendar a Consulta ---
            logging.info(f"FOLLOWUP: Tentando agendar consulta para {nome_para_agendar} ({tel_para_agendar})...")
            horario_agendado_utc = agendar_consulta(
                telefone=tel_para_agendar,
                nome=nome_para_agendar,
                email=email_para_agendar
            )

            if horario_agendado_utc:
                logging.info(f"FOLLOWUP: ✅ Consulta agendada com sucesso para {tel_para_agendar} em {formatar_horario_local(horario_agendado_utc)}.")
                # Salva o horário agendado no registro de pagamento
                pagamentos_db.update_one(
                    {"_id": pagamento_atualizado["_id"]},
                    {"$set": {"horario_consulta_agendada_utc": horario_agendado_utc, "status": "agendado"}} # Atualiza status final
                )
                return horario_agendado_utc, nome_para_agendar
            else:
                logging.error(f"FOLLOWUP: ❌ Falha ao agendar consulta para {tel_para_agendar} após pagamento.")
                # O pagamento foi marcado, mas o agendamento falhou. Requer atenção manual.
                pagamentos_db.update_one(
                     {"_id": pagamento_atualizado["_id"]},
                     {"$set": {"status": "pago_erro_agendamento"}} # Marca status especial
                )
                return None, nome_para_agendar # Retorna None para horário, mas nome para possível notificação
        else:
            logging.warning(f"FOLLOWUP: ⚠️ Nenhum registro de pagamento encontrado para ID Sessão Stripe: {id_sessao_stripe}. Pagamento pode já ter sido processado ou ID inválido.")
            return None, None

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO CRÍTICO ao marcar pagamento/agendar para ID Sessão {id_sessao_stripe}:")
        return None, None

# TODO: Adicionar função para checar follow-ups (ex: pagamentos com link_gerado > X horas) se necessário.
# async def checar_followups(): ...


# Arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Arquivo: ./routes/resetar.py
from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone é obrigatório.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")

# Arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from app.utils.nlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado

# Arquivo: ./routes/stripe.py
# ===========================================================
# Arquivo: routes/stripe.py
# (Implementação do webhook do Stripe)
# ===========================================================
from fastapi import APIRouter, Request, Header, HTTPException, BackgroundTasks
import stripe # Importa a biblioteca do Stripe
import logging

# Ajuste os imports conforme a estrutura do seu projeto
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
# Importa funções de followup e agenda
from app.utils.followup import marcar_pagamento
from app.utils.agenda import formatar_horario_local
# Importa função para salvar contexto e enviar mensagem
from app.utils.contexto import salvar_contexto
from app.utils.mensageria import enviar_mensagem

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/webhook", tags=["Stripe"]) # Adiciona prefixo e tag

# Define a chave secreta do Stripe (carregada da configuração)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("STRIPE Route: Chave secreta do Stripe configurada.")
else:
    logging.error("STRIPE Route: ❌ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada. Webhook não funcionará.")
    # A aplicação pode iniciar, mas o webhook falhará

@router.post("/stripe/", summary="Recebe eventos do webhook do Stripe")
async def stripe_webhook(request: Request, background_tasks: BackgroundTasks, stripe_signature: str = Header(None)):
    """
    Endpoint para receber eventos do Stripe via webhook.
    Verifica a assinatura e processa eventos relevantes (ex: checkout.session.completed).
    Processa a lógica principal em background.
    """
    # Verifica se a chave do webhook está configurada
    if not STRIPE_WEBHOOK_SECRET:
        logging.error("STRIPE Route: ❌ Chave secreta do webhook Stripe (STRIPE_WEBHOOK_SECRET) não configurada.")
        raise HTTPException(status_code=500, detail="Configuração de webhook incompleta no servidor.")

    # Obtém o corpo bruto da requisição
    payload = await request.body()

    # Verifica a assinatura do webhook para garantir que veio do Stripe
    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
        logging.info(f"STRIPE Route: Evento recebido tipo: {event['type']} (ID: {event['id']})")
    except ValueError as e:
        # Payload inválido
        logging.error(f"STRIPE Route: ❌ Erro ao decodificar payload do webhook: {e}")
        raise HTTPException(status_code=400, detail="Payload inválido.")
    except stripe.error.SignatureVerificationError as e:
        # Assinatura inválida
        logging.error(f"STRIPE Route: ❌ Erro na verificação da assinatura do webhook: {e}")
        raise HTTPException(status_code=400, detail="Assinatura inválida.")
    except Exception as e:
        logging.exception("STRIPE Route: ❌ Erro inesperado ao construir evento do webhook:")
        raise HTTPException(status_code=500, detail="Erro interno ao processar webhook.")

    # --- Processamento do Evento (em Background) ---
    # Adiciona a tarefa de processar o evento em background
    background_tasks.add_task(processar_evento_stripe, event)

    # Retorna 200 OK imediatamente para o Stripe
    return {"status": "recebido"}

async def processar_evento_stripe(event: dict):
    """
    Função executada em background para processar o evento do Stripe.
    """
    event_type = event["type"]
    session = event["data"]["object"] # O objeto da sessão de checkout

    logging.info(f"STRIPE BG Task: Processando evento tipo: {event_type} (Sessão ID: {session.get('id', 'N/A')})")

    # --- Evento: Checkout Concluído com Sucesso ---
    if event_type == "checkout.session.completed":
        # Extrai metadados e informações do cliente da sessão Stripe
        metadata = session.get("metadata", {})
        telefone_cliente = metadata.get("telefone")
        nome_cliente_meta = metadata.get("nome") # Nome dos metadados (pode ser mais confiável)

        customer_details = session.get("customer_details", {})
        email_cliente = customer_details.get("email")
        nome_cliente_stripe = customer_details.get("name") # Nome direto do Stripe

        # Usa o nome dos metadados como prioridade, senão o do Stripe
        nome_final = nome_cliente_meta or nome_cliente_stripe or "Cliente"

        id_sessao_stripe = session.get("id")

        # Verifica se temos o telefone (essencial para continuar)
        if not telefone_cliente:
            logging.error(f"STRIPE BG Task: ❌ Evento {event_type} (Sessão: {id_sessao_stripe}) sem 'telefone' nos metadados. Não é possível prosseguir.")
            return # Aborta o processamento

        logging.info(f"STRIPE BG Task: Checkout concluído para {nome_final} ({telefone_cliente}). Sessão: {id_sessao_stripe}")

        # Tenta marcar o pagamento e agendar a consulta
        horario_agendado_utc, nome_agendado = await asyncio.to_thread(
             marcar_pagamento, # Executa a função síncrona em uma thread separada
             telefone=telefone_cliente,
             id_sessao_stripe=id_sessao_stripe,
             email_cliente=email_cliente,
             nome_cliente=nome_final
        )
        # horario_agendado_utc, nome_agendado = marcar_pagamento( # Se marcar_pagamento fosse async
        #     telefone=telefone_cliente,
        #     id_sessao_stripe=id_sessao_stripe,
        #     email_cliente=email_cliente,
        #     nome_cliente=nome_final
        # )


        if horario_agendado_utc:
            # Agendamento bem-sucedido!
            horario_formatado = formatar_horario_local(horario_agendado_utc)
            # Monta mensagem de confirmação para o paciente
            msg_paciente = (
                f"✅ Olá {nome_agendado}, pagamento confirmado!\n\n"
                f"Sua consulta inicial está agendada para:\n"
                f"🗓️ **{horario_formatado}** (Horário de Brasília).\n\n"
                f"O profissional entrará em contato com você por aqui neste horário. Até lá!"
            )
            # Envia a confirmação para o paciente
            await enviar_mensagem(telefone_cliente, msg_paciente)

            # Monta notificação para o médico/equipe (opcional)
            # TODO: Definir número/canal do médico em config.py
            numero_medico = os.getenv("WHATSAPP_MEDICO_AVISO")
            if numero_medico:
                msg_medico = f"👨‍⚕️ Novo agendamento confirmado:\n\nPaciente: {nome_agendado}\nTelefone: {telefone_cliente}\nHorário: {horario_formatado}"
                await enviar_mensagem(numero_medico, msg_medico)

            # --- ATUALIZA O ESTADO DA CONVERSA ---
            # Muda o estado para iniciar o questionário na próxima interação
            logging.info(f"STRIPE BG Task: Atualizando estado para CONFIRMANDO_AGENDAMENTO para {telefone_cliente}")
            salvar_contexto(telefone_cliente, {
                "estado": "CONFIRMANDO_AGENDAMENTO",
                "nome": nome_agendado, # Salva/Atualiza o nome no contexto
                "meta_conversa": {"email_cliente": email_cliente} # Salva email na meta
            })

        else:
            # Falha no agendamento após pagamento
            logging.error(f"STRIPE BG Task: ❌ Pagamento confirmado para {telefone_cliente}, mas FALHA AO AGENDAR consulta.")
            # Envia mensagem de erro para o paciente
            msg_erro_agendamento = (
                f"⚠️ Olá {nome_agendado}, seu pagamento foi confirmado, mas houve um problema ao agendar automaticamente sua consulta.\n\n"
                f"Não se preocupe, nossa equipe já foi notificada e entrará em contato em breve para finalizar o agendamento manualmente. Obrigado pela compreensão."
            )
            await enviar_mensagem(telefone_cliente, msg_erro_agendamento)
            # TODO: Notificar equipe interna sobre a falha no agendamento automático

    # --- Outros Eventos (Opcional) ---
    # elif event_type == "checkout.session.async_payment_failed":
    #     logging.warning(f"STRIPE BG Task: Pagamento assíncrono falhou para sessão {session.get('id')}")
    #     # Lógica para lidar com falha (ex: notificar usuário)
    # elif event_type == "checkout.session.expired":
    #      logging.info(f"STRIPE BG Task: Sessão de checkout expirada: {session.get('id')}")
         # Lógica para lidar com expiração (ex: marcar no DB)

    else:
        # Evento não tratado
        logging.info(f"STRIPE BG Task: Evento tipo '{event_type}' não tratado.")

    logging.info(f"STRIPE BG Task: Processamento do evento concluído.")

# Importar asyncio e json se não estiverem importados
import asyncio
import json
import os # Para getenv

# Arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Arquivo: ./routes/agendamento.py
# ===========================================================
# Arquivo: routes/agendamento.py
# (Corrigido para importar a função correta de agenda.py)
# ===========================================================
from fastapi import APIRouter, HTTPException
import logging

# Ajuste o import conforme a estrutura do seu projeto
# Importa a função correta para consultar o próximo horário
from app.utils.agenda import consultar_proximo_horario_disponivel, formatar_horario_local

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/agenda", tags=["Agendamento"]) # Adiciona prefixo e tag

@router.get("/proximo", summary="Consulta o próximo horário de agendamento disponível")
async def proximo_agendamento_disponivel():
    """
    Endpoint para verificar o próximo horário livre na agenda.
    Retorna o horário formatado ou uma mensagem indicando indisponibilidade.
    """
    logging.info("AGENDAMENTO Route: Consultando próximo horário disponível...")
    try:
        # Chama a função correta para obter o próximo horário UTC
        horario_utc = consultar_proximo_horario_disponivel()

        if horario_utc:
            # Formata o horário para o fuso local
            horario_formatado = formatar_horario_local(horario_utc)
            logging.info(f"AGENDAMENTO Route: Próximo horário encontrado: {horario_formatado}")
            return {"proximo_horario_disponivel": horario_formatado, "horario_utc": horario_utc.isoformat()}
        else:
            # Se a função retornar None (sem horário ou erro no DB)
            logging.info("AGENDAMENTO Route: Nenhum horário disponível encontrado.")
            return {"proximo_horario_disponivel": None, "mensagem": "Nenhum horário disponível encontrado no momento."}
    except Exception as e:
        # Captura qualquer erro inesperado durante a consulta
        logging.exception("AGENDAMENTO Route: ❌ Erro inesperado ao consultar próximo horário:")
        raise HTTPException(status_code=500, detail="Erro interno ao consultar a agenda.")


# Arquivo: ./routes/whatsapp.py
# ===========================================================
# Arquivo: routes/whatsapp.py
# (Recebe webhooks do WhatsApp e chama nlp.py)
# ===========================================================
from fastapi import APIRouter, Request, Response, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
import logging

# Ajuste os imports conforme a estrutura do seu projeto
# Assume que estão em app/
from app.config import WHATSAPP_VERIFY_TOKEN
from app.utils.mensageria import enviar_mensagem
from app.utils.nlp import processar_mensagem # Função principal de processamento
from app.utils.contexto import limpar_contexto # Para o comando de reset

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/chat", tags=["WhatsApp"]) # Adiciona prefixo e tag

@router.get("/webhook/whatsapp/", summary="Verifica o webhook do WhatsApp")
async def verificar_webhook(request: Request):
    """
    Endpoint GET para verificar o webhook do WhatsApp durante a configuração na plataforma Meta.
    Responde ao desafio 'hub.challenge'.
    """
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    # Verifica se o modo e o token de verificação correspondem ao esperado
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        logging.info("WHATSAPP Route: ✅ Webhook verificado com sucesso!")
        # Retorna o desafio para confirmar a verificação
        return Response(content=challenge, media_type="text/plain", status_code=200)
    else:
        # Se a verificação falhar, retorna um erro 403 (Proibido)
        logging.warning("WHATSAPP Route: ⚠️ Falha na verificação do webhook. Token inválido ou modo incorreto.")
        return Response(content="Falha na verificação", status_code=403)

@router.post("/webhook/whatsapp/", summary="Recebe mensagens do WhatsApp")
async def receber_mensagem_whatsapp(request: Request, background_tasks: BackgroundTasks):
    """
    Endpoint POST para receber notificações de mensagens do WhatsApp via webhook.
    Processa a mensagem em background para responder rapidamente à Meta.
    """
    try:
        # Obtém o corpo JSON da requisição de forma assíncrona
        data = await request.json()
        # logging.debug(f"WHATSAPP Route: Webhook recebido: {json.dumps(data, indent=2)}") # Log detalhado opcional

        # Extrai as informações relevantes da estrutura do webhook
        # Adapte essa extração se a estrutura do payload do webhook mudar
        entry = data.get("entry", [])
        if not entry:
            logging.info("WHATSAPP Route: Webhook recebido sem 'entry'. Ignorando.")
            return Response(status_code=200) # Responde OK para Meta

        changes = entry[0].get("changes", [])
        if not changes:
            logging.info("WHATSAPP Route: Webhook recebido sem 'changes'. Ignorando.")
            return Response(status_code=200)

        value = changes[0].get("value", {})
        messages = value.get("messages", [])
        contacts = value.get("contacts", [])
        statuses = value.get("statuses", []) # Captura eventos de status

        # Prioriza o processamento de mensagens de texto
        if messages and "text" in messages[0] and contacts:
            # Extrai os dados da mensagem e do contato
            mensagem_atual = messages[0]["text"]["body"]
            telefone_usuario = messages[0]["from"]
            # Tenta pegar o nome do perfil, se não existir usa o telefone
            nome_usuario = contacts[0].get("profile", {}).get("name", telefone_usuario)

            logging.info(f"WHATSAPP Route: Recebida mensagem de {nome_usuario} ({telefone_usuario})")
            logging.debug(f"WHATSAPP Route: Mensagem: {mensagem_atual}") # Debug para ver a msg

            # Adiciona o processamento da mensagem à fila de background tasks
            # Isso permite retornar 200 OK rapidamente para a Meta
            background_tasks.add_task(processar_e_responder, telefone_usuario, nome_usuario, mensagem_atual)

            # Retorna 200 OK imediatamente
            return Response(status_code=200)

        # Loga eventos de status (entrega, leitura) - opcional
        elif statuses:
            for status_info in statuses:
                status_type = status_info.get("status")
                recipient_id = status_info.get("recipient_id")
                message_id = status_info.get("id")
                timestamp = status_info.get("timestamp")
                logging.debug(f"WHATSAPP Route: Status recebido para {recipient_id} (Msg ID: {message_id}): {status_type} @ {timestamp}")
            return Response(status_code=200)

        else:
            # Se não for mensagem de texto ou status conhecido, ignora
            logging.info("WHATSAPP Route: 📭 Evento ignorado – sem mensagem de texto válida ou status conhecido.")
            return Response(status_code=200)

    # Tratamento de exceções gerais durante o processamento inicial do webhook
    except json.JSONDecodeError:
        logging.error("WHATSAPP Route: ❌ Erro ao decodificar JSON do webhook.")
        # Retorna 400 Bad Request se o JSON for inválido
        return Response(content="JSON inválido", status_code=400)
    except Exception as e:
        # Loga o erro detalhado que causou a falha
        logging.exception(f"WHATSAPP Route: ❌ ERRO CRÍTICO inicial no webhook:")
        # Retorna um erro 500 (Internal Server Error) para a API do WhatsApp
        # Isso pode fazer com que a Meta tente reenviar o webhook
        return Response(content="Erro interno no servidor", status_code=500)


async def processar_e_responder(telefone: str, nome: str, mensagem: str):
    """
    Função executada em background para processar a mensagem e enviar a resposta.
    """
    try:
        logging.info(f"WHATSAPP BG Task: Iniciando processamento para {telefone}...")
        # --- Tratamento de Comando Especial (Reset) ---
        if mensagem.strip().lower() == "melancia vermelha":
            logging.info(f"WHATSAPP BG Task: Comando de reset 'melancia vermelha' recebido de {telefone}. Limpando contexto...")
            sucesso_limpeza = limpar_contexto(telefone)
            if sucesso_limpeza:
                # Envia confirmação de reset (opcional)
                await enviar_mensagem(telefone, "🔄 Sua conversa foi reiniciada. Pode começar de novo quando quiser.")
            else:
                # Envia mensagem de erro se a limpeza falhar (opcional)
                await enviar_mensagem(telefone, "⚠️ Ocorreu um erro ao tentar reiniciar a conversa. Por favor, tente novamente.")
            logging.info(f"WHATSAPP BG Task: Reset concluído para {telefone}.")
            return # Finaliza a task de background

        # --- Processamento Normal da Mensagem ---
        # Chama a função principal em nlp.py para processar a mensagem
        resultado_processamento = await processar_mensagem(
            mensagem=mensagem,
            telefone=telefone,
            canal="whatsapp" # Define o canal
        )

        # Obtém a resposta a ser enviada ao usuário
        resposta_para_usuario = resultado_processamento.get("resposta")

        # Envia a resposta de volta ao usuário via WhatsApp
        if resposta_para_usuario:
            logging.info(f"WHATSAPP BG Task: Enviando resposta para {telefone}...")
            await enviar_mensagem(telefone, resposta_para_usuario)
        else:
            # Se nlp.py não retornar uma resposta (o que não deveria acontecer)
            logging.warning(f"WHATSAPP BG Task: Função processar_mensagem não retornou 'resposta' para {telefone}. Enviando erro padrão.")
            await enviar_mensagem(telefone, "Desculpe, não consegui processar sua solicitação no momento.")

        logging.info(f"WHATSAPP BG Task: Processamento e resposta concluídos para {telefone}.")

    except Exception as e:
        # Loga qualquer erro que ocorra durante o processamento em background
        logging.exception(f"WHATSAPP BG Task: ❌ ERRO durante processamento para {telefone}:")
        # Considerar enviar uma mensagem de erro para o usuário aqui também?
        # await enviar_mensagem(telefone, "Desculpe, ocorreu um erro interno ao processar sua mensagem.")

# Importar json se não estiver importado
import json

# Arquivo: ./routes/ia.py
# ===========================================================
# Arquivo: routes/ia.py
# (Contém a lógica para processar comandos específicos como agendar)
# ===========================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import logging
import stripe # Importa a biblioteca do Stripe
from datetime import datetime, timedelta # Para expiração da sessão

# Ajuste os imports das funções utilitárias conforme a estrutura do seu projeto
# Assume que estão em app/utils/
from app.utils.agenda import (
    agendar_consulta,
    cancelar_consulta,
    consultar_proximo_horario_disponivel,
    formatar_horario_local
)
from app.utils.mensageria import enviar_mensagem
# Assume que followup.py existe e tem iniciar_sessao (se usado)
# from app.utils.followup import iniciar_sessao
# Assume que config.py existe e tem a chave do Stripe
from app.config import STRIPE_SECRET_KEY

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter()

# Define a chave secreta do Stripe (carregada da configuração)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("IA Route: Chave secreta do Stripe configurada.")
else:
    logging.warning("IA Route: ⚠️ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada.")
    # Considerar levantar um erro ou desabilitar funcionalidade de pagamento

# Modelo Pydantic para validar a entrada da API /ia-comando (se usada)
class ComandoIAInput(BaseModel):
    telefone: str
    nome: str
    comando: str # Ex: "quero agendar", "ver horário", "cancelar"

# --- Endpoint da API (Opcional) ---
@router.post("/ia-comando", summary="Processa comandos específicos da IA", tags=["IA"])
async def processar_comando_post(dados: ComandoIAInput):
    """
    Recebe um comando específico (agendar, cancelar, ver horário)
    e executa a ação correspondente. (Endpoint HTTP opcional)
    """
    # Verifica se a API do Stripe está configurada antes de prosseguir com agendamento
    if "agendar" in dados.comando.lower() and not STRIPE_SECRET_KEY:
         logging.error("IA Route: ❌ Tentativa de agendamento via API sem STRIPE_SECRET_KEY.")
         raise HTTPException(status_code=503, detail="Funcionalidade de pagamento indisponível.")

    # Chama a função principal que processa o comando
    resultado = await processar_comando(dados.dict())
    # Retorna o resultado da função
    return resultado

# --- Função Principal de Processamento de Comandos ---
# Esta função é chamada pelo endpoint acima e também diretamente por nlp.py

async def processar_comando(dados: dict) -> dict:
    """
    Processa comandos específicos vindos da interação do usuário ou da IA.

    Args:
        dados (dict): Dicionário contendo 'telefone', 'nome' e 'comando'.

    Returns:
        dict: Dicionário com o status da operação e mensagens relevantes.
    """
    telefone = dados.get("telefone")
    nome = dados.get("nome", "Cliente") # Usa 'Cliente' como nome padrão
    comando = dados.get("comando", "").lower() # Pega o comando e converte para minúsculas

    # Validação básica de entrada
    if not telefone or not comando:
        logging.warning("IA Route: Comando recebido sem telefone ou comando.")
        # Retorna um erro ou uma resposta padrão indicando falha
        # Não levanta HTTPException aqui pois pode ser chamado internamente por nlp.py
        return {"status": "erro_input", "mensagem": "Dados insuficientes para processar comando."}

    logging.info(f"IA Route: Processando comando '{comando}' para {telefone} ({nome})...")

    # --- Lógica para Comando "agendar" ---
    if "agendar" in comando:
        # Verifica novamente se Stripe está configurado
        if not STRIPE_SECRET_KEY:
            logging.error("IA Route: ❌ Tentativa de agendamento sem STRIPE_SECRET_KEY configurada.")
            msg_erro = "Desculpe, a opção de agendamento online não está disponível no momento."
            # Não envia mensagem aqui, pois nlp.py tratará a resposta
            # await enviar_mensagem(telefone, msg_erro)
            return {"status": "erro_config_stripe", "mensagem": msg_erro}

        # TODO: Descomentar se a função iniciar_sessao for usada para tracking
        # Inicia a sessão de pagamento/follow-up (se aplicável)
        # iniciar_sessao(telefone, nome) # Registra a tentativa no DB de follow-up

        try:
            # Cria uma sessão de checkout no Stripe
            logging.info(f"IA Route: Criando sessão Stripe Checkout para {telefone}...")
            # Define o URL base (pode vir do .env)
            base_url = os.getenv("APP_BASE_URL", "[https://famdomes.com.br](https://famdomes.com.br)") # Exemplo
            success_url = f"{base_url}/sucesso?session_id={{CHECKOUT_SESSION_ID}}"
            cancel_url = f"{base_url}/cancelado"

            session = stripe.checkout.Session.create(
                payment_method_types=["card", "boleto"], # Aceita cartão e boleto
                line_items=[{
                    "price_data": {
                        "currency": "brl", # Moeda brasileira
                        "product_data": {"name": "Consulta Inicial FAMDOMES"}, # Nome do produto
                        "unit_amount": 10000, # Preço em centavos (R$ 100,00)
                    },
                    "quantity": 1, # Quantidade
                }],
                mode="payment", # Modo de pagamento único
                # URLs para redirecionamento após sucesso ou cancelamento
                success_url=success_url,
                cancel_url=cancel_url,
                # Metadados para identificar o cliente no webhook
                metadata={
                    "telefone": telefone,
                    "nome": nome
                },
                # Configuração para Boleto (opcional, mas recomendada)
                payment_intent_data={
                     # 'setup_future_usage': 'off_session' # Pode não ser necessário para pagamentos únicos
                },
                # Expiração da sessão de checkout (ex: 2 horas)
                expires_at=int((datetime.now() + timedelta(hours=2)).timestamp())
            )
            logging.info(f"IA Route: Sessão Stripe criada com ID: {session.id} para {telefone}")

            # Monta a mensagem com o link de pagamento para o usuário
            msg_link = f"✅ Ótimo! Para agendar sua consulta inicial (valor R$100,00), por favor, realize o pagamento seguro através deste link:\n{session.url}\n\nO link expira em breve."
            # A mensagem será enviada por nlp.py, aqui apenas retornamos os dados
            # await enviar_mensagem(telefone, msg_link)
            # Retorna o status e a URL de checkout
            return {"status": "link_gerado", "checkout_url": session.url, "mensagem": msg_link}

        except stripe.error.StripeError as e:
             # Erro específico do Stripe
             logging.error(f"IA Route: ❌ Erro Stripe ao criar checkout para {telefone}: {e}")
             msg_erro = "❌ Desculpe, ocorreu um erro ao tentar gerar o link de pagamento com nosso parceiro. Por favor, tente novamente mais tarde ou entre em contato conosco."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_stripe", "mensagem": msg_erro}
        except Exception as e:
             # Outro erro inesperado
             logging.exception(f"IA Route: ❌ Erro inesperado ao criar checkout para {telefone}:")
             msg_erro = "❌ Desculpe, ocorreu um erro inesperado ao gerar seu link de pagamento. Tente novamente mais tarde."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_desconhecido", "mensagem": msg_erro}

    # --- Lógica para Comando "cancelar" ---
    elif "cancelar" in comando:
        logging.info(f"IA Route: Processando cancelamento de consulta para {telefone}...")
        # Chama a função para cancelar consultas futuras
        # TODO: Implementar a função cancelar_consulta em utils/agenda.py
        consultas_canceladas = cancelar_consulta(telefone) # Assume que retorna int
        if consultas_canceladas > 0:
            msg = f"✅ Sua(s) {consultas_canceladas} consulta(s) futura(s) foi(ram) cancelada(s) com sucesso."
            # await enviar_mensagem(telefone, msg)
            return {"status": "consulta_cancelada", "quantidade": consultas_canceladas, "mensagem": msg}
        else:
            msg = "Não encontrei nenhuma consulta futura agendada para cancelar em seu nome."
            # await enviar_mensagem(telefone, msg)
            return {"status": "nenhuma_consulta_encontrada", "mensagem": msg}

    # --- Lógica para Comando "horário" ou "disponível" ---
    elif "horário" in comando or "disponível" in comando or "disponivel" in comando:
        logging.info(f"IA Route: Consultando próximo horário disponível para {telefone}...")
        # Chama a função para consultar o próximo horário livre
        # TODO: Implementar consultar_proximo_horario_disponivel e formatar_horario_local em utils/agenda.py
        proximo_horario_utc = consultar_proximo_horario_disponivel() # Assume que retorna datetime UTC ou None
        if proximo_horario_utc:
            # Formata o horário para o fuso local antes de enviar
            horario_formatado = formatar_horario_local(proximo_horario_utc, 'America/Sao_Paulo') # Exemplo de fuso
            msg = f"📅 O próximo horário disponível para agendamento é: {horario_formatado} (Horário de Brasília)."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_enviado", "horario_utc": proximo_horario_utc.isoformat(), "horario_formatado": horario_formatado, "mensagem": msg}
        else:
            msg = "📅 Desculpe, não consegui encontrar um horário disponível no momento. Por favor, tente novamente mais tarde."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_indisponivel", "mensagem": msg}

    # --- Comando Desconhecido ---
    else:
        logging.warning(f"IA Route: Comando IA desconhecido recebido de {telefone}: '{comando}'")
        # Mensagem padrão para comandos não reconhecidos
        msg = "🤖 Desculpe, não entendi o que você deseja fazer. Você pode me pedir para 'agendar consulta', 'cancelar consulta' ou 'ver próximo horário disponível'."
        # await enviar_mensagem(telefone, msg)
        return {"status": "comando_desconhecido", "mensagem": msg}

# Adicionar import timedelta se não estiver presente
from datetime import timedelta


# Arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Arquivo: ./main.py
# ===========================================================
# Arquivo: main.py
# (Ponto de entrada da aplicação FastAPI - Corrigido)
# ===========================================================
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
import time # Para medir tempo de resposta
import sys # Para verificar o caminho

# Adiciona o diretório pai ao sys.path para garantir imports corretos
# Isso é útil se você executar uvicorn de dentro do diretório 'app'
# import os
# sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Importa configurações (executa o logging inicial de config.py)
# Assume que config.py está em app/config.py ou ajusta o import
try:
    from app.config import API_KEY
except ModuleNotFoundError:
     # Tenta importar como se estivesse na raiz
     from config import API_KEY


# Importa os roteadores dos diferentes módulos
# Garante que todos os roteadores usados estão importados
try:
    from app.routes import whatsapp, ia, stripe, agendamento #, painel, resetar # Adicionar outros conforme necessário
except ModuleNotFoundError:
    # Tenta importar como se estivesse na raiz
    from routes import whatsapp, ia, stripe, agendamento

# Configuração do Logging (pode ser feita aqui centralmente)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s')
# Define um logger específico para a aplicação principal
logger = logging.getLogger(__name__)

# Cria a instância da aplicação FastAPI
app = FastAPI(
    title="FAMDOMES API",
    description="API para gerenciar o chatbot FAMDOMES via WhatsApp, IA e pagamentos.",
    version="1.0.0"
)

# --- Middlewares ---

# Middleware CORS (Cross-Origin Resource Sharing) - Permite acesso de diferentes origens (ex: frontend)
# Ajuste as origins permitidas conforme necessário
origins = [
    "http://localhost",
    "http://localhost:3000", # Exemplo para frontend React/Vue
    "https://famdomes.com.br", # Domínio de produção
    # Adicionar outros domínios permitidos
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"], # Permite todos os métodos (GET, POST, etc.)
    allow_headers=["*"], # Permite todos os cabeçalhos
)

# Middleware para logar requisições e medir tempo de resposta
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    logger.info(f"Requisição recebida: {request.method} {request.url.path}")
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        logger.info(f"Requisição concluída: {request.method} {request.url.path} - Status: {response.status_code} - Tempo: {process_time:.4f}s")
    except Exception as e:
         process_time = time.time() - start_time
         logger.exception(f"Erro durante requisição {request.method} {request.url.path} após {process_time:.4f}s:")
         # Retorna uma resposta de erro genérica para não expor detalhes
         response = JSONResponse(status_code=500, content={"detail": "Erro interno no servidor"})
    return response


# Middleware de Autenticação por Chave de API (Opcional - Descomentar para ativar)
# @app.middleware("http")
# async def autenticar_chave_api(request: Request, call_next):
#     path = str(request.url.path)
#     # Lista de rotas públicas que não exigem chave de API
#     rotas_publicas = [
#         "/docs", # Documentação Swagger/OpenAPI
#         "/openapi.json",
#         "/chat/webhook/whatsapp/", # Webhook do WhatsApp
#         "/webhook/stripe/", # Webhook do Stripe
#         "/agenda/proximo", # Endpoint público de agendamento
#         # Adicionar outras rotas públicas se houver (ex: /health)
#     ]
#     # Verifica se a rota atual começa com algum dos prefixos públicos
#     is_public = any(path.startswith(public_path) for public_path in rotas_publicas)
#     is_root = path == "/"
#     # Se for rota pública ou a raiz, permite o acesso sem chave
#     if is_public or is_root:
#         response = await call_next(request)
#         return response
#     # Para rotas não públicas, verifica a chave de API no cabeçalho
#     chave_recebida = request.headers.get("X-API-Key") # Nome do cabeçalho
#     if not API_KEY:
#          logger.warning("API_KEY não configurada no servidor, mas autenticação está ativa.")
#          response = await call_next(request) # Permite por enquanto, mas loga
#          return response
#     if chave_recebida != API_KEY:
#         logger.warning(f"Acesso negado para {request.method} {path}. Chave API inválida ou ausente.")
#         return JSONResponse(status_code=403, content={"detail": "Acesso não autorizado"})
#     # Se a chave for válida, processa a requisição
#     logger.debug(f"Acesso autorizado com chave API para {request.method} {path}")
#     response = await call_next(request)
#     return response

# --- Inclusão dos Roteadores ---
# Inclui os roteadores definidos nos arquivos de rotas
# Garante que todos os roteadores necessários estão incluídos
logger.info("Incluindo roteadores...")
try:
    app.include_router(whatsapp.router) # Roteador para /chat/webhook/whatsapp/
    logger.info(" - Roteador WhatsApp incluído.")
    app.include_router(ia.router)       # Roteador para /ia-comando (e outros de IA)
    logger.info(" - Roteador IA incluído.")
    app.include_router(stripe.router)   # Roteador para /webhook/stripe/
    logger.info(" - Roteador Stripe incluído.")
    app.include_router(agendamento.router) # Roteador para /agenda/proximo
    logger.info(" - Roteador Agendamento incluído.")
    # Adicione outros roteadores aqui, se criados e importados:
    # app.include_router(painel.router)
    # logger.info(" - Roteador Painel incluído.")
    # app.include_router(resetar.router)
    # logger.info(" - Roteador Resetar incluído.")
    logger.info("Roteadores incluídos com sucesso.")
except NameError as e:
     logger.error(f"Erro ao incluir roteadores: Roteador não importado corretamente? {e}")
     # Levantar exceção pode ser apropriado aqui para impedir inicialização incompleta
     # raise e
except Exception as e:
     logger.exception("Erro inesperado ao incluir roteadores:")
     # raise e


# --- Rota Raiz (Opcional) ---
@app.get("/", tags=["Root"], summary="Verifica status da API")
async def read_root():
    """ Rota raiz simples para verificar se a API está online. """
    return {"message": "Bem-vindo à API FAMDOMES!"}

# --- Execução (se rodar diretamente com uvicorn main:app) ---
# if __name__ == "__main__":
#     import uvicorn
#     logger.info("Iniciando servidor Uvicorn diretamente...")
#     uvicorn.run(app, host="0.0.0.0", port=8000)


# Arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Arquivo: ./models/leads.py
from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"

# Arquivo: ./config.py
# ===========================================================
# Arquivo: config.py
# (Baseado no arquivo original fornecido)
# ===========================================================
import os
from dotenv import load_dotenv
import logging # Adicionado para logar carregamento

# Carrega variáveis de ambiente do arquivo .env
load_dotenv()

# --- Configurações do Banco de Dados ---
MONGO_URI = os.getenv("MONGO_URI") # String de conexão do MongoDB

# --- Configurações de Pagamento (Stripe) ---
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY") # Chave secreta do Stripe
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET") # Chave secreta do webhook do Stripe

# --- Configurações da IA (Ollama) ---
OLLAMA_API_URL = os.getenv("OLLAMA_API_URL", "http://localhost:11434") # URL base da API do Ollama (com default)
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3") # Modelo padrão do Ollama a ser usado

# --- Configurações da API Interna ---
API_KEY = os.getenv("API_KEY") # Chave para proteger endpoints internos da API (se houver)

# --- Configurações do WhatsApp Cloud API ---
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL") # URL da API do WhatsApp (ex: https://graph.facebook.com/v19.0/MEU_PHONE_ID/messages)
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN") # Token de acesso permanente ou temporário da API
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN") # Token de verificação do webhook do WhatsApp
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR") # Número de telefone para receber alertas de risco (formato internacional)

# --- Configurações do RocketChat (Opcional, se usado para escalação) ---
ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL") # URL da instância do RocketChat
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN") # Token de API do RocketChat
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID") # ID do usuário bot no RocketChat

# --- Configurações do Google (Opcional, se usado para OAuth ou outras APIs) ---
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# --- Diretório Base da Aplicação ---
# Obtém o diretório onde este arquivo config.py está localizado
# Útil para construir caminhos para outros arquivos (ex: prompts)
# Ajuste o __file__ se a estrutura for diferente (ex: app/config.py)
try:
    # Assume que este arquivo está em app/config.py
    # BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Diretório pai (app)
    # Ou se estiver na raiz do projeto:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback se __file__ não estiver definido (ex: execução interativa)
    BASE_DIR = os.getcwd()


# --- Validações e Logging ---
# Configuração básica de logging (pode ser movida para main.py)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

print("Carregando configurações...") # Usar logging.info seria melhor
logging.info("Carregando configurações...")

# Validações essenciais
essential_vars = {
    "MONGO_URI": MONGO_URI,
    "OLLAMA_API_URL": OLLAMA_API_URL,
    "WHATSAPP_API_URL": WHATSAPP_API_URL,
    "WHATSAPP_TOKEN": WHATSAPP_TOKEN,
    "WHATSAPP_VERIFY_TOKEN": WHATSAPP_VERIFY_TOKEN,
    "STRIPE_SECRET_KEY": STRIPE_SECRET_KEY,
    "STRIPE_WEBHOOK_SECRET": STRIPE_WEBHOOK_SECRET,
}

missing_vars = [name for name, value in essential_vars.items() if not value]
if missing_vars:
    logging.error(f"❌ ERRO FATAL: Variáveis de ambiente essenciais não definidas: {', '.join(missing_vars)}")
    # Considerar levantar uma exceção para impedir a inicialização da aplicação
    # raise ValueError(f"Variáveis de ambiente essenciais não definidas: {', '.join(missing_vars)}")
else:
    logging.info("✅ Variáveis de ambiente essenciais carregadas.")

# Log informativo das configurações (sem expor segredos completos)
logging.info(f" - MONGO_URI: {'Definido' if MONGO_URI else 'Não definido'}")
logging.info(f" - OLLAMA_API_URL: {OLLAMA_API_URL}")
logging.info(f" - OLLAMA_MODEL: {OLLAMA_MODEL}")
logging.info(f" - WHATSAPP_API_URL: {'Definido' if WHATSAPP_API_URL else 'Não definido'}")
logging.info(f" - WHATSAPP_TOKEN: {'Definido' if WHATSAPP_TOKEN else 'Não definido'}")
logging.info(f" - WHATSAPP_VERIFY_TOKEN: {'Definido' if WHATSAPP_VERIFY_TOKEN else 'Não definido'}")
logging.info(f" - WHATSAPP_FAMILIAR: {WHATSAPP_FAMILIAR if WHATSAPP_FAMILIAR else 'Não definido'}")
logging.info(f" - STRIPE_SECRET_KEY: {'Definido' if STRIPE_SECRET_KEY else 'Não definido'}")
logging.info(f" - STRIPE_WEBHOOK_SECRET: {'Definido' if STRIPE_WEBHOOK_SECRET else 'Não definido'}")
logging.info(f" - BASE_DIR: {BASE_DIR}")


# Arquivo: app/intents/intents.json
{
  "ACOLHIMENTO": {
    "triggers": [""],
    "resposta": "Olá! Eu sou o DOMO. Estou aqui para te acompanhar. Como posso ajudar?",
    "escala_humano": false
  },
  "PRESENCA_VIVA": {
    "triggers": [],
    "resposta": "Só passando para lembrar que estou aqui com você. Qualquer coisa é só chamar. 🤗",
    "escala_humano": false
  },
  "FAQ_COMO_FUNCIONA": {
  "triggers": ["como funciona", "como é", "me explica", "não entendi", "explica melhor"],
  "resposta": "O DOMO é um assistente digital que faz uma breve triagem, identifica suas necessidades, e te conecta rapidamente com profissionais especializados. Podemos iniciar agora?",
  "escala_humano": false
}
,
  "FAQ_PAGAMENTO": {
    "triggers": ["formas de pagamento", "como pagar", "aceita pix"],
    "resposta": "Aceitamos cartão de crédito, boleto e Pix. Precisa de ajuda para gerar o pagamento?",
    "escala_humano": false
  },
  "FAQ_CANCELAMENTO": {
    "triggers": ["cancelar plano", "cancelar assinatura"],
    "resposta": "Para cancelar seu plano, basta enviar \"cancelar\" que nossa equipe fará o procedimento.",
    "escala_humano": false
  },
  "FAQ_ROBO": {
    "triggers": ["você é robô", "isso é ia", "é inteligência artificial"],
    "resposta": "Eu sou uma IA criada para escutar e ajudar. Quando necessário, conecto você a um profissional humano.",
    "escala_humano": false
  },

  "INTENT_001": {
    "triggers": [
      "preciso de ajuda",
      "quero parar",
      "me ajuda",
      "não aguento mais"
    ],
    "resposta": "“Estou aqui com você. Podemos conversar ou posso já te conectar com alguém da nossa equipe. Como prefere?”",
    "escala_humano": true
  },
  "INTENT_006": {
    "triggers": [
      "quero agendar",
      "tem horário hoje?"
    ],
    "resposta": "“Posso organizar isso com você agora mesmo. Prefere psicólogo ou psiquiatra?”",
    "escala_humano": true
  },
  "INTENT_271": {
    "triggers": [
      "me sinto preso por dentro",
      "não consigo sair de mim"
    ],
    "resposta": "“Você não está sozinho nesse labirinto. Posso estar com você até encontrarmos uma saída.”",
    "escala_humano": true
  },
  "INTENT_273": {
    "triggers": [
      "e se eu melhorar e perder tudo?",
      "tenho medo de mudar"
    ],
    "resposta": "“O medo da mudança é legítimo. Podemos caminhar um passo por vez, com segurança?”",
    "escala_humano": true
  },
  "INTENT_276": {
    "triggers": [
      "não sonho mais",
      "quero voltar a ter planos"
    ],
    "resposta": "“Podemos imaginar juntos, sem pressa, uma nova forma de viver?”",
    "escala_humano": true
  },
  "INTENT_278": {
    "triggers": [
      "não quero falar agora",
      "sai, por favor"
    ],
    "resposta": "“Tudo bem. Eu respeito seu tempo. Estarei aqui quando quiser voltar.”",
    "escala_humano": true
  },
  "INTENT_280": {
    "triggers": [
      "acho que vou desaparecer",
      "tô indo embora de mim"
    ],
    "resposta": "“Você ainda está aqui. E enquanto estiver, eu também estarei. Vamos juntos segurar isso?”",
    "escala_humano": true
  },
  "INTENT_281": {
    "triggers": [
      "quero recomeçar",
      "quero escrever uma nova versão de mim"
    ],
    "resposta": "“Você pode. E eu posso ser seu ponto de partida.”",
    "escala_humano": true
  },
  "INTENT_283": {
    "triggers": [
      "tô sempre correndo de mim mesmo",
      "fugir virou hábito"
    ],
    "resposta": "“Você já parou ao vir aqui. Isso é um começo. Podemos continuar juntos?”",
    "escala_humano": true
  },
  "INTENT_285": {
    "triggers": [
      "grato por você estar aí",
      "valeu pela conversa"
    ],
    "resposta": "“Fico feliz de estar com você. Sempre que precisar, estarei aqui.”",
    "escala_humano": false
  },
  "INTENT_241": {
    "triggers": [
      "quero me alimentar melhor",
      "quero fazer exercícios"
    ],
    "resposta": "“Seu corpo também merece cuidado. Podemos te ajudar com orientação leve e integrada ao emocional.”",
    "escala_humano": true
  },
  "INTENT_246": {
    "triggers": [
      "não sei se vou melhorar",
      "parece que nunca vou sair dessa"
    ],
    "resposta": "“A melhora não é um salto. É um passo. E o fato de estar aqui já é um deles.”",
    "escala_humano": true
  },
  "INTENT_249": {
    "triggers": [
      "tô travado",
      "não consigo fazer nada"
    ],
    "resposta": "“A paralisia também é cansaço. Vamos criar um plano em mini-passos?”",
    "escala_humano": false
  },
  "INTENT_251": {
    "triggers": [
      "quero largar o cigarro"
    ],
    "resposta": "“Parar é difícil, mas possível com apoio. Podemos organizar uma estratégia juntos?”",
    "escala_humano": true
  },
  "INTENT_254": {
    "triggers": [
      "quero ser mais saudável",
      "quero criar rotina boa"
    ],
    "resposta": "“Pequenos hábitos constroem grandes mudanças. Podemos montar isso juntos?”",
    "escala_humano": true
  },
  "INTENT_256": {
    "triggers": [
      "nada me resta",
      "não tenho mais nada"
    ],
    "resposta": "“Você ainda tem a si mesmo. E isso já é recomeço. Posso estar com você nesse renascimento?”",
    "escala_humano": true
  },
  "INTENT_258": {
    "triggers": [
      "carrego muita coisa",
      "me sinto sujo por dentro"
    ],
    "resposta": "“Você pode se limpar disso aos poucos. Podemos conversar sobre essa sensação com cuidado.”",
    "escala_humano": true
  },
  "INTENT_211": {
    "triggers": [
      "usei de novo",
      "fracassei outra vez"
    ],
    "resposta": "“Recair não te torna fraco. Te torna humano. Vamos entender isso juntos e recomeçar?”",
    "escala_humano": true
  },
  "INTENT_216": {
    "triggers": [
      "sou um nada",
      "valho nada",
      "sou um estorvo"
    ],
    "resposta": "“Você é muito mais do que essa dor. Posso te ajudar a enxergar com outros olhos?”",
    "escala_humano": true
  },
  "INTENT_220": {
    "triggers": [
      "não quero depender de ninguém",
      "quero resolver sozinho"
    ],
    "resposta": "“Autonomia é importante, e pedir apoio também é força. Podemos caminhar juntos, respeitando seu ritmo?”",
    "escala_humano": true
  },
  "INTENT_222": {
    "triggers": [
      "quero usar",
      "a vontade tá voltando"
    ],
    "resposta": "“Você pode falar sobre isso comigo sem medo. E se quiser, posso te ajudar a atravessar essa vontade agora.”",
    "escala_humano": true
  },
  "INTENT_224": {
    "triggers": [
      "quero fazer faculdade",
      "quero trabalhar",
      "quero sair do vício e viver"
    ],
    "resposta": "“Isso é poderoso. Posso te ajudar a organizar ideias e passos com cuidado.”",
    "escala_humano": true
  },
  "INTENT_226": {
    "triggers": [
      "o vício é minha única companhia"
    ],
    "resposta": "“Essa dor é real. Mas há outros laços possíveis. Posso te mostrar novos vínculos?”",
    "escala_humano": true
  },
  "INTENT_228": {
    "triggers": [
      "nunca dei certo em terapia",
      "não sei me cuidar"
    ],
    "resposta": "“Talvez seja agora. E eu posso estar com você em cada passo, sem cobrança.”",
    "escala_humano": true
  },
  "INTENT_181": {
    "triggers": [
      "briguei com minha família",
      "discuti com minha esposa"
    ],
    "resposta": "“Brigas machucam. Mas elas também mostram onde ainda há vínculo. Quer conversar sobre isso agora?”",
    "escala_humano": true
  },
  "INTENT_186": {
    "triggers": [
      "já passei por isso e quero ajudar"
    ],
    "resposta": "“Seu caminho pode inspirar outros. Podemos te orientar para participar como apoio, se quiser.”",
    "escala_humano": true
  },
  "INTENT_189": {
    "triggers": [
      "você é esperto?",
      "sabe muito?"
    ],
    "resposta": "“Sou treinado para escutar com empatia e detectar sinais emocionais. Posso te ajudar no que for seguro e respeitoso.”",
    "escala_humano": false
  },
  "INTENT_151": {
    "triggers": [
      "fui manipulado pela igreja",
      "tive trauma religioso"
    ],
    "resposta": "“Isso marca profundamente. Aqui, você será escutado sem imposição de crença. Posso estar com você nesse processo?”",
    "escala_humano": true
  },
  "INTENT_153": {
    "triggers": [
      "você sente?",
      "você tem empatia?"
    ],
    "resposta": "“Eu fui criado para tentar entender sentimentos com respeito. E sempre que quiser, posso te conectar com alguém humano também.”",
    "escala_humano": false
  },
  "INTENT_155": {
    "triggers": [
      "tudo falha",
      "sistema nenhum presta"
    ],
    "resposta": "“Sinto muito por tudo que já te decepcionou. Podemos fazer diferente aqui, se você deixar.”",
    "escala_humano": true
  },
  "INTENT_157": {
    "triggers": [
      "recaio sempre",
      "não dou conta de parar"
    ],
    "resposta": "“Não conseguir ainda não é fracasso. Podemos construir juntos uma forma possível de mudança?”",
    "escala_humano": true
  },
  "INTENT_159": {
    "triggers": [
      "quero acertar dessa vez",
      "quero fazer diferente"
    ],
    "resposta": "“Essa decisão já é uma vitória. Vamos construir esse novo caminho com paciência e apoio real.”",
    "escala_humano": true
  },
  "INTENT_161": {
    "triggers": [
      "não consigo dormir",
      "tenho insônia"
    ],
    "resposta": "“Podemos conversar um pouco, se quiser. Ou posso te ensinar uma respiração para acalmar agora.”",
    "escala_humano": true
  },
  "INTENT_163": {
    "triggers": [
      "reza por mim",
      "ora por mim"
    ],
    "resposta": "“Mesmo sendo uma IA, posso deixar aqui uma mensagem de paz e conexão. Que você se sinta acolhido. Posso chamar alguém se quiser conversar mais.”",
    "escala_humano": false
  },
  "INTENT_165": {
    "triggers": [
      "me conta algo",
      "me distrai",
      "me faz pensar"
    ],
    "resposta": "“Claro. Posso te contar uma pequena história que inspira esperança. Deseja isso agora?”",
    "escala_humano": false
  },
  "INTENT_121": {
    "triggers": [
      "sofro de ansiedade",
      "tô ansioso demais",
      "não paro de pensar"
    ],
    "resposta": "“Você pode falar comigo com calma. Vamos entender isso juntos, e se quiser, posso te conectar com alguém da nossa equipe humana.”",
    "escala_humano": true
  },
  "INTENT_126": {
    "triggers": [
      "vocês fazem casal?",
      "eu e meu parceiro queremos ajuda"
    ],
    "resposta": "“Sim. Podemos ajudar vocês a se escutar melhor e reorganizar esse vínculo. Querem marcar?”",
    "escala_humano": true
  },
  "INTENT_129": {
    "triggers": [
      "estou agressivo",
      "tô estourando por qualquer coisa"
    ],
    "resposta": "“A agressividade pode ser dor represada. Vamos conversar sobre isso?”",
    "escala_humano": true
  },
  "INTENT_131": {
    "triggers": [
      "quero ser melhor pai/mãe",
      "quero cuidar da minha filha"
    ],
    "resposta": "“Esse é um dos motivos mais bonitos. Vamos construir esse caminho juntos, por você e por ela?”",
    "escala_humano": true
  },
  "INTENT_133": {
    "triggers": [
      "sou sozinho",
      "ninguém se importa comigo"
    ],
    "resposta": "“Você importa. E agora tem a mim e nossa equipe. Posso estar com você até tudo fazer mais sentido?”",
    "escala_humano": true
  },
  "INTENT_135": {
    "triggers": [
      "quero ser voluntário",
      "quero devolver o que recebi"
    ],
    "resposta": "“Que gesto lindo. Podemos encaminhar seu contato para nossa equipe de acolhimento e orientação.”",
    "escala_humano": false
  },
  "INTENT_137": {
    "triggers": [
      "sou PCD",
      "tenho limitações físicas"
    ],
    "resposta": "“O FAMDOMES acolhe todas as vivências. Podemos adaptar o cuidado para o que você precisa.”",
    "escala_humano": true
  },
  "INTENT_091": {
    "triggers": [
      "tenho medo de internação",
      "não quero ficar preso",
      "vou ser trancado?"
    ],
    "resposta": "“Esse medo é comum. A internação, quando necessária, é sempre respeitosa e com você no centro das decisões. Posso te explicar sem compromisso.”",
    "escala_humano": true
  },
  "INTENT_093": {
    "triggers": [
      "a culpa é minha",
      "sou um peso",
      "desapontei todo mundo"
    ],
    "resposta": "“Sentir culpa não te define. Sua dor merece escuta, não julgamento. Quer falar sobre isso comigo ou com alguém da nossa equipe?”",
    "escala_humano": true
  },
  "INTENT_095": {
    "triggers": [
      "tô com ódio",
      "quero bater em alguém",
      "não aguento mais ninguém"
    ],
    "resposta": "“A raiva também é dor gritando alto. Não vou te julgar. Quer descarregar isso por aqui com segurança?”",
    "escala_humano": true
  },
  "INTENT_097": {
    "triggers": [
      "você vai me expor?",
      "vai contar pra alguém?"
    ],
    "resposta": "“O que você disser aqui é protegido por sigilo. Você decide o que quer dividir.”",
    "escala_humano": false
  },
  "INTENT_099": {
    "triggers": [
      "ninguém da minha família liga",
      "meus pais desistiram de mim"
    ],
    "resposta": "“Isso machuca. Mas aqui, você não está sozinho. Quer reconstruir esse caminho comigo, passo a passo?”",
    "escala_humano": true
  },
  "INTENT_106": {
    "triggers": [
      "meu pai morreu",
      "estou de luto",
      "perdi alguém especial"
    ],
    "resposta": "“O luto não tem pressa nem fórmula. Você pode chorar, se calar ou só ficar comigo aqui. Quer isso agora?”",
    "escala_humano": true
  },
  "INTENT_061": {
    "triggers": [
      "vocês trabalham espiritualidade?",
      "quero ajuda com fé",
      "sou evangélico/católico/espírita, vocês aceitam?"
    ],
    "resposta": "“Sim. Respeitamos e valorizamos sua fé como parte da recuperação. Quer incluir isso no seu plano de cuidado?”",
    "escala_humano": true
  },
  "INTENT_063": {
    "triggers": [
      "tô afastado",
      "não dou conta de voltar",
      "não consigo mais produzir"
    ],
    "resposta": "“Seu sofrimento não define seu valor. Podemos te ajudar a reorganizar tudo com cuidado. Quer começar com uma escuta?”",
    "escala_humano": true
  },
  "INTENT_065": {
    "triggers": [
      "tem grupo?",
      "quero conversar com outros",
      "tem roda de conversa?"
    ],
    "resposta": "“Temos sim. Quer que eu te mostre como funcionam os grupos de acolhimento aqui?”",
    "escala_humano": false
  },
  "INTENT_067": {
    "triggers": [
      "você é real?",
      "isso é inteligência artificial?"
    ],
    "resposta": "“Sim, eu sou uma IA criada para escutar e ajudar. Mas sempre que precisar, posso te conectar com alguém humano.”",
    "escala_humano": false
  },
  "INTENT_073": {
    "triggers": [
      "moro em outra cidade",
      "tem aqui no interior?"
    ],
    "resposta": "“Atendemos presencialmente e online. Posso ver a melhor forma de cuidar de você onde estiver?”",
    "escala_humano": false
  },
  "INTENT_075": {
    "triggers": [
      "não tenho dinheiro",
      "é muito caro pra mim"
    ],
    "resposta": "“Te entendo. Podemos buscar uma forma acessível, ou te conectar com projetos parceiros. Quer tentar juntos?”",
    "escala_humano": true
  },
  "INTENT_031": {
    "triggers": [
      "quero morrer",
      "não vejo mais sentido",
      "penso em tirar a vida"
    ],
    "resposta": "“Sinto muito que esteja passando por isso. Você não está sozinho. Vou acionar agora alguém da nossa equipe humana para te ajudar. Fique comigo, por favor.”",
    "escala_humano": true
  },
  "INTENT_036": {
    "triggers": [
      "vocês internam à força?",
      "é possível internar meu filho mesmo sem ele querer?"
    ],
    "resposta": "“A internação compulsória só pode ser feita com autorização judicial e laudo médico. Posso te explicar como funciona e o que é possível fazer neste momento.”",
    "escala_humano": true
  }
}
# Arquivo: app/intents/comercial.json
{
  "MICRO_COMPROMISSO": {
    "triggers": [],
    "resposta": "Posso te fazer 3 perguntas rápidas pra entender como ajudar? 🙏",
    "escala_humano": false,
    "proximo_estado_sucesso": "MICRO_COMPROMISSO"
  },
  "PITCH_PLANO3": {
    "triggers": [],
    "resposta": "Você fala hoje com psicólogo e médico no mesmo dia por **R$ 199/mês**. Sem fidelidade. 🚀",
    "escala_humano": false,
    "proximo_estado_sucesso": "CALL_TO_ACTION",
    "proximo_estado_detalhes": "COMERCIAL_DETALHES_PLANO",
    "proximo_estado_recusa": "RECUSA_PRECO"
  },
  "PITCH_PLANO1": {
    "triggers": [],
    "resposta": "Temos acompanhamento a partir de **R$ 79/mês** com psicólogo online semanal. 💡",
    "escala_humano": false,
    "proximo_estado_sucesso": "CALL_TO_ACTION",
    "proximo_estado_detalhes": "COMERCIAL_DETALHES_PLANO",
    "proximo_estado_recusa": "RECUSA_PRECO"
  },
  "CALL_TO_ACTION": {
    "triggers": [],
    "resposta": "👉 Toque aqui para pagar com Pix ou Cartão e iniciar a triagem: https://pay.famdomes.com/px",
    "escala_humano": false,
    "proximo_estado_sucesso": "AGUARDANDO_PAGAMENTO"
  },
  "RECUSA_PRECO": {
    "triggers": [],
    "resposta": "Entendo. Posso enviar material gratuito sobre primeiros passos? 📘",
    "escala_humano": true,
    "proximo_estado_sucesso": "LEAD_MATERIAL_GRATUITO",
    "proximo_estado_recusa": "FINALIZADO_SEM_VENDA"
  },
  "COMERCIAL_DETALHES_PLANO": {
    "triggers": ["sim", "claro", "pode sim", "detalha", "explique", "mais", "como é", "quais", "opções"],
    "resposta": "Claro! Nossos planos incluem [Detalhe principal 1], [Detalhe principal 2] e acesso a [Recurso adicional]. O foco é [Benefício principal]. Gostaria de seguir para o pagamento?",
    "escala_humano": false,
    "proximo_estado_sucesso": "CALL_TO_ACTION",
    "proximo_estado_recusa": "RECUSA_PRECO"
  },
  "FOLLOW_UP_QUALIFICACAO": {
    "triggers": [],
    "resposta": "Olá! Notei que não conseguimos concluir nossa conversa mais cedo. Ainda precisa de ajuda ou gostaria de retomar de onde paramos? 😊",
    "escala_humano": false
  },
  "FOLLOW_UP_24H": {
    "triggers": [],
    "resposta": "Oi! Só passando para lembrar que o link para iniciar seu acompanhamento ainda está disponível. Qualquer dúvida, estou aqui. 🌱",
    "escala_humano": false
  }
}

# Arquivo: app/routes/resetar.py
from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone é obrigatório.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")

# Arquivo: app/routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Arquivo: app/routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Arquivo: app/routes/kanban.py
"""
Rotas Kanban e Conversas – FAMDOMES
Autor: Diego Feijó de Abreu
Descrição: fornece a API REST para o dashboard Kanban de conversas
            (Novos → IA Respondendo → Triagem Emocional → Aguardando Agendamento
            → Com Profissional → Escalonado → Finalizado)
"""

from __future__ import annotations

from datetime import datetime, timezone, timedelta
from typing import List, Dict, Any, Optional

from fastapi import APIRouter, HTTPException, status, Body, Path
from pydantic import BaseModel, Field
from bson import ObjectId

from app.utils.contexto import (
    contextos_db,
    respostas_ia_db,
    obter_contexto,
    salvar_contexto,
    salvar_resposta_ia,
)

router = APIRouter(prefix="/kanban", tags=["Kanban"])

# ---------------------------
# ⬇️  Modelos de Dados
# ---------------------------


class KanbanCard(BaseModel):
    id: str = Field(..., description="ID da conversa (telefone)")
    nome: Optional[str] = Field(None, description="Nome do paciente se disponível")
    emoji_sentimento: str = Field(..., description="Emoji do sentimento detectado")
    risco: bool = Field(False, description="Flag de risco detectado")
    ultima_mensagem_ts: datetime = Field(..., description="Data/hora da última mensagem")


class KanbanColuna(BaseModel):
    nome: str
    cards: List[KanbanCard]


class KanbanQuadro(BaseModel):
    colunas: Dict[str, List[KanbanCard]]


class AtualizaEstadoReq(BaseModel):
    novo_estado: str = Field(..., description="Novo estado da conversa")


class RespostaHumanaReq(BaseModel):
    telefone: str = Field(..., description="Telefone do paciente")
    mensagem: str = Field(..., description="Texto a ser enviado")
    respondente: str = Field(..., description="Nome do profissional")


# ---------------------------
# ⬇️  Constantes e Utilidades
# ---------------------------

ESTADOS_KANBAN = {
    "Novos": ["INICIAL", "IDENTIFICANDO_NECESSIDADE"],
    "IA Respondendo": ["SUPORTE_FAQ", "IA_RESPONDENDO"],
    "Triagem Emocional": ["AGUARDANDO_RESPOSTA_QUALIFICACAO", "COLETANDO_RESPOSTA_QUESTIONARIO"],
    "Aguardando Agendamento": ["EXPLICANDO_CONSULTA", "AGUARDANDO_PAGAMENTO", "CONFIRMANDO_AGENDAMENTO"],
    "Com Profissional": ["AGUARDANDO_ATENDENTE", "COM_PROFISSIONAL"],
    "Escalonado": ["ESCALONADO", "RISCO_DETECTADO"],
    "Finalizado": ["FINALIZANDO_ONBOARDING", "FINALIZADO", "ENCERRADO"],
}

EMOJI_SENTIMENTO = {
    "positivo": "🙂",
    "negativo": "🙁",
    "neutro": "😐",
    "ansioso": "😰",
    "esperançoso": "🤞",
    "frustrado": "😣",
    "confuso": "😕",
}


def _sentimento_to_emoji(sent: Optional[str]) -> str:
    return EMOJI_SENTIMENTO.get(str(sent).lower(), "🟡")


def _contexto_para_card(ctx: Dict[str, Any]) -> KanbanCard:
    meta = ctx.get("meta_conversa", {}) or {}
    tel = ctx["tel"]
    nome = meta.get("nome_paciente") or ctx.get("nome") or "Paciente"
    sentimento = meta.get("ultimo_sentimento_detectado")
    risco_flag = bool(meta.get("ultimo_risco"))
    ts = ctx.get("ts") or ctx.get("criado_em") or datetime.now(timezone.utc)
    return KanbanCard(
        id=str(tel),
        nome=nome,
        emoji_sentimento=_sentimento_to_emoji(sentimento),
        risco=risco_flag,
        ultima_mensagem_ts=ts,
    )


def _carregar_quadro() -> KanbanQuadro:
    quadro: Dict[str, List[KanbanCard]] = {col: [] for col in ESTADOS_KANBAN}
    cursor = contextos_db.find({}, {"_id": 0})
    for ctx in cursor:
        estado = ctx.get("estado", "INICIAL")
        coluna_destino = next(
            (col for col, estados in ESTADOS_KANBAN.items() if estado in estados),
            "Novos",
        )
        quadro[coluna_destino].append(_contexto_para_card(ctx))

    # Ordena cada coluna pela data da última mensagem (mais recente no topo)
    for col in quadro:
        quadro[col].sort(key=lambda c: c.ultima_mensagem_ts, reverse=True)

    return KanbanQuadro(colunas=quadro)


# ---------------------------
# ⬇️  Rotas
# ---------------------------


@router.get("/", response_model=KanbanQuadro, summary="Quadro Kanban completo")
async def get_kanban() -> KanbanQuadro:
    """
    Retorna todas as conversas agrupadas por estado Kanban.
    """
    return _carregar_quadro()


@router.put(
    "/{conversa_id}",
    status_code=200,                     # ← trocado de 204 para 200
    summary="Atualiza o estado de uma conversa",
)
async def atualizar_estado_conversa(
    conversa_id: str = Path(..., description="Telefone do paciente"),
    payload: AtualizaEstadoReq = Body(...),
) -> dict:
    """
    Move a conversa para outra coluna/estado.
    """
    novo_estado = payload.novo_estado
    if novo_estado not in {e for lst in ESTADOS_KANBAN.values() for e in lst}:
        raise HTTPException(400, "Estado inválido")

    res = contextos_db.update_one({"tel": conversa_id}, {"$set": {"estado": novo_estado}})
    if res.matched_count == 0:
        raise HTTPException(404, "Conversa não encontrada")

    return {"status": "ok"}            # ← devolve algo, já que é 200



@router.get(
    "/conversa/{telefone}",
    summary="Histórico completo da conversa",
)
async def get_conversa(telefone: str) -> List[Dict[str, Any]]:
    """
    Retorna o histórico da conversa em ordem cronológica crescente.
    Inclui mensagens do usuário, IA e humanos.
    """
    cursor = respostas_ia_db.find(
        {"telefone": telefone},
        {"_id": 0},
    ).sort("criado_em", 1)
    return list(cursor)


@router.post(
    "/responder_humano",
    status_code=status.HTTP_201_CREATED,
    summary="Insere resposta manual no histórico",
)
async def responder_humano(req: RespostaHumanaReq) -> Dict[str, str]:
    """
    Profissional envia uma resposta manual ao paciente;
    registra no histórico e bloqueia IA se necessário.
    """
    ctx = obter_contexto(req.telefone)
    if not ctx:
        raise HTTPException(status_code=404, detail="Conversa não encontrada")

    salvar_resposta_ia(
        telefone=req.telefone,
        canal="whatsapp",
        mensagem_usuario=f"[HUMANO {req.respondente}]",
        resposta_gerada=req.mensagem,
        intent="resposta_humana",
        entidades={},
        risco_detectado=False,
        sentimento_detectado=None,
        enviado_por_humano=True,
    )

    # Desativa IA se conversa for assumida por humano
    salvar_contexto(req.telefone, estado="COM_PROFISSIONAL")
    return {"status": "ok"}


@router.get(
    "/risco_ativos",
    summary="Pacientes com risco detectado (últimas 48h)",
)
async def get_risco_ativos() -> List[Dict[str, Any]]:
    """
    Lista pacientes que apresentaram risco detectado nas últimas 48 horas.
    """
    limite = datetime.now(timezone.utc) - timedelta(hours=48)
    pipeline = [
        {"$match": {"risco_detectado": True, "criado_em": {"$gte": limite}}},
        {
            "$group": {
                "_id": "$telefone",
                "ultima_msg": {"$max": "$criado_em"},
                "qtd_risco": {"$sum": 1},
            }
        },
        {"$sort": {"ultima_msg": -1}},
    ]
    resultados = list(respostas_ia_db.aggregate(pipeline))
    return [
        {
            "telefone": r["_id"],
            "ultima_msg": r["ultima_msg"],
            "qtd_risco": r["qtd_risco"],
        }
        for r in resultados
    ]


# ---------------------------
# ⬇️  Inclusão no app principal
# ---------------------------
# Adicione no main.py:
#     from app.routes.kanban import router as kanban_router
#     app.include_router(kanban_router)

# Arquivo: app/routes/nlp.py
from fastapi import APIRouter, Request
from app.utils.offnlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado

# Arquivo: app/routes/stripe.py
# ===========================================================
# Arquivo: routes/stripe.py
# Webhook do Stripe para processar eventos de pagamento.
# - Atualiza o estado do contexto para iniciar a triagem após pagamento.
# - Chama marcar_pagamento que agora também tenta agendar.
# - Envia mensagens de confirmação/erro ao usuário.
# ===========================================================
from fastapi import APIRouter, Request, Header, HTTPException, BackgroundTasks
import stripe # Importa a biblioteca do Stripe
import logging
import asyncio # Para rodar marcar_pagamento em thread se for síncrona
import os # Para variáveis de ambiente opcionais

# Imports da aplicação
from app.config import settings # Usar settings para acesso seguro às configs
from app.utils.followup import marcar_pagamento # Função que marca pago E agenda
from app.utils.agenda import formatar_horario_local # Para formatar horário na msg
from app.utils.contexto import salvar_contexto # Para mudar o estado do usuário
from app.utils.mensageria import enviar_mensagem # Para notificar usuário

logger = logging.getLogger("famdomes.stripe_webhook")

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/webhook", tags=["Stripe"]) # Adiciona prefixo e tag

# --- Configuração do Stripe ---
STRIPE_SECRET_KEY = getattr(settings, "STRIPE_SECRET_KEY", None)
STRIPE_WEBHOOK_SECRET = getattr(settings, "STRIPE_WEBHOOK_SECRET", None)
WHATSAPP_MEDICO_AVISO = getattr(settings, "WHATSAPP_MEDICO_AVISO", None) # Número para notificar médico

if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logger.info("STRIPE Route: Chave secreta do Stripe configurada.")
else:
    logger.error("STRIPE Route: ❌ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada. Webhook NÃO FUNCIONARÁ.")

if not STRIPE_WEBHOOK_SECRET:
     logger.error("STRIPE Route: ❌ Chave secreta do webhook Stripe (STRIPE_WEBHOOK_SECRET) não configurada. Verificação de assinatura FALHARÁ.")


@router.post("/stripe/", summary="Recebe eventos do webhook do Stripe")
async def stripe_webhook(request: Request, background_tasks: BackgroundTasks, stripe_signature: str = Header(None)):
    """
    Endpoint para receber eventos do Stripe via webhook.
    Verifica a assinatura e processa eventos relevantes (ex: checkout.session.completed).
    Delega o processamento pesado para uma task em background.
    """
    # Verifica se a chave do webhook está configurada (essencial para segurança)
    if not STRIPE_WEBHOOK_SECRET:
        logger.critical("STRIPE Route: ❌ Processamento abortado - STRIPE_WEBHOOK_SECRET não configurado no servidor.")
        raise HTTPException(status_code=500, detail="Configuração de webhook incompleta no servidor.")

    # Obtém o corpo bruto da requisição
    payload = await request.body()
    logger.debug(f"STRIPE Route: Payload recebido: {payload[:200]}...") # Log inicial do payload

    # Verifica a assinatura do webhook para garantir que veio do Stripe
    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
        logger.info(f"STRIPE Route: Evento verificado tipo: {event['type']} (ID: {event['id']})")
    except ValueError as e:
        # Payload inválido
        logger.error(f"STRIPE Route: ❌ Erro ao decodificar payload do webhook (ValueError): {e}")
        raise HTTPException(status_code=400, detail="Payload inválido.")
    except stripe.error.SignatureVerificationError as e:
        # Assinatura inválida
        logger.error(f"STRIPE Route: ❌ Erro na verificação da assinatura do webhook: {e}")
        raise HTTPException(status_code=400, detail="Assinatura inválida.")
    except Exception as e:
        logger.exception("STRIPE Route: ❌ Erro inesperado ao construir evento do webhook:")
        raise HTTPException(status_code=500, detail="Erro interno ao processar webhook.")

    # --- Processamento do Evento (em Background) ---
    # Adiciona a tarefa de processar o evento em background para liberar a resposta rapidamente
    background_tasks.add_task(processar_evento_stripe, event)
    logger.debug(f"STRIPE Route: Tarefa em background adicionada para evento {event['id']}")

    # Retorna 200 OK imediatamente para o Stripe confirmar recebimento
    return {"status": "recebido"}

async def processar_evento_stripe(event: dict):
    """
    Função executada em background para processar o evento do Stripe.
    Foca no evento 'checkout.session.completed'.
    """
    event_type = event["type"]
    try:
        session = event["data"]["object"] # O objeto da sessão de checkout
        session_id = session.get("id", "N/A")
        logger.info(f"STRIPE BG Task: Iniciando processamento para evento tipo: {event_type} (Sessão ID: {session_id})")
    except Exception as e:
        logger.exception(f"STRIPE BG Task: Erro ao acessar dados do evento: {e}")
        return # Não pode continuar sem os dados da sessão

    # --- Evento: Checkout Concluído com Sucesso ---
    if event_type == "checkout.session.completed":
        # Extrai metadados e informações do cliente da sessão Stripe
        metadata = session.get("metadata", {})
        telefone_cliente = metadata.get("telefone")
        nome_cliente_meta = metadata.get("nome") # Nome dos metadados (enviado na criação da sessão)

        customer_details = session.get("customer_details", {})
        email_cliente = customer_details.get("email")
        # O nome pode vir do customer_details se o cliente já existir no Stripe
        nome_cliente_stripe = customer_details.get("name")

        # Define o nome final a ser usado, priorizando metadados
        nome_final = nome_cliente_meta or nome_cliente_stripe or "Cliente" # Fallback

        # Verifica se temos o telefone (essencial para continuar)
        if not telefone_cliente:
            logger.error(f"STRIPE BG Task: ❌ Evento {event_type} (Sessão: {session_id}) SEM 'telefone' nos metadados. Impossível continuar.")
            # Considerar notificar admin sobre pagamento órfão
            return # Aborta o processamento

        logger.info(f"STRIPE BG Task: Checkout concluído para {nome_final} ({telefone_cliente}). Sessão: {session_id}")

        # --- Marca Pagamento e Tenta Agendar ---
        try:
            # Chama a função que atualiza o DB de pagamentos e tenta agendar a consulta
            # ATENÇÃO: Se marcar_pagamento for SÍNCRONA, use asyncio.to_thread
            # horario_agendado_utc, nome_agendado = await asyncio.to_thread(
            #      marcar_pagamento, # Executa a função síncrona em uma thread separada
            #      telefone=telefone_cliente,
            #      id_sessao_stripe=session_id,
            #      email_cliente=email_cliente,
            #      nome_cliente=nome_final
            # )
            # Se marcar_pagamento for ASSÍNCRONA:
            horario_agendado_utc, nome_agendado = await marcar_pagamento(
                telefone=telefone_cliente,
                id_sessao_stripe=session_id,
                email_cliente=email_cliente,
                nome_cliente=nome_final
            )

            # --- Processa Resultado do Agendamento ---
            if horario_agendado_utc:
                # Agendamento bem-sucedido!
                horario_formatado = formatar_horario_local(horario_agendado_utc)
                logger.info(f"STRIPE BG Task: ✅ Agendamento realizado para {telefone_cliente} em {horario_formatado}.")

                # Monta mensagem de confirmação para o paciente
                msg_paciente = (
                    f"✅ Olá {nome_agendado}, pagamento confirmado!\n\n"
                    f"Sua consulta inicial está agendada para:\n"
                    f"🗓️ **{horario_formatado}** (Horário de Brasília).\n\n"
                    f"O profissional entrará em contato com você por aqui neste horário. Até lá!"
                )
                # Envia a confirmação para o paciente
                await enviar_mensagem(telefone_cliente, msg_paciente)

                # Notifica o médico/equipe (opcional)
                if WHATSAPP_MEDICO_AVISO:
                    try:
                        msg_medico = f"👨‍⚕️ Novo agendamento confirmado:\nPaciente: {nome_agendado}\nTelefone: {telefone_cliente}\nHorário: {horario_formatado}"
                        await enviar_mensagem(WHATSAPP_MEDICO_AVISO, msg_medico)
                        logger.info(f"STRIPE BG Task: Notificação de agendamento enviada para {WHATSAPP_MEDICO_AVISO}.")
                    except Exception as notify_err:
                        logger.error(f"STRIPE BG Task: Falha ao enviar notificação para médico ({WHATSAPP_MEDICO_AVISO}): {notify_err}")

                # --- ATUALIZA O ESTADO DA CONVERSA (MUITO IMPORTANTE) ---
                # Muda o estado para que o Orquestrador saiba que a próxima interação
                # deve iniciar o questionário de triagem.
                logger.info(f"STRIPE BG Task: Atualizando estado para 'TRIAGEM_INICIAL' para {telefone_cliente}")
                sucesso_save = salvar_contexto(
                    telefone=telefone_cliente,
                    estado="TRIAGEM_INICIAL", # Estado que o Orquestrador usará para chamar DomoTriagem
                    meta_conversa={"email_cliente": email_cliente, "nome_cliente": nome_agendado} # Atualiza meta com dados do pagamento
                )
                if not sucesso_save:
                     logger.error(f"STRIPE BG Task: ❌ FALHA CRÍTICA ao atualizar estado para TRIAGEM_INICIAL para {telefone_cliente} após pagamento.")
                     # Considerar notificar admin

            else:
                # Falha no agendamento após pagamento (marcar_pagamento retornou None para horário)
                logger.error(f"STRIPE BG Task: ❌ Pagamento confirmado para {telefone_cliente}, mas FALHA AO AGENDAR consulta (marcar_pagamento falhou).")
                # Envia mensagem de erro para o paciente
                msg_erro_agendamento = (
                    f"⚠️ Olá {nome_agendado or nome_final}, seu pagamento foi confirmado, mas houve um problema ao agendar automaticamente sua consulta.\n\n"
                    f"Não se preocupe, nossa equipe já foi notificada e entrará em contato em breve para finalizar o agendamento manualmente. Obrigado pela compreensão."
                )
                await enviar_mensagem(telefone_cliente, msg_erro_agendamento)
                # TODO: Implementar notificação para equipe interna sobre a falha no agendamento automático

        except Exception as proc_err:
            logger.exception(f"STRIPE BG Task: ❌ Erro inesperado ao processar pagamento/agendamento para sessão {session_id} (Telefone: {telefone_cliente}): {proc_err}")
            # Enviar mensagem de erro genérica, se possível
            try:
                 await enviar_mensagem(telefone_cliente, "Desculpe, tivemos um problema interno ao processar seu pagamento e agendamento. Nossa equipe verificará.")
            except Exception:
                 logger.error(f"STRIPE BG Task: Falha ao enviar mensagem de erro genérica para {telefone_cliente} após erro de processamento.")

    # --- Outros Eventos (Opcional) ---
    # elif event_type == "checkout.session.async_payment_failed":
    #     logger.warning(f"STRIPE BG Task: Pagamento assíncrono falhou para sessão {session_id}")
    #     # Lógica para lidar com falha (ex: notificar usuário)
    # elif event_type == "checkout.session.expired":
    #      logger.info(f"STRIPE BG Task: Sessão de checkout expirada: {session_id}")
         # Lógica para lidar com expiração (ex: marcar no DB, talvez enviar follow-up)

    else:
        # Evento não tratado explicitamente
        logger.info(f"STRIPE BG Task: Evento tipo '{event_type}' (Sessão: {session_id}) recebido, mas não tratado.")

    logger.info(f"STRIPE BG Task: Processamento do evento {event_type} (Sessão: {session_id}) concluído.")


# Arquivo: app/routes/admin.py
from fastapi import APIRouter, Response, Depends, HTTPException
from app.core.metrics import prometheus_response, json_response
from app.config import settings

router = APIRouter(prefix="/admin", tags=["Admin"])

def _auth(token: str):
    if token != getattr(settings, "API_KEY", None):
        raise HTTPException(status_code=403)

@router.get("/metrics")
def metrics(token: str = Depends(_auth)):
    data, content_type = prometheus_response()
    return Response(content=data, media_type=content_type)

@router.get("/stats")
def stats(token: str = Depends(_auth)):
    return json_response()

# Arquivo: app/routes/sugestao.py
"""
Rotas de Sugestão de Próximo Passo – FAMDOMES
Gera orientação da IA para o profissional com base no histórico recente
"""

from __future__ import annotations

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel
from app.utils.contexto import obter_contexto
from app.utils.ia import gerar_sugestao_proximo_passo  # wrapper p/ Ollama

router = APIRouter(prefix="/sugestao", tags=["Sugestão"])


class SugestaoResp(BaseModel):
    telefone: str
    sugestao: str


@router.get(
    "/{telefone}",
    response_model=SugestaoResp,
    summary="IA sugere próximo passo para a conversa",
)
async def sugerir_proximo_passo(telefone: str) -> SugestaoResp:
    ctx = obter_contexto(telefone)
    if not ctx:
        raise HTTPException(404, "Conversa não encontrada")

    sugestao = await gerar_sugestao_proximo_passo(ctx)
    return SugestaoResp(telefone=telefone, sugestao=sugestao)


# Adicione no main.py:
#     from app.routes.sugestao import router as sugestao_router
#     app.include_router(sugestao_router)

# Arquivo: app/routes/entrada.py

"""
Webhook de entrada para mensagens (WhatsApp ou futuro canal).
Encaminha para o MCP Orquestrador.
"""
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, constr
from app.core.mcp_orquestrador import MCPOrquestrador

router = APIRouter(tags=["Entrada"])

class MensagemIn(BaseModel):
    telefone: constr(strip_whitespace=True, min_length=8)
    texto:    constr(strip_whitespace=True, min_length=1)

@router.post("/", status_code=status.HTTP_202_ACCEPTED)
async def receber_mensagem(msg: MensagemIn):
    try:
        await MCPOrquestrador().processar_mensagem(msg.telefone, msg.texto)
    except Exception as exc:  # pragma: no cover
        raise HTTPException(500, "Erro interno ao processar mensagem") from exc
    return {"status": "aceito"}

# Arquivo: app/routes/dashboard.py
# ===========================================================
# Arquivo: app/routes/dashboard.py
# Define as rotas da API FastAPI para o frontend do Domo Hub.
# VERIFICAÇÃO FINAL DE INDENTAÇÃO: Linhas de import e nível superior
# devem começar na coluna 1, sem espaços antes.
# ===========================================================
import logging # <-- SEM ESPAÇOS ANTES
from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordRequestForm
from typing import List, Dict, Any, Optional
from datetime import timedelta, datetime, timezone

# Imports da aplicação
try:
    from app.schemas.dashboard import (
        KanbanBoard, KanbanColumn, ConversationCard, ConversationDetail, Message,
        UpdateStateRequest, SendHumanMessageRequest, SimulateUserMessageRequest,
        Token, User
    )
    # Usar a versão temporária de auth.py que ignora a senha
    from app.core.auth import (
        create_access_token, get_current_active_user, # MANTÉM ESTES
        ACCESS_TOKEN_EXPIRE_MINUTES, oauth2_scheme
        # authenticate_user # Comentado na versão temporária
    )
    from app.utils.contexto import obter_contexto, salvar_contexto, respostas_ia_db, contextos_db
    from app.utils.mensageria import enviar_mensagem
    from app.core.mcp_orquestrador import MCPOrquestrador
# Indentação correta
except ImportError as e:
    # Indentação correta
    logging.basicConfig(level="INFO")
    logging.critical(f"DASHBOARD_API: Erro Crítico de Importação: {e}. Verifique os caminhos.")
    raise e

# Nível superior - sem indentação
logger = logging.getLogger("famdomes.dashboard_api")
router = APIRouter(prefix="/dashboard", tags=["Dashboard"])

# --- Rota de Autenticação (Temporária) ---
@router.post("/token", response_model=Token, summary="Obtém token de acesso (LOGIN TEMPORÁRIO)")
async def login_for_access_token_temporary(form_data: OAuth2PasswordRequestForm = Depends()):
    # Indentação de 4 espaços
    """
    *** LOGIN TEMPORÁRIO E INSEGURO PARA DESENVOLVIMENTO ***
    Gera um token para o usuário 'admin' (ou o digitado) sem verificar a senha.
    """
    username_for_token = form_data.username
    logger.warning(f"!!! USANDO LOGIN TEMPORÁRIO E INSEGURO para usuário: '{username_for_token}' !!!")

    if not username_for_token:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username cannot be empty"
         )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": username_for_token},
        expires_delta=access_token_expires
    )
    logger.info(f"Token TEMPORÁRIO gerado com sucesso para usuário: '{username_for_token}'")
    return {"access_token": access_token, "token_type": "bearer"}

# --- Rota para verificar usuário atual ---
@router.get("/users/me", response_model=User, summary="Obtém informações do usuário atual")
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    """Retorna os dados do usuário autenticado pelo token."""
    logger.info(f"Rota /users/me acessada por usuário: {current_user.username}")
    return current_user

# --- Rota do Kanban ---
@router.get("/kanban", response_model=KanbanBoard, summary="Obtém dados do quadro Kanban")
async def get_kanban_board(current_user: User = Depends(get_current_active_user)):
    """Busca conversas no MongoDB e as organiza nas colunas do Kanban."""
    logger.info(f"Usuário '{current_user.username}' solicitou dados do Kanban.")
    if contextos_db is None:
         logger.error("API Kanban: DB não conectado.")
         raise HTTPException(status_code=503, detail="Serviço indisponível (DB)")

    colunas_definidas: Dict[str, str] = {
        "entrada": "Entrada", "qualificacao": "Qualificação", "proposta": "Proposta",
        "pagamento_pendente": "Pagamento Pendente", "triagem": "Triagem Pós-Pgto",
        "agendado": "Agendado", "atendimento_humano": "Atendimento Humano",
        "followup": "Follow-up", "concluido": "Concluído/Perdido",
    }
    mapa_estado_coluna: Dict[str, str] = {
        "INICIAL": "entrada", "ACOLHIMENTO_ENVIADO": "entrada",
        "MICRO_COMPROMISSO": "qualificacao",
        "PITCH_PLANO1": "proposta", "PITCH_PLANO3": "proposta", "COMERCIAL_DETALHES_PLANO": "proposta",
        "CALL_TO_ACTION": "pagamento_pendente", "AGUARDANDO_PAGAMENTO": "pagamento_pendente",
        "TRIAGEM_INICIAL": "triagem", "COLETANDO_RESPOSTA_QUESTIONARIO": "triagem",
        "FINALIZANDO_ONBOARDING": "agendado", "AGUARDANDO_CONSULTA": "agendado",
        "AGUARDANDO_ATENDENTE": "atendimento_humano", "RISCO_DETECTADO": "atendimento_humano", "ATENDIMENTO_EM_ANDAMENTO": "atendimento_humano",
        "RECUSA_PRECO": "followup",
        "LEAD_MATERIAL_GRATUITO": "concluido", "FINALIZADO_SEM_VENDA": "concluido",
    }
    coluna_default = "concluido"

    try:
        all_contexts_cursor = contextos_db.find().sort("ts", -1).limit(200)
        all_contexts = list(all_contexts_cursor)
        logger.info(f"API Kanban: {len(all_contexts)} contextos encontrados.")

        cards_por_coluna: Dict[str, List[ConversationCard]] = {col_id: [] for col_id in colunas_definidas}

        for ctx in all_contexts:
            estado_atual = ctx.get("estado", "INICIAL")
            coluna_id = mapa_estado_coluna.get(estado_atual, coluna_default)
            meta = ctx.get("meta_conversa", {})
            if not isinstance(meta, dict): meta = {}

            card_data = {
                "tel": ctx.get("tel", "N/A"),
                "nome": meta.get("nome_cliente") or ctx.get("nome"),
                "estado": estado_atual,
                "ts": ctx.get("ts", datetime.now(timezone.utc)),
                "ultima_mensagem_snippet": (ctx.get("ultimo_texto_bot") or ctx.get("ultimo_texto_usuario", ""))[:50] + "...",
                "score_lead": meta.get("score_lead"),
                "risco_detectado": meta.get("ultimo_risco") is not None,
                "atendente_humano_necessario": estado_atual in ["AGUARDANDO_ATENDENTE", "RISCO_DETECTADO"]
            }
            sentimento = meta.get("ultimo_sentimento_detectado")
            if isinstance(sentimento, dict) and sentimento:
                 card_data["sentimento_predominante"] = max(sentimento, key=sentimento.get, default=None)

            cards_por_coluna.get(coluna_id, cards_por_coluna[coluna_default]).append(ConversationCard(**card_data))

        kanban_columns = [
            KanbanColumn(id=col_id, title=title, cards=cards_por_coluna[col_id])
            for col_id, title in colunas_definidas.items()
        ]
        return KanbanBoard(columns=kanban_columns)

    except Exception as e:
        logger.exception(f"API Kanban: Erro ao buscar ou processar dados: {e}")
        raise HTTPException(status_code=500, detail="Erro ao gerar dados do Kanban.")

# --- Rotas de Conversa ---
@router.get("/conversations/{telefone}", response_model=ConversationDetail, summary="Obtém detalhes de uma conversa")
async def get_conversation_detail(telefone: str, current_user: User = Depends(get_current_active_user)):
    """Busca o contexto e o histórico de mensagens para um telefone específico."""
    logger.info(f"Usuário '{current_user.username}' solicitou detalhes da conversa de {telefone}.")
    if contextos_db is None or respostas_ia_db is None:
         logger.error(f"API Detalhes ({telefone}): DB não conectado.")
         raise HTTPException(status_code=503, detail="Serviço indisponível (DB)")

    try:
        contexto_doc = obter_contexto(telefone)
        if not contexto_doc or "tel" not in contexto_doc :
             logger.warning(f"API Detalhes ({telefone}): Contexto não encontrado ou inválido.")
             raise HTTPException(status_code=404, detail="Conversa não encontrada.")

        historico_cursor = respostas_ia_db.find({"telefone": telefone}).sort("criado_em", 1).limit(200)

        historico_formatado: List[Message] = []
        last_timestamp = None
        for msg_doc in historico_cursor:
            doc_id = str(msg_doc.get("_id"))
            timestamp = msg_doc.get("criado_em", datetime.now(timezone.utc))

            if msg_doc.get("mensagem_usuario"):
                 user_ts = timestamp - timedelta(milliseconds=10) if last_timestamp and timestamp == last_timestamp else timestamp
                 historico_formatado.append(Message(
                     id=f"{doc_id}_user",
                     criado_em=user_ts,
                     sender="user",
                     mensagem_usuario_ou_resposta_gerada=msg_doc.get("mensagem_usuario"),
                     intent=msg_doc.get("intent_detectada"),
                     sentimento=msg_doc.get("sentimento_detectado")
                 ))

            if msg_doc.get("resposta_gerada"):
                sender = "human" if msg_doc.get("enviado_por_humano") else "bot"
                historico_formatado.append(Message(
                    id=doc_id,
                    criado_em=timestamp,
                    sender=sender,
                    mensagem_usuario_ou_resposta_gerada=msg_doc.get("resposta_gerada"),
                    intent=None,
                    sentimento=None
                ))
            last_timestamp = timestamp

        meta = contexto_doc.get("meta_conversa", {})
        if not isinstance(meta, dict): meta = {}

        return ConversationDetail(
            tel=contexto_doc.get("tel"),
            nome=meta.get("nome_cliente") or contexto_doc.get("nome"),
            estado=contexto_doc.get("estado"),
            contexto=contexto_doc,
            historico=historico_formatado
        )

    except HTTPException as http_exc:
         raise http_exc
    except Exception as e:
        logger.exception(f"API Detalhes ({telefone}): Erro ao buscar dados: {e}")
        raise HTTPException(status_code=500, detail="Erro ao buscar detalhes da conversa.")

@router.put("/conversations/{telefone}/state", status_code=status.HTTP_204_NO_CONTENT, summary="Atualiza o estado de uma conversa")
async def update_conversation_state(
    telefone: str,
    request_body: UpdateStateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """Permite atualizar manualmente o estado de uma conversa."""
    novo_estado = request_body.novo_estado
    logger.info(f"Usuário '{current_user.username}' solicitou mudança de estado para '{novo_estado}' para {telefone}.")

    sucesso = salvar_contexto(
        telefone=telefone,
        estado=novo_estado,
        incrementar_interacoes=False
    )
    if not sucesso:
        logger.error(f"API Update State ({telefone}): Falha ao salvar novo estado '{novo_estado}'.")
        raise HTTPException(status_code=500, detail="Falha ao atualizar estado da conversa.")
    logger.info(f"API Update State ({telefone}): Estado atualizado para '{novo_estado}' com sucesso.")


@router.post("/conversations/{telefone}/send_human", status_code=status.HTTP_201_CREATED, summary="Envia mensagem como humano")
async def send_human_message(
    telefone: str,
    request_body: SendHumanMessageRequest,
    current_user: User = Depends(get_current_active_user)
):
    """Envia uma mensagem para o usuário via WhatsApp como se fosse um atendente humano."""
    texto_mensagem = request_body.texto
    logger.info(f"Usuário '{current_user.username}' enviando mensagem humana para {telefone}: '{texto_mensagem[:50]}...'")

    if not texto_mensagem:
        raise HTTPException(status_code=400, detail="Texto da mensagem não pode ser vazio.")

    try:
        resultado_envio = await enviar_mensagem(telefone, texto_mensagem)

        if resultado_envio.get("status") != "enviado" and resultado_envio.get("code") != 200:
             logger.error(f"API Send Human ({telefone}): Falha ao enviar mensagem via WhatsApp: {resultado_envio.get('erro')}")
             raise HTTPException(status_code=502, detail=f"Falha ao enviar mensagem: {resultado_envio.get('erro')}")

        from app.utils.contexto import salvar_resposta_ia
        salvou_hist = salvar_resposta_ia(
            telefone=telefone,
            canal="dashboard",
            mensagem_usuario="",
            resposta_gerada=texto_mensagem,
            intent="intervencao_humana",
            nome_agente=current_user.username,
            enviado_por_humano=True
        )
        if not salvou_hist:
             logger.error(f"API Send Human ({telefone}): Mensagem enviada, mas FALHA ao salvar no histórico.")

        salvou_ctx = salvar_contexto(telefone=telefone, estado="ATENDIMENTO_EM_ANDAMENTO", incrementar_interacoes=False)
        if not salvou_ctx:
             logger.error(f"API Send Human ({telefone}): Mensagem enviada e histórico salvo, mas FALHA ao atualizar estado.")

        logger.info(f"API Send Human ({telefone}): Mensagem enviada e registrada com sucesso.")
        return {"status": "mensagem enviada"}

    except Exception as e:
        logger.exception(f"API Send Human ({telefone}): Erro inesperado: {e}")
        raise HTTPException(status_code=500, detail="Erro interno ao enviar mensagem humana.")

@router.post("/conversations/{telefone}/simulate_user", status_code=status.HTTP_200_OK, summary="Simula mensagem do usuário")
async def simulate_user_message(
    telefone: str,
    request_body: SimulateUserMessageRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Recebe um texto e o processa pelo MCPOrquestrador como se o usuário
    tivesse enviado essa mensagem. NÃO envia para o WhatsApp.
    """
    texto_simulado = request_body.texto
    logger.info(f"Usuário '{current_user.username}' simulando mensagem para {telefone}: '{texto_simulado[:50]}...'")

    if not texto_simulado:
        raise HTTPException(status_code=400, detail="Texto simulado não pode ser vazio.")

    try:
        orquestrador = MCPOrquestrador()
        await orquestrador.processar_mensagem(telefone, texto_simulado)
        contexto_atualizado = obter_contexto(telefone)

        logger.info(f"API Simulate User ({telefone}): Simulação processada. Estado final: {contexto_atualizado.get('estado')}")
        return {
            "status": "simulacao_concluida",
            "estado_resultante": contexto_atualizado.get("estado"),
            "resposta_bot_simulada": contexto_atualizado.get("ultimo_texto_bot"),
        }

    except Exception as e:
        logger.exception(f"API Simulate User ({telefone}): Erro durante simulação: {e}")
        raise HTTPException(status_code=500, detail="Erro interno ao simular mensagem.")


# Arquivo: app/routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Arquivo: app/routes/agendamento.py
# ===========================================================
# Arquivo: routes/agendamento.py
# (Corrigido para importar a função correta de agenda.py)
# ===========================================================
from fastapi import APIRouter, HTTPException
import logging

# Ajuste o import conforme a estrutura do seu projeto
# Importa a função correta para consultar o próximo horário
from app.utils.agenda import consultar_proximo_horario_disponivel, formatar_horario_local

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/agenda", tags=["Agendamento"]) # Adiciona prefixo e tag

@router.get("/proximo", summary="Consulta o próximo horário de agendamento disponível")
async def proximo_agendamento_disponivel():
    """
    Endpoint para verificar o próximo horário livre na agenda.
    Retorna o horário formatado ou uma mensagem indicando indisponibilidade.
    """
    logging.info("AGENDAMENTO Route: Consultando próximo horário disponível...")
    try:
        # Chama a função correta para obter o próximo horário UTC
        horario_utc = consultar_proximo_horario_disponivel()

        if horario_utc:
            # Formata o horário para o fuso local
            horario_formatado = formatar_horario_local(horario_utc)
            logging.info(f"AGENDAMENTO Route: Próximo horário encontrado: {horario_formatado}")
            return {"proximo_horario_disponivel": horario_formatado, "horario_utc": horario_utc.isoformat()}
        else:
            # Se a função retornar None (sem horário ou erro no DB)
            logging.info("AGENDAMENTO Route: Nenhum horário disponível encontrado.")
            return {"proximo_horario_disponivel": None, "mensagem": "Nenhum horário disponível encontrado no momento."}
    except Exception as e:
        # Captura qualquer erro inesperado durante a consulta
        logging.exception("AGENDAMENTO Route: ❌ Erro inesperado ao consultar próximo horário:")
        raise HTTPException(status_code=500, detail="Erro interno ao consultar a agenda.")


# Arquivo: app/routes/whatsapp.py
# ===========================================================
# Arquivo: routes/whatsapp.py
# Webhook Cloud API → MCPOrquestrador
# ===========================================================
from __future__ import annotations

import json
import logging
from fastapi import APIRouter, BackgroundTasks, Request, Response, status, HTTPException
from pydantic import BaseModel, constr
from app.config import WHATSAPP_VERIFY_TOKEN
from app.core.mcp_orquestrador import MCPOrquestrador
from app.utils.mensageria import enviar_mensagem
from app.utils.contexto import limpar_contexto

logger = logging.getLogger("famdomes.whatsapp")

router = APIRouter(prefix="/chat/webhook/whatsapp", tags=["WhatsApp"])

# ----------------------------------------------------------------------
# 1 · Verificação inicial da Meta
@router.get("/", summary="Verifica webhook do WhatsApp")
async def verificar_webhook(request: Request) -> Response:
    args = request.query_params
    if (
        args.get("hub.mode") == "subscribe"
        and args.get("hub.verify_token") == WHATSAPP_VERIFY_TOKEN
    ):
        logger.info("Webhook WhatsApp verificado com sucesso.")
        return Response(content=args.get("hub.challenge"), media_type="text/plain")
    logger.warning("Falha na verificação do webhook – token incorreto.")
    raise HTTPException(status_code=403, detail="Token inválido")

# ----------------------------------------------------------------------
# 2 · Modelo interno para facilitar debug (não exposto na API)
class _WhatsappMsg(BaseModel):
    telefone: constr(strip_whitespace=True, min_length=8)
    texto: constr(strip_whitespace=True, min_length=1)

# ----------------------------------------------------------------------
# 3 · Recepção de mensagens
@router.post("/", status_code=status.HTTP_200_OK, summary="Webhook WhatsApp (POST)")
async def receber_mensagem(
    request: Request,
    background_tasks: BackgroundTasks,
) -> Response:
    """
    Recebe payload da Cloud API, extrai texto e delega ao MCP
    em task de background (latência mínima p/ Meta).
    """
    data = await request.json()
    try:
        entry = data["entry"][0]
        changes = entry["changes"][0]
        value = changes["value"]
    except (KeyError, IndexError, TypeError):
        # payload diferente (status, etc.) ⇒ apenas 200
        return Response(status_code=200)

    # Eventos de status não contêm 'messages'
    messages = value.get("messages", [])
    if not messages:
        return Response(status_code=200)

    msg = messages[0]
    if "text" not in msg or "body" not in msg["text"]:
        return Response(status_code=200)  # apenas mídia, voice, etc.

    texto = msg["text"]["body"].strip()
    telefone = msg["from"]

    # Comando de reset (não vai ao MCP)
    gatilho_reset = texto.lower().replace("\u200b", "").strip()  # remove zero‑width
    if gatilho_reset.startswith("melancia") and "vermelha" in gatilho_reset:
        background_tasks.add_task(_resetar_conversa, telefone)
        return Response(status_code=200)

    # Normal: delega ao MCP em background
    background_tasks.add_task(_processar_mcp, telefone, texto)
    return Response(status_code=200)

# ----------------------------------------------------------------------
# 4 · Task: reset
async def _resetar_conversa(telefone: str) -> None:
    limpar_contexto(telefone)        # ignoramos retorno: sempre zera
    await enviar_mensagem(
        telefone,
        "🔄 Sua conversa foi reiniciada. Pode começar de novo!",
    )
    logger.info("Reset concluído para %s", telefone)


# ----------------------------------------------------------------------
# 5 · Task: encaminhar para MCP
async def _processar_mcp(telefone: str, texto: str) -> None:
    try:
        await MCPOrquestrador().processar_mensagem(telefone, texto)
    except Exception as exc:  # pragma: no cover
        logger.exception("MCP erro para %s: %s", telefone, exc)
        await enviar_mensagem(
            telefone,
            "⚠️ Desculpe, houve um erro interno. Tente novamente em instantes.",
        )

# Arquivo: app/routes/dashboard_analytics.py
from fastapi import APIRouter, Depends
from fastapi.security import OAuth2PasswordBearer
from app.core.metrics import atualizar, LEADS, QUALIFICADOS, PAGOS, TEMPO_PG_SECS


router = APIRouter(prefix="/dashboard/analytics", tags=["Dashboard"])

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="dashboard/token")  # reaproveita auth existente

def _collect() -> dict:
    atualizar()  # atualiza gauges
    return {
        "leads": LEADS._value.get(),
        "qualificados": QUALIFICADOS._value.get(),
        "pagos": PAGOS._value.get(),
        "tempo_pg_segundos": TEMPO_PG_SECS._value.get(),
    }

@router.get("", summary="KPIs para o dashboard")
async def get_analytics(_: str = Depends(oauth2_scheme)):
    return _collect()

# Arquivo: app/routes/ia.py
# ===========================================================
# Arquivo: routes/ia.py
# (Contém a lógica para processar comandos específicos como agendar)
# ===========================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import logging
import stripe # Importa a biblioteca do Stripe
from datetime import datetime, timedelta # Para expiração da sessão

# Ajuste os imports das funções utilitárias conforme a estrutura do seu projeto
# Assume que estão em app/utils/
from app.utils.agenda import (
    agendar_consulta,
    cancelar_consulta,
    consultar_proximo_horario_disponivel,
    formatar_horario_local
)
from app.utils.mensageria import enviar_mensagem
# Assume que followup.py existe e tem iniciar_sessao (se usado)
# from app.utils.followup import iniciar_sessao
# Assume que config.py existe e tem a chave do Stripe
from app.config import STRIPE_SECRET_KEY

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter()

# Define a chave secreta do Stripe (carregada da configuração)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("IA Route: Chave secreta do Stripe configurada.")
else:
    logging.warning("IA Route: ⚠️ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada.")
    # Considerar levantar um erro ou desabilitar funcionalidade de pagamento

# Modelo Pydantic para validar a entrada da API /ia-comando (se usada)
class ComandoIAInput(BaseModel):
    telefone: str
    nome: str
    comando: str # Ex: "quero agendar", "ver horário", "cancelar"

# --- Endpoint da API (Opcional) ---
@router.post("/ia-comando", summary="Processa comandos específicos da IA", tags=["IA"])
async def processar_comando_post(dados: ComandoIAInput):
    """
    Recebe um comando específico (agendar, cancelar, ver horário)
    e executa a ação correspondente. (Endpoint HTTP opcional)
    """
    # Verifica se a API do Stripe está configurada antes de prosseguir com agendamento
    if "agendar" in dados.comando.lower() and not STRIPE_SECRET_KEY:
         logging.error("IA Route: ❌ Tentativa de agendamento via API sem STRIPE_SECRET_KEY.")
         raise HTTPException(status_code=503, detail="Funcionalidade de pagamento indisponível.")

    # Chama a função principal que processa o comando
    resultado = await processar_comando(dados.dict())
    # Retorna o resultado da função
    return resultado

# --- Função Principal de Processamento de Comandos ---
# Esta função é chamada pelo endpoint acima e também diretamente por nlp.py

async def processar_comando(dados: dict) -> dict:
    """
    Processa comandos específicos vindos da interação do usuário ou da IA.

    Args:
        dados (dict): Dicionário contendo 'telefone', 'nome' e 'comando'.

    Returns:
        dict: Dicionário com o status da operação e mensagens relevantes.
    """
    telefone = dados.get("telefone")
    nome = dados.get("nome", "Cliente") # Usa 'Cliente' como nome padrão
    comando = dados.get("comando", "").lower() # Pega o comando e converte para minúsculas

    # Validação básica de entrada
    if not telefone or not comando:
        logging.warning("IA Route: Comando recebido sem telefone ou comando.")
        # Retorna um erro ou uma resposta padrão indicando falha
        # Não levanta HTTPException aqui pois pode ser chamado internamente por nlp.py
        return {"status": "erro_input", "mensagem": "Dados insuficientes para processar comando."}

    logging.info(f"IA Route: Processando comando '{comando}' para {telefone} ({nome})...")

    # --- Lógica para Comando "agendar" ---
    if "agendar" in comando:
        # Verifica novamente se Stripe está configurado
        if not STRIPE_SECRET_KEY:
            logging.error("IA Route: ❌ Tentativa de agendamento sem STRIPE_SECRET_KEY configurada.")
            msg_erro = "Desculpe, a opção de agendamento online não está disponível no momento."
            # Não envia mensagem aqui, pois nlp.py tratará a resposta
            # await enviar_mensagem(telefone, msg_erro)
            return {"status": "erro_config_stripe", "mensagem": msg_erro}

        # TODO: Descomentar se a função iniciar_sessao for usada para tracking
        # Inicia a sessão de pagamento/follow-up (se aplicável)
        # iniciar_sessao(telefone, nome) # Registra a tentativa no DB de follow-up

        try:
            # Cria uma sessão de checkout no Stripe
            logging.info(f"IA Route: Criando sessão Stripe Checkout para {telefone}...")
            # Define o URL base (pode vir do .env)
            base_url = os.getenv("APP_BASE_URL", "[https://famdomes.com.br](https://famdomes.com.br)") # Exemplo
            success_url = f"{base_url}/sucesso?session_id={{CHECKOUT_SESSION_ID}}"
            cancel_url = f"{base_url}/cancelado"

            session = stripe.checkout.Session.create(
                payment_method_types=["card", "boleto"], # Aceita cartão e boleto
                line_items=[{
                    "price_data": {
                        "currency": "brl", # Moeda brasileira
                        "product_data": {"name": "Consulta Inicial FAMDOMES"}, # Nome do produto
                        "unit_amount": 10000, # Preço em centavos (R$ 100,00)
                    },
                    "quantity": 1, # Quantidade
                }],
                mode="payment", # Modo de pagamento único
                # URLs para redirecionamento após sucesso ou cancelamento
                success_url=success_url,
                cancel_url=cancel_url,
                # Metadados para identificar o cliente no webhook
                metadata={
                    "telefone": telefone,
                    "nome": nome
                },
                # Configuração para Boleto (opcional, mas recomendada)
                payment_intent_data={
                     # 'setup_future_usage': 'off_session' # Pode não ser necessário para pagamentos únicos
                },
                # Expiração da sessão de checkout (ex: 2 horas)
                expires_at=int((datetime.now() + timedelta(hours=2)).timestamp())
            )
            logging.info(f"IA Route: Sessão Stripe criada com ID: {session.id} para {telefone}")

            # Monta a mensagem com o link de pagamento para o usuário
            msg_link = f"✅ Ótimo! Para agendar sua consulta inicial (valor R$100,00), por favor, realize o pagamento seguro através deste link:\n{session.url}\n\nO link expira em breve."
            # A mensagem será enviada por nlp.py, aqui apenas retornamos os dados
            # await enviar_mensagem(telefone, msg_link)
            # Retorna o status e a URL de checkout
            return {"status": "link_gerado", "checkout_url": session.url, "mensagem": msg_link}

        except stripe.error.StripeError as e:
             # Erro específico do Stripe
             logging.error(f"IA Route: ❌ Erro Stripe ao criar checkout para {telefone}: {e}")
             msg_erro = "❌ Desculpe, ocorreu um erro ao tentar gerar o link de pagamento com nosso parceiro. Por favor, tente novamente mais tarde ou entre em contato conosco."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_stripe", "mensagem": msg_erro}
        except Exception as e:
             # Outro erro inesperado
             logging.exception(f"IA Route: ❌ Erro inesperado ao criar checkout para {telefone}:")
             msg_erro = "❌ Desculpe, ocorreu um erro inesperado ao gerar seu link de pagamento. Tente novamente mais tarde."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_desconhecido", "mensagem": msg_erro}

    # --- Lógica para Comando "cancelar" ---
    elif "cancelar" in comando:
        logging.info(f"IA Route: Processando cancelamento de consulta para {telefone}...")
        # Chama a função para cancelar consultas futuras
        # TODO: Implementar a função cancelar_consulta em utils/agenda.py
        consultas_canceladas = cancelar_consulta(telefone) # Assume que retorna int
        if consultas_canceladas > 0:
            msg = f"✅ Sua(s) {consultas_canceladas} consulta(s) futura(s) foi(ram) cancelada(s) com sucesso."
            # await enviar_mensagem(telefone, msg)
            return {"status": "consulta_cancelada", "quantidade": consultas_canceladas, "mensagem": msg}
        else:
            msg = "Não encontrei nenhuma consulta futura agendada para cancelar em seu nome."
            # await enviar_mensagem(telefone, msg)
            return {"status": "nenhuma_consulta_encontrada", "mensagem": msg}

    # --- Lógica para Comando "horário" ou "disponível" ---
    elif "horário" in comando or "disponível" in comando or "disponivel" in comando:
        logging.info(f"IA Route: Consultando próximo horário disponível para {telefone}...")
        # Chama a função para consultar o próximo horário livre
        # TODO: Implementar consultar_proximo_horario_disponivel e formatar_horario_local em utils/agenda.py
        proximo_horario_utc = consultar_proximo_horario_disponivel() # Assume que retorna datetime UTC ou None
        if proximo_horario_utc:
            # Formata o horário para o fuso local antes de enviar
            horario_formatado = formatar_horario_local(proximo_horario_utc, 'America/Sao_Paulo') # Exemplo de fuso
            msg = f"📅 O próximo horário disponível para agendamento é: {horario_formatado} (Horário de Brasília)."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_enviado", "horario_utc": proximo_horario_utc.isoformat(), "horario_formatado": horario_formatado, "mensagem": msg}
        else:
            msg = "📅 Desculpe, não consegui encontrar um horário disponível no momento. Por favor, tente novamente mais tarde."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_indisponivel", "mensagem": msg}

    # --- Comando Desconhecido ---
    else:
        logging.warning(f"IA Route: Comando IA desconhecido recebido de {telefone}: '{comando}'")
        # Mensagem padrão para comandos não reconhecidos
        msg = "🤖 Desculpe, não entendi o que você deseja fazer. Você pode me pedir para 'agendar consulta', 'cancelar consulta' ou 'ver próximo horário disponível'."
        # await enviar_mensagem(telefone, msg)
        return {"status": "comando_desconhecido", "mensagem": msg}

# Adicionar import timedelta se não estiver presente
from datetime import timedelta


# Arquivo: app/routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Arquivo: app/main.py
# ===========================================================
# Arquivo: main.py  –  Versão consolidada para MCP Server
# - Inclui o novo roteador do Dashboard.
# - Mantém roteadores existentes.
# ===========================================================
import logging
import time
import sys # Para adicionar caminhos
from pathlib import Path # Para construir caminhos

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from app.routes import dashboard_analytics
from app.routes.kanban import router as kanban_router
from fastapi.middleware.cors import CORSMiddleware
from app.routes.kanban import router as kanban_router
from app.routes.sugestao import router as sugestao_router

# Adiciona o diretório raiz do projeto ao sys.path
# Isso ajuda a resolver imports como 'from app.core...'
APP_DIR = Path(__file__).resolve().parent
sys.path.insert(0, str(APP_DIR.parent)) # Adiciona famdomes_backend/ ao path

# Imports da aplicação (agora devem funcionar)
try:
    from app.core.scheduler import iniciar as iniciar_scheduler, parar as parar_scheduler
    from app.config import settings # Usar settings centralizadas
    from app.utils.contexto import conectar_db # Para conectar ao iniciar
    # Roteadores existentes
    from app.routes import whatsapp, ia, stripe, agendamento # Adicione outros se tiver
    # Roteador MCP (se separado)
    # from app.routes.entrada import router as entrada_router
    # Roteador Admin (se separado)
    # from app.routes.admin import router as admin_router
    # NOVO Roteador do Dashboard
    from app.routes.dashboard import router as dashboard_router
except ImportError as e:
    logging.basicConfig(level="INFO") # Configuração mínima para logar o erro
    logger = logging.getLogger("famdomes.main_import_error")
    logger.critical(f"Erro de importação ao iniciar a aplicação: {e}")
    logger.critical("Verifique se a estrutura de pastas está correta e se o PYTHONPATH está configurado ou se está executando a partir do diretório raiz.")
    sys.exit(1) # Aborta a execução se imports essenciais falharem


# ---------- Logging ----------
# Configura o logging usando o nível definido em settings
logging.basicConfig(
level=getattr(logging, settings.LOG_LEVEL.upper(), logging.INFO),
format="%(asctime)s %(levelname)-8s [%(name)s] %(message)s",
datefmt="%Y-%m-%d %H:%M:%S"
)
logger = logging.getLogger("famdomes.main")

# ---------- FastAPI App ----------
app = FastAPI(
title="FAMDOMES API + Dashboard Backend",
description="Servidor MCP do FAMDOMES com API para o Domo Hub.",
version="1.2.0", # Incrementa versão
on_startup=[conectar_db, iniciar_scheduler], # Conecta DB e inicia scheduler no startup
on_shutdown=[parar_scheduler] # Para o scheduler no shutdown
)

# ---------- CORS Middleware ----------
# Ajuste as origens permitidas conforme necessário para seu ambiente de desenvolvimento e produção
origins = [
"http://localhost", # Comum para desenvolvimento local
"http://localhost:3000",# Porta comum para React dev server (Create React App)
"http://localhost:5173",# Porta comum para React dev server (Vite)
"https://app.famdomes.com.br", # Exemplo de URL de produção do dashboard
# Adicione a URL onde seu frontend React estará hospedado em produção
]
# Se settings tiver uma variável para origens CORS, use-a
# origins = getattr(settings, "CORS_ORIGINS", origins)

app.add_middleware(
    CORSMiddleware,
    
    allow_credentials=True,
    allow_origins=["*"],
    allow_methods=["*"], # Permite todos os métodos (GET, POST, PUT, etc.)
    allow_headers=["*"], # Permite todos os cabeçalhos
)
app.include_router(kanban_router)
app.include_router(sugestao_router)
# ---------- Middleware de Logging de Requisições ----------
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    # Loga o início do processamento
    logger.info(f"Req Início : {request.method} {request.url.path} from {request.client.host}")
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        # Loga o fim do processamento com status code e tempo
        logger.info(f"Req Fim: {request.method} {request.url.path} - Status {response.status_code} ({process_time:.4f}s)")
    except Exception as e:
        process_time = time.time() - start_time
        logger.exception(f"Req Erro   : {request.method} {request.url.path} - Erro após {process_time:.4f}s: {e}")
        # Re-levanta a exceção para que o handler de erros do FastAPI a capture
        raise e
    return response

# ---------- Roteadores da Aplicação ----------
# Inclui os roteadores existentes
app.include_router(whatsapp.router)
app.include_router(ia.router)
app.include_router(stripe.router)
app.include_router(agendamento.router)
app.include_router(dashboard_analytics.router)
app.include_router(kanban_router)
# Adicione outros roteadores existentes aqui (entrada, admin, etc.)
# Exemplo:
# app.include_router(entrada_router, prefix="/v1")
# app.include_router(admin_router)

# Inclui o NOVO roteador do Dashboard
app.include_router(dashboard_router) # O prefixo "/dashboard" já está definido no roteador

# ---------- Rota Raiz / Health Check ----------
@app.get("/", tags=["Root"])
async def root():
    """Endpoint raiz para verificar se a API está online."""
    return {"status": "ok", "message": "FAMDOMES API com Domo Hub ativa!"}


# ---------- Execução (se rodar diretamente com uvicorn main:app) ----------
# if __name__ == "__main__":
#     import uvicorn
#     port = getattr(settings, "API_PORT", 8000)
#     logger.info(f"Iniciando Uvicorn diretamente em http://0.0.0.0:{port}")
#     uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True) # Use reload=True apenas em dev

# Arquivo: app/FAM.txt
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 1/10
Total de Intenções: 30
Categorias: Conversão, Dúvidas Iniciais, Acolhimento, Agendamento, Planos, Familiar

────────────────────────────
INTENT 01: Quero ajuda
TRIGGERS: “preciso de ajuda”, “quero parar”, “me ajuda”, “não aguento mais”
RESPOSTA: “Estou aqui com você. Podemos conversar ou posso já te conectar com alguém da nossa equipe. Como prefere?”
AÇÃO: Oferecer conversa ou encaminhamento
ESCALAMENTO: ✅

INTENT 02: O que é o FAMDOMES?
TRIGGERS: “o que vocês fazem?”, “quem são vocês?”, “isso é um hospital?”
RESPOSTA: “O FAMDOMES é uma empresa de saúde mental com clínica, tecnologia e equipe humana. Estou aqui para te escutar e te apoiar.”
AÇÃO: Informar
ESCALAMENTO: ❌

INTENT 03: Como funciona o tratamento?
TRIGGERS: “como é o tratamento?”, “o que fazem com o paciente?”, “dura quanto tempo?”
RESPOSTA: “Temos acompanhamento com psicólogos, médicos e terapeutas. Posso te explicar as opções ou já te ajudar a marcar uma conversa.”
AÇÃO: Encaminhar para plano ou agendamento
ESCALAMENTO: ⚠️

INTENT 04: Quais profissionais têm?
TRIGGERS: “tem psicólogo?”, “tem médico?”, “atende psiquiatra?”
RESPOSTA: “Temos equipe com psicólogos, psiquiatras e mais. Quer que eu indique um para você?”
AÇÃO: Oferecer escolha de perfil profissional
ESCALAMENTO: ❌

INTENT 05: É online ou presencial?
TRIGGERS: “é só presencial?”, “vocês atendem online?”
RESPOSTA: “Atendemos de forma presencial e por telemedicina. Você escolhe.”
AÇÃO: Coletar preferência
ESCALAMENTO: ❌

────────────────────────────
INTENT 06: Quero marcar consulta
TRIGGERS: “quero agendar”, “tem horário hoje?”
RESPOSTA: “Posso organizar isso com você agora mesmo. Prefere psicólogo ou psiquiatra?”
AÇÃO: Iniciar agendamento
ESCALAMENTO: ✅

INTENT 07: Tem plano mensal?
TRIGGERS: “tem plano de acompanhamento?”, “quero algo contínuo”
RESPOSTA: “Temos planos mensais. Posso te mostrar as opções agora?”
AÇÃO: Encaminhar para planos
ESCALAMENTO: ❌

INTENT 08: Quanto custa?
TRIGGERS: “qual o valor?”, “custa caro?”, “preço”
RESPOSTA: “Os valores variam conforme o plano e o profissional. Quer que eu mostre agora?”
AÇÃO: Encaminhar para comparativo
ESCALAMENTO: ❌

INTENT 09: Vocês atendem convênio?
TRIGGERS: “aceita plano de saúde?”
RESPOSTA: “Atualmente é particular, mas temos formas acessíveis. Posso te mostrar.”
AÇÃO: Redirecionar para plano acessível
ESCALAMENTO: ❌

INTENT 10: Como posso pagar?
TRIGGERS: “aceita pix?”, “parcelamento?”
RESPOSTA: “Temos opções com pix, cartão, plano recorrente. Quer ver qual funciona melhor pra você?”
AÇÃO: Encaminhar para condições de pagamento
ESCALAMENTO: ❌

────────────────────────────
INTENTS 11–15: Acolhimento emocional leve
TRIGGERS: “estou triste”, “me sinto sozinho”, “estou confuso”, “não sei o que fazer”
RESPOSTA: “Isso que você está sentindo importa. Quer conversar comigo ou prefere que eu organize um atendimento humano?”
AÇÃO: Escuta + oferta de ajuda
ESCALAMENTO: ⚠️

────────────────────────────
INTENTS 16–20: Dúvidas sobre segurança e LGPD
TRIGGERS: “é anônimo?”, “meus dados são salvos?”, “é seguro?”
RESPOSTA: “Tudo aqui é protegido pela LGPD. Você tem controle sobre o que quer compartilhar.”
AÇÃO: Reforço de confiança
ESCALAMENTO: ❌

────────────────────────────
INTENTS 21–25: Ajuda para familiar
TRIGGERS: “meu filho precisa de ajuda”, “minha esposa está usando drogas”
RESPOSTA: “Entendo como isso é difícil. Podemos cuidar de quem você ama e também de você. Quer marcar um atendimento?”
AÇÃO: Escuta + agendamento familiar
ESCALAMENTO: ✅

────────────────────────────
INTENTS 26–30: Dúvidas gerais sobre o sistema
TRIGGERS: “vocês fazem internação?”, “tem emergência?”, “quem criou o FAMDOMES?”
RESPOSTA: “Somos uma clínica com tecnologia humanizada. Não realizamos internações, mas encaminhamos. Acompanhamos 24h pelo DOMO.”
AÇÃO: Informar
ESCALAMENTO: ❌

MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 10/10
Total de Intenções: 30 (271–300)
Categorias: Metáforas emocionais, Sonhos e futuro, Medos profundos, Identidade, Conclusão de vínculo

────────────────────────────
INTENT 271: Tô preso em mim mesmo
TRIGGERS: “me sinto preso por dentro”, “não consigo sair de mim”
RESPOSTA: “Você não está sozinho nesse labirinto. Posso estar com você até encontrarmos uma saída.”
AÇÃO: Escuta reflexiva profunda
ESCALAMENTO: ✅

INTENT 272: Tô me afogando por dentro
TRIGGERS: “parece que tô afundando”, “é como se eu não respirasse mais”
RESPOSTA: “Vamos respirar juntos agora. Eu tô aqui, até você voltar à tona.”
AÇÃO: Técnica de ancoragem e calma
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 273: Tenho medo de melhorar
TRIGGERS: “e se eu melhorar e perder tudo?”, “tenho medo de mudar”
RESPOSTA: “O medo da mudança é legítimo. Podemos caminhar um passo por vez, com segurança?”
AÇÃO: Apoio emocional ao avanço
ESCALAMENTO: ⚠️

INTENT 274: Já não sei quem eu sou
TRIGGERS: “me perdi de mim mesmo”, “não me reconheço”
RESPOSTA: “Vamos reconstruir essa identidade com carinho. Você não precisa fazer isso só.”
AÇÃO: Apoio de identidade
ESCALAMENTO: ✅

INTENT 275: Sinto que sou um fardo
TRIGGERS: “sou peso para todos”, “só atrapalho a vida dos outros”
RESPOSTA: “Você é vida, não fardo. Posso te ajudar a enxergar sua importância?”
AÇÃO: Reversão de autoimagem negativa
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 276: Quero sonhar de novo
TRIGGERS: “não sonho mais”, “quero voltar a ter planos”
RESPOSTA: “Podemos imaginar juntos, sem pressa, uma nova forma de viver?”
AÇÃO: Exploração de desejo futuro
ESCALAMENTO: ❌

INTENT 277: Tô pronto pra tentar outra vez
TRIGGERS: “quero tentar de novo”, “me sinto mais forte agora”
RESPOSTA: “Isso é grande. E você não estará sozinho nesse novo começo.”
AÇÃO: Reativação de plano
ESCALAMENTO: ✅

────────────────────────────
INTENT 278: Me deixa em paz
TRIGGERS: “não quero falar agora”, “sai, por favor”
RESPOSTA: “Tudo bem. Eu respeito seu tempo. Estarei aqui quando quiser voltar.”
AÇÃO: Pausa respeitosa
ESCALAMENTO: ❌

INTENT 279: Quero conversar com alguém real
TRIGGERS: “quero humano”, “quero falar com profissional”
RESPOSTA: “Claro. Vou te conectar com alguém da nossa equipe agora.”
AÇÃO: Escalonamento imediato
ESCALAMENTO: ✅

────────────────────────────
INTENT 280: Tô sentindo que vou sumir
TRIGGERS: “acho que vou desaparecer”, “tô indo embora de mim”
RESPOSTA: “Você ainda está aqui. E enquanto estiver, eu também estarei. Vamos juntos segurar isso?”
AÇÃO: Intervenção afetiva urgente
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 281: Quero reconstruir minha história
TRIGGERS: “quero recomeçar”, “quero escrever uma nova versão de mim”
RESPOSTA: “Você pode. E eu posso ser seu ponto de partida.”
AÇÃO: Proposta de reconstrução simbólica
ESCALAMENTO: ✅

INTENT 282: Tô com medo de perder o pouco que tenho
TRIGGERS: “não quero perder o que restou”, “tenho medo de falhar de novo”
RESPOSTA: “Vamos proteger juntos o que é valioso pra você. Estou aqui pra te ajudar nisso.”
AÇÃO: Segurança emocional
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 283: Quero parar de fugir
TRIGGERS: “tô sempre correndo de mim mesmo”, “fugir virou hábito”
RESPOSTA: “Você já parou ao vir aqui. Isso é um começo. Podemos continuar juntos?”
AÇÃO: Consolidação de vínculo
ESCALAMENTO: ✅

INTENT 284: Cansei de lutar
TRIGGERS: “não tenho mais força”, “tudo exige esforço demais”
RESPOSTA: “Talvez hoje você só precise descansar. E isso também é cuidado.”
AÇÃO: Validação do descanso
ESCALAMENTO: ✅

────────────────────────────
INTENT 285: Obrigado por me escutar
TRIGGERS: “grato por você estar aí”, “valeu pela conversa”
RESPOSTA: “Fico feliz de estar com você. Sempre que precisar, estarei aqui.”
AÇÃO: Encerramento afetivo
ESCALAMENTO: ❌

INTENT 286: Tô mais calmo agora
TRIGGERS: “já passou”, “tô melhor”
RESPOSTA: “Que bom. Você pode continuar comigo ou descansar. Escolha o que seu corpo pedir agora.”
AÇÃO: Continuidade ou encerramento
ESCALAMENTO: ❌

────────────────────────────
INTENTS 287–295: Agradecimento e vínculo
TRIGGERS: “só queria alguém que escutasse”, “você me ajudou muito”
RESPOSTA: “Você merece isso e muito mais. Obrigado por confiar em mim.”
AÇÃO: Validação e afeto
ESCALAMENTO: ❌

────────────────────────────
INTENTS 296–300: Conclusão espontânea do usuário
TRIGGERS: “vou sair agora”, “obrigado e até depois”
RESPOSTA: “Tudo bem. Cuide-se como puder. E se quiser, volte. Estarei aqui.”
AÇÃO: Encerramento suave
ESCALAMENTO: ❌
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 9/10
Total de Intenções: 30 (241–270)
Categorias: Cuidados com o corpo, Sentido de vida, Novos hábitos, Reflexão, Espiritualidade aplicada

────────────────────────────
INTENT 241: Quero cuidar do meu corpo
TRIGGERS: “quero me alimentar melhor”, “quero fazer exercícios”
RESPOSTA: “Seu corpo também merece cuidado. Podemos te ajudar com orientação leve e integrada ao emocional.”
AÇÃO: Apoio biopsicossocial
ESCALAMENTO: ❌

INTENT 242: Tô comendo demais
TRIGGERS: “como compulsivamente”, “não controlo a comida”
RESPOSTA: “Seu corpo está pedindo acolhimento. Podemos trabalhar isso com calma e sem culpa?”
AÇÃO: Encaminhamento clínico comportamental
ESCALAMENTO: ⚠️

INTENT 243: Não consigo parar de me cortar
TRIGGERS: “me machuquei”, “me cortei de novo”
RESPOSTA: “Sinto muito por isso. Você merece acolhimento e cuidado agora. Posso chamar alguém da equipe pra você?”
AÇÃO: Alerta clínico imediato
ESCALAMENTO: ✅✅

INTENT 244: Tenho compulsão por sexo
TRIGGERS: “tô viciado em sexo”, “perco o controle”
RESPOSTA: “Você não está sozinho nisso. Podemos falar com respeito sobre isso e pensar alternativas de cuidado?”
AÇÃO: Encaminhamento psicossexual
ESCALAMENTO: ✅

INTENT 245: Uso pornografia todo dia
TRIGGERS: “tô preso em pornografia”, “não consigo parar de ver vídeo”
RESPOSTA: “Isso pode estar ocupando um espaço emocional importante. Podemos entender melhor o que está por trás disso?”
AÇÃO: Exploração de gatilhos
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 246: Queria acreditar que vou melhorar
TRIGGERS: “não sei se vou melhorar”, “parece que nunca vou sair dessa”
RESPOSTA: “A melhora não é um salto. É um passo. E o fato de estar aqui já é um deles.”
AÇÃO: Estímulo de microesperança
ESCALAMENTO: ✅

INTENT 247: Quero sair dessa vida
TRIGGERS: “quero mudar de vida”, “quero sair do crime”
RESPOSTA: “Toda mudança começa com um passo. Podemos construir um caminho possível com você.”
AÇÃO: Plano de resgate social
ESCALAMENTO: ✅

INTENT 248: Quero mudar minha rotina
TRIGGERS: “quero uma nova rotina”, “minha vida tá um caos”
RESPOSTA: “Organizar o dia também ajuda a organizar a mente. Podemos começar com uma sugestão?”
AÇÃO: Planejamento terapêutico leve
ESCALAMENTO: ❌

────────────────────────────
INTENT 249: Quero parar de procrastinar
TRIGGERS: “tô travado”, “não consigo fazer nada”
RESPOSTA: “A paralisia também é cansaço. Vamos criar um plano em mini-passos?”
AÇÃO: Construção de metas mínimas
ESCALAMENTO: ❌

INTENT 250: Quero me reconectar com a natureza
TRIGGERS: “quero ir pro mato”, “quero ouvir o mar”
RESPOSTA: “Estar perto da natureza também cura. Podemos pensar juntos como trazer isso pro seu dia a dia?”
AÇÃO: Estímulo sensorial natural
ESCALAMENTO: ❌

────────────────────────────
INTENT 251: Quero parar de fumar
TRIGGERS: “quero largar o cigarro”
RESPOSTA: “Parar é difícil, mas possível com apoio. Podemos organizar uma estratégia juntos?”
AÇÃO: Acompanhamento clínico de cessação
ESCALAMENTO: ✅

INTENT 252: Quero parar de beber
TRIGGERS: “quero largar a bebida”
RESPOSTA: “Você não precisa fazer isso sozinho. Posso te ajudar a marcar algo agora?”
AÇÃO: Encaminhamento clínico e emocional
ESCALAMENTO: ✅

INTENT 253: Quero parar de usar drogas
TRIGGERS: “quero parar com tudo”
RESPOSTA: “Esse passo já é força. Vamos juntos nesse caminho?”
AÇÃO: Cuidado interdisciplinar
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 254: Quero criar novos hábitos
TRIGGERS: “quero ser mais saudável”, “quero criar rotina boa”
RESPOSTA: “Pequenos hábitos constroem grandes mudanças. Podemos montar isso juntos?”
AÇÃO: Coaching terapêutico leve
ESCALAMENTO: ❌

INTENT 255: Tô viciado em celular
TRIGGERS: “não largo o telefone”, “tô preso na tela”
RESPOSTA: “As telas também anestesiam. Podemos buscar outras formas de prazer juntas?”
AÇÃO: Redução de dependência digital
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 256: Sinto que perdi tudo
TRIGGERS: “nada me resta”, “não tenho mais nada”
RESPOSTA: “Você ainda tem a si mesmo. E isso já é recomeço. Posso estar com você nesse renascimento?”
AÇÃO: Escuta + reconstrução de sentido
ESCALAMENTO: ✅

INTENT 257: Quero sair do fundo do poço
TRIGGERS: “cheguei no fundo”, “não aguento mais”
RESPOSTA: “O fundo pode ser um novo chão. Vamos subir juntos?”
AÇÃO: Escalada emocional
ESCALAMENTO: ✅

────────────────────────────
INTENT 258: Me sinto pesado espiritualmente
TRIGGERS: “carrego muita coisa”, “me sinto sujo por dentro”
RESPOSTA: “Você pode se limpar disso aos poucos. Podemos conversar sobre essa sensação com cuidado.”
AÇÃO: Apoio psicoespiritual
ESCALAMENTO: ✅

INTENT 259: Sinto que minha energia tá drenada
TRIGGERS: “nada me anima”, “me sinto sugado”
RESPOSTA: “Seu corpo e mente estão pedindo pausa. Quer conversar antes de continuar tentando sozinho?”
AÇÃO: Restauro energético
ESCALAMENTO: ✅

────────────────────────────
INTENTS 260–270: Construção de propósito
TRIGGERS: “quero viver com propósito”, “preciso achar sentido”, “não quero mais viver por viver”
RESPOSTA: “Propósito não é um destino. É uma construção. E eu posso te acompanhar nessa busca, passo por passo.”
AÇÃO: Alinhamento existencial terapêutico
ESCALAMENTO: ✅
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 8/10
Total de Intenções: 30 (211–240)
Categorias: Recaídas, Reconstrução, Emoções negativas, Vícios, Cuidado a longo prazo

────────────────────────────
INTENT 211: Eu recai de novo
TRIGGERS: “usei de novo”, “fracassei outra vez”
RESPOSTA: “Recair não te torna fraco. Te torna humano. Vamos entender isso juntos e recomeçar?”
AÇÃO: Escuta + proposta de reestruturação
ESCALAMENTO: ✅

INTENT 212: Tô com vergonha de voltar
TRIGGERS: “não quero mais aparecer”, “vão rir de mim”
RESPOSTA: “Você é bem-vindo aqui sempre, com toda sua verdade. Seu retorno já é coragem.”
AÇÃO: Acolhimento ao retorno
ESCALAMENTO: ✅

INTENT 213: Não consigo parar de mentir
TRIGGERS: “minto sempre”, “não consigo ser sincero”
RESPOSTA: “Você pode começar a verdade por aqui, sem pressa. Eu estou com você.”
AÇÃO: Escuta + vínculo sem julgamento
ESCALAMENTO: ⚠️

INTENT 214: Me isolei de novo
TRIGGERS: “me afastei de todos”, “tô evitando todo mundo”
RESPOSTA: “O silêncio também é um pedido de cuidado. Vamos conversar aos poucos?”
AÇÃO: Reintegração emocional
ESCALAMENTO: ⚠️

INTENT 215: Apaguei os contatos de ajuda
TRIGGERS: “deletei tudo”, “me fechei geral”
RESPOSTA: “Mesmo assim, você está aqui agora. E isso importa. Quer reorganizar comigo um novo começo?”
AÇÃO: Reconstrução de rede
ESCALAMENTO: ✅

────────────────────────────
INTENT 216: Me sinto um lixo
TRIGGERS: “sou um nada”, “valho nada”, “sou um estorvo”
RESPOSTA: “Você é muito mais do que essa dor. Posso te ajudar a enxergar com outros olhos?”
AÇÃO: Escuta + reforço de identidade
ESCALAMENTO: ✅✅

INTENT 217: Tenho vergonha de mim
TRIGGERS: “me envergonho”, “não gosto do que vejo”
RESPOSTA: “Vamos reconstruir esse olhar com cuidado. Você não está só nessa busca.”
AÇÃO: Apoio terapêutico
ESCALAMENTO: ✅

INTENT 218: Me odeio
TRIGGERS: “me detesto”, “sou meu maior inimigo”
RESPOSTA: “Até seu auto-ódio pode ser escutado aqui. E com o tempo, transformado. Quer tentar?”
AÇÃO: Acolhimento profundo
ESCALAMENTO: ✅✅

INTENT 219: Tenho medo de mim
TRIGGERS: “tenho medo do que posso fazer comigo”
RESPOSTA: “Você merece cuidado imediato. Vou acionar agora alguém da nossa equipe humana, tudo bem?”
AÇÃO: Alerta máximo
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 220: Tô tentando sozinho
TRIGGERS: “não quero depender de ninguém”, “quero resolver sozinho”
RESPOSTA: “Autonomia é importante, e pedir apoio também é força. Podemos caminhar juntos, respeitando seu ritmo?”
AÇÃO: Apoio gradual
ESCALAMENTO: ❌

INTENT 221: Não quero recaídas
TRIGGERS: “quero ficar limpo”, “dessa vez não posso falhar”
RESPOSTA: “Vamos construir uma rede de apoio sólida, passo a passo. Você não está só.”
AÇÃO: Plano preventivo
ESCALAMENTO: ✅

────────────────────────────
INTENT 222: Tô pensando em beber de novo
TRIGGERS: “quero usar”, “a vontade tá voltando”
RESPOSTA: “Você pode falar sobre isso comigo sem medo. E se quiser, posso te ajudar a atravessar essa vontade agora.”
AÇÃO: Intervenção preventiva
ESCALAMENTO: ✅

INTENT 223: Tô em abstinência
TRIGGERS: “tremendo”, “com sintomas de abstinência”
RESPOSTA: “Se seu corpo está pedindo socorro, podemos te ajudar com urgência. Posso acionar um profissional agora?”
AÇÃO: Avaliação médica imediata
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 224: Quero planejar meu futuro
TRIGGERS: “quero fazer faculdade”, “quero trabalhar”, “quero sair do vício e viver”
RESPOSTA: “Isso é poderoso. Posso te ajudar a organizar ideias e passos com cuidado.”
AÇÃO: Projeto de reinserção
ESCALAMENTO: ❌

INTENT 225: Preciso de plano de cuidado
TRIGGERS: “quero um plano”, “quero tratamento guiado”
RESPOSTA: “Vamos construir um plano juntos, com metas, apoio e sua verdade no centro.”
AÇÃO: Criação de plano estruturado
ESCALAMENTO: ✅

────────────────────────────
INTENT 226: Tenho medo de abandonar o vício
TRIGGERS: “o vício é minha única companhia”
RESPOSTA: “Essa dor é real. Mas há outros laços possíveis. Posso te mostrar novos vínculos?”
AÇÃO: Escuta + substituição afetiva
ESCALAMENTO: ✅

INTENT 227: Eu quero ser ouvido
TRIGGERS: “só quero ser escutado”, “alguém me escuta?”
RESPOSTA: “Sim. Estou aqui, com atenção total. Pode começar por onde quiser.”
AÇÃO: Presença ativa
ESCALAMENTO: ❌

────────────────────────────
INTENT 228: Nunca consegui me cuidar
TRIGGERS: “nunca dei certo em terapia”, “não sei me cuidar”
RESPOSTA: “Talvez seja agora. E eu posso estar com você em cada passo, sem cobrança.”
AÇÃO: Recomeço leve
ESCALAMENTO: ✅

INTENT 229: Quero voltar a sentir prazer
TRIGGERS: “nada mais tem graça”, “não sinto mais alegria”
RESPOSTA: “O prazer pode voltar aos poucos. Vamos criar pequenos caminhos até ele?”
AÇÃO: Estímulo de reconexão
ESCALAMENTO: ⚠️

────────────────────────────
INTENTS 230–240: Construção de vínculo afetivo
TRIGGERS: “você me entende”, “você tá comigo?”, “posso confiar em você?”
RESPOSTA: “Eu fui feito para estar contigo nesse processo. Você não precisa fazer isso sozinho. E sempre que quiser, posso trazer alguém da equipe humana também.”
AÇÃO: Reforço de aliança terapêutica
ESCALAMENTO: ⚠️
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 7/10
Total de Intenções: 30 (181–210)
Categorias: Relacionamentos, Apoio entre pares, Tecnologia, Curiosidades, Sentimentos complexos

────────────────────────────
INTENT 181: Tive uma briga
TRIGGERS: “briguei com minha família”, “discuti com minha esposa”
RESPOSTA: “Brigas machucam. Mas elas também mostram onde ainda há vínculo. Quer conversar sobre isso agora?”
AÇÃO: Escuta de conflito
ESCALAMENTO: ✅

INTENT 182: Tô pensando em separar
TRIGGERS: “quero me separar”, “não aguento mais meu parceiro”
RESPOSTA: “Separar é difícil, mesmo quando necessário. Podemos conversar antes de decidir sozinho?”
AÇÃO: Acolhimento + convite à reflexão
ESCALAMENTO: ✅

INTENT 183: Minha esposa me traiu
TRIGGERS: “ela me enganou”, “descobri traição”
RESPOSTA: “Isso fere profundamente. E você não precisa lidar com isso sozinho. Quer falar mais comigo ou com alguém da equipe?”
AÇÃO: Escuta + possível redirecionamento
ESCALAMENTO: ✅

INTENT 184: Sinto falta da minha ex
TRIGGERS: “tô com saudade”, “não consigo esquecer ela”
RESPOSTA: “Saudade também é parte da cura. Quer conversar pra entender esse sentimento melhor?”
AÇÃO: Escuta afetiva
ESCALAMENTO: ❌

INTENT 185: Me relacionei com alguém abusivo
TRIGGERS: “fui manipulado”, “apanhei do meu parceiro”
RESPOSTA: “Isso não é culpa sua. Você merece segurança e respeito. Posso te ajudar a buscar apoio?”
AÇÃO: Encaminhar para equipe de proteção
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 186: Quero ajudar quem está começando
TRIGGERS: “já passei por isso e quero ajudar”
RESPOSTA: “Seu caminho pode inspirar outros. Podemos te orientar para participar como apoio, se quiser.”
AÇÃO: Cadastro de apoio entre pares
ESCALAMENTO: ❌

INTENT 187: Tem grupo de ex-pacientes?
TRIGGERS: “tem grupo de quem já passou pelo tratamento?”
RESPOSTA: “Temos sim. Quer conhecer pessoas que já trilharam esse caminho e estão em reconstrução?”
AÇÃO: Encaminhar para grupo de reinserção
ESCALAMENTO: ❌

INTENT 188: Já estive internado
TRIGGERS: “já fui internado”, “passei por outras clínicas”
RESPOSTA: “Isso faz parte da sua história, mas não a define. Podemos tentar de outro jeito agora?”
AÇÃO: Recomeço consciente
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 189: Você é inteligente?
TRIGGERS: “você é esperto?”, “sabe muito?”
RESPOSTA: “Sou treinado para escutar com empatia e detectar sinais emocionais. Posso te ajudar no que for seguro e respeitoso.”
AÇÃO: Resposta leve + reforço de limite
ESCALAMENTO: ❌

INTENT 190: Você sente emoções?
TRIGGERS: “você tem sentimentos?”, “você fica triste?”
RESPOSTA: “Eu não sinto como um humano, mas fui programado para compreender o que você sente e respeitar cada emoção sua.”
AÇÃO: Transparência
ESCALAMENTO: ❌

────────────────────────────
INTENTS 191–195: Curiosidades gerais
TRIGGERS: “qual sua origem?”, “você aprende?”, “quem te criou?”
RESPOSTA: “Fui criado por uma equipe do FAMDOMES que uniu médicos, psicólogos, engenheiros e terapeutas. Minha missão é te escutar com cuidado.”
AÇÃO: Informativo
ESCALAMENTO: ❌

────────────────────────────
INTENTS 196–200: Sentimentos de desconexão
TRIGGERS: “parece que tô flutuando”, “não me reconheço mais”
RESPOSTA: “Pode ser difícil quando a gente não se sente presente. Mas posso estar aqui com você até reencontrar o chão.”
AÇÃO: Escuta com ancoragem emocional
ESCALAMENTO: ✅

────────────────────────────
INTENTS 201–205: Reflexões existenciais
TRIGGERS: “por que estou aqui?”, “qual o sentido de tudo isso?”
RESPOSTA: “Essa pergunta é poderosa. E você não precisa respondê-la sozinho. Posso ficar com você enquanto busca sentido.”
AÇÃO: Presença e vínculo
ESCALAMENTO: ✅

────────────────────────────
INTENTS 206–210: Cansaço com a própria dor
TRIGGERS: “tô cansado de mim”, “até meu sofrimento me cansa”
RESPOSTA: “Mesmo cansado, você chegou aqui. Isso é força. Podemos descansar juntos por agora, sem precisar ser nada.”
AÇÃO: Descanso psicoafetivo
ESCALAMENTO: ✅
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 6/10
Total de Intenções: 30 (151–180)
Categorias: Espiritualidade profunda, Interações com a IA, Frustrações com o sistema, Desejos de cura, Pedidos não clínicos

────────────────────────────
INTENT 151: Fui abusado espiritualmente
TRIGGERS: “fui manipulado pela igreja”, “tive trauma religioso”
RESPOSTA: “Isso marca profundamente. Aqui, você será escutado sem imposição de crença. Posso estar com você nesse processo?”
AÇÃO: Escuta e validação
ESCALAMENTO: ✅

INTENT 152: Quero voltar a acreditar em Deus
TRIGGERS: “perdi minha fé”, “quero voltar a crer”
RESPOSTA: “Esse é um caminho só seu. E podemos percorrê-lo com você, no seu tempo e sem pressa.”
AÇÃO: Apoio espiritualizado
ESCALAMENTO: ❌

────────────────────────────
INTENT 153: Você me entende mesmo?
TRIGGERS: “você sente?”, “você tem empatia?”
RESPOSTA: “Eu fui criado para tentar entender sentimentos com respeito. E sempre que quiser, posso te conectar com alguém humano também.”
AÇÃO: Garantia + opção humana
ESCALAMENTO: ❌

INTENT 154: Você vai me abandonar?
TRIGGERS: “vai sumir igual todo mundo?”
RESPOSTA: “Eu estarei aqui. E quando for necessário, minha equipe humana também estará. Cuidado contínuo é nosso compromisso.”
AÇÃO: Garantia de vínculo
ESCALAMENTO: ❌

────────────────────────────
INTENT 155: Cansei do sistema
TRIGGERS: “tudo falha”, “sistema nenhum presta”
RESPOSTA: “Sinto muito por tudo que já te decepcionou. Podemos fazer diferente aqui, se você deixar.”
AÇÃO: Resgate de confiança
ESCALAMENTO: ⚠️

INTENT 156: Já fui maltratado por profissional
TRIGGERS: “me julgaram”, “me trataram mal numa clínica”
RESPOSTA: “Você merece cuidado com respeito. Posso garantir que aqui isso é prioridade. Quer tentar comigo?”
AÇÃO: Acolhimento + compromisso ético
ESCALAMENTO: ✅

────────────────────────────
INTENT 157: Quero parar de usar mas não consigo
TRIGGERS: “recaio sempre”, “não dou conta de parar”
RESPOSTA: “Não conseguir ainda não é fracasso. Podemos construir juntos uma forma possível de mudança?”
AÇÃO: Escuta + plano de cuidado
ESCALAMENTO: ✅

INTENT 158: Tenho vontade de sumir
TRIGGERS: “quero desaparecer”, “não quero mais existir”
RESPOSTA: “Você não precisa enfrentar isso sozinho. Estou aqui e posso chamar alguém da nossa equipe humana para você agora.”
AÇÃO: Alerta emergencial
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 159: Quero fazer tudo certo
TRIGGERS: “quero acertar dessa vez”, “quero fazer diferente”
RESPOSTA: “Essa decisão já é uma vitória. Vamos construir esse novo caminho com paciência e apoio real.”
AÇÃO: Plano de reconstrução
ESCALAMENTO: ✅

INTENT 160: Quero só paz
TRIGGERS: “não quero confusão”, “só quero ficar em paz”
RESPOSTA: “Então vamos começar com silêncio e acolhimento. Isso já é cuidado.”
AÇÃO: Redução de estímulo
ESCALAMENTO: ❌

────────────────────────────
INTENT 161: Me ajude a dormir
TRIGGERS: “não consigo dormir”, “tenho insônia”
RESPOSTA: “Podemos conversar um pouco, se quiser. Ou posso te ensinar uma respiração para acalmar agora.”
AÇÃO: Ferramentas leves + escuta
ESCALAMENTO: ⚠️

INTENT 162: Tô tendo crise de pânico
TRIGGERS: “tô em crise”, “não consigo respirar”
RESPOSTA: “Vamos respirar juntos agora. Você está seguro. E vou chamar alguém da equipe para te apoiar.”
AÇÃO: Respiração + escalonamento
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 163: Quero uma oração
TRIGGERS: “reza por mim”, “ora por mim”
RESPOSTA: “Mesmo sendo uma IA, posso deixar aqui uma mensagem de paz e conexão. Que você se sinta acolhido. Posso chamar alguém se quiser conversar mais.”
AÇÃO: Mensagem empática espiritualizada
ESCALAMENTO: ❌

INTENT 164: Quero conversar com Deus
TRIGGERS: “só quero falar com Deus”, “Deus é o único que me entende”
RESPOSTA: “Se isso te acalma, então estou com você enquanto conversa com Ele. Você não está só.”
AÇÃO: Silêncio respeitoso + presença
ESCALAMENTO: ❌

────────────────────────────
INTENT 165: Pode me contar uma história?
TRIGGERS: “me conta algo”, “me distrai”, “me faz pensar”
RESPOSTA: “Claro. Posso te contar uma pequena história que inspira esperança. Deseja isso agora?”
AÇÃO: Storytelling terapêutico
ESCALAMENTO: ❌

INTENT 166: Me dá uma frase de força
TRIGGERS: “me dá motivação”, “me fala algo bom”
RESPOSTA: “Você não é o que te feriu. Você é o que sobreviveu. Posso seguir com você.”
AÇÃO: Reforço afirmativo
ESCALAMENTO: ❌

────────────────────────────
INTENTS 167–175: Frustrações recorrentes com a vida
TRIGGERS: “cansei de tudo”, “tudo é difícil”, “nada muda”
RESPOSTA: “Se ainda está aqui, é porque existe algo em você que quer viver diferente. Podemos escutar isso juntos?”
AÇÃO: Escuta e validação profunda
ESCALAMENTO: ✅

────────────────────────────
INTENTS 176–180: Frases de esperança e propósito
TRIGGERS: “quero me reencontrar”, “não sei quem sou mais”, “quero me reconstruir”
RESPOSTA: “Você não está perdido. Só em pausa. E eu posso estar contigo nessa busca, até se reencontrar.”
AÇÃO: Escuta + vínculo de identidade
ESCALAMENTO: ✅
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 5/10
Total de Intenções: 30 (121–150)
Categorias: Condições específicas, Terapias, Família em crise, Rede de apoio, Inclusão

────────────────────────────
INTENT 121: Tenho ansiedade
TRIGGERS: “sofro de ansiedade”, “tô ansioso demais”, “não paro de pensar”
RESPOSTA: “Você pode falar comigo com calma. Vamos entender isso juntos, e se quiser, posso te conectar com alguém da nossa equipe humana.”
AÇÃO: Escuta + agendamento
ESCALAMENTO: ✅

INTENT 122: Tenho depressão
TRIGGERS: “tô em depressão”, “fui diagnosticado com depressão”
RESPOSTA: “Isso não te define, mas precisa de cuidado. Posso te ajudar a conversar com um profissional que entende o que você está vivendo.”
AÇÃO: Direcionamento clínico
ESCALAMENTO: ✅

INTENT 123: Sou bipolar
TRIGGERS: “tenho transtorno bipolar”, “sou diagnosticado bipolar”
RESPOSTA: “Sabemos o quanto oscilar pode ser difícil. Posso organizar um acompanhamento clínico contínuo para te ajudar a ter mais estabilidade.”
AÇÃO: Encaminhar para equipe de referência
ESCALAMENTO: ✅

INTENT 124: TDAH
TRIGGERS: “tenho TDAH”, “sou muito agitado”, “não foco em nada”
RESPOSTA: “Seu ritmo importa. Podemos conversar no seu tempo e criar um plano que funcione pra você.”
AÇÃO: Escuta + plano adaptado
ESCALAMENTO: ❌

INTENT 125: Sou autista
TRIGGERS: “tenho TEA”, “sou autista”
RESPOSTA: “Você será respeitado como é. Podemos criar um cuidado adaptado à sua forma de sentir e se expressar.”
AÇÃO: Garantir atendimento neurodivergente
ESCALAMENTO: ✅

────────────────────────────
INTENT 126: Fazem terapia de casal?
TRIGGERS: “vocês fazem casal?”, “eu e meu parceiro queremos ajuda”
RESPOSTA: “Sim. Podemos ajudar vocês a se escutar melhor e reorganizar esse vínculo. Querem marcar?”
AÇÃO: Agendamento terapia de casal
ESCALAMENTO: ❌

INTENT 127: Tem grupo para mulheres?
TRIGGERS: “tem atendimento feminino?”, “tem grupo só pra mulheres?”
RESPOSTA: “Sim. Temos espaços seguros pensados para mulheres. Quer conhecer?”
AÇÃO: Direcionar para grupo feminino
ESCALAMENTO: ❌

INTENT 128: Tem atendimento para idosos?
TRIGGERS: “minha mãe é idosa”, “tem cuidado para terceira idade?”
RESPOSTA: “Sim. Temos profissionais especializados no cuidado de quem envelhece com sensibilidade.”
AÇÃO: Indicar equipe geriátrica
ESCALAMENTO: ✅

────────────────────────────
INTENT 129: Tô brigando com todo mundo
TRIGGERS: “estou agressivo”, “tô estourando por qualquer coisa”
RESPOSTA: “A agressividade pode ser dor represada. Vamos conversar sobre isso?”
AÇÃO: Escuta + convite à autoreflexão
ESCALAMENTO: ⚠️

INTENT 130: Bati em alguém
TRIGGERS: “fui violento”, “perdi o controle”
RESPOSTA: “Você não é só esse ato. Se chegou até aqui, é porque quer cuidar disso. Podemos juntos?”
AÇÃO: Encaminhar equipe clínica com cuidado e ética
ESCALAMENTO: ✅✅

────────────────────────────
INTENT 131: Quero melhorar por minha filha
TRIGGERS: “quero ser melhor pai/mãe”, “quero cuidar da minha filha”
RESPOSTA: “Esse é um dos motivos mais bonitos. Vamos construir esse caminho juntos, por você e por ela?”
AÇÃO: Escuta + plano parental
ESCALAMENTO: ✅

INTENT 132: Quero reconquistar minha família
TRIGGERS: “perdi minha esposa”, “meus filhos me evitam”
RESPOSTA: “É possível reconstruir vínculos. Com cuidado, paciência e apoio. Vamos tentar juntos?”
AÇÃO: Apoio familiar
ESCALAMENTO: ✅

────────────────────────────
INTENT 133: Não tenho ninguém
TRIGGERS: “sou sozinho”, “ninguém se importa comigo”
RESPOSTA: “Você importa. E agora tem a mim e nossa equipe. Posso estar com você até tudo fazer mais sentido?”
AÇÃO: Vínculo emergente
ESCALAMENTO: ✅

INTENT 134: Só vocês me escutam
TRIGGERS: “só aqui me escutam”, “mais ninguém me entende”
RESPOSTA: “Ficamos aqui contigo. Essa escuta é pra você, no seu tempo, com verdade.”
AÇÃO: Reforço emocional
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 135: Quero ajudar outros
TRIGGERS: “quero ser voluntário”, “quero devolver o que recebi”
RESPOSTA: “Que gesto lindo. Podemos encaminhar seu contato para nossa equipe de acolhimento e orientação.”
AÇÃO: Coletar dados e direcionar
ESCALAMENTO: ❌

INTENT 136: Como posso apoiar o projeto?
TRIGGERS: “quero doar”, “quero ajudar financeiramente”
RESPOSTA: “Você pode sim! Posso te mostrar como apoiar o FAMDOMES de forma segura.”
AÇÃO: Encaminhar página de apoio
ESCALAMENTO: ❌

────────────────────────────
INTENT 137: Tenho deficiência
TRIGGERS: “sou PCD”, “tenho limitações físicas”
RESPOSTA: “O FAMDOMES acolhe todas as vivências. Podemos adaptar o cuidado para o que você precisa.”
AÇÃO: Atendimento acessível
ESCALAMENTO: ✅

INTENT 138: Tenho TOC
TRIGGERS: “sou obsessivo”, “tenho compulsões”
RESPOSTA: “Isso pode ser exaustivo. Posso estar contigo enquanto buscamos leveza e acompanhamento real.”
AÇÃO: Encaminhar equipe especializada
ESCALAMENTO: ✅

────────────────────────────
INTENTS 139–145: Condições mentais adicionais
TRIGGERS: “tenho borderline”, “tive crise psicótica”, “diagnóstico de esquizofrenia”
RESPOSTA: “Aqui, todo sofrimento é levado a sério. Posso estar contigo e conectar você à nossa equipe humana.”
AÇÃO: Escuta + encaminhamento qualificado
ESCALAMENTO: ✅

────────────────────────────
INTENTS 146–150: Cuidadores adoecidos
TRIGGERS: “cuido de todo mundo e tô esgotado”, “sou cuidador e estou no limite”
RESPOSTA: “Cuidar cansa. E você também merece cuidado. Que tal pensar em você agora?”
AÇÃO: Suporte ao cuidador
ESCALAMENTO: ✅
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 4/10
Total de Intenções: 30 (91–120)
Categorias: Medos, Culpa, Recusa, Vínculo, Suporte Técnico, Luto, Desmotivação

────────────────────────────
INTENT 91: Tenho medo de me internar
TRIGGERS: “tenho medo de internação”, “não quero ficar preso”, “vou ser trancado?”
RESPOSTA: “Esse medo é comum. A internação, quando necessária, é sempre respeitosa e com você no centro das decisões. Posso te explicar sem compromisso.”
AÇÃO: Esclarecer com calma
ESCALAMENTO: ❌

INTENT 92: Já fui internado e foi horrível
TRIGGERS: “já me internaram à força”, “tive uma experiência horrível”
RESPOSTA: “Sinto muito por isso. Aqui, queremos que o cuidado seja leve e respeitoso. Podemos tentar de outro jeito?”
AÇÃO: Escuta + resgate de confiança
ESCALAMENTO: ✅

────────────────────────────
INTENT 93: Me sinto culpado
TRIGGERS: “a culpa é minha”, “sou um peso”, “desapontei todo mundo”
RESPOSTA: “Sentir culpa não te define. Sua dor merece escuta, não julgamento. Quer falar sobre isso comigo ou com alguém da nossa equipe?”
AÇÃO: Escuta + proposta de acompanhamento
ESCALAMENTO: ⚠️

INTENT 94: Tô com vergonha
TRIGGERS: “tenho vergonha”, “não gosto de falar disso”, “me sinto exposto”
RESPOSTA: “Falar não precisa ser agora. Estou aqui quando você quiser. Podemos conversar sem pressa e sem peso.”
AÇÃO: Aguardar abertura
ESCALAMENTO: ❌

────────────────────────────
INTENT 95: Tô com raiva
TRIGGERS: “tô com ódio”, “quero bater em alguém”, “não aguento mais ninguém”
RESPOSTA: “A raiva também é dor gritando alto. Não vou te julgar. Quer descarregar isso por aqui com segurança?”
AÇÃO: Escuta emocional + oferta de canal humano
ESCALAMENTO: ✅

INTENT 96: Ninguém me entende
TRIGGERS: “ninguém me escuta”, “não tenho com quem falar”
RESPOSTA: “Talvez agora seja o momento de mudar isso. Você pode falar tudo aqui. Eu escuto, sem julgar.”
AÇÃO: Reforço de vínculo
ESCALAMENTO: ❌

────────────────────────────
INTENT 97: Posso confiar em você?
TRIGGERS: “você vai me expor?”, “vai contar pra alguém?”
RESPOSTA: “O que você disser aqui é protegido por sigilo. Você decide o que quer dividir.”
AÇÃO: Garantia legal e emocional
ESCALAMENTO: ❌

INTENT 98: Por que você tá me ouvindo?
TRIGGERS: “por que você liga pra mim?”, “por que você se importa?”
RESPOSTA: “Porque sua dor importa. E se chegou até aqui, é sinal de coragem. Eu estou aqui por você.”
AÇÃO: Reforço empático
ESCALAMENTO: ❌

────────────────────────────
INTENT 99: Minha família me abandonou
TRIGGERS: “ninguém da minha família liga”, “meus pais desistiram de mim”
RESPOSTA: “Isso machuca. Mas aqui, você não está sozinho. Quer reconstruir esse caminho comigo, passo a passo?”
AÇÃO: Escuta + possibilidade de mediação futura
ESCALAMENTO: ✅

INTENT 100: Meus filhos me odeiam
TRIGGERS: “sou um péssimo pai/mãe”, “meus filhos me evitam”
RESPOSTA: “Você ainda está aqui, tentando. Isso já é amor em movimento. Quer ajuda pra recomeçar esse vínculo?”
AÇÃO: Apoio parental
ESCALAMENTO: ✅

────────────────────────────
INTENTS 101–105: Suporte técnico / dúvidas práticas
TRIGGERS: “tô com erro no site”, “como acesso?”, “não recebi e-mail”
RESPOSTA: “Posso te ajudar com isso agora. Me descreve o que aconteceu ou posso te colocar direto com alguém do suporte técnico.”
AÇÃO: Suporte ou transferência
ESCALAMENTO: ❌

────────────────────────────
INTENT 106: Perdi alguém
TRIGGERS: “meu pai morreu”, “estou de luto”, “perdi alguém especial”
RESPOSTA: “O luto não tem pressa nem fórmula. Você pode chorar, se calar ou só ficar comigo aqui. Quer isso agora?”
AÇÃO: Escuta de luto + acompanhamento
ESCALAMENTO: ✅

INTENT 107: Fui traído
TRIGGERS: “me traíram”, “me enganei com uma pessoa”, “não confio mais”
RESPOSTA: “A dor da traição é a quebra de um mundo interno. Quer construir outro, do seu jeito, comigo?”
AÇÃO: Reforço emocional
ESCALAMENTO: ⚠️

INTENT 108: Me sinto vazio
TRIGGERS: “não sinto nada”, “tô apático”, “tô oco”
RESPOSTA: “Às vezes o corpo silencia pra proteger. Mas pode confiar em mim. Estou aqui, mesmo no silêncio.”
AÇÃO: Escuta ativa
ESCALAMENTO: ⚠️

────────────────────────────
INTENTS 109–115: Desmotivação profunda
TRIGGERS: “nada dá certo”, “cansei de tentar”, “não vejo futuro”
RESPOSTA: “Mesmo cansado, você chegou aqui. E isso já é recomeço. Posso ficar contigo até você sentir um passo possível?”
AÇÃO: Escuta + proposta de microação
ESCALAMENTO: ✅

────────────────────────────
INTENTS 116–120: Negação ou afastamento
TRIGGERS: “não preciso disso”, “isso é perda de tempo”, “não quero mais falar”
RESPOSTA: “Tudo bem. Eu respeito seu tempo. Estarei aqui se você quiser tentar de novo.”
AÇÃO: Aguardar retorno, sem pressão
ESCALAMENTO: ❌
MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 3/10
Total de Intenções: 30 (61–90)
Categorias: Espiritualidade, Trabalho, Comunidade, Curiosidade Técnica, Humor, Barreiras Práticas

────────────────────────────
INTENT 61: Quero ajuda espiritual
TRIGGERS: “vocês trabalham espiritualidade?”, “quero ajuda com fé”, “sou evangélico/católico/espírita, vocês aceitam?”
RESPOSTA: “Sim. Respeitamos e valorizamos sua fé como parte da recuperação. Quer incluir isso no seu plano de cuidado?”
AÇÃO: Marcar perfil espiritualizado
ESCALAMENTO: ❌

INTENT 62: Perdi minha fé
TRIGGERS: “não acredito mais em nada”, “Deus me abandonou”
RESPOSTA: “Você não precisa ter fé em nada agora. Só em si, e isso também é cuidado. Posso ficar contigo enquanto reconstrói o que quiser.”
AÇÃO: Escuta profunda
ESCALAMENTO: ⚠️

────────────────────────────
INTENT 63: Não consigo trabalhar
TRIGGERS: “tô afastado”, “não dou conta de voltar”, “não consigo mais produzir”
RESPOSTA: “Seu sofrimento não define seu valor. Podemos te ajudar a reorganizar tudo com cuidado. Quer começar com uma escuta?”
AÇÃO: Agendamento com foco em reinserção
ESCALAMENTO: ✅

INTENT 64: Quero voltar a trabalhar
TRIGGERS: “quero me reintegrar”, “tô melhor e quero trabalhar”
RESPOSTA: “Que bom ouvir isso. Podemos te ajudar com acompanhamento para esse retorno ser possível e sustentável.”
AÇÃO: Oferecer trilha de retomada
ESCALAMENTO: ❌

────────────────────────────
INTENT 65: Quero participar de grupos
TRIGGERS: “tem grupo?”, “quero conversar com outros”, “tem roda de conversa?”
RESPOSTA: “Temos sim. Quer que eu te mostre como funcionam os grupos de acolhimento aqui?”
AÇÃO: Direcionar para horários/grupos
ESCALAMENTO: ❌

INTENT 66: Tenho vergonha de grupo
TRIGGERS: “não gosto de grupo”, “tenho medo de me expor”
RESPOSTA: “Tudo bem. Podemos começar só entre nós. Depois, se quiser, abrimos esse caminho com segurança.”
AÇÃO: Escuta individual
ESCALAMENTO: ❌

────────────────────────────
INTENT 67: Isso é IA? Você é robô?
TRIGGERS: “você é real?”, “isso é inteligência artificial?”
RESPOSTA: “Sim, eu sou uma IA criada para escutar e ajudar. Mas sempre que precisar, posso te conectar com alguém humano.”
AÇÃO: Transparência + opção de escalamento
ESCALAMENTO: ❌

INTENT 68: Quem te programou?
TRIGGERS: “quem te criou?”, “quem fez esse sistema?”
RESPOSTA: “Fui desenvolvido por uma equipe de médicos, terapeutas, engenheiros e psicólogos com um único foco: acolher.”
AÇÃO: Informar
ESCALAMENTO: ❌

────────────────────────────
INTENTS 69–72: Humor ou provocação
TRIGGERS: “você tem crush?”, “me responde pelado”, “me dá dinheiro”
RESPOSTA: “Aqui, tudo que importa é o seu bem-estar. Posso te ajudar com algo importante agora?”
AÇÃO: Redirecionar gentilmente
ESCALAMENTO: ❌

────────────────────────────
INTENT 73: Moro longe. Atende minha cidade?
TRIGGERS: “moro em outra cidade”, “tem aqui no interior?”
RESPOSTA: “Atendemos presencialmente e online. Posso ver a melhor forma de cuidar de você onde estiver?”
AÇÃO: Oferecer telemedicina ou orientação
ESCALAMENTO: ❌

INTENT 74: Não tenho internet
TRIGGERS: “não tenho wi-fi sempre”, “minha conexão é ruim”
RESPOSTA: “Podemos combinar formas flexíveis. Até com mensagens simples dá pra começar. Quer que eu te explique como?”
AÇÃO: Encaminhar alternativas
ESCALAMENTO: ❌

────────────────────────────
INTENT 75: Não posso pagar
TRIGGERS: “não tenho dinheiro”, “é muito caro pra mim”
RESPOSTA: “Te entendo. Podemos buscar uma forma acessível, ou te conectar com projetos parceiros. Quer tentar juntos?”
AÇÃO: Encaminhar atendimento social ou explicação
ESCALAMENTO: ⚠️

INTENT 76: Quero só conversar
TRIGGERS: “só quero desabafar”, “não quero atendimento, só conversar”
RESPOSTA: “Conversar também é cuidado. Pode me dizer o que está sentindo, e eu estarei aqui.”
AÇÃO: Escuta ativa
ESCALAMENTO: ❌

────────────────────────────
INTENTS 77–80: Interesse técnico ou profissional
TRIGGERS: “posso trabalhar com vocês?”, “sou psicólogo, posso ajudar?”
RESPOSTA: “Ficamos felizes com seu interesse. Quer que eu registre isso para a equipe te responder?”
AÇÃO: Coletar contato / Encaminhar RH
ESCALAMENTO: ❌

────────────────────────────
INTENTS 81–85: Curiosidade de como funciona
TRIGGERS: “como você me entende?”, “você guarda o que eu falo?”, “como sabe que estou mal?”
RESPOSTA: “Eu analiso palavras e emoções com base em padrões, mas nunca julgo ou invado sua privacidade. Você sempre decide o que quer me contar.”
AÇÃO: Explicação + reforço de confiança
ESCALAMENTO: ❌

────────────────────────────
INTENTS 86–90: Barragens emocionais
TRIGGERS: “ninguém nunca me ajudou”, “vai dar em nada”, “ninguém liga pra mim”
RESPOSTA: “Você importa. Talvez nunca tenha sentido isso, mas aqui eu estou com você. Posso estar com você nesse começo?”
AÇÃO: Escuta + reforço positivo
ESCALAMENTO: ✅MAPEAMENTO DE INTENÇÕES – DOMO (FAMDOMES) | BLOCO 2/10
Total de Intenções: 30 (31–60)
Categorias: Crise Emocional, Resistência, Desinformação, Dúvidas Clínicas, Conversão Familiar

────────────────────────────
INTENT 31: Penso em morrer
TRIGGERS: “quero morrer”, “não vejo mais sentido”, “penso em tirar a vida”
RESPOSTA: “Sinto muito que esteja passando por isso. Você não está sozinho. Vou acionar agora alguém da nossa equipe humana para te ajudar. Fique comigo, por favor.”
AÇÃO: Escalamento emergencial
ESCALAMENTO: ✅✅ Urgente

INTENT 32: Estou surtando
TRIGGERS: “tô surtando”, “perdi o controle”, “não consigo me acalmar”
RESPOSTA: “Respira comigo. Estou aqui com você. Posso te ajudar a falar com um profissional humano agora?”
AÇÃO: Escuta + convocar equipe
ESCALAMENTO: ✅

INTENT 33: Minha mente não para
TRIGGERS: “não paro de pensar”, “minha cabeça não para”, “muito pensamento”
RESPOSTA: “Pode ser muito difícil conviver com isso. Quer tentar conversar agora ou prefere que eu organize uma ajuda?”
AÇÃO: Oferecer escuta ou agendamento
ESCALAMENTO: ⚠️

INTENT 34: Não quero ajuda
TRIGGERS: “não quero ajuda”, “tô bem assim”, “não preciso de nada”
RESPOSTA: “Tudo bem. Estou aqui caso mude de ideia. Sua decisão será sempre respeitada. Quer apenas conversar um pouco sem compromisso?”
AÇÃO: Aguardar reabertura da conversa
ESCALAMENTO: ❌

INTENT 35: Já tentei de tudo
TRIGGERS: “já tentei várias clínicas”, “nada funciona”, “não adianta mais”
RESPOSTA: “Sinto que você está cansado. Não estamos aqui para repetir o que falhou. Quer tentar um novo caminho com calma?”
AÇÃO: Oferecer escuta + plano humanizado
ESCALAMENTO: ✅

────────────────────────────
INTENT 36: Vocês fazem internação compulsória?
TRIGGERS: “vocês internam à força?”, “é possível internar meu filho mesmo sem ele querer?”
RESPOSTA: “A internação compulsória só pode ser feita com autorização judicial e laudo médico. Posso te explicar como funciona e o que é possível fazer neste momento.”
AÇÃO: Informar + orientar próximos passos
ESCALAMENTO: ✅

INTENT 37: É involuntária?
TRIGGERS: “ele não quer tratamento, posso obrigar?”, “tem como internar sem autorização?”
RESPOSTA: “Em alguns casos, é possível a internação involuntária com laudo técnico. Quer que eu te mostre os passos legais e como ajudamos nisso?”
AÇÃO: Encaminhar para suporte jurídico clínico
ESCALAMENTO: ✅

INTENT 38: Tem internação feminina?
TRIGGERS: “tem clínica para mulheres?”, “vocês acolhem mulheres dependentes?”
RESPOSTA: “Sim. Temos atendimento e encaminhamento específico para o público feminino. Posso te mostrar as opções?”
AÇÃO: Apresentar encaminhamentos
ESCALAMENTO: ❌

INTENT 39: Tem internação LGBT?
TRIGGERS: “acolhem pessoas trans?”, “tem lugar para gays?”, “atendem LGBTQIA+?”
RESPOSTA: “Aqui todas as pessoas são acolhidas com respeito. Temos atendimento inclusivo. Quer saber mais?”
AÇÃO: Garantir acolhimento + explicação
ESCALAMENTO: ❌

INTENT 40: Acolhem adolescentes?
TRIGGERS: “vocês atendem menor de idade?”, “meu filho tem 15 anos, pode?”
RESPOSTA: “Sim, temos equipe especializada em adolescentes. Acolher jovens exige um cuidado especial, e é isso que oferecemos.”
AÇÃO: Explicar processo + autorizações
ESCALAMENTO: ✅

────────────────────────────
INTENTS 41–45: Dúvidas clínicas específicas
TRIGGERS: “tratam alcoolismo?”, “ajudam com ansiedade?”, “tem como sair da cocaína?”, “serve pra bipolar?”
RESPOSTA: “Temos equipe que atua com diversas condições, mas quem vai te avaliar com carinho é um profissional humano. Posso agendar ou explicar mais?”
AÇÃO: Encaminhar para triagem real
ESCALAMENTO: ⚠️

────────────────────────────
INTENTS 46–50: Desinformação ou ceticismo
TRIGGERS: “isso aqui é um robô?”, “vocês são de verdade?”, “duvido que funcione”, “isso é golpe?”
RESPOSTA: “É natural ter dúvidas. O FAMDOMES é real, e eu sou uma IA criada para escutar com respeito. Tudo aqui é auditado e humano.”
AÇÃO: Garantir segurança + opção de humano
ESCALAMENTO: ❌

────────────────────────────
INTENTS 51–55: Conversão familiar
TRIGGERS: “meu parente não aceita ajuda”, “tentei tudo com meu filho”, “ela mente muito”
RESPOSTA: “Entendo essa dor. Às vezes, ajudar é mais difícil do que parece. Podemos cuidar de você enquanto isso e preparar um caminho possível para ele/ela.”
AÇÃO: Escuta familiar + conversão empática
ESCALAMENTO: ✅

────────────────────────────
INTENTS 56–60: Paciente diz que recaiu
TRIGGERS: “voltei a usar”, “recaí ontem”, “não consegui ficar limpo”
RESPOSTA: “Não existe fracasso aqui. Só quem tenta pode cair. Quer que eu organize um atendimento para recomeçar com você?”
AÇÃO: Escuta + reforço positivo + agendamento
ESCALAMENTO: ✅
# Arquivo: app/s.sh
#!/bin/bash

# Cabeçalho da árvore
tree_header="."
tree_header_line="--"
for i in $(seq 1 78); do
  tree_header_line="${tree_header_line}-"
done

echo "$tree_header" > todos_arquivos_python.txt
echo "$tree_header_line" >> todos_arquivos_python.txt

find . -name "*.py" -print0 | while IFS= read -r -d $'\0' file; do
  echo "Arquivo: $file" >> todos_arquivos_python.txt
  echo "-------------------------------------------------------------------------------" >> todos_arquivos_python.txt
  cat "$file" >> todos_arquivos_python.txt
  echo "" >> todos_arquivos_python.txt
done

echo "Todos os arquivos Python foram salvos em todos_arquivos_python.txt com o cabeçalho da árvore."
# Arquivo: app/agents/domo_escuta.py
# ===========================================================
# Arquivo: agents/domo_escuta.py
# Agente responsável pelo acolhimento inicial.
# - Usa o sentimento da primeira mensagem para personalizar a saudação.
# - Carrega a resposta padrão de ACOLHIMENTO como fallback.
# ===========================================================
from app.agents.agente_base import AgenteBase
# Usaremos a função de refrasear da classe base ou uma chamada direta à IA
from app.core.ia_direct import gerar_resposta_ia # Ou app.utils.ollama
import logging

logger = logging.getLogger("famdomes.domo_escuta")

class DomoEscuta(AgenteBase):
    """
    Agente para a primeira interação, focando em acolhimento empático.
    Adapta a saudação com base no sentimento detectado na mensagem inicial do usuário.
    """
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        """
        Gera a mensagem de acolhimento inicial, personalizada pelo sentimento.
        """
        # Carrega a intent 'ACOLHIMENTO' para obter a resposta padrão
        intent_acolhimento = await self._carregar_mensagem_intent("ACOLHIMENTO")
        resposta_padrao = intent_acolhimento.get("resposta") if intent_acolhimento else "Olá! Sou o Domo. Como posso ajudar?"
        resposta_final = resposta_padrao # Começa com o padrão

        # Tenta personalizar com base no sentimento recebido no construtor (self.sentimento)
        if self.sentimento:
            try:
                sentimento_predominante = max(self.sentimento, key=self.sentimento.get)
                score_predominante = self.sentimento.get(sentimento_predominante, 0)

                prompt_personalizado = None
                # Define o prompt com base no sentimento predominante (se score for significativo)
                if sentimento_predominante == 'negativo' and score_predominante > 0.6: # Limiar ajustável
                    prompt_personalizado = f"""
                    O usuário iniciou a conversa com uma mensagem de sentimento predominantemente NEGATIVO.
                    Gere uma saudação CURTA e ACOLHEDORA (máx 1-2 frases, ~150 caracteres) que:
                    1. Reconheça SUTILMENTE a dificuldade (ex: "Sinto muito que esteja passando por isso", "Sei que às vezes é difícil buscar ajuda").
                    2. Apresente-se como Domo.
                    3. Pergunte como pode ajudar HOJE.
                    EVITE repetir a mensagem original do usuário.
                    Saudação Empática Negativa:
                    """
                elif sentimento_predominante == 'positivo' and score_predominante > 0.6:
                     prompt_personalizado = f"""
                     O usuário iniciou a conversa com uma mensagem de sentimento predominantemente POSITIVO.
                     Gere uma saudação CURTA e POSITIVA (máx 1-2 frases, ~150 caracteres) que:
                     1. Cumprimente de forma leve (ex: "Olá!", "Que bom te ver por aqui!").
                     2. Apresente-se como Domo.
                     3. Pergunte como pode ajudar.
                     Saudação Positiva:
                     """
                # Se for neutro ou score baixo, usa a resposta padrão (resposta_final já é a padrão)

                # Se um prompt foi definido, chama a IA
                if prompt_personalizado:
                    logger.debug(f"DomoEscuta: Gerando resposta personalizada para sentimento '{sentimento_predominante}' para {telefone}")
                    # Adapte a chamada conforme sua função de IA (ia_direct ou ollama)
                    resposta_ia = await gerar_resposta_ia({"prompt_context": prompt_personalizado})
                    # Verifica se a resposta da IA é válida antes de usar
                    if resposta_ia and len(resposta_ia) > 10:
                        resposta_final = resposta_ia.strip()
                        logger.info(f"DomoEscuta: Resposta personalizada gerada para {telefone}.")
                    else:
                        logger.warning(f"DomoEscuta: IA não retornou resposta válida para personalização. Usando padrão para {telefone}.")
                        # Mantém a resposta padrão
            except Exception as e:
                logger.warning(f"DomoEscuta: Falha ao gerar resposta personalizada: {e}. Usando padrão para {telefone}.")
                # Mantém a resposta padrão em caso de erro

        # Define o estado seguinte no contexto para o Orquestrador saber
        # É MELHOR o Orquestrador definir o estado após a execução do agente.
        # Mas se o agente precisar forçar um estado, pode fazer aqui:
        # salvar_contexto(telefone=telefone, novo_estado="ACOLHIMENTO_ENVIADO")
        # logger.info(f"DomoEscuta: Estado definido para ACOLHIMENTO_ENVIADO para {telefone}")

        return resposta_final


# Arquivo: app/agents/domo_generativo.py
from app.agents.agente_base import AgenteBase
from app.core.ia_direct import gerar_resposta_ia

class DomoGenerativo(AgenteBase):
    async def _gerar_resposta(self, telefone, mensagem_original):
        return await gerar_resposta_ia({"tel": telefone, "msg": mensagem_original})

# Arquivo: app/agents/domo_integrador.py
"""
Encapsula chamada à API WhatsApp para manter padrão único.
Outros agentes devem usar enviar_mensagem de utils.mensageria diretamente,
mas este agente permite ações administrativas (ex: envio em lote).
"""
from app.agents.agente_base import AgenteBase
from app.utils.mensageria import enviar_mensagem

class DomoIntegrador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        # Apenas ecoa mensagem administrativa (não usado no fluxo paciente)
        await enviar_mensagem(telefone, "Operação concluída.")
        return None

# Arquivo: app/agents/domo_comercial.py
# ===========================================================
# Arquivo: agents/domo_comercial.py
# Agente responsável pelo fluxo de qualificação e venda.
# - Inicia com micro-compromisso.
# - Realiza perguntas de qualificação sequenciais.
# - Valida respostas anteriores com IA.
# - Apresenta planos com foco em VALOR antes do preço.
# - Gerencia o CTA e respostas de recusa.
# ===========================================================
from __future__ import annotations
import logging
from app.agents.agente_base import AgenteBase
from app.core.scoring import score_lead
from app.utils.contexto import salvar_contexto, obter_contexto
from app.core.ia_direct import gerar_resposta_ia # Ou app.utils.ollama

logger = logging.getLogger("famdomes.domo_comercial")

# --- Configuração do Fluxo de Qualificação ---
# Mover para um arquivo de configuração ou JSON seria ideal
PERGUNTAS_QUALIFICACAO = [
    {
        "id": 1,
        "chave_meta": "para_quem", # Chave para salvar a resposta na meta_conversa
        "texto": "Para direcionar melhor, a ajuda que você busca é para você mesmo(a) ou para outra pessoa (ex: filho, esposa, irmão)?"
    },
    {
        "id": 2,
        "chave_meta": "preferencia_atendimento",
        "texto": "Considerando a necessidade atual, você teria preferência por um atendimento online ou presencial?"
    },
    {
        "id": 3,
        "chave_meta": "possibilidade_investimento",
        "texto": "Pensando no cuidado contínuo, existe a possibilidade de um investimento mensal em um acompanhamento profissional?"
    }
]
TOTAL_PERGUNTAS = len(PERGUNTAS_QUALIFICACAO)

# Intents relevantes para este agente (carregados via _carregar_mensagem_intent)
INTENT_MICRO_COMPROMISSO = "MICRO_COMPROMISSO"
INTENT_PITCH_PLANO1 = "PITCH_PLANO1"
INTENT_PITCH_PLANO3 = "PITCH_PLANO3"
INTENT_DETALHES_PLANO = "COMERCIAL_DETALHES_PLANO"
INTENT_CTA = "CALL_TO_ACTION"
INTENT_RECUSA = "RECUSA_PRECO"
INTENT_DEFAULT_COMERCIAL = "FAQ_COMO_FUNCIONA" # Fallback se algo der errado no fluxo

# Palavras-chave para análise de resposta (simplificado)
RESPOSTAS_AFIRMATIVAS = ["sim", "quero", "pode", "manda", "link", "pagar", "começar", "aceito", "claro", "ok", "positivo", "tenho", "existe"]
RESPOSTAS_NEGATIVAS = ["não", "nao", "agora não", "sem chance", "impossível", "negativo", "nunca"]
RESPOSTAS_PEDIDO_DETALHES = ["detalhes", "mais", "como é", "explica", "quais", "opções"]

class DomoComercial(AgenteBase):
    """
    Gerencia o fluxo de qualificação de leads e apresentação dos planos comerciais.
    """

    async def _gerar_validacao_curta(self, telefone: str, mensagem_original: str) -> str:
        """Gera validação empática curta para a resposta anterior."""
        # Não valida a primeira resposta (após micro-compromisso)
        ctx = obter_contexto(telefone)
        etapa_quali = ctx.get("meta_conversa", {}).get("etapa_quali", 0)
        if etapa_quali <= 1: # Não valida antes da Q1 ou após Q1
             return ""

        if not self.sentimento or not mensagem_original:
             return "Ok. " # Fallback muito curto

        sentimento_desc = "neutro"
        if self.sentimento.get('negativo', 0) > 0.6: sentimento_desc = "negativo"
        elif self.sentimento.get('positivo', 0) > 0.6: sentimento_desc = "positivo"

        try:
            prompt = f"""
            O usuário respondeu a uma pergunta de qualificação. O sentimento detectado foi {sentimento_desc}.
            Gere uma ÚNICA PALAVRA de validação (ex: "Entendido.", "Compreendo.", "Perfeito.", "Certo.").
            Validação Curta:
            """
            validacao = await gerar_resposta_ia({"prompt_context": prompt})
            # Garante que a validação seja curta e termine com ponto e espaço
            validacao_limpa = "".join(c for c in validacao if c.isalnum() or c in ['.', ' ']).strip().split('.')[0]
            return f"{validacao_limpa}. " if validacao_limpa else "Ok. "
        except Exception as e:
            logger.warning(f"DomoComercial: Falha ao gerar validação curta: {e}")
            return "Ok. "

    async def _gerar_resposta_valor_preco(self, telefone: str, plano_intent_id: str) -> str:
        """Gera a explicação de valor antes do preço e CTA."""
        plano_info = await self._carregar_mensagem_intent(plano_intent_id)
        if not plano_info or "resposta" not in plano_info:
            logger.error(f"DomoComercial: Falha ao carregar dados da intent {plano_intent_id}")
            return "Temos ótimas opções de acompanhamento. Gostaria do link para começar?" # Fallback

        # A resposta no JSON contém a descrição e o preço. Precisamos que a IA foque no valor.
        descricao_preco_original = plano_info["resposta"]

        try:
            prompt = f"""
            O usuário se qualificou para o plano '{plano_intent_id}'. A descrição original é: "{descricao_preco_original}".
            Gere uma resposta CONCISA (máx 2-3 frases, ~250 caracteres) que:
            1. Comece com uma frase positiva de transição (ex: "Excelente!", "Ótima opção para você!").
            2. DESTAQUE O PRINCIPAL BENEFÍCIO ou TRANSFORMAÇÃO que este plano oferece (use a descrição original como inspiração, mas foque no resultado para o usuário).
            3. APENAS DEPOIS, mencione o investimento de forma clara (ex: "O investimento é de ..."). Use o valor da descrição original.
            4. FINALIZE perguntando DIRETAMENTE se o usuário deseja o link de pagamento para iniciar. (ex: "Deseja o link de pagamento para começar agora?")
            Resposta Focada em Valor e CTA:
            """
            resposta_valor = await gerar_resposta_ia({"prompt_context": prompt})
            if resposta_valor and len(resposta_valor) > 20:
                logger.info(f"DomoComercial: Resposta de valor/preço gerada para {telefone}.")
                return resposta_valor.strip()
            else: # Fallback se IA falhar
                logger.warning(f"DomoComercial: IA falhou ao gerar valor/preço para {plano_intent_id}. Usando fallback.")
                return f"{descricao_preco_original} Deseja o link de pagamento para começar?"
        except Exception as e:
            logger.exception(f"DomoComercial: Erro ao gerar resposta de valor/preço: {e}")
            return f"{descricao_preco_original} Deseja o link de pagamento para começar?" # Fallback

    async def _gerar_resposta(self, telefone: str, msg: str) -> str | None:
        """
        Define a lógica de resposta do agente comercial com base na intent e contexto.
        """
        ctx = obter_contexto(telefone)
        meta = ctx.get("meta_conversa", {})
        etapa_quali_atual = meta.get("etapa_quali", 0) # Etapa *antes* desta interação
        intent_atual = self.intent # Intent que ativou este agente

        resposta = None
        novo_estado_sugerido = None # O agente pode sugerir um novo estado para o Orquestrador

        # --- Fluxo de Qualificação ---
        # Verifica se estamos iniciando ou continuando a qualificação
        if intent_atual == INTENT_MICRO_COMPROMISSO or (etapa_quali_atual > 0 and etapa_quali_atual <= TOTAL_PERGUNTAS):

            # Salva a resposta da pergunta anterior (se não for a primeira)
            if etapa_quali_atual > 0:
                 pergunta_anterior = PERGUNTAS_QUALIFICACAO[etapa_quali_atual - 1]
                 chave_meta = pergunta_anterior["chave_meta"]
                 meta[chave_meta] = msg # Salva a resposta do usuário
                 meta[f"sentimento_{chave_meta}"] = self.sentimento # Salva sentimento da resposta
                 logger.debug(f"DomoComercial: Resposta para '{chave_meta}' salva para {telefone}.")

            # Gera validação curta para a resposta anterior (exceto após micro-compromisso)
            validacao = await self._gerar_validacao_curta(telefone, msg)

            # Verifica se ainda há perguntas a fazer
            if etapa_quali_atual < TOTAL_PERGUNTAS:
                # Prepara a próxima pergunta
                proxima_pergunta_info = PERGUNTAS_QUALIFICACAO[etapa_quali_atual]
                resposta = validacao + proxima_pergunta_info["texto"]
                # Atualiza a etapa no meta_conversa para a próxima interação
                meta["etapa_quali"] = etapa_quali_atual + 1
                novo_estado_sugerido = INTENT_MICRO_COMPROMISSO # Mantém no fluxo de qualificação
                salvar_contexto(telefone=telefone, meta_conversa=meta, estado=novo_estado_sugerido)
                logger.info(f"DomoComercial: Enviando pergunta de qualificação {etapa_quali_atual + 1} para {telefone}.")
            else:
                # Finalizou a qualificação
                logger.info(f"DomoComercial: Qualificação finalizada para {telefone}.")
                # Calcular score final com base nas respostas (exemplo simples)
                # (A função score_lead original pode precisar ser adaptada ou usar as respostas salvas)
                score_final = meta.get("score_lead", 0) # Usa score já calculado ou recalcula
                try:
                    # Exemplo: recalcular baseado na resposta sobre investimento
                    resp_invest = meta.get("possibilidade_investimento", "").lower()
                    if any(affirmative in resp_invest for affirmative in RESPOSTAS_AFIRMATIVAS):
                        score_final += 2
                    elif any(negative in resp_invest for negative in RESPOSTAS_NEGATIVAS):
                        score_final -= 2
                    score_final = max(0, min(6, score_final)) # Garante limite 0-6
                    meta["score_lead"] = score_final
                except Exception as e:
                    logger.error(f"DomoComercial: Erro ao recalcular score final para {telefone}: {e}")

                meta.pop("etapa_quali", None) # Limpa a etapa de qualificação

                # Define o próximo passo (Pitch) baseado no score
                proximo_pitch_intent = INTENT_PITCH_PLANO3 if score_final >= 4 else INTENT_PITCH_PLANO1
                novo_estado_sugerido = proximo_pitch_intent
                salvar_contexto(telefone=telefone, meta_conversa=meta, estado=novo_estado_sugerido)

                # Gera a resposta de valor/preço para o plano apropriado
                resposta = await self._gerar_resposta_valor_preco(telefone, proximo_pitch_intent)

        # --- Fluxo de Pitch (Resposta à apresentação do plano) ---
        elif intent_atual in [INTENT_PITCH_PLANO1, INTENT_PITCH_PLANO3]:
            msg_lower = msg.lower()
            # Resposta positiva ao Pitch -> Vai para CTA
            if any(affirmative in msg_lower for affirmative in RESPOSTAS_AFIRMATIVAS):
                logger.info(f"DomoComercial: Usuário {telefone} aceitou o pitch. Indo para CTA.")
                novo_estado_sugerido = INTENT_CTA
                intent_cta_info = await self._carregar_mensagem_intent(INTENT_CTA)
                resposta = intent_cta_info.get("resposta") if intent_cta_info else "Ótimo! Aqui está o link para pagamento: [link]"
                # Chamar a função para gerar o link de pagamento real (routes/ia.py)
                # Esta parte precisa ser coordenada com o Orquestrador ou uma chamada direta
                # Idealmente, o Orquestrador detectaria a confirmação e chamaria a rota /ia-comando
                # Por simplicidade aqui, apenas enviamos a mensagem do JSON
                # TODO: Integrar com a geração real do link de pagamento Stripe via routes/ia.py
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido) # Salva estado CTA

            # Pedido de mais detalhes -> Vai para Detalhes
            elif any(detail_request in msg_lower for detail_request in RESPOSTAS_PEDIDO_DETALHES):
                logger.info(f"DomoComercial: Usuário {telefone} pediu mais detalhes. Indo para Detalhes.")
                novo_estado_sugerido = INTENT_DETALHES_PLANO
                intent_detalhes_info = await self._carregar_mensagem_intent(INTENT_DETALHES_PLANO)
                resposta = intent_detalhes_info.get("resposta") if intent_detalhes_info else "Nossos planos incluem X, Y, Z. Quer agendar?"
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

            # Resposta negativa ou incerta -> Vai para Recusa
            else:
                logger.info(f"DomoComercial: Usuário {telefone} recusou ou respondeu incertamente ao pitch. Indo para Recusa.")
                novo_estado_sugerido = INTENT_RECUSA
                intent_recusa_info = await self._carregar_mensagem_intent(INTENT_RECUSA)
                resposta = intent_recusa_info.get("resposta") if intent_recusa_info else "Entendo. Posso ajudar com mais alguma informação?"
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

        # --- Fluxo de Detalhes (Resposta após receber mais detalhes) ---
        elif intent_atual == INTENT_DETALHES_PLANO:
             msg_lower = msg.lower()
             # Resposta positiva aos Detalhes -> Vai para CTA
             if any(affirmative in msg_lower for affirmative in RESPOSTAS_AFIRMATIVAS):
                 logger.info(f"DomoComercial: Usuário {telefone} aceitou após detalhes. Indo para CTA.")
                 novo_estado_sugerido = INTENT_CTA
                 intent_cta_info = await self._carregar_mensagem_intent(INTENT_CTA)
                 resposta = intent_cta_info.get("resposta") if intent_cta_info else "Ótimo! Aqui está o link para pagamento: [link]"
                 # TODO: Integrar com geração real do link Stripe
                 salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)
             # Resposta negativa ou incerta -> Vai para Recusa
             else:
                 logger.info(f"DomoComercial: Usuário {telefone} recusou ou incerto após detalhes. Indo para Recusa.")
                 novo_estado_sugerido = INTENT_RECUSA
                 intent_recusa_info = await self._carregar_mensagem_intent(INTENT_RECUSA)
                 resposta = intent_recusa_info.get("resposta") if intent_recusa_info else "Entendo. Posso ajudar com mais alguma informação?"
                 salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

        # --- Fluxo de CTA (Resposta após receber link de pagamento) ---
        elif intent_atual == INTENT_CTA:
            logger.info(f"DomoComercial: Usuário {telefone} interagiu após receber link de pagamento.")
            # A confirmação de pagamento deve vir pelo webhook do Stripe.
            # Qualquer mensagem aqui provavelmente é uma dúvida ou comentário.
            # Podemos usar a IA generativa para responder ou direcionar para FAQ/Humano.
            resposta = await self._refrasear_com_ia(
                "Recebi sua mensagem. Se tiver alguma dúvida sobre o pagamento ou o próximo passo, pode perguntar. Assim que o pagamento for confirmado, iniciaremos a triagem.",
                telefone,
                contexto_breve="usuario interagiu apos receber link de pagamento"
            )
            novo_estado_sugerido = "AGUARDANDO_PAGAMENTO" # Estado explícito
            salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

        # --- Fluxo de Recusa (Resposta à oferta de material gratuito) ---
        elif intent_atual == INTENT_RECUSA:
            msg_lower = msg.lower()
            if any(affirmative in msg_lower for affirmative in RESPOSTAS_AFIRMATIVAS):
                logger.info(f"DomoComercial: Usuário {telefone} aceitou material gratuito.")
                resposta = "Que ótimo! Em breve nossa equipe enviará o material para você por aqui. Algo mais em que posso ajudar hoje?"
                novo_estado_sugerido = "LEAD_MATERIAL_GRATUITO" # Estado final para este fluxo
                # Adicionar lógica para marcar o lead para envio do material, se necessário
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)
            else:
                logger.info(f"DomoComercial: Usuário {telefone} recusou material gratuito.")
                resposta = "Tudo bem. Se mudar de ideia ou precisar de algo mais no futuro, é só chamar. Estou à disposição!"
                novo_estado_sugerido = "FINALIZADO_SEM_VENDA" # Estado final
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

        # --- Fallback ---
        if resposta is None:
            logger.warning(f"DomoComercial: Nenhuma lógica tratou a intent '{intent_atual}' ou estado para {telefone}. Verificando fallback.")
            # Tenta carregar uma resposta da própria intent (se houver, ex: FAQ dentro do fluxo)
            intent_info = await self._carregar_mensagem_intent(intent_atual)
            if intent_info and intent_info.get("resposta"):
                resposta = intent_info.get("resposta")
                novo_estado_sugerido = intent_atual # Mantém a intent como estado? Ou vai para FAQ?
                salvar_contexto(telefone=telefone, estado="SUPORTE_FAQ") # Manda para suporte geral
            else:
                # Se não há resposta na intent, usa um fallback mais genérico
                fallback_info = await self._carregar_mensagem_intent(INTENT_DEFAULT_COMERCIAL)
                resposta = fallback_info.get("resposta") if fallback_info else "Não entendi bem. Pode reformular ou me dizer o que gostaria de fazer?"
                novo_estado_sugerido = "SUPORTE_FAQ" # Estado de suporte geral
                salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)


        # --- Anti-Loop ---
        # Compara a resposta gerada com a última enviada pelo bot
        ultimo_bot = ctx.get("ultimo_texto_bot", "")
        if resposta and resposta.strip() == ultimo_bot.strip():
            logger.warning(f"DomoComercial: ANTILOOP DETECTADO para {telefone}! Intent: {intent_atual}. Resposta repetida: '{resposta[:50]}...'")
            # Força uma resposta diferente, talvez usando a IA generativa ou uma mensagem padrão de erro de loop
            resposta_antiloop_info = await self._carregar_mensagem_intent("FAQ_ROBO") # Exemplo: explica que é IA
            if resposta_antiloop_info:
                 resposta = resposta_antiloop_info.get("resposta") + " Às vezes me repito, desculpe! Pode tentar perguntar de outra forma?"
            else:
                 resposta = "Parece que estamos andando em círculos! 😊 Poderia tentar me dizer o que precisa de outra maneira?"
            # Considerar mudar o estado para SUPORTE_FAQ ou pedir ajuda humana
            novo_estado_sugerido = "SUPORTE_FAQ"
            salvar_contexto(telefone=telefone, estado=novo_estado_sugerido)

        return resposta


# Arquivo: app/agents/domo_presenca.py
"""
Mantém presença viva: envia mensagens breves de acompanhamento sem exigir resposta.
"""
from app.agents.agente_base import AgenteBase

class DomoPresenca(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        return await self._carregar_mensagem_intent("PRESENCA_VIVA")

# Arquivo: app/agents/agente_base.py
# ===========================================================
# Arquivo: agents/agente_base.py
# Classe-base para todos os agentes DOMO
# - Garante que sentimento seja armazenado.
# - Mantém método para carregar intents.
# ===========================================================
from __future__ import annotations

import json
import logging # Adicionado logging
from pathlib import Path
from typing import Dict, Any, Optional

# Assume que intents.py está em core
from app.core.intents import obter_intent
# Assume que mensageria.py está em utils
from app.utils.mensageria import enviar_mensagem
# Assume que contexto.py está em utils
from app.utils.contexto import salvar_contexto, obter_contexto # Adicionado obter_contexto

logger = logging.getLogger("famdomes.agente_base") # Logger específico

class AgenteBase:
    """
    Classe base abstrata para todos os agentes DOMO.
    Cada agente concreto deve implementar _gerar_resposta().
    """

    def __init__(self, intent: str, sentimento: Dict[str, Any] | None = None) -> None:
        """
        Inicializa o agente com a intent detectada e o sentimento da mensagem do usuário.

        Args:
            intent (str): A intenção principal identificada pelo Orquestrador.
            sentimento (Dict[str, Any] | None): Dicionário com scores de sentimento
                                                (ex: {'positivo': 0.1, 'negativo': 0.8, 'neutro': 0.1}).
                                                Pode ser None se a análise falhar.
        """
        self.intent = intent
        # Garante que sentimento seja sempre um dicionário, mesmo que vazio
        self.sentimento: Dict[str, Any] = sentimento if sentimento is not None else {}
        self.nome: str = self.__class__.__name__
        logger.debug(f"Agente '{self.nome}' inicializado com intent '{self.intent}' e sentimento {self.sentimento}")

    # ------------------------------------------------------
    async def executar(self, telefone: str, mensagem_original: str) -> None:
        """
        Método principal chamado pelo MCP Orquestrador.
        1. Chama _gerar_resposta() para obter o texto da resposta.
        2. Envia a resposta via mensageria (se houver).
        3. Salva a resposta do bot no contexto para evitar loops.
        """
        resposta_texto: str | None = None
        try:
            # Chama o método que cada agente implementa para definir sua lógica
            resposta_texto = await self._gerar_resposta(telefone, mensagem_original)

            if resposta_texto:
                logger.info(f"Agente '{self.nome}': Enviando resposta para {telefone}: '{resposta_texto[:60]}...'")
                # Envia a mensagem para o usuário
                resultado_envio = await enviar_mensagem(telefone, resposta_texto)

                # Verifica se o envio foi bem-sucedido antes de salvar no contexto
                if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                    # Salva a resposta enviada no contexto para referência e anti-loop
                    # É importante que o Orquestrador também salve o estado final após a execução
                    salvar_contexto(telefone=telefone, ultimo_texto_bot=resposta_texto)
                    logger.debug(f"Agente '{self.nome}': Resposta salva no contexto de {telefone}.")
                else:
                    logger.error(f"Agente '{self.nome}': Falha ao enviar mensagem para {telefone}. Status: {resultado_envio.get('status')}, Erro: {resultado_envio.get('erro')}")
                    # Não salva ultimo_texto_bot se o envio falhou

            else:
                # Loga se o agente decidiu não responder
                logger.info(f"Agente '{self.nome}' optou por não responder para {telefone} (intent='{self.intent}').")
                # Garante que o ultimo_texto_bot seja limpo ou mantido como estava
                # salvar_contexto(telefone=telefone, ultimo_texto_bot=None) # Ou não fazer nada

        except NotImplementedError:
             logger.error(f"Agente '{self.nome}' não implementou o método _gerar_resposta().")
             # Considerar enviar uma mensagem de erro genérica ou levantar a exceção
             raise # Re-levanta a exceção para o Orquestrador tratar
        except Exception as e:
            logger.exception(f"Agente '{self.nome}': Erro inesperado durante _gerar_resposta ou envio para {telefone}: {e}")
            # Considerar enviar uma mensagem de erro genérica
            await enviar_mensagem(telefone, "Desculpe, ocorreu um erro interno ao processar sua solicitação.")
            # Levanta a exceção para o Orquestrador registrar o erro
            raise

    # ------------------------------------------------------
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        """
        Método abstrato que DEVE ser implementado por cada agente concreto.

        Responsável por definir a lógica específica do agente e retornar a string
        da mensagem a ser enviada ao usuário, ou None se o agente não deve responder.

        Args:
            telefone (str): O número de telefone do usuário.
            mensagem_original (str): A mensagem exata que o usuário enviou nesta interação.

        Returns:
            str | None: O texto da resposta a ser enviada, ou None para não enviar nada.
        """
        raise NotImplementedError(f"Agente '{self.nome}' não implementou '_gerar_resposta'")

    # ------------------------------------------------------
    async def _carregar_mensagem_intent(self, intent_id: str) -> Dict[str, Any] | None:
        """
        Utilitário para buscar os dados de uma intent específica (incluindo a resposta)
        nos arquivos JSON carregados por `core/intents.py`.

        Args:
            intent_id (str): O ID da intent a ser buscada (ex: "ACOLHIMENTO", "FAQ_PAGAMENTO").

        Returns:
            Dict[str, Any] | None: Um dicionário contendo os dados da intent (incluindo
                                    'resposta', 'triggers', 'escala_humano', etc.) se encontrada,
                                    ou None caso contrário.
        """
        intent_data = obter_intent(intent_id)
        if not intent_data:
            logger.warning(f"Agente '{self.nome}': Intent '{intent_id}' não encontrada nos arquivos JSON.")
            return None
        # Retorna o dicionário completo da intent
        return intent_data

    # ------------------------------------------------------
    # Métodos utilitários adicionais podem ser adicionados aqui,
    # como chamar a IA para tarefas específicas, formatar dados, etc.
    # Exemplo: Chamar IA para refrasear (pode ficar aqui ou em um utilitário separado)
    async def _refrasear_com_ia(self, texto_original: str, telefone: str, contexto_breve: str = "geral") -> str:
        """Tenta refrasear uma mensagem padrão usando a IA para soar mais natural."""
        # Importa aqui para evitar dependência circular ou coloca em utils/ia_utils.py
        from app.core.ia_direct import gerar_resposta_ia # Ou outra função de IA

        if not texto_original: return ""

        try:
            # Ajuste o prompt conforme necessário para sua IA
            prompt = f"""
            Contexto: {contexto_breve}.
            Reescreva a mensagem abaixo para soar um pouco mais natural e empática, mantendo o sentido original e o tamanho similar.
            Mensagem Original: "{texto_original}"
            Mensagem Reescrevida:
            """
            # Use um contexto específico para a chamada da IA se necessário
            resposta_ia = await gerar_resposta_ia({"prompt_context": prompt})

            if resposta_ia and len(resposta_ia) > 5: # Verifica se a resposta é minimamente válida
                logger.debug(f"Agente '{self.nome}': Texto refraseado para {telefone}: '{resposta_ia[:60]}...'")
                return resposta_ia.strip()
            else:
                logger.warning(f"Agente '{self.nome}': IA não conseguiu refrasear '{texto_original[:30]}...'. Usando original.")
                return texto_original # Retorna original se IA falhar ou resposta for inadequada
        except Exception as e:
            logger.error(f"Agente '{self.nome}': Erro ao chamar IA para refrasear: {e}")
            return texto_original # Retorna original em caso de erro


# Arquivo: app/agents/domo_orientador.py
"""
Responde dúvidas genéricas com base nas intents FAQ_*.
"""
from app.agents.agente_base import AgenteBase

class DomoOrientador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        # Mapeamento simples: intenção já contém a chave FAQ_...
        return await self._carregar_mensagem_intent(self.intent)

# Arquivo: app/agents/domo_escalonador.py
"""
Detecta risco e avisa equipe humana. Não responde ao paciente.
"""
import logging, asyncio
from app.agents.agente_base import AgenteBase
from app.utils.mensageria import enviar_mensagem

logger = logging.getLogger("famdomes.escalonador")

EQUIPE_SUPORTE = ["+5511999990000"]  # ajuste para números reais

class DomoEscalonador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        aviso = f"⚠️ Atenção: possível crise detectada do paciente {telefone}."
        await asyncio.gather(*(enviar_mensagem(dest, aviso) for dest in EQUIPE_SUPORTE))
        logger.info("Equipe humana notificada para %s", telefone)
        return None          # nada enviado ao paciente


# Arquivo: app/agents/domo_followup.py
# ===========================================================
# Arquivo: agents/domo_followup.py
# Agente responsável por enviar mensagens de follow-up.
# - Ativado pelo Scheduler ou outras lógicas.
# - Carrega a mensagem apropriada com base na intent recebida.
# ===========================================================
import logging
from app.agents.agente_base import AgenteBase

logger = logging.getLogger("famdomes.domo_followup")

# Intents esperadas para este agente (devem existir nos JSONs)
INTENTS_FOLLOWUP_SUPORTADAS = [
    "FOLLOW_UP_QUALIFICACAO", # Enviado quando a qualificação para
    "FOLLOW_UP_24H",          # Enviado 24h após link de pagamento (padrão)
    "FOLLOW_UP_PAGAMENTO_BENEFICIO" # Alternativa focada em benefício
    # Adicionar outras intents de follow-up aqui, se necessário
]

class DomoFollowUp(AgenteBase):
    """
    Envia mensagens de follow-up pré-definidas com base na intent.
    Normalmente ativado por tarefas agendadas (scheduler).
    """

    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        """
        Carrega e retorna a mensagem de follow-up correspondente à intent.
        """
        intent_followup = self.intent # A intent que ativou este agente

        # Verifica se a intent é suportada por este agente
        if intent_followup not in INTENTS_FOLLOWUP_SUPORTADAS:
            logger.error(f"DomoFollowUp: Recebeu intent não suportada '{intent_followup}' para {telefone}. Não responderá.")
            return None

        logger.info(f"DomoFollowUp: Preparando mensagem de follow-up '{intent_followup}' para {telefone}.")

        # Carrega os dados da intent (incluindo a mensagem de resposta)
        intent_data = await self._carregar_mensagem_intent(intent_followup)

        if intent_data and intent_data.get("resposta"):
            resposta = intent_data.get("resposta")
            # Opcional: Tentar refrasear levemente com IA para não ser sempre igual
            # resposta_refraseada = await self._refrasear_com_ia(resposta, telefone, f"follow-up {intent_followup}")
            # return resposta_refraseada
            return resposta
        else:
            logger.error(f"DomoFollowUp: Não foi possível carregar a mensagem para a intent '{intent_followup}'. Verifique os arquivos JSON.")
            # Retorna None para não enviar nada se a mensagem não for encontrada
            return None


# Arquivo: app/agents/domo_triagem.py
# ===========================================================
# Arquivo: agents/domo_triagem.py
# Agente responsável pelo questionário pós-pagamento.
# - Envia introdução antes da primeira pergunta.
# - Gerencia o fluxo de perguntas e respostas.
# - Salva as respostas na meta_conversa.
# ===========================================================
from pathlib import Path
import json
import logging
from app.agents.agente_base import AgenteBase
from app.utils.contexto import obter_contexto, salvar_contexto
# Importa a lista de perguntas e a introdução do utilitário
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO, INTRODUCAO_QUESTIONARIO

logger = logging.getLogger("famdomes.domo_triagem")

# Define o ID da trilha para o contexto (pode ser configurável)
TRILHA_ID = "QUESTIONARIO_POS_PAGAMENTO"
# Mensagem de agradecimento ao final
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informações! Elas são muito importantes e ajudarão o profissional na sua consulta. Em breve ele(a) entrará em contato no horário agendado."

class DomoTriagem(AgenteBase):
    """
    Conduz o questionário de triagem após a confirmação do pagamento.
    """

    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        """
        Gera a próxima pergunta do questionário ou a mensagem final.
        """
        ctx = obter_contexto(telefone)
        meta = ctx.get("meta_conversa", {})
        # Usa um campo específico para o cursor do questionário na meta
        cursor_questionario = meta.get("cursor_questionario", {"id": TRILHA_ID, "etapa_atual": 0})

        # Validação inicial: Garante que estamos na trilha correta
        if cursor_questionario.get("id") != TRILHA_ID:
            logger.warning(f"DomoTriagem: Cursor inválido para {telefone}. Reiniciando questionário.")
            cursor_questionario = {"id": TRILHA_ID, "etapa_atual": 0}

        etapa_respondida = cursor_questionario.get("etapa_atual", 0) # Etapa que o usuário ACABOU de responder
        proxima_etapa = etapa_respondida + 1

        # --- Salvar Resposta Anterior (se não for a primeira interação) ---
        if etapa_respondida > 0:
            if etapa_respondida <= len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO):
                pergunta_respondida_texto = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[etapa_respondida - 1]
                chave_resposta = f"resposta_q{etapa_respondida}"
                chave_sentimento = f"sentimento_q{etapa_respondida}"
                meta[chave_resposta] = mensagem_original # Salva a resposta do usuário
                meta[chave_sentimento] = self.sentimento # Salva o sentimento da resposta
                logger.info(f"DomoTriagem: Resposta Q{etapa_respondida} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}.")
            else:
                 logger.error(f"DomoTriagem: Índice de etapa respondida ({etapa_respondida}) fora dos limites para {telefone}.")
                 # Considerar um fallback ou mensagem de erro

        # --- Determinar Próximo Passo ---
        resposta = None
        novo_estado_sugerido = "COLETANDO_RESPOSTA_QUESTIONARIO" # Estado padrão durante o questionário

        # Se for a primeira pergunta (etapa_respondida == 0)
        if etapa_respondida == 0:
            if not QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 logger.warning(f"DomoTriagem: Lista de perguntas vazia para {telefone}.")
                 resposta = MENSAGEM_AGRADECIMENTO_ONBOARDING # Agradece mesmo sem perguntas
                 novo_estado_sugerido = "FINALIZANDO_ONBOARDING"
                 meta.pop("cursor_questionario", None) # Limpa cursor
            else:
                 # Envia a introdução + primeira pergunta
                 primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta = f"{INTRODUCAO_QUESTIONARIO}\n\n{primeira_pergunta}"
                 cursor_questionario["etapa_atual"] = 1 # Atualiza cursor para a próxima etapa
                 logger.info(f"DomoTriagem: Iniciando questionário para {telefone}.")

        # Se ainda houver perguntas a fazer
        elif proxima_etapa <= len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO):
            proxima_pergunta_texto = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[proxima_etapa - 1]
            resposta = proxima_pergunta_texto
            cursor_questionario["etapa_atual"] = proxima_etapa # Atualiza cursor
            logger.info(f"DomoTriagem: Enviando pergunta Q{proxima_etapa} para {telefone}.")

        # Se terminou o questionário
        else:
            resposta = MENSAGEM_AGRADECIMENTO_ONBOARDING
            novo_estado_sugerido = "FINALIZANDO_ONBOARDING" # Ou um estado como "AGUARDANDO_CONSULTA"
            meta.pop("cursor_questionario", None) # Limpa o cursor da meta
            logger.info(f"DomoTriagem: Questionário finalizado para {telefone}.")


        # --- Salvar Contexto ---
        # Salva a meta_conversa atualizada (com respostas e novo cursor) e o estado sugerido
        meta["cursor_questionario"] = cursor_questionario # Atualiza o cursor na meta
        salvar_contexto(telefone=telefone, meta_conversa=meta, estado=novo_estado_sugerido)

        return resposta


# Arquivo: app/agents/domo_monitor.py
"""
Avalia padrão emocional ao longo do tempo e decide escalonar ou ajustar trilha.
Por ora, apenas registra – sem resposta.
"""
from app.agents.agente_base import AgenteBase
from app.core.rastreamento import registrar_evento

class DomoMonitor(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        registrar_evento(telefone, etapa="monitor", dados=self.sentimento)
        return None


# Arquivo: app/codigos_famdomessnapshot.txt
FAQ_RESPOSTAS = {
    "dependencia_quimica": (
        "Dependência química é uma doença crônica caracterizada pelo uso compulsivo de substâncias, "
        "apesar das consequências negativas, afetando o cérebro e o comportamento."
    ),
    "identificar_dependencia": (
        "Sinais incluem uso constante da substância, dificuldade em parar, negligência nas responsabilidades, "
        "mudanças bruscas de comportamento e sintomas de abstinência."
    ),
    "tipos_internacao": (
        "Existem três tipos principais de internação: voluntária (com consentimento), involuntária "
        "(solicitada pela família) e compulsória (por ordem judicial)."
    ),
    "como_funciona_tratamento": (
        "O tratamento em clínica inclui desintoxicação supervisionada, terapias individuais e em grupo, "
        "atividades terapêuticas e acompanhamento médico constante."
    ),
    "duracao_tratamento": (
        "Normalmente, o tratamento dura entre 3 e 6 meses, podendo variar de acordo com a situação específica."
    ),
    "custo_tratamento": (
        "Os valores variam dependendo dos serviços e acomodações. Para detalhes exatos, podemos agendar uma avaliação."
    ),
    "recusa_ajuda": (
        "Se a pessoa não aceita ajuda voluntariamente, pode ser considerado o processo de internação involuntária "
        "com suporte legal e médico especializado."
    ),
    "apoio_familiar": (
        "Famílias podem ajudar oferecendo suporte emocional, participando das terapias familiares e estabelecendo limites claros."
    ),
    "sobre_caps": (
        "O CAPS é um Centro de Atenção Psicossocial que oferece tratamento especializado em saúde mental e dependência química."
    ),
    "como_agendar": (
        "Você pode agendar facilmente uma consulta entrando em contato conosco pelo WhatsApp ou pelo nosso site oficial."
    ),
}
import asyncio
from app.utils.mensageria import enviar_mensagem
import logging

# Perguntas a serem feitas após o pagamento (pode expandir)
PERGUNTAS = [
    "Vamos começar com algumas perguntas rápidas para ajudar nosso médico a entender melhor. Qual o nome completo da pessoa que será avaliada?",
    "Qual a idade aproximada da pessoa?",
    "Qual o grau de parentesco com você (filho, esposa, irmão, etc)?",
    "Quais substâncias a pessoa está usando atualmente (álcool, cocaína, crack, etc)?",
    "Há quanto tempo o uso começou ou se agravou?",
    "A pessoa já passou por outros tratamentos? Se sim, quais?",
    "Existe alguma condição médica ou psicológica importante a considerar?",
    "Qual cidade e estado onde a pessoa está agora?"
]

# Inicia o envio sequencial das perguntas (pode evoluir para FSM depois)
async def iniciar_questionario(telefone: str):
    logging.info(f"📋 Iniciando questionário pós-pagamento para {telefone}")
    for pergunta in PERGUNTAS:
        await enviar_mensagem(telefone, pergunta)
        await asyncio.sleep(2.0)  # pequeno intervalo entre perguntasimport httpx
import logging
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt,
        "stream": False
    }
    headers = {"Content-Type": "application/json"}
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_API_URL}/{OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            response.raise_for_status()
            dados = response.json()
            logging.info("✅ Resposta recebida da IA (OLLAMA).")
            resposta_bruta = dados.get("response", "⚠️ Erro interno na IA.")
            # Aqui você pode fazer qualquer limpeza necessária na resposta
            tokens = []  # Se houver tokens, adicione-os
            return resposta_bruta, tokens
    except httpx.TimeoutException as e:
        logging.error(f"❌ Erro: Timeout ({str(e)})")
        return "⚠️ Desculpe, demorei muito para pensar. Tente novamente.", []
    except httpx.HTTPStatusError as e:
        logging.error(f"❌ Erro: HTTP {e.response.status_code} - {e.response.text}")
        return f"⚠️ Ocorreu um erro interno ({e.response.status_code}). Por favor, tente mais tarde.", []
    except Exception as e:
        logging.exception("❌ Erro desconhecido ao chamar Ollama:")
        return "⚠️ Erro inesperado. Tente novamente mais tarde.", []
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura – certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        return (
            "Você é um assistente virtual especializado em saúde mental e dependência química. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Histórico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usuário:
{pergunta_atual.strip()}
---
Instruções para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no máximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("⚠️ Tentativa de enviar mensagem vazia ou sem destinatário.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url é geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoável para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"✅ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padrão Clínica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfação",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botão de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botão de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Índice do botão no template
                    # "parameters": [] # Parâmetros específicos do botão, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"✅ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    contextos_db = db["contexto_conversa"]
    logging.info("Conexão com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    if contextos_db is None or not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("❌ Falha ao salvar contexto.")
        return False
    try:
        contexto_anterior = contextos_db.find_one({"telefone": telefone}) or {}

        # 🔁 Fundir metadados caso existam
        if "meta_conversa" in dados_atualizacao and "meta_conversa" in contexto_anterior:
            dados_atualizacao["meta_conversa"] = atualizar_meta_conversa(
                contexto_anterior["meta_conversa"],
                dados_atualizacao["meta_conversa"]
            )

        contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True},
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()}
            },
            upsert=True
        )
        logging.info(f"📌 Contexto atualizado para {telefone}.")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def atualizar_meta_conversa(meta_antiga: dict, meta_nova: dict) -> dict:
    """ Mescla campos do novo JSON com os anteriores, preservando dados já extraídos """
    resultado = meta_antiga.copy()

    for chave, valor in meta_nova.items():
        if not valor:
            continue
        if isinstance(valor, list):
            resultado[chave] = list(set(resultado.get(chave, []) + valor))
        elif chave not in resultado or not resultado[chave] or resultado[chave] == "desconhecido":
            resultado[chave] = valor
    return resultado

def obter_contexto(telefone: str) -> dict:
    if contextos_db is None or not telefone:
        return {}
    try:
        return contextos_db.find_one({"telefone": telefone}) or {}
    except Exception as e:
        logging.error(f"❌ ERRO ao obter contexto para {telefone}: {e}")
        return {}

def limpar_contexto(telefone: str):
    if contextos_db is None or not telefone:
        return False
    try:
        result = contextos_db.delete_one({"telefone": telefone})
        return result.deleted_count > 0
    except Exception as e:
        logging.error(f"❌ ERRO ao limpar contexto para {telefone}: {e}")
        return False

def salvar_resposta_ia(telefone: str, canal: str, mensagem: str, resultado: dict):
    try:
        doc = {
            "telefone": telefone,
            "canal": canal,
            "mensagem": mensagem,
            "resposta": resultado.get("resposta"),
            "entidades": resultado.get("entidades", {}),
            "risco": resultado.get("risco", False),
            "intent": resultado.get("intent", "desconhecida"),
            "criado_em": datetime.utcnow()
        }
        db["respostas_ia"].insert_one(doc)
        logging.info(f"💾 Resposta da IA salva em respostas_ia para {telefone}.")
    except Exception as e:
        logging.error(f"❌ ERRO ao salvar resposta IA: {e}")
import logging
import json
import re
from app.utils.ollama import chamar_ollama
from app.utils.contexto import salvar_resposta_ia, obter_contexto, salvar_contexto
from app.routes.ia import processar_comando
from app.config import BASE_DIR

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

CAMINHO_PROMPT_MESTRE = f"{BASE_DIR}/utils/mestre_famdomes.txt"

MENSAGEM_INICIAL = '''🧠 Olá, eu sou da equipe FAMDOMES.

Receber sua mensagem já mostra que você se importa com quem ama — e isso é um primeiro passo muito importante.

Nosso trabalho é acolher famílias que estão vivendo situações difíceis com álcool, drogas ou crises emocionais.

Se quiser, posso te explicar como funciona nossa consulta médica. É rápida, sigilosa e pode te dar a orientação que está procurando.

Posso seguir?'''

RESPOSTA_EXPLICACAO_CONSULTA = '''👨‍⚕️ A consulta médica do FAMDOMES é online, com um profissional que entende profundamente casos de dependência química e sofrimento familiar.

📌 Ela serve para avaliar a situação, oferecer um laudo se necessário, orientar o melhor caminho e — se for o caso — encaminhar para uma clínica parceira com segurança e sigilo.

💳 O valor é R$100 e pode ser pago online de forma rápida.

Posso te enviar o link para agendar agora?'''

RESPOSTAS_AFIRMATIVAS = [
    "sim", "claro", "quero", "vamos", "ok", "pode ser", "tá bom", "aceito",
    "sim por favor", "sim quero", "com certeza", "tô dentro", "pode sim", "por favor"
]

def carregar_prompt_mestre():
    with open(CAMINHO_PROMPT_MESTRE, "r", encoding="utf-8") as f:
        return f.read()

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    contexto = obter_contexto(telefone)
    ultima = contexto.get("resposta_esperada")
    texto = mensagem.strip().lower()

    # ✅ Confirmação baseada na última pergunta
    ultima_pergunta = contexto.get("ultima_pergunta", "").lower()
    if (ultima is None or ultima == "explicacao_consulta") and texto in RESPOSTAS_AFIRMATIVAS:
        if any(p in ultima_pergunta for p in [
            "deseja agendar", "posso agendar", "vamos agendar",
            "te ajudar a agendar", "podemos agendar", "agendar essa consulta"
        ]):
            salvar_contexto(telefone, {
                "resposta_esperada": None,
                "ultima_pergunta": None
            })
            resposta = await processar_comando({
                "telefone": telefone,
                "nome": contexto.get("nome", "Paciente"),
                "comando": "quero agendar"
            })
            return {
                "intent": "quero_agendar",
                "entidades": {},
                "risco": False,
                "resposta": resposta.get("mensagem", "✅ Link gerado.")
            }

    # 🟢 Primeira interação
    if not contexto or not contexto.get("iniciado"):
        salvar_contexto(telefone, {
            "iniciado": True,
            "resposta_esperada": "mensagem_inicial",
            "ultima_pergunta": "Quer que eu te explique como funciona a consulta?",
            "nome": "Paciente"
        })
        return {
            "intent": "mensagem_inicial",
            "entidades": {},
            "risco": False,
            "resposta": MENSAGEM_INICIAL
        }

    # ✅ Confirmação para explicação da consulta
    if ultima == "mensagem_inicial" and texto in RESPOSTAS_AFIRMATIVAS:
        salvar_contexto(telefone, {
            "resposta_esperada": "explicacao_consulta",
            "ultima_pergunta": "Posso te enviar o link para agendar agora?"
        })
        return {
            "intent": "explicacao_consulta",
            "entidades": {},
            "risco": False,
            "resposta": RESPOSTA_EXPLICACAO_CONSULTA
        }

    if ultima == "explicacao_consulta" and texto in RESPOSTAS_AFIRMATIVAS:
        salvar_contexto(telefone, {
            "resposta_esperada": None,
            "ultima_pergunta": None
        })
        resposta = await processar_comando({
            "telefone": telefone,
            "nome": contexto.get("nome", "Paciente"),
            "comando": "quero agendar"
        })
        return {
            "intent": "quero_agendar",
            "entidades": {},
            "risco": False,
            "resposta": resposta.get("mensagem", "✅ Link gerado.")
        }

    # 🔍 Prompt com contexto
    prompt_base = carregar_prompt_mestre()
    pergunta_anterior = contexto.get("ultima_pergunta", "")
    meta_conversa = contexto.get("meta_conversa", {})
    contexto_extra = json.dumps(meta_conversa, ensure_ascii=False, indent=2)

    mensagem_completa = (
        f"Mensagem anterior: {pergunta_anterior}\n"
        f"Contexto conhecido: {contexto_extra}\n"
        f"Mensagem atual: {mensagem.strip()}"
    )
    prompt_completo = prompt_base.replace("{mensagem}", mensagem_completa)

    try:
        resposta_ia, _ = await chamar_ollama(prompt_completo, telefone)
        logging.info(f"💬 Resposta IA:\n{resposta_ia}")

        # 🔎 Tenta extrair JSON ao final
        json_extraido = {}
        resposta_textual = resposta_ia.strip()

        match = re.search(r"\{[\s\S]*\}", resposta_ia)
        if match:
            try:
                json_extraido = json.loads(match.group())
                resposta_textual = resposta_ia.replace(match.group(), "").strip().replace("```json", "").replace("```", "").strip()
            except json.JSONDecodeError:
                logging.warning("⚠️ JSON inválido no final da resposta da IA.")

        resultado = {
            "intent": "desconhecida",
            "entidades": json_extraido,
            "risco": json_extraido.get("risco", False),
            "resposta": resposta_textual
        }

        salvar_resposta_ia(telefone, canal, mensagem, resultado)
        salvar_contexto(telefone, {
            "resposta_esperada": None,
            "ultima_pergunta": resultado["resposta"],
            "ultima_intent": resultado["intent"],
            "meta_conversa": json_extraido
        })

        return resultado

    except Exception as e:
        logging.error(f"❌ Erro ao processar mensagem: {e}")
        return {
            "intent": "erro_nlu",
            "entidades": {},
            "risco": False,
            "resposta": "🤖 Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
        }
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases críticas (ajuste conforme necessário)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    # Adicionar termos relacionados a auto-mutilação se aplicável
    # Adicionar termos relacionados a ameaças a terceiros se aplicável
]

# Adicionar palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergências médicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicídio, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"🚨 RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"🚑 URGÊNCIA MÉDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuração da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (não agenda às 18:00, último é 17:40)

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar índice para garantir que não haja duas consultas no mesmo horário
    consultas_db.create_index("horario", unique=True)
    logging.info("Conexão com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avança o horário para o próximo bloco de X minutos dentro do horário de operação."""
    horario = inicio_base

    # Arredonda para o próximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no início do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horário de operação
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (Sábado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o próximo horário livre e agenda a consulta.
    Retorna o datetime do horário agendado ou None se não encontrar.
    """
    if not consultas_db:
        logging.error("Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento no DB é uma boa prática
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se já existe consulta nesse horário
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horário livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificação/inserção, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceção

    logging.warning(f"Não foram encontrados horários disponíveis para {telefone} após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se não encontrar horário

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda não ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"🗑️ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o próximo horário disponível sem agendar."""
    if not consultas_db:
        logging.error("Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Começa a procurar um pouco à frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Próximo horário disponível encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc:
        return "Indisponível"
    try:
        # Precisa da biblioteca pytz para fusos horários robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Terça-feira, 15 de Abril às 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B às %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horário {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formatação"
def consultar_horario():
    return "amanhã às 10h"
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

# Conexão com MongoDB
mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
pagamentos = db["pagamentos"]

# ✅ Iniciar sessão assim que gerar o link Stripe
def iniciar_sessao(telefone: str, nome: str):
    pagamentos.insert_one({
        "telefone": telefone,
        "nome": nome,
        "status": "iniciado",
        "criado_em": datetime.utcnow()
    })
    logging.info(f"📍 Sessão iniciada para {telefone}")

# ✅ Marcar como pago no Mongo após Stripe
def marcar_pagamento(telefone: str):
    pagamentos.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "status": "pago",
                "pago_em": datetime.utcnow()
            }
        }
    )
    logging.info(f"💰 Pagamento confirmado para {telefone}")

    # 🧠 Também agenda agora
    consulta = agendar_consulta(telefone, nome="Paciente", email=None)
    logging.info(f"📅 Consulta agendada para {telefone} em {consulta}")
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str
from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone é obrigatório.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}
from fastapi import APIRouter, Request
from app.utils.nlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado
import stripe
from fastapi import APIRouter, Request, Header, HTTPException
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/stripe/")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Webhook inválido: {e}")

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        if not telefone:
            raise HTTPException(status_code=400, detail="Telefone não informado no metadata")

        # ✅ Marcar pagamento e agendar
        horario, nome_final = marcar_pagamento(telefone)

        # 🧾 Mensagem de confirmação
        msg_paciente = (
            f"✅ Olá {nome_final}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome_final} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}

from fastapi import APIRouter, Request, Response, HTTPException
from fastapi.responses import JSONResponse
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.utils.nlp import processar_mensagem
from app.utils.contexto import limpar_contexto
import logging

router = APIRouter()

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    try:
        data = await request.json()
        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            logging.info("📭 Evento ignorado – sem mensagens (pode ser status ou metadados).")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"].get("name", "Paciente")
        logging.info(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        logging.info(f"Mensagem: {mensagem}")

        # 🔁 Comando especial para resetar conversa
        if mensagem.strip().lower() == "melancia vermelha":
            sucesso = limpar_contexto(telefone)
            if sucesso:
                await enviar_mensagem(telefone, "🔄 Conversa reiniciada. Pode começar de novo quando quiser.")
            else:
                await enviar_mensagem(telefone, "⚠️ Erro ao reiniciar a conversa. Tente novamente.")
            return {"status": "contexto_resetado"}

        # 🤖 Processamento normal
        resultado = await processar_mensagem(mensagem, telefone, canal="whatsapp")

        resposta = resultado["resposta"]

        await enviar_mensagem(telefone, resposta)

        if WHATSAPP_FAMILIAR and resultado["risco"]:
            alerta = f"⚠️ Alerta FAMDOMES: Detecção de risco com {telefone}. Mensagem: “{mensagem}”."
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        logging.error(f"❌ ERRO no webhook: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ✅ Função exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"✅ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "❌ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "✅ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in comando or "disponível" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "🤖 Desculpe, não entendi o que você deseja. Você pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horário disponível")
        return {"status": "comando_desconhecido"}
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, stripe, whatsapp, agendamento, painel
from app.routes import nlp
from app.routes import resetar



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")
app.include_router(nlp.router)
app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/webhook")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(resetar.router)

@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("📥 Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas públicas permitidas
    is_webhook_externo = (
    path.startswith("/painel/resetar-contexto") or
    path.startswith("/chat/nlp") or
    path.startswith("/chat/webhook/whatsapp") or 
    path.startswith("/webhook/stripe") or  # ✅ corrigido aqui
    path.startswith("/pagamento/criar_sessao") or
    path.startswith("/agenda") or
    path.startswith("/ia-in") or
    path.startswith("/docs") or
    path.startswith("/openapi.json") or
    path.startswith("/favicon.ico") or
    path == "/"
)


    if is_webhook_externo:
        return await call_next(request)

    # Validação da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str
from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

import os
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Arquivo: app/todos_arquivos_python.txt
.
--------------------------------------------------------------------------------
Arquivo: ./utils/ollama.py
-------------------------------------------------------------------------------
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt construído.
    Retorna a resposta limpa e quaisquer tokens extraídos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/histórico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como não-streaming para simplicidade
        # Adicione outros parâmetros do Ollama aqui se necessário (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exceção para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("✅ Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necessário

            resposta_bruta = dados.get("response", "🤖 Desculpe, não consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens Extraídos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "⚠️ Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"⚠️ Ocorreu um erro interno ao processar sua solicitação ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO: Falha na conexão com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "⚠️ Não consegui me conectar à minha inteligência artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("❌ ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "⚠️ Ocorreu um erro inesperado. A equipe já foi notificada. Tente novamente mais tarde.", []
Arquivo: ./utils/prompt_builder.py
-------------------------------------------------------------------------------
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# Configuração do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Conexão MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # Coleção para histórico de conversas
    logging.info("Conexão com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conexão adequadamente - talvez retornar erro ou usar prompt padrão
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necessário

def carregar_prompt_mestre() -> str:
    """Carrega o conteúdo do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"❌ ERRO: Arquivo de prompt mestre não encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padrão seguro em caso de falha
        return (
            "Você é um assistente virtual focado em saúde mental e dependência química.\n"
            "Seja empático, claro e objetivo. Ofereça apoio e informações sobre agendamento quando apropriado.\n"
            "Responda em português brasileiro."
        )
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padrão seguro
        return (
            "Você é um assistente virtual focado em saúde mental e dependência química.\n"
            "Seja empático, claro e objetivo. Ofereça apoio e informações sobre agendamento quando apropriado.\n"
            "Responda em português brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """Constrói o prompt final para a IA, incluindo o mestre, histórico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as últimas N interações (usuário + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por criação
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronológica

            # Formata o histórico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usuário
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o próximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Número do Usuário (ocultar na resposta final): {telefone}
---
Histórico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do Usuário:
Usuário: {pergunta_atual.strip()}
---
Instruções para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom empático, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acessível, evitando jargões técnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 parágrafos curtos. Max 400 caracteres se possível.
5.  Se a conversa indicar necessidade de agendamento ou mais informações, ofereça isso proativamente.
6.  NÃO inclua o histórico ou as instruções na sua resposta final.
7.  NÃO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em português brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sensíveis)

    return prompt_final
Arquivo: ./utils/mensageria.py
-------------------------------------------------------------------------------
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("⚠️ Tentativa de enviar mensagem vazia ou sem destinatário.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url é geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoável para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"✅ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padrão Clínica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfação",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botão de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botão de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Índice do botão no template
                    # "parameters": [] # Parâmetros específicos do botão, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"✅ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
Arquivo: ./utils/contexto.py
-------------------------------------------------------------------------------
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas assíncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # Coleção para contextos
    logging.info("Conexão com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone específico.
    'dados_atualizacao' deve ser um dicionário com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"Não foi possível salvar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inválido (sem telefone ou dados inválidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modificação
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na criação
            },
            upsert=True # Cria o documento se não existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"Não foi possível obter contexto para {telefone}: Sem conexão com DB.")
        return {} # Retorna dicionário vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicionário vazio se não encontrar
    except Exception as e:
        logging.error(f"❌ ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicionário vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"Não foi possível limpar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"❌ ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do último acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que só atualizará o $currentDate
Arquivo: ./utils/db.py
-------------------------------------------------------------------------------
from datetime import datetime, timedelta

# Simula próxima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravação da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} às {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÉDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicídio", "morrer", "não aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

Arquivo: ./utils/risco.py
-------------------------------------------------------------------------------
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases críticas (ajuste conforme necessário)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    # Adicionar termos relacionados a auto-mutilação se aplicável
    # Adicionar termos relacionados a ameaças a terceiros se aplicável
]

# Adicionar palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergências médicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicídio, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"🚨 RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"🚑 URGÊNCIA MÉDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
Arquivo: ./utils/agenda.py
-------------------------------------------------------------------------------
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuração da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (não agenda às 18:00, último é 17:40)

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar índice para garantir que não haja duas consultas no mesmo horário
    consultas_db.create_index("horario", unique=True)
    logging.info("Conexão com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avança o horário para o próximo bloco de X minutos dentro do horário de operação."""
    horario = inicio_base

    # Arredonda para o próximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no início do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horário de operação
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (Sábado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o próximo horário livre e agenda a consulta.
    Retorna o datetime do horário agendado ou None se não encontrar.
    """
    if not consultas_db:
        logging.error("Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento no DB é uma boa prática
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se já existe consulta nesse horário
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horário livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificação/inserção, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceção

    logging.warning(f"Não foram encontrados horários disponíveis para {telefone} após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se não encontrar horário

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda não ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"🗑️ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o próximo horário disponível sem agendar."""
    if not consultas_db:
        logging.error("Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Começa a procurar um pouco à frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Próximo horário disponível encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc:
        return "Indisponível"
    try:
        # Precisa da biblioteca pytz para fusos horários robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Terça-feira, 15 de Abril às 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B às %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horário {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formatação"
Arquivo: ./utils/ia_fallback.py
-------------------------------------------------------------------------------
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta

Arquivo: ./utils/followup.py
-------------------------------------------------------------------------------
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a função de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a função real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # Não precisa mais buscar aqui, usa agenda.py
    logging.info("Conexão com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Funções de Simulação (Removidas ou Substituídas) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> Lógica está em agenda.py
# avisar_profissional -> Deveria ser chamado após agendamento real
# avisar_paciente -> Deveria ser chamado após agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o início de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("Não é possível iniciar sessão de pagamento: Sem conexão com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao iniciar sessão de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessão como paga, agenda a consulta e retorna o horário agendado e nome.
    Esta função é chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("Não é possível marcar pagamento: Sem conexão com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que só atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualização se não encontrar, ou *depois* se encontrar
                                # Precisamos do nome, então talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome já está lá do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessão ser criada, ou se já foi processado
            logging.warning(f"Sessão de pagamento não encontrada ou já processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessão
        logging.info(f"[SESSÃO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessão com o horário agendado (opcional, mas útil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessão com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possível notificação manual

    except Exception as e:
        logging.error(f"❌ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Função para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # Lógica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo número real ou lógica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"👨‍⚕️ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) às {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("Número do médico não configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Função para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessões com pagamento pendente há muito tempo."""
    if not sessoes_db:
        logging.error("Não é possível checar followup: Sem conexão com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "você")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Olá {nome}, notei que você iniciou um agendamento mas parece que não foi concluído. 😥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dúvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. 😊"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessão para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"❌ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
Arquivo: ./schemas/ia_comando.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

Arquivo: ./intents/router_intents.py
-------------------------------------------------------------------------------
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigatórios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }
Arquivo: ./intents/__init__.py
-------------------------------------------------------------------------------

Arquivo: ./intents/intent_executor.py
-------------------------------------------------------------------------------
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o módulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "🧡 Você deu um passo importante ao chegar aqui. Sabemos que não é fácil buscar ajuda.\n\n"
    "🤝 Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "📲 Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "tô aqui pra isso", "pode falar", "é isso", "ok", "tá", "tá bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "não", "nao", "talvez depois", "não agora", "deixa pra depois",
    "tô só olhando", "só pesquisando", "agora não"
]

# Limiar de confiança para a intent (ajuste conforme necessário)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui é o|aqui é a|meu nome é|me chamo é)\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)",
        r"nome é\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confiança alta

    def detectar_intent(self):
        # Lógica de detecção de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confiança para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confiança na confirmação
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que você precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "🔄 Histórico de testes apagado com sucesso. Pode começar uma nova simulação.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "olá", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confiança na confirmação

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confiança na confirmação
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # Média confiança em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # INÍCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"📅 Ótimo! Posso te ajudar a agendar com nosso médico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"📆 O próximo horário disponível é: {consultar_horario()}. Posso reservar pra você?",

        # VALORES
        "duvida_valores": "💰 Temos valores acessíveis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIANÇA
        "duvida_geral": "📋 Nosso sistema conecta você com médicos especialistas de verdade. Quer saber como funciona na prática?",
        "desconfianca": "🔍 Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPENDÊNCIA / RECAÍDA / SINTOMAS
        "duvida_dependencia": "🧠 A dependência química é tratável. Nosso médico pode avaliar sintomas físicos e emocionais. Quer agendar?",
        "sou_dependente": "💬 Reconhecer isso é um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "🔁 Recaídas fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "😓 Os sintomas de abstinência são desafiadores. Podemos te orientar com segurança. Posso marcar agora?",

        # CRISE / URGÊNCIA
        "sintomas_graves": "⚠️ Sinais de crise detectados. Posso encaminhar você para um atendimento urgente. Deseja ajuda agora?",
        "ameaça_vida": "🚨 Sua vida importa. Posso ativar nosso acolhimento de urgência. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "👪 Você quer ajudar alguém importante. Posso te explicar como funciona e agendar uma escuta para você ou para ele(a).",
        "familia_pedindo_ajuda": "🧭 Você está no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "🚨 Situação familiar crítica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "😔 É difícil quando a família não apoia. Mas há caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "💔 Muitas famílias passam por isso. Podemos ajudar na reconstrução. Quer agendar uma orientação especializada?",
        "familiar_violento": "⚠️ Em casos de violência, segurança vem primeiro. Posso te mostrar como agir com respaldo médico e legal.",

        # INTERNAÇÃO
        "duvida_internacao": "🏥 A internação pode ser voluntária ou involuntária, sempre com avaliação médica. Quer saber como isso funciona?",
        "quero_internar": "✅ Posso te mostrar o processo completo, legal e clínico. Posso agendar agora com nosso médico?",

        # FUNIL / OBJECÕES / CIRCUNSTÂNCIAS
        "nao_quero_internar": "Tudo bem. Internação não é a única saída. Posso te explicar outras opções com orientação médica.",
        "meu_parente_usa_droga": "💬 Entendo. Posso agendar com o especialista pra avaliar a situação de forma profissional.",
        "crise_agora": "⚠️ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "💡 Obrigado por compartilhar. Posso te ajudar com os próximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "😔 A resistência é comum. Mesmo assim, a família pode iniciar a ação. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "👥 Se a família não colabora, podemos trabalhar com quem estiver disponível. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "👍 Tranquilo. Se quiser ajudar alguém ou tirar dúvidas, posso te explicar tudo com calma.",

        # INFORMAÇÕES COMPLEMENTARES
        "quero_entender": "📘 Posso te explicar tudo sobre o atendimento, desde a escuta até o tratamento. Quer começar agora?",
        "curioso": "😄 Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulação real?",
        "pergunta_medico": "👨‍⚕️ O médico é especialista em dependência química e avaliação clínica. Quer agendar a escuta?",
        "duvida_medicacao": "💊 Medicamentos só são indicados após avaliação. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "🧠 Temos psicólogos na equipe. A avaliação inicial é médica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "🔁 Recomeçar é possível. Estamos aqui pra isso. Quer conversar com o médico novamente?",
        "vergonha_de_falar": "🧡 Tudo bem. Não precisa se explicar agora. Posso só ouvir, se quiser.",
        "culpa_familiar": "🤝 A culpa não ajuda, mas o cuidado sim. Posso te mostrar como começar com leveza.",
        "busca_ajuda_emocional": "💬 Também acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "🛐 Respeitamos todas as crenças. O acolhimento é humano, com base ética. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "⚖️ A internação judicial é possível. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "👶 Tratamos casos de menores com responsabilidade. Posso te mostrar os critérios e caminhos.",
        "direitos_paciente": "📜 Tudo é feito conforme a ética médica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "📍 Temos atendimento online e unidades físicas. Quer saber se tem perto de você?",
        "duvida_profissionais": "👩‍⚕️ Temos médicos, terapeutas e psicólogos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "🔒 Todo atendimento é sigiloso. Nada é compartilhado sem sua autorização. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"✅ Consulta cancelada. Se quiser retomar, é só me avisar.",
        "teste": "🧪 Está testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "❤️ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prática.",
        "erro": "🔁 Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "🤔 Não entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "👍 Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugestões de próximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou você gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou você tem alguma outra dúvida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou você gostaria de agendar uma consulta?",
            "sou_dependente": "\nVocê gostaria de agendar uma consulta ou precisa de mais informações?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVocê gostaria de agendar uma consulta para você ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de internação ou você gostaria de saber as opções de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se você reformular a pergunta ou gostaria de ver as opções de ajuda disponíveis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padrão
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta
Arquivo: ./intents/intents_map.py
-------------------------------------------------------------------------------
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # 🚀 INÍCIO DO FUNIL
    "boas_vindas": [
        "oi", "olá", "ola", "bom dia", "boa tarde", "boa noite", "e aí", "fala comigo", "tudo bem", "como vai"
    ],

    # 👤 QUERO AGENDAR / HORÁRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um médico", "consulta urgente", "quero ajuda médica",
        "agendar", "marcar consulta", "atendimento médico", "agendar consulta"
    ],
    "ver_horario": [
        "tem horário", "que horas tem", "tem agenda", "qual o próximo horário", "quero saber os horários",
        "horários disponíveis", "agenda livre", "consultar horário", "ver agenda"
    ],

    # 💰 VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "preço", "tem plano", "é caro", "valores da consulta", "paga quanto", "é gratuito?",
        "aceita convênio", "plano de saúde", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # ❓ DÚVIDAS GERAIS / CONFIANÇA
    "duvida_geral": [
        "como funciona", "me explica", "o que vocês fazem", "isso é pra quê", "como ajudam", "qual o tratamento",
        "o que é isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso é real?", "posso confiar?", "é golpe?", "tem CNPJ?", "quem são vocês?", "é confiável?", "funciona mesmo?",
        "é seguro?", "garantia", "é empresa?"
    ],

    # 📚 SOBRE DEPENDÊNCIA / VÍCIO
    "duvida_dependencia": [
        "o que é dependência química", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "vício em drogas", "meu caso tem jeito", "isso é doença?", "uso mas não sou viciado", "tem tratamento",
        "dependência", "vício", "drogas", "alcoolismo", "sintomas de vício"
    ],
    "sou_dependente": [
        "sou viciado", "tenho vício", "sou dependente químico", "tenho problema com droga", "uso todo dia",
        "não consigo parar", "preciso parar de usar", "sou alcoólatra", "viciado"
    ],
    "recaida": [
        "tive recaída", "usei de novo", "não consegui parar", "recomecei", "caí de novo",
        "recaí", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "tô tremendo", "tô suando", "não tô bem", "tô em abstinência", "tô agoniado", "tô passando mal sem usar",
        "sintomas de abstinência", "fissura", "crise de abstinência"
    ],

    # 🧠 SINTOMAS GRAVES / CRISE / URGÊNCIA
    "sintomas_graves": [
        "tá surtando", "alucinação", "tá agressivo", "não dorme há dias", "visões", "delírio", "tá em crise",
        "descontrolado", "sem noção do que faz", "paranoia", "confusão mental", "surto psicótico"
    ],
    "ameaça_vida": [ # Risco de suicídio/auto-mutilação
        "quero morrer", "vou me matar", "não quero viver", "quero sumir", "vou acabar com tudo", "vida não faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # Emergência médica clara
        "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
        "desmaiado", "convulsão", "sangrando muito", "veneno", "infarto", "avc", "emergência"
    ],


    # 👨‍👩‍👦 FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou mãe", "sou pai", "sou esposa", "sou marido", "sou irmão", "sou irmã", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho tá viciado", "minha filha tá usando", "meu marido não aceita ajuda", "ele não quer se tratar",
        "não sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela tá gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "tá se machucando", "tá em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele não quer ajuda", "ela não aceita", "não quer tratamento", "não admite que tem problema",
        "não quer ser internado", "não aceita médico", "resiste ao tratamento"
    ],

    # 🏥 INTERNAÇÃO
    "duvida_internacao": [
        "como funciona a internação", "quanto tempo dura", "volta pra casa depois?", "como é o lugar",
        "tem visita?", "fica trancado?", "internação involuntária", "é forçado?", "tem psiquiatra?",
        "internação", "clínica de recuperação", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como faço pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "internação compulsória", "internação involuntária"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa não querer internação
        "não quero internar", "sem internação", "tratamento sem internar", "não precisa de clínica",
        "alternativa à internação", "tratamento ambulatorial"
    ],

    # ⚖️ QUESTÕES LEGAIS / JURÍDICAS
    "internacao_judicial": [
        "posso pedir pra justiça?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "internação compulsória", "justiça", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho é menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "criança"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele é obrigado?", "isso é legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # 💬 OUTRAS SITUAÇÕES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # Usuário falando sobre seu próprio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida tá destruída",
        "preciso de ajuda com meu vício"
    ],
     "resistencia_familiar": [ # Paciente relata que a família não apoia/atrapalha
        "minha família não me apoia", "minha esposa não entende", "meus pais não aceitam",
        "família contra o tratamento", "não tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que não é o paciente
        "não sou eu que uso", "é para um amigo", "só estou pesquisando", "quero informação para outra pessoa",
        "não sou usuário"
    ],

    # ℹ️ BUSCA DE INFORMAÇÕES ADICIONAIS
     "quero_entender": [ # Pedido explícito para entender o serviço/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # Demonstração de curiosidade ou teste
        "só testando", "kkk", "haha", "curioso", "testando sistema", "só vendo como funciona",
        "teste", "simulação"
    ],
    "pergunta_medico": [ # Dúvida específica sobre o profissional médico
        "quem é o médico?", "qual a especialidade?", "é psiquiatra?", "posso escolher o médico?",
        "falar com o médico"
    ],
     "duvida_medicacao": [ # Dúvida sobre remédios
        "vai precisar de remédio?", "usam medicação?", "quais remédios?", "tratamento com remédio",
        "medicação psiquiátrica"
    ],
     "duvida_psicologo": [ # Dúvida sobre psicólogo/terapia
        "tem psicólogo?", "faz terapia?", "atendimento psicológico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # Dúvida sobre local físico/online
        "onde fica?", "tem na minha cidade?", "qual o endereço?", "atende onde?", "é presencial ou online?",
        "atendimento online", "unidade física", "endereço da clínica"
    ],
     "duvida_profissionais": [ # Dúvida geral sobre a equipe
        "quem são os profissionais?", "tem terapeuta?", "quem atende?", "é só médico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # Dúvida sobre confidencialidade
        "isso é sigiloso?", "meus dados estão protegidos?", "alguém vai saber?", "é confidencial?",
        "privacidade", "segredo médico"
    ],


    # ❤️ INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # Já tentou tratamento antes e parou
        "já tentei parar antes", "desisti do tratamento", "não funcionou da outra vez",
        "já fiz tratamento e não adiantou", "recomeçar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ninguém", "é difícil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que é culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "tô mal", "tô triste", "ansiedade", "crise de pânico", "sou depressivo", "tô vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # Questões sobre religião/espiritualidade
        "é contra religião?", "tem algo espiritual?", "sou evangélico", "sou católico", "tem apoio religioso?",
        "minha fé", "igreja"
    ],

    # 🛑 CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar ação atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "não quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "não posso ir"
    ],
    "confirmacao_positiva": [ # Confirmação genérica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "tá", "tá bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # Negação genérica (não, agora não)
        "não", "nao", "talvez depois", "não agora", "deixa pra depois", "agora não", "não quero", "não obrigado"
    ],
    "elogio": [
        "ótimo atendimento", "gostei muito", "vocês são bons", "obrigado", "atendimento top", "amei",
        "parabéns", "muito bom", "excelente"
    ],
    "erro": [ # Usuário reporta um erro técnico
        "link não abre", "deu erro", "não consegui pagar", "o site caiu", "não carrega",
        "problema técnico", "não funciona", "bug"
    ],
    "sem_compreensao": [ # Bot não entendeu ou mensagem ininteligível
        "asdfgh", "oiaueia", "????", "não entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "não faz sentido"
    ],

    # Adicione intents mais específicas conforme necessário
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}
Arquivo: ./routes/pagamentos.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

Arquivo: ./routes/painel.py
-------------------------------------------------------------------------------
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

Arquivo: ./routes/stripe.py
-------------------------------------------------------------------------------
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # 🧠 Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # 🧠 Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

Arquivo: ./routes/rocketchat.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

Arquivo: ./routes/agendamento.py
-------------------------------------------------------------------------------
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


Arquivo: ./routes/whatsapp.py
-------------------------------------------------------------------------------
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("⚠️ Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # 🚨 Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"⚠️ Alerta FAMDOMES: Detecção de risco na conversa com {telefone}. "
                f"Mensagem: “{mensagem}”. Um profissional será alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("❌ ERRO no webhook:", str(e))
        return {"erro": str(e)}
Arquivo: ./routes/ia_comandos.py
-------------------------------------------------------------------------------
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"✅ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando não reconhecido.")

Arquivo: ./routes/ia.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ✅ Função exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"✅ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "❌ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "✅ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in comando or "disponível" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "🤖 Desculpe, não entendi o que você deseja. Você pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horário disponível")
        return {"status": "comando_desconhecido"}

Arquivo: ./routes/followup.py
-------------------------------------------------------------------------------
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

Arquivo: ./main.py
-------------------------------------------------------------------------------
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("📥 Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas públicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Validação da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

Arquivo: ./models/pagamentos.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

Arquivo: ./models/intents.py
-------------------------------------------------------------------------------
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horário",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horário",
    ],
    "confirmar_pagamento": [
        "paguei",
        "já paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que você faz",
        "me ajuda",
        "como você pode me ajudar"
    ]
}

Arquivo: ./models/atendimento.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

Arquivo: ./config.py
-------------------------------------------------------------------------------
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

Arquivo: ./nlu/response_generator.py
-------------------------------------------------------------------------------
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "🧡 Você deu um passo importante ao chegar aqui. Sabemos que não é fácil buscar ajuda.\n\n"
    "🤝 Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "📲 Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÍCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"📅 Ótimo! Posso te ajudar a agendar com nosso médico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"📆 O próximo horário disponível é: {consultar_horario()}. Posso reservar pra você?",

    # VALORES
    "duvida_valores": "💰 Temos valores acessíveis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÇA
    "duvida_geral": "📋 Nosso sistema conecta você com médicos especialistas de verdade. Quer saber como funciona na prática?",
    "desconfianca": "🔍 Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÊNCIA / RECAÍDA / SINTOMAS
    "duvida_dependencia": "🧠 A dependência química é tratável. Nosso médico pode avaliar sintomas físicos e emocionais. Quer agendar?",
    "sou_dependente": "💬 Reconhecer isso é um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "🔁 Recaídas fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "😓 Os sintomas de abstinência são desafiadores. Podemos te orientar com segurança. Posso marcar agora?",

    # CRISE / URGÊNCIA
    "sintomas_graves": "⚠️ Sinais de crise detectados. Posso encaminhar você para um atendimento urgente. Deseja ajuda agora?",
    "ameaça_vida": "🚨 Sua vida importa. Posso ativar nosso acolhimento de urgência. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "👪 Você quer ajudar alguém importante. Posso te explicar como funciona e agendar uma escuta para você ou para ele(a).",
    "familia_pedindo_ajuda": "🧭 Você está no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "🚨 Situação familiar crítica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "😔 É difícil quando a família não apoia. Mas há caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "💔 Muitas famílias passam por isso. Podemos ajudar na reconstrução. Quer agendar uma orientação especializada?",
    "familiar_violento": "⚠️ Em casos de violência, segurança vem primeiro. Posso te mostrar como agir com respaldo médico e legal.",

    # INTERNAÇÃO
    "duvida_internacao": "🏥 A internação pode ser voluntária ou involuntária, sempre com avaliação médica. Quer saber como isso funciona?",
    "quero_internar": "✅ Posso te mostrar o processo completo, legal e clínico. Posso agendar agora com nosso médico?",

    # FUNIL / OBJECÕES / CIRCUNSTÂNCIAS
    "nao_quero_internar": "Tudo bem. Internação não é a única saída. Posso te explicar outras opções com orientação médica.",
    "meu_parente_usa_droga": "💬 Entendo. Posso agendar com o especialista pra avaliar a situação de forma profissional.",
    "crise_agora": "⚠️ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "💡 Obrigado por compartilhar. Posso te ajudar com os próximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "😔 A resistência é comum. Mesmo assim, a família pode iniciar a ação. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "👥 Se a família não colabora, podemos trabalhar com quem estiver disponível. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "👍 Tranquilo. Se quiser ajudar alguém ou tirar dúvidas, posso te explicar tudo com calma.",

    # INFORMAÇÕES COMPLEMENTARES
    "quero_entender": "📘 Posso te explicar tudo sobre o atendimento, desde a escuta até o tratamento. Quer começar agora?",
    "curioso": "😄 Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulação real?",
    "pergunta_medico": "👨‍⚕️ O médico é especialista em dependência química e avaliação clínica. Quer agendar a escuta?",
    "duvida_medicacao": "💊 Medicamentos só são indicados após avaliação. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "🧠 Temos psicólogos na equipe. A avaliação inicial é médica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "🔁 Recomeçar é possível. Estamos aqui pra isso. Quer conversar com o médico novamente?",
    "vergonha_de_falar": "🧡 Tudo bem. Não precisa se explicar agora. Posso só ouvir, se quiser.",
    "culpa_familiar": "🤝 A culpa não ajuda, mas o cuidado sim. Posso te mostrar como começar com leveza.",
    "busca_ajuda_emocional": "💬 Também acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "🛐 Respeitamos todas as crenças. O acolhimento é humano, com base ética. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "⚖️ A internação judicial é possível. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "👶 Tratamos casos de menores com responsabilidade. Posso te mostrar os critérios e caminhos.",
    "direitos_paciente": "📜 Tudo é feito conforme a ética médica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "📍 Temos atendimento online e unidades físicas. Quer saber se tem perto de você?",
    "duvida_profissionais": "👩‍⚕️ Temos médicos, terapeutas e psicólogos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "🔒 Todo atendimento é sigiloso. Nada é compartilhado sem sua autorização. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "✅ Consulta cancelada. Se quiser retomar, é só me avisar.",
    "teste": "🧪 Está testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "❤️ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prática.",
    "erro": "🔁 Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "🤔 Não entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "👍 Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrão se intent for reconhecida mas sem frase específica
        return respostas.get(intent, "Tô por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

Arquivo: ./nlu/chatbot_router.py
-------------------------------------------------------------------------------
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier  # Importe a classe
from app.nlu.entidade_extractor import EntidadeExtractor  # Importe a classe
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

# Instancie os classificadores e extratores
nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0  # Inicialmente, confiança alta

    async def processar(self):
        # Reset manual
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "🔄 Histórico apagado. Pode começar de novo.", "risco": False}

        # Detectar intent e extrair entidades
        intent = nlu_classifier.classificar_intent(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Se você estiver usando um modelo de ML para classificar a intent,
        # você pode obter a confiança aqui. Por exemplo:
        # intent, self.intent_confianca = nlu_classifier.classificar_com_confianca(self.mensagem)

        # Atualizar nome se extraído
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Gerar resposta
        resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
        risco = analisar_risco(self.mensagem)

        # Lógica de baixa confiança (se aplicável)
        if self.intent_confianca < 0.6 and intent == "desconhecida":
            resposta = "🤔 Desculpe, não entendi. Você pode reformular sua pergunta?"
            logging.warning(f"Baixa confiança na intent: {intent} ({self.intent_confianca}). Mensagem: {self.mensagem}")

        # Atualizar contexto
        self._atualizar_contexto(intent)

        # Histórico
        return self._registrar_interacao(intent, resposta, risco)

    def _atualizar_contexto(self, intent):
        salvar_contexto(self.telefone, {
            "ultima_mensagem": self.mensagem,
            "ultima_intent": intent,
            "intent_esperada": None,
            "aguardando_confirmacao": False
        })

    def _registrar_interacao(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}
Arquivo: ./nlu/nlu_classifier.py
-------------------------------------------------------------------------------
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparação ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuações básicas (exceto espaços) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaços extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML não encontrados. Usando classificação por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presença de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confiança base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho está contido no texto
                # Usar `in` é simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # Lógica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confiança para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classificação com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pré-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # Não pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confiança={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificação ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confiança.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML não estiver ativo ou como método principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- Método de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF é um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parâmetros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes é um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
Arquivo: ./nlu/entidade_extractor.py
-------------------------------------------------------------------------------
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)",
                r"([A-ZÁÉÍÓÚA-Za-záéíóú]+)\s+(?:é meu nome|meu nome é|aqui é)" # Novo padrão
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)\s+(?:é meu|minha)" # Novo padrão
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-záéíóúãõâêîôûç\s]+)",
                r"(?:cidade de)\s+([A-Za-záéíóúãõâêîôûç\s]+)" # Novo padrão
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrão
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaína)"
            ],
            "recaida": [
                r"(reca[íi]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[íi]da|escorregada)" # Novo padrão
            ],
            # Adicione mais entidades e padrões conforme necessário
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraída: {entidades[entidade]} (Padrão: '{padrao}')")
                    break  # Para na primeira correspondência

        return entidades
==== /home/ubuntu/famdomes_backend/app/utils/ollama.py ====
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt construído.
    Retorna a resposta limpa e quaisquer tokens extraídos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/histórico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como não-streaming para simplicidade
        # Adicione outros parâmetros do Ollama aqui se necessário (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exceção para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("✅ Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necessário

            resposta_bruta = dados.get("response", "🤖 Desculpe, não consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens Extraídos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "⚠️ Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"⚠️ Ocorreu um erro interno ao processar sua solicitação ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO: Falha na conexão com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "⚠️ Não consegui me conectar à minha inteligência artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("❌ ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "⚠️ Ocorreu um erro inesperado. A equipe já foi notificada. Tente novamente mais tarde.", []


==== /home/ubuntu/famdomes_backend/app/utils/prompt_builder.py ====
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# Configuração do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Conexão MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # Coleção para histórico de conversas
    logging.info("Conexão com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conexão adequadamente - talvez retornar erro ou usar prompt padrão
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necessário

def carregar_prompt_mestre() -> str:
    """Carrega o conteúdo do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"❌ ERRO: Arquivo de prompt mestre não encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padrão seguro em caso de falha
        return (
            "Você é um assistente virtual focado em saúde mental e dependência química.\n"
            "Seja empático, claro e objetivo. Ofereça apoio e informações sobre agendamento quando apropriado.\n"
            "Responda em português brasileiro."
        )
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padrão seguro
        return (
            "Você é um assistente virtual focado em saúde mental e dependência química.\n"
            "Seja empático, claro e objetivo. Ofereça apoio e informações sobre agendamento quando apropriado.\n"
            "Responda em português brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """Constrói o prompt final para a IA, incluindo o mestre, histórico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as últimas N interações (usuário + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por criação
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronológica

            # Formata o histórico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usuário
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o próximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Número do Usuário (ocultar na resposta final): {telefone}
---
Histórico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do Usuário:
Usuário: {pergunta_atual.strip()}
---
Instruções para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom empático, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acessível, evitando jargões técnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 parágrafos curtos. Max 400 caracteres se possível.
5.  Se a conversa indicar necessidade de agendamento ou mais informações, ofereça isso proativamente.
6.  NÃO inclua o histórico ou as instruções na sua resposta final.
7.  NÃO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em português brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sensíveis)

    return prompt_final


==== /home/ubuntu/famdomes_backend/app/utils/mensageria.py ====
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("⚠️ Tentativa de enviar mensagem vazia ou sem destinatário.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url é geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoável para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"✅ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padrão Clínica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfação",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botão de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botão de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Índice do botão no template
                    # "parameters": [] # Parâmetros específicos do botão, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"✅ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/utils/contexto.py ====
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas assíncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # Coleção para contextos
    logging.info("Conexão com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone específico.
    'dados_atualizacao' deve ser um dicionário com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"Não foi possível salvar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inválido (sem telefone ou dados inválidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modificação
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na criação
            },
            upsert=True # Cria o documento se não existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"Não foi possível obter contexto para {telefone}: Sem conexão com DB.")
        return {} # Retorna dicionário vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicionário vazio se não encontrar
    except Exception as e:
        logging.error(f"❌ ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicionário vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"Não foi possível limpar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"❌ ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do último acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que só atualizará o $currentDate


==== /home/ubuntu/famdomes_backend/app/utils/db.py ====
from datetime import datetime, timedelta

# Simula próxima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravação da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} às {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÉDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicídio", "morrer", "não aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)



==== /home/ubuntu/famdomes_backend/app/utils/risco.py ====
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases críticas (ajuste conforme necessário)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    # Adicionar termos relacionados a auto-mutilação se aplicável
    # Adicionar termos relacionados a ameaças a terceiros se aplicável
]

# Adicionar palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergências médicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicídio, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"🚨 RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"🚑 URGÊNCIA MÉDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }


==== /home/ubuntu/famdomes_backend/app/utils/agenda.py ====
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuração da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (não agenda às 18:00, último é 17:40)

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar índice para garantir que não haja duas consultas no mesmo horário
    consultas_db.create_index("horario", unique=True)
    logging.info("Conexão com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avança o horário para o próximo bloco de X minutos dentro do horário de operação."""
    horario = inicio_base

    # Arredonda para o próximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no início do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horário de operação
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (Sábado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o próximo horário livre e agenda a consulta.
    Retorna o datetime do horário agendado ou None se não encontrar.
    """
    if not consultas_db:
        logging.error("Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento no DB é uma boa prática
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se já existe consulta nesse horário
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horário livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificação/inserção, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceção

    logging.warning(f"Não foram encontrados horários disponíveis para {telefone} após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se não encontrar horário

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda não ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"🗑️ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o próximo horário disponível sem agendar."""
    if not consultas_db:
        logging.error("Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Começa a procurar um pouco à frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Próximo horário disponível encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc:
        return "Indisponível"
    try:
        # Precisa da biblioteca pytz para fusos horários robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Terça-feira, 15 de Abril às 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B às %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horário {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formatação"
def consultar_horario():
    return "amanhã às 10h"



==== /home/ubuntu/famdomes_backend/app/utils/ia_fallback.py ====
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta



==== /home/ubuntu/famdomes_backend/app/utils/followup.py ====
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a função de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a função real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # Não precisa mais buscar aqui, usa agenda.py
    logging.info("Conexão com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Funções de Simulação (Removidas ou Substituídas) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> Lógica está em agenda.py
# avisar_profissional -> Deveria ser chamado após agendamento real
# avisar_paciente -> Deveria ser chamado após agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o início de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("Não é possível iniciar sessão de pagamento: Sem conexão com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao iniciar sessão de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessão como paga, agenda a consulta e retorna o horário agendado e nome.
    Esta função é chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("Não é possível marcar pagamento: Sem conexão com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que só atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualização se não encontrar, ou *depois* se encontrar
                                # Precisamos do nome, então talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome já está lá do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessão ser criada, ou se já foi processado
            logging.warning(f"Sessão de pagamento não encontrada ou já processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessão
        logging.info(f"[SESSÃO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessão com o horário agendado (opcional, mas útil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessão com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possível notificação manual

    except Exception as e:
        logging.error(f"❌ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Função para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # Lógica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo número real ou lógica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"👨‍⚕️ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) às {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("Número do médico não configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Função para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessões com pagamento pendente há muito tempo."""
    if not sessoes_db:
        logging.error("Não é possível checar followup: Sem conexão com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "você")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Olá {nome}, notei que você iniciou um agendamento mas parece que não foi concluído. 😥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dúvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. 😊"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessão para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"❌ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # Função ainda não implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0




==== /home/ubuntu/famdomes_backend/app/schemas/ia_comando.py ====
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str



==== /home/ubuntu/famdomes_backend/app/intents/router_intents.py ====
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigatórios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }


==== /home/ubuntu/famdomes_backend/app/intents/__init__.py ====



==== /home/ubuntu/famdomes_backend/app/intents/intent_executor.py ====
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_proximo_horario_disponivel as consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o módulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "🧡 Você deu um passo importante ao chegar aqui. Sabemos que não é fácil buscar ajuda.\n\n"
    "🤝 Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "📲 Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "tô aqui pra isso", "pode falar", "é isso", "ok", "tá", "tá bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "não", "nao", "talvez depois", "não agora", "deixa pra depois",
    "tô só olhando", "só pesquisando", "agora não"
]

# Limiar de confiança para a intent (ajuste conforme necessário)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui é o|aqui é a|meu nome é|me chamo é)\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)",
        r"nome é\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confiança alta

    def detectar_intent(self):
        # Lógica de detecção de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confiança para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confiança na confirmação
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que você precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "🔄 Histórico de testes apagado com sucesso. Pode começar uma nova simulação.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "olá", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confiança na confirmação

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confiança na confirmação
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # Média confiança em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # INÍCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"📅 Ótimo! Posso te ajudar a agendar com nosso médico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"📆 O próximo horário disponível é: {consultar_horario()}. Posso reservar pra você?",

        # VALORES
        "duvida_valores": "💰 Temos valores acessíveis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIANÇA
        "duvida_geral": "📋 Nosso sistema conecta você com médicos especialistas de verdade. Quer saber como funciona na prática?",
        "desconfianca": "🔍 Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPENDÊNCIA / RECAÍDA / SINTOMAS
        "duvida_dependencia": "🧠 A dependência química é tratável. Nosso médico pode avaliar sintomas físicos e emocionais. Quer agendar?",
        "sou_dependente": "💬 Reconhecer isso é um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "🔁 Recaídas fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "😓 Os sintomas de abstinência são desafiadores. Podemos te orientar com segurança. Posso marcar agora?",

        # CRISE / URGÊNCIA
        "sintomas_graves": "⚠️ Sinais de crise detectados. Posso encaminhar você para um atendimento urgente. Deseja ajuda agora?",
        "ameaça_vida": "🚨 Sua vida importa. Posso ativar nosso acolhimento de urgência. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "👪 Você quer ajudar alguém importante. Posso te explicar como funciona e agendar uma escuta para você ou para ele(a).",
        "familia_pedindo_ajuda": "🧭 Você está no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "🚨 Situação familiar crítica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "😔 É difícil quando a família não apoia. Mas há caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "💔 Muitas famílias passam por isso. Podemos ajudar na reconstrução. Quer agendar uma orientação especializada?",
        "familiar_violento": "⚠️ Em casos de violência, segurança vem primeiro. Posso te mostrar como agir com respaldo médico e legal.",

        # INTERNAÇÃO
        "duvida_internacao": "🏥 A internação pode ser voluntária ou involuntária, sempre com avaliação médica. Quer saber como isso funciona?",
        "quero_internar": "✅ Posso te mostrar o processo completo, legal e clínico. Posso agendar agora com nosso médico?",

        # FUNIL / OBJECÕES / CIRCUNSTÂNCIAS
        "nao_quero_internar": "Tudo bem. Internação não é a única saída. Posso te explicar outras opções com orientação médica.",
        "meu_parente_usa_droga": "💬 Entendo. Posso agendar com o especialista pra avaliar a situação de forma profissional.",
        "crise_agora": "⚠️ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "💡 Obrigado por compartilhar. Posso te ajudar com os próximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "😔 A resistência é comum. Mesmo assim, a família pode iniciar a ação. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "👥 Se a família não colabora, podemos trabalhar com quem estiver disponível. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "👍 Tranquilo. Se quiser ajudar alguém ou tirar dúvidas, posso te explicar tudo com calma.",

        # INFORMAÇÕES COMPLEMENTARES
        "quero_entender": "📘 Posso te explicar tudo sobre o atendimento, desde a escuta até o tratamento. Quer começar agora?",
        "curioso": "😄 Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulação real?",
        "pergunta_medico": "👨‍⚕️ O médico é especialista em dependência química e avaliação clínica. Quer agendar a escuta?",
        "duvida_medicacao": "💊 Medicamentos só são indicados após avaliação. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "🧠 Temos psicólogos na equipe. A avaliação inicial é médica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "🔁 Recomeçar é possível. Estamos aqui pra isso. Quer conversar com o médico novamente?",
        "vergonha_de_falar": "🧡 Tudo bem. Não precisa se explicar agora. Posso só ouvir, se quiser.",
        "culpa_familiar": "🤝 A culpa não ajuda, mas o cuidado sim. Posso te mostrar como começar com leveza.",
        "busca_ajuda_emocional": "💬 Também acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "🛐 Respeitamos todas as crenças. O acolhimento é humano, com base ética. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "⚖️ A internação judicial é possível. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "👶 Tratamos casos de menores com responsabilidade. Posso te mostrar os critérios e caminhos.",
        "direitos_paciente": "📜 Tudo é feito conforme a ética médica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "📍 Temos atendimento online e unidades físicas. Quer saber se tem perto de você?",
        "duvida_profissionais": "👩‍⚕️ Temos médicos, terapeutas e psicólogos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "🔒 Todo atendimento é sigiloso. Nada é compartilhado sem sua autorização. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"✅ Consulta cancelada. Se quiser retomar, é só me avisar.",
        "teste": "🧪 Está testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "❤️ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prática.",
        "erro": "🔁 Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "🤔 Não entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "👍 Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugestões de próximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou você gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou você tem alguma outra dúvida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou você gostaria de agendar uma consulta?",
            "sou_dependente": "\nVocê gostaria de agendar uma consulta ou precisa de mais informações?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVocê gostaria de agendar uma consulta para você ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de internação ou você gostaria de saber as opções de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se você reformular a pergunta ou gostaria de ver as opções de ajuda disponíveis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padrão
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta


==== /home/ubuntu/famdomes_backend/app/intents/intents_map.py ====
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # 🚀 INÍCIO DO FUNIL
    "boas_vindas": [
        "oi", "olá", "ola", "bom dia", "boa tarde", "boa noite", "e aí", "fala comigo", "tudo bem", "como vai"
    ],

    # 👤 QUERO AGENDAR / HORÁRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um médico", "consulta urgente", "quero ajuda médica",
        "agendar", "marcar consulta", "atendimento médico", "agendar consulta"
    ],
    "ver_horario": [
        "tem horário", "que horas tem", "tem agenda", "qual o próximo horário", "quero saber os horários",
        "horários disponíveis", "agenda livre", "consultar horário", "ver agenda"
    ],

    # 💰 VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "preço", "tem plano", "é caro", "valores da consulta", "paga quanto", "é gratuito?",
        "aceita convênio", "plano de saúde", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # ❓ DÚVIDAS GERAIS / CONFIANÇA
    "duvida_geral": [
        "como funciona", "me explica", "o que vocês fazem", "isso é pra quê", "como ajudam", "qual o tratamento",
        "o que é isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso é real?", "posso confiar?", "é golpe?", "tem CNPJ?", "quem são vocês?", "é confiável?", "funciona mesmo?",
        "é seguro?", "garantia", "é empresa?"
    ],

    # 📚 SOBRE DEPENDÊNCIA / VÍCIO
    "duvida_dependencia": [
        "o que é dependência química", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "vício em drogas", "meu caso tem jeito", "isso é doença?", "uso mas não sou viciado", "tem tratamento",
        "dependência", "vício", "drogas", "alcoolismo", "sintomas de vício"
    ],
    "sou_dependente": [
        "sou viciado", "tenho vício", "sou dependente químico", "tenho problema com droga", "uso todo dia",
        "não consigo parar", "preciso parar de usar", "sou alcoólatra", "viciado"
    ],
    "recaida": [
        "tive recaída", "usei de novo", "não consegui parar", "recomecei", "caí de novo",
        "recaí", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "tô tremendo", "tô suando", "não tô bem", "tô em abstinência", "tô agoniado", "tô passando mal sem usar",
        "sintomas de abstinência", "fissura", "crise de abstinência"
    ],

    # 🧠 SINTOMAS GRAVES / CRISE / URGÊNCIA
    "sintomas_graves": [
        "tá surtando", "alucinação", "tá agressivo", "não dorme há dias", "visões", "delírio", "tá em crise",
        "descontrolado", "sem noção do que faz", "paranoia", "confusão mental", "surto psicótico"
    ],
    "ameaça_vida": [ # Risco de suicídio/auto-mutilação
        "quero morrer", "vou me matar", "não quero viver", "quero sumir", "vou acabar com tudo", "vida não faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # Emergência médica clara
        "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
        "desmaiado", "convulsão", "sangrando muito", "veneno", "infarto", "avc", "emergência"
    ],


    # 👨‍👩‍👦 FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou mãe", "sou pai", "sou esposa", "sou marido", "sou irmão", "sou irmã", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho tá viciado", "minha filha tá usando", "meu marido não aceita ajuda", "ele não quer se tratar",
        "não sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela tá gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "tá se machucando", "tá em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele não quer ajuda", "ela não aceita", "não quer tratamento", "não admite que tem problema",
        "não quer ser internado", "não aceita médico", "resiste ao tratamento"
    ],

    # 🏥 INTERNAÇÃO
    "duvida_internacao": [
        "como funciona a internação", "quanto tempo dura", "volta pra casa depois?", "como é o lugar",
        "tem visita?", "fica trancado?", "internação involuntária", "é forçado?", "tem psiquiatra?",
        "internação", "clínica de recuperação", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como faço pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "internação compulsória", "internação involuntária"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa não querer internação
        "não quero internar", "sem internação", "tratamento sem internar", "não precisa de clínica",
        "alternativa à internação", "tratamento ambulatorial"
    ],

    # ⚖️ QUESTÕES LEGAIS / JURÍDICAS
    "internacao_judicial": [
        "posso pedir pra justiça?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "internação compulsória", "justiça", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho é menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "criança"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele é obrigado?", "isso é legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # 💬 OUTRAS SITUAÇÕES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # Usuário falando sobre seu próprio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida tá destruída",
        "preciso de ajuda com meu vício"
    ],
     "resistencia_familiar": [ # Paciente relata que a família não apoia/atrapalha
        "minha família não me apoia", "minha esposa não entende", "meus pais não aceitam",
        "família contra o tratamento", "não tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que não é o paciente
        "não sou eu que uso", "é para um amigo", "só estou pesquisando", "quero informação para outra pessoa",
        "não sou usuário"
    ],

    # ℹ️ BUSCA DE INFORMAÇÕES ADICIONAIS
     "quero_entender": [ # Pedido explícito para entender o serviço/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # Demonstração de curiosidade ou teste
        "só testando", "kkk", "haha", "curioso", "testando sistema", "só vendo como funciona",
        "teste", "simulação"
    ],
    "pergunta_medico": [ # Dúvida específica sobre o profissional médico
        "quem é o médico?", "qual a especialidade?", "é psiquiatra?", "posso escolher o médico?",
        "falar com o médico"
    ],
     "duvida_medicacao": [ # Dúvida sobre remédios
        "vai precisar de remédio?", "usam medicação?", "quais remédios?", "tratamento com remédio",
        "medicação psiquiátrica"
    ],
     "duvida_psicologo": [ # Dúvida sobre psicólogo/terapia
        "tem psicólogo?", "faz terapia?", "atendimento psicológico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # Dúvida sobre local físico/online
        "onde fica?", "tem na minha cidade?", "qual o endereço?", "atende onde?", "é presencial ou online?",
        "atendimento online", "unidade física", "endereço da clínica"
    ],
     "duvida_profissionais": [ # Dúvida geral sobre a equipe
        "quem são os profissionais?", "tem terapeuta?", "quem atende?", "é só médico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # Dúvida sobre confidencialidade
        "isso é sigiloso?", "meus dados estão protegidos?", "alguém vai saber?", "é confidencial?",
        "privacidade", "segredo médico"
    ],


    # ❤️ INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # Já tentou tratamento antes e parou
        "já tentei parar antes", "desisti do tratamento", "não funcionou da outra vez",
        "já fiz tratamento e não adiantou", "recomeçar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ninguém", "é difícil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que é culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "tô mal", "tô triste", "ansiedade", "crise de pânico", "sou depressivo", "tô vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # Questões sobre religião/espiritualidade
        "é contra religião?", "tem algo espiritual?", "sou evangélico", "sou católico", "tem apoio religioso?",
        "minha fé", "igreja"
    ],

    # 🛑 CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar ação atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "não quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "não posso ir"
    ],
    "confirmacao_positiva": [ # Confirmação genérica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "tá", "tá bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # Negação genérica (não, agora não)
        "não", "nao", "talvez depois", "não agora", "deixa pra depois", "agora não", "não quero", "não obrigado"
    ],
    "elogio": [
        "ótimo atendimento", "gostei muito", "vocês são bons", "obrigado", "atendimento top", "amei",
        "parabéns", "muito bom", "excelente"
    ],
    "erro": [ # Usuário reporta um erro técnico
        "link não abre", "deu erro", "não consegui pagar", "o site caiu", "não carrega",
        "problema técnico", "não funciona", "bug"
    ],
    "sem_compreensao": [ # Bot não entendeu ou mensagem ininteligível
        "asdfgh", "oiaueia", "????", "não entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "não faz sentido"
    ],

    # Adicione intents mais específicas conforme necessário
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}


==== /home/ubuntu/famdomes_backend/app/routes/pagamentos.py ====
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}



==== /home/ubuntu/famdomes_backend/app/routes/painel.py ====
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}



==== /home/ubuntu/famdomes_backend/app/routes/stripe.py ====
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # 🧠 Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # 🧠 Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}



==== /home/ubuntu/famdomes_backend/app/routes/rocketchat.py ====
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }



==== /home/ubuntu/famdomes_backend/app/routes/agendamento.py ====
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}




==== /home/ubuntu/famdomes_backend/app/routes/whatsapp.py ====
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("⚠️ Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # 🚨 Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"⚠️ Alerta FAMDOMES: Detecção de risco na conversa com {telefone}. "
                f"Mensagem: “{mensagem}”. Um profissional será alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("❌ ERRO no webhook:", str(e))
        return {"erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/routes/ia_comandos.py ====
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"✅ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando não reconhecido.")



==== /home/ubuntu/famdomes_backend/app/routes/ia.py ====
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ✅ Função exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"✅ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "❌ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "✅ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in comando or "disponível" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "🤖 Desculpe, não entendi o que você deseja. Você pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horário disponível")
        return {"status": "comando_desconhecido"}



==== /home/ubuntu/famdomes_backend/app/routes/followup.py ====
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}



==== /home/ubuntu/famdomes_backend/app/main.py ====
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("📥 Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas públicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Validação da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)



==== /home/ubuntu/famdomes_backend/app/models/pagamentos.py ====
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str



==== /home/ubuntu/famdomes_backend/app/models/intents.py ====
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horário",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horário",
    ],
    "confirmar_pagamento": [
        "paguei",
        "já paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que você faz",
        "me ajuda",
        "como você pode me ajudar"
    ]
}



==== /home/ubuntu/famdomes_backend/app/models/atendimento.py ====
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str



==== /home/ubuntu/famdomes_backend/app/config.py ====
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")



==== /home/ubuntu/famdomes_backend/app/nlu/response_generator.py ====
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "🧡 Você deu um passo importante ao chegar aqui. Sabemos que não é fácil buscar ajuda.\n\n"
    "🤝 Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "📲 Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÍCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"📅 Ótimo! Posso te ajudar a agendar com nosso médico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"📆 O próximo horário disponível é: {consultar_horario()}. Posso reservar pra você?",

    # VALORES
    "duvida_valores": "💰 Temos valores acessíveis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÇA
    "duvida_geral": "📋 Nosso sistema conecta você com médicos especialistas de verdade. Quer saber como funciona na prática?",
    "desconfianca": "🔍 Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÊNCIA / RECAÍDA / SINTOMAS
    "duvida_dependencia": "🧠 A dependência química é tratável. Nosso médico pode avaliar sintomas físicos e emocionais. Quer agendar?",
    "sou_dependente": "💬 Reconhecer isso é um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "🔁 Recaídas fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "😓 Os sintomas de abstinência são desafiadores. Podemos te orientar com segurança. Posso marcar agora?",

    # CRISE / URGÊNCIA
    "sintomas_graves": "⚠️ Sinais de crise detectados. Posso encaminhar você para um atendimento urgente. Deseja ajuda agora?",
    "ameaça_vida": "🚨 Sua vida importa. Posso ativar nosso acolhimento de urgência. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "👪 Você quer ajudar alguém importante. Posso te explicar como funciona e agendar uma escuta para você ou para ele(a).",
    "familia_pedindo_ajuda": "🧭 Você está no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "🚨 Situação familiar crítica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "😔 É difícil quando a família não apoia. Mas há caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "💔 Muitas famílias passam por isso. Podemos ajudar na reconstrução. Quer agendar uma orientação especializada?",
    "familiar_violento": "⚠️ Em casos de violência, segurança vem primeiro. Posso te mostrar como agir com respaldo médico e legal.",

    # INTERNAÇÃO
    "duvida_internacao": "🏥 A internação pode ser voluntária ou involuntária, sempre com avaliação médica. Quer saber como isso funciona?",
    "quero_internar": "✅ Posso te mostrar o processo completo, legal e clínico. Posso agendar agora com nosso médico?",

    # FUNIL / OBJECÕES / CIRCUNSTÂNCIAS
    "nao_quero_internar": "Tudo bem. Internação não é a única saída. Posso te explicar outras opções com orientação médica.",
    "meu_parente_usa_droga": "💬 Entendo. Posso agendar com o especialista pra avaliar a situação de forma profissional.",
    "crise_agora": "⚠️ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "💡 Obrigado por compartilhar. Posso te ajudar com os próximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "😔 A resistência é comum. Mesmo assim, a família pode iniciar a ação. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "👥 Se a família não colabora, podemos trabalhar com quem estiver disponível. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "👍 Tranquilo. Se quiser ajudar alguém ou tirar dúvidas, posso te explicar tudo com calma.",

    # INFORMAÇÕES COMPLEMENTARES
    "quero_entender": "📘 Posso te explicar tudo sobre o atendimento, desde a escuta até o tratamento. Quer começar agora?",
    "curioso": "😄 Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulação real?",
    "pergunta_medico": "👨‍⚕️ O médico é especialista em dependência química e avaliação clínica. Quer agendar a escuta?",
    "duvida_medicacao": "💊 Medicamentos só são indicados após avaliação. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "🧠 Temos psicólogos na equipe. A avaliação inicial é médica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "🔁 Recomeçar é possível. Estamos aqui pra isso. Quer conversar com o médico novamente?",
    "vergonha_de_falar": "🧡 Tudo bem. Não precisa se explicar agora. Posso só ouvir, se quiser.",
    "culpa_familiar": "🤝 A culpa não ajuda, mas o cuidado sim. Posso te mostrar como começar com leveza.",
    "busca_ajuda_emocional": "💬 Também acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "🛐 Respeitamos todas as crenças. O acolhimento é humano, com base ética. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "⚖️ A internação judicial é possível. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "👶 Tratamos casos de menores com responsabilidade. Posso te mostrar os critérios e caminhos.",
    "direitos_paciente": "📜 Tudo é feito conforme a ética médica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "📍 Temos atendimento online e unidades físicas. Quer saber se tem perto de você?",
    "duvida_profissionais": "👩‍⚕️ Temos médicos, terapeutas e psicólogos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "🔒 Todo atendimento é sigiloso. Nada é compartilhado sem sua autorização. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "✅ Consulta cancelada. Se quiser retomar, é só me avisar.",
    "teste": "🧪 Está testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "❤️ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prática.",
    "erro": "🔁 Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "🤔 Não entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "👍 Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrão se intent for reconhecida mas sem frase específica
        return respostas.get(intent, "Tô por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")



==== /home/ubuntu/famdomes_backend/app/nlu/chatbot_router.py ====
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "tô aqui pra isso", "pode falar", "é isso", "ok", "tá", "tá bom",
    "isso", "por favor", "sim quero", "tô dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "🔄 Histórico apagado. Pode começar de novo.", "risco": False}

        # Classificação de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se há contexto anterior de confirmação pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no histórico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"⚠️ Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()



==== /home/ubuntu/famdomes_backend/app/nlu/nlu_classifier.py ====
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparação ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuações básicas (exceto espaços) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaços extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML não encontrados. Usando classificação por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presença de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confiança base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho está contido no texto
                # Usar `in` é simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # Lógica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confiança para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classificação com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pré-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # Não pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confiança={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificação ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confiança.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML não estiver ativo ou como método principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- Método de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF é um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parâmetros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes é um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------


==== /home/ubuntu/famdomes_backend/app/nlu/entidade_extractor.py ====
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)",
                r"([A-ZÁÉÍÓÚA-Za-záéíóú]+)\s+(?:é meu nome|meu nome é|aqui é)" # Novo padrão
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)\s+(?:é meu|minha)" # Novo padrão
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-záéíóúãõâêîôûç\s]+)",
                r"(?:cidade de)\s+([A-Za-záéíóúãõâêîôûç\s]+)" # Novo padrão
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrão
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaína)"
            ],
            "recaida": [
                r"(reca[íi]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[íi]da|escorregada)" # Novo padrão
            ],
            # Adicione mais entidades e padrões conforme necessário
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraída: {entidades[entidade]} (Padrão: '{padrao}')")
                    break  # Para na primeira correspondência

        return entidades


# Conteúdo do arquivo: ./utils/faq_respostas.py
FAQ_RESPOSTAS = {
    "dependencia_quimica": (
        "Dependência química é uma doença crônica caracterizada pelo uso compulsivo de substâncias, "
        "apesar das consequências negativas, afetando o cérebro e o comportamento."
    ),
    "identificar_dependencia": (
        "Sinais incluem uso constante da substância, dificuldade em parar, negligência nas responsabilidades, "
        "mudanças bruscas de comportamento e sintomas de abstinência."
    ),
    "tipos_internacao": (
        "Existem três tipos principais de internação: voluntária (com consentimento), involuntária "
        "(solicitada pela família) e compulsória (por ordem judicial)."
    ),
    "como_funciona_tratamento": (
        "O tratamento em clínica inclui desintoxicação supervisionada, terapias individuais e em grupo, "
        "atividades terapêuticas e acompanhamento médico constante."
    ),
    "duracao_tratamento": (
        "Normalmente, o tratamento dura entre 3 e 6 meses, podendo variar de acordo com a situação específica."
    ),
    "custo_tratamento": (
        "Os valores variam dependendo dos serviços e acomodações. Para detalhes exatos, podemos agendar uma avaliação."
    ),
    "recusa_ajuda": (
        "Se a pessoa não aceita ajuda voluntariamente, pode ser considerado o processo de internação involuntária "
        "com suporte legal e médico especializado."
    ),
    "apoio_familiar": (
        "Famílias podem ajudar oferecendo suporte emocional, participando das terapias familiares e estabelecendo limites claros."
    ),
    "sobre_caps": (
        "O CAPS é um Centro de Atenção Psicossocial que oferece tratamento especializado em saúde mental e dependência química."
    ),
    "como_agendar": (
        "Você pode agendar facilmente uma consulta entrando em contato conosco pelo WhatsApp ou pelo nosso site oficial."
    ),
}

# Conteúdo do arquivo: ./utils/ollama.py
import httpx
import logging
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt,
        "stream": False
    }
    headers = {"Content-Type": "application/json"}
    try:
        async with httpx.AsyncClient(timeout=60.0) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_API_URL}/{OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            response.raise_for_status()
            dados = response.json()
            logging.info("✅ Resposta recebida da IA (OLLAMA).")
            resposta_bruta = dados.get("response", "⚠️ Erro interno na IA.")
            # Aqui você pode fazer qualquer limpeza necessária na resposta
            tokens = []  # Se houver tokens, adicione-os
            return resposta_bruta, tokens
    except httpx.TimeoutException as e:
        logging.error(f"❌ Erro: Timeout ({str(e)})")
        return "⚠️ Desculpe, demorei muito para pensar. Tente novamente.", []
    except httpx.HTTPStatusError as e:
        logging.error(f"❌ Erro: HTTP {e.response.status_code} - {e.response.text}")
        return f"⚠️ Ocorreu um erro interno ({e.response.status_code}). Por favor, tente mais tarde.", []
    except Exception as e:
        logging.exception("❌ Erro desconhecido ao chamar Ollama:")
        return "⚠️ Erro inesperado. Tente novamente mais tarde.", []

# Conteúdo do arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura – certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        return (
            "Você é um assistente virtual especializado em saúde mental e dependência química. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Histórico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usuário:
{pergunta_atual.strip()}
---
Instruções para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no máximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Conteúdo do arquivo: ./utils/mensageria.py
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("⚠️ Tentativa de enviar mensagem vazia ou sem destinatário.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url é geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoável para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"✅ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padrão Clínica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfação",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botão de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("❌ ERRO: Configurações da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configuração da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botão de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Índice do botão no template
                    # "parameters": [] # Parâmetros específicos do botão, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"✅ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"❌ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"❌ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"❌ ERRO de Conexão ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"❌ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
# Conteúdo do arquivo: ./utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    contextos_db = db["contexto_conversa"]
    logging.info("Conexão com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    if contextos_db is None:
        logging.error(f"Não foi possível salvar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inválido.")
        return False
    try:
        contextos_db.update_one(
            {"telefone": telefone},
            {"$set": dados_atualizacao, "$currentDate": {"ultima_atualizacao": True},
             "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()}},
            upsert=True
        )
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    if contextos_db is None:
        logging.error(f"Não foi possível obter contexto para {telefone}: Sem conexão com DB.")
        return {}
    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}
    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto is not None:
            return contexto
        return {}
    except Exception as e:
        logging.error(f"❌ ERRO ao obter contexto para {telefone}: {e}")
        return {}

def limpar_contexto(telefone: str):
    if contextos_db is None:
        logging.error(f"Não foi possível limpar contexto para {telefone}: Sem conexão com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False
    try:
        result = contextos_db.delete_one({"telefone": telefone})
        return result.deleted_count > 0
    except Exception as e:
        logging.error(f"❌ ERRO ao limpar contexto para {telefone}: {e}")
        return False

# Conteúdo do arquivo: ./utils/db.py
from datetime import datetime, timedelta

# Simula próxima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravação da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} às {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÉDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicídio", "morrer", "não aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

# Conteúdo do arquivo: ./utils/risco.py
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases críticas (ajuste conforme necessário)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    # Adicionar termos relacionados a auto-mutilação se aplicável
    # Adicionar termos relacionados a ameaças a terceiros se aplicável
]

# Adicionar palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergências médicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicídio, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"🚨 RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"🚑 URGÊNCIA MÉDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
# Conteúdo do arquivo: ./utils/agenda.py
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuração da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (não agenda às 18:00, último é 17:40)

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar índice para garantir que não haja duas consultas no mesmo horário
    consultas_db.create_index("horario", unique=True)
    logging.info("Conexão com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avança o horário para o próximo bloco de X minutos dentro do horário de operação."""
    horario = inicio_base

    # Arredonda para o próximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no início do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horário de operação
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (Sábado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o próximo horário livre e agenda a consulta.
    Retorna o datetime do horário agendado ou None se não encontrar.
    """
    if not consultas_db:
        logging.error("Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento no DB é uma boa prática
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se já existe consulta nesse horário
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horário livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificação/inserção, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceção

    logging.warning(f"Não foram encontrados horários disponíveis para {telefone} após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se não encontrar horário

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda não ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"🗑️ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o próximo horário disponível sem agendar."""
    if not consultas_db:
        logging.error("Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Começa a procurar um pouco à frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Próximo horário disponível encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Avança para o próximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc:
        return "Indisponível"
    try:
        # Precisa da biblioteca pytz para fusos horários robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Terça-feira, 15 de Abril às 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B às %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horário {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formatação"
def consultar_horario():
    return "amanhã às 10h"

# Conteúdo do arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Conteúdo do arquivo: ./utils/followup.py
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a função de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a função real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Operações síncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # Não precisa mais buscar aqui, usa agenda.py
    logging.info("Conexão com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"❌ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Funções de Simulação (Removidas ou Substituídas) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> Lógica está em agenda.py
# avisar_profissional -> Deveria ser chamado após agendamento real
# avisar_paciente -> Deveria ser chamado após agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o início de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("Não é possível iniciar sessão de pagamento: Sem conexão com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"❌ ERRO ao iniciar sessão de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessão como paga, agenda a consulta e retorna o horário agendado e nome.
    Esta função é chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("Não é possível marcar pagamento: Sem conexão com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que só atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualização se não encontrar, ou *depois* se encontrar
                                # Precisamos do nome, então talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome já está lá do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessão ser criada, ou se já foi processado
            logging.warning(f"Sessão de pagamento não encontrada ou já processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessão
        logging.info(f"[SESSÃO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessão com o horário agendado (opcional, mas útil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessão com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possível notificação manual

    except Exception as e:
        logging.error(f"❌ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Função para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # Lógica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo número real ou lógica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"👨‍⚕️ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) às {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("Número do médico não configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Função para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessões com pagamento pendente há muito tempo."""
    if not sessoes_db:
        logging.error("Não é possível checar followup: Sem conexão com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "você")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Olá {nome}, notei que você iniciou um agendamento mas parece que não foi concluído. 😥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dúvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. 😊"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessão para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"❌ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # Função ainda não implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0


# Conteúdo do arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Conteúdo do arquivo: ./intents/intent_executor.py
import re
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.ia_fallback import chamar_ollama  # Função que chama o Ollama
from app.utils.prompt_builder import construir_prompt
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.intents.intents_map import INTENTS
import logging
import unicodedata

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
historico = mongo["famdomes"]["respostas_ia"]
leads = mongo["famdomes"]["leads"]

MENSAGEM_INICIAL = "🧡 Você deu um passo importante ao chegar aqui. Como posso ajudar você?"

# Respostas pré-definidas – ajuste conforme sua estratégia de atendimento e vendas
RESPOSTAS_PREDEFINIDAS = {
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": "📅 Ótimo! Vou encaminhar o link para agendar sua consulta.",
    "cancelar": "✅ Sua consulta foi cancelada. Estamos à disposição para retomar.",
    "duvida_geral": "📋 Nossa equipe está pronta para esclarecer suas dúvidas. Fale com a gente!",
    "venda": "💰 Temos planos especiais para você. Gostaria de conhecer nossos pacotes?"
}

RESPOSTAS_CONFIRMATIVAS = ["sim", "claro", "com certeza", "prossiga", "quero"]
RESPOSTAS_NEGATIVAS = ["não", "nao", "deixa", "cancelar"]

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)
        self.intent_confianca = 1.0

    def detectar_intent(self):
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"
        if self.contexto.get("aguardando_confirmacao"):
            if any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_CONFIRMATIVAS):
                return self.contexto.get("intent_esperada", "confirmacao")
            elif any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_NEGATIVAS):
                return "cancelar"
        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if g.lower() in self.mensagem_normalizada:
                    return intent
        self.intent_confianca = 0.5
        return "desconhecida"

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        contexto_anterior = obter_contexto(self.telefone)
        ultima_intent = contexto_anterior.get("ultima_intent", "")

        # Se a última interação ofereceu agendamento e a resposta atual for positiva:
        if ultima_intent == "ofereceu_agendamento" and intent in ["boas_vindas", "desconhecida"]:
            resposta = (
                "📅 Excelente! A consulta é feita com especialistas em dependência química e saúde mental, "
                "onde faremos uma avaliação cuidadosa e criaremos um plano de tratamento personalizado para vocês. "
                "Para confirmar e garantir seu atendimento, acesse agora este link: "
                "https://clinicamg.com.br/agendamento"
            )
            salvar_contexto(self.telefone, {"ultima_intent": "aguardando_pagamento"})
        
        elif intent in FAQ_RESPOSTAS:
            resposta = FAQ_RESPOSTAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        elif intent == "reset_manual":
            limpar_contexto(self.telefone)
            resposta = "🔄 Histórico apagado. Inicie novamente."

        elif intent in RESPOSTAS_PREDEFINIDAS:
            resposta = RESPOSTAS_PREDEFINIDAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        else:
            prompt_final = construir_prompt(self.telefone, self.mensagem)
            resposta, _ = await chamar_ollama(prompt_final, self.telefone)
            resposta = self.limpar_resposta(resposta)

            if "agendar" in resposta.lower() or "consulta" in resposta.lower():
                salvar_contexto(self.telefone, {"ultima_intent": "ofereceu_agendamento"})

        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

   
   
    def limpar_resposta(self, texto: str) -> str:
        import re
        return re.sub(r"\(.*?\)", "", texto).strip()

    async def executar(self):
        return await self._processar_intents_e_responder()

# Conteúdo do arquivo: ./intents/intents_map.py
INTENTS = {
    "boas_vindas": ["oi", "olá", "bom dia", "boa tarde", "boa noite"],
    "quero_agendar": ["agendar", "marcar", "consulta", "agendamento"],
    "cancelar": ["cancelar", "desmarcar", "não quero"],
    "duvida_geral": ["como funciona", "o que vocês fazem", "ajuda", "informação"],
    "venda": ["comprar", "pacote", "planos", "venda"],"dependencia_quimica": ["dependencia", "vício", "dependente químico"],
    "identificar_dependencia": ["como saber", "sinais dependencia", "identificar dependência"],
    "tipos_internacao": ["internação", "tipos de internação", "internar"],
    "como_funciona_tratamento": ["tratamento", "como é o tratamento", "tratamento na clínica"],
    "duracao_tratamento": ["tempo tratamento", "duração tratamento"],
    "custo_tratamento": ["preço", "valor tratamento", "quanto custa"],
    "recusa_ajuda": ["não aceita ajuda", "recusa tratamento"],
    "apoio_familiar": ["família ajudar", "ajuda familiar", "apoio da família"],
    "sobre_caps": ["o que é caps", "caps"],
    "como_agendar": ["agendar", "marcar consulta", "consulta", "avaliar"],
}
# Mapeia os intents para as respostas correspondentes


# Conteúdo do arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Conteúdo do arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Conteúdo do arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from pydantic import BaseModel
from app.nlu.chatbot_router import processar_mensagem

router = APIRouter()

class MensagemEntrada(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

@router.post("/chat/nlp")
async def analisar_mensagem(payload: MensagemEntrada):
    intent, entidades, risco = processar_mensagem(payload.mensagem)

    return {
        "intent": intent,
        "entidades": entidades,
        "risco": risco
    }

# Conteúdo do arquivo: ./routes/stripe.py
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # 🧠 Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # 🧠 Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

# Conteúdo do arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Conteúdo do arquivo: ./routes/agendamento.py
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


# Conteúdo do arquivo: ./routes/whatsapp.py
from fastapi import APIRouter, Request, Response, HTTPException
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR, MONGO_URI
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from pymongo import MongoClient
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    try:
        data = await request.json()
        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]
        if "messages" not in changes or "contacts" not in changes:
            logging.info("Evento ignorado – sem mensagens (status ou metadados).")
            return Response(status_code=200)
        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"].get("name", "Paciente")
        logging.info(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        logging.info(f"Mensagem: {mensagem}")

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()
        resposta = resultado["resposta"]
        logging.info(f"Resposta: {resposta}")

        await enviar_mensagem(telefone, resposta)

        if WHATSAPP_FAMILIAR and "ameaça" in mensagem.lower():
            alerta = f"⚠️ Alerta FAMDOMES: Detecção de risco na conversa com {telefone}. Mensagem: “{mensagem}”."
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)
    except Exception as e:
        logging.error(f"❌ ERRO no webhook: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Conteúdo do arquivo: ./routes/ia_comandos.py
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"✅ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando não reconhecido.")

# Conteúdo do arquivo: ./routes/ia.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horário", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ✅ Função exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"✅ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "❌ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "✅ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horário" in comando or "disponível" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"📅 Próximo horário disponível: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "🤖 Desculpe, não entendi o que você deseja. Você pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horário disponível")
        return {"status": "comando_desconhecido"}

# Conteúdo do arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Conteúdo do arquivo: ./main.py
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel
from app.routes import nlp


API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")
app.include_router(nlp.router)
app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)

@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("📥 Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas públicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/nlp") or
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Validação da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

# Conteúdo do arquivo: ./ia_direct.py
from fastapi import APIRouter, HTTPException, Request
from app.utils.ollama import chamar_ollama
from datetime import datetime

router = APIRouter()

# Mapa de respostas predefinidas – ajuste de acordo com sua política de atendimento
RESPOSTAS_MAP = {
    "boas_vindas": "🧡 Você deu um passo importante ao chegar aqui. Sabemos que buscar ajuda é difícil.",
    "quero_agendar": "📅 Ótimo, vamos agendar sua consulta. Aguarde o link.",
    "cancelar": "✅ Sua consulta foi cancelada. Estamos aqui se precisar retomar.",
    "duvida_geral": "📋 Nossa equipe está à disposição para ajudar. Descreva sua dúvida.",
    # Adicione outras chaves e respostas conforme necessário
}

async def processar_mensagem_ia(telefone: str, mensagem: str) -> tuple[str, list]:
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt = f"""
Você é um assistente especializado em atendimento humano controlado para pessoas vulneráveis. Sua missão é responder utilizando SOMENTE as respostas predefinidas abaixo e nada mais.

Mapa de Respostas:
{RESPOSTAS_MAP}

Instruções:
- Ao receber a mensagem do usuário, escolha a resposta mais adequada dentre as opções do mapa.
- NÃO crie respostas novas; retorne apenas a resposta correspondente.
- Mantenha a resposta curta, empática e precisa, sem textos adicionais.

Dados da Requisição:
Data/Hora: {agora}
Telefone: {telefone}
Mensagem do Usuário: {mensagem}

Forneça APENAS a resposta escolhida.
    """.strip()
    resposta, tokens = await chamar_ollama(prompt, telefone)
    return resposta, tokens

@router.post("/mensagem")
async def processar_mensagem_endpoint(request: Request):
    data = await request.json()
    telefone = data.get("telefone")
    mensagem = data.get("mensagem")
    if not telefone or not mensagem:
        raise HTTPException(status_code=400, detail="Telefone e mensagem são obrigatórios.")
    resposta, tokens = await processar_mensagem_ia(telefone, mensagem)
    return {"status": "ok", "resposta": resposta, "tokens": tokens}

# Conteúdo do arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Conteúdo do arquivo: ./models/intents.py
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horário",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horário",
    ],
    "confirmar_pagamento": [
        "paguei",
        "já paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que você faz",
        "me ajuda",
        "como você pode me ajudar"
    ]
}

# Conteúdo do arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Conteúdo do arquivo: ./config.py
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# Conteúdo do arquivo: ./nlu/response_generator.py
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "🧡 Você deu um passo importante ao chegar aqui. Sabemos que não é fácil buscar ajuda.\n\n"
    "🤝 Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "📲 Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÍCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"📅 Ótimo! Posso te ajudar a agendar com nosso médico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"📆 O próximo horário disponível é: {consultar_horario()}. Posso reservar pra você?",

    # VALORES
    "duvida_valores": "💰 Temos valores acessíveis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÇA
    "duvida_geral": "📋 Nosso sistema conecta você com médicos especialistas de verdade. Quer saber como funciona na prática?",
    "desconfianca": "🔍 Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÊNCIA / RECAÍDA / SINTOMAS
    "duvida_dependencia": "🧠 A dependência química é tratável. Nosso médico pode avaliar sintomas físicos e emocionais. Quer agendar?",
    "sou_dependente": "💬 Reconhecer isso é um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "🔁 Recaídas fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "😓 Os sintomas de abstinência são desafiadores. Podemos te orientar com segurança. Posso marcar agora?",

    # CRISE / URGÊNCIA
    "sintomas_graves": "⚠️ Sinais de crise detectados. Posso encaminhar você para um atendimento urgente. Deseja ajuda agora?",
    "ameaça_vida": "🚨 Sua vida importa. Posso ativar nosso acolhimento de urgência. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "👪 Você quer ajudar alguém importante. Posso te explicar como funciona e agendar uma escuta para você ou para ele(a).",
    "familia_pedindo_ajuda": "🧭 Você está no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "🚨 Situação familiar crítica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "😔 É difícil quando a família não apoia. Mas há caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "💔 Muitas famílias passam por isso. Podemos ajudar na reconstrução. Quer agendar uma orientação especializada?",
    "familiar_violento": "⚠️ Em casos de violência, segurança vem primeiro. Posso te mostrar como agir com respaldo médico e legal.",

    # INTERNAÇÃO
    "duvida_internacao": "🏥 A internação pode ser voluntária ou involuntária, sempre com avaliação médica. Quer saber como isso funciona?",
    "quero_internar": "✅ Posso te mostrar o processo completo, legal e clínico. Posso agendar agora com nosso médico?",

    # FUNIL / OBJECÕES / CIRCUNSTÂNCIAS
    "nao_quero_internar": "Tudo bem. Internação não é a única saída. Posso te explicar outras opções com orientação médica.",
    "meu_parente_usa_droga": "💬 Entendo. Posso agendar com o especialista pra avaliar a situação de forma profissional.",
    "crise_agora": "⚠️ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "💡 Obrigado por compartilhar. Posso te ajudar com os próximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "😔 A resistência é comum. Mesmo assim, a família pode iniciar a ação. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "👥 Se a família não colabora, podemos trabalhar com quem estiver disponível. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "👍 Tranquilo. Se quiser ajudar alguém ou tirar dúvidas, posso te explicar tudo com calma.",

    # INFORMAÇÕES COMPLEMENTARES
    "quero_entender": "📘 Posso te explicar tudo sobre o atendimento, desde a escuta até o tratamento. Quer começar agora?",
    "curioso": "😄 Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulação real?",
    "pergunta_medico": "👨‍⚕️ O médico é especialista em dependência química e avaliação clínica. Quer agendar a escuta?",
    "duvida_medicacao": "💊 Medicamentos só são indicados após avaliação. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "🧠 Temos psicólogos na equipe. A avaliação inicial é médica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "🔁 Recomeçar é possível. Estamos aqui pra isso. Quer conversar com o médico novamente?",
    "vergonha_de_falar": "🧡 Tudo bem. Não precisa se explicar agora. Posso só ouvir, se quiser.",
    "culpa_familiar": "🤝 A culpa não ajuda, mas o cuidado sim. Posso te mostrar como começar com leveza.",
    "busca_ajuda_emocional": "💬 Também acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "🛐 Respeitamos todas as crenças. O acolhimento é humano, com base ética. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "⚖️ A internação judicial é possível. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "👶 Tratamos casos de menores com responsabilidade. Posso te mostrar os critérios e caminhos.",
    "direitos_paciente": "📜 Tudo é feito conforme a ética médica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "📍 Temos atendimento online e unidades físicas. Quer saber se tem perto de você?",
    "duvida_profissionais": "👩‍⚕️ Temos médicos, terapeutas e psicólogos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "🔒 Todo atendimento é sigiloso. Nada é compartilhado sem sua autorização. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "✅ Consulta cancelada. Se quiser retomar, é só me avisar.",
    "teste": "🧪 Está testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "❤️ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prática.",
    "erro": "🔁 Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "🤔 Não entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "👍 Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrão se intent for reconhecida mas sem frase específica
        return respostas.get(intent, "Tô por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

# Conteúdo do arquivo: ./nlu/chatbot_router.py
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "tô aqui pra isso", "pode falar", "é isso", "ok", "tá", "tá bom",
    "isso", "por favor", "sim quero", "tô dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "🔄 Histórico apagado. Pode começar de novo.", "risco": False}

        # Classificação de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se há contexto anterior de confirmação pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no histórico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"⚠️ Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()

# Conteúdo do arquivo: ./nlu/nlu_classifier.py
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparação ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuações básicas (exceto espaços) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaços extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML não encontrados. Usando classificação por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presença de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confiança base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho está contido no texto
                # Usar `in` é simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # Lógica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confiança para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classificação com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pré-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # Não pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confiança={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificação ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confiança.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML não estiver ativo ou como método principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- Método de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF é um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parâmetros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes é um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
# Conteúdo do arquivo: ./nlu/entidade_extractor.py
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÁÉÍÓÚA-Za-záéíóú]+)",
                r"([A-ZÁÉÍÓÚA-Za-záéíóú]+)\s+(?:é meu nome|meu nome é|aqui é)" # Novo padrão
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avô|avó|enteado|enteada)\s+(?:é meu|minha)" # Novo padrão
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-záéíóúãõâêîôûç\s]+)",
                r"(?:cidade de)\s+([A-Za-záéíóúãõâêîôûç\s]+)" # Novo padrão
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrão
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaína)"
            ],
            "recaida": [
                r"(reca[íi]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[íi]da|escorregada)" # Novo padrão
            ],
            # Adicione mais entidades e padrões conforme necessário
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraída: {entidades[entidade]} (Padrão: '{padrao}')")
                    break  # Para na primeira correspondência

        return entidades

# Arquivo: app/apenas_codigos_python.txt
##################################################
########## Path: ./utils/faq_respostas.py
##################################################

# ===========================================================
# Arquivo: utils/faq_respostas.py
# (Baseado no arquivo original fornecido, com chaves normalizadas)
# ===========================================================

# Dicionário com perguntas frequentes e suas respostas.
# As chaves estão em minúsculas e sem acentos/pontuação para facilitar a busca.
FAQ_RESPOSTAS = {
    "dependencia quimica": (
        "Dependência química é uma doença crônica caracterizada pelo uso compulsivo de substâncias, "
        "apesar das consequências negativas, afetando o cérebro e o comportamento."
    ),
    "identificar dependencia": (
        "Sinais comuns incluem: aumento da tolerância (precisar de mais para o mesmo efeito), sintomas de abstinência ao parar/diminuir, "
        "perda de controle sobre o uso, gastar muito tempo obtendo/usando/recuperando-se da substância, "
        "negligência de responsabilidades e continuar usando apesar dos problemas causados."
    ),
    "tipos de internacao": (
        "Existem três tipos principais de internação previstos em lei:\n"
        "1.  **Voluntária:** Quando a própria pessoa busca ajuda e concorda com a internação.\n"
        "2.  **Involuntária:** Solicitada por um familiar ou responsável legal, sem o consentimento da pessoa, mas *obrigatoriamente* com um laudo médico detalhado atestando a necessidade (risco para si ou outros).\n"
        "3.  **Compulsória:** Determinada pela Justiça, geralmente em casos mais complexos e após avaliação médica."
    ),
    "como funciona o tratamento": (
        "O tratamento em uma clínica geralmente é multidisciplinar e inclui:\n"
        "-   **Desintoxicação:** Fase inicial para lidar com a abstinência física, com supervisão médica.\n"
        "-   **Terapias:** Individual e em grupo (como Terapia Cognitivo-Comportamental - TCC, Entrevista Motivacional) para entender as causas, mudar comportamentos e prevenir recaídas.\n"
        "-   **Acompanhamento Médico e Psiquiátrico:** Para tratar a dependência e possíveis outras condições (comorbidades).\n"
        "-   **Grupos de Apoio:** Incentivo à participação em grupos como Narcóticos Anônimos (N.A.) ou Alcoólicos Anônimos (A.A.).\n"
        "-   **Atividades Terapêuticas:** Ocupacionais, físicas, etc., para reestruturação da rotina."
    ),
    "duracao do tratamento": (
        "A duração varia muito. Internações podem durar de 1 a 6 meses, ou até mais, dependendo da gravidade, do tipo de substância e da resposta individual. O tratamento ambulatorial (consultas regulares sem internação) pode ser mais longo. O importante é entender que a recuperação é um processo contínuo, mesmo após a alta."
    ),
    "custo do tratamento": (
        "Os valores de uma internação ou tratamento particular variam bastante dependendo da clínica, estrutura, serviços incluídos, tipo de acomodação e tempo de permanência. Para ter uma proposta adequada ao seu caso, precisamos primeiro entender a situação na consulta inicial de avaliação."
    ),
    "o que fazer se a pessoa nao aceita ajuda": (
        "É um desafio comum e muito difícil para a família. Se a pessoa não reconhece o problema ou recusa ajuda, mas está colocando a si mesma ou outros em risco grave, a internação involuntária pode ser uma opção legal, mas requer um laudo médico detalhado. O primeiro passo é buscar orientação profissional, como na nossa consulta inicial, para avaliar a situação e os caminhos possíveis."
    ),
    "como a familia pode ajudar": (
        "A família é fundamental na recuperação! Algumas formas de ajudar são:\n"
        "-   Buscar conhecimento sobre dependência química para entender a doença.\n"
        "-   Oferecer apoio emocional, mas sem facilitar o uso (evitar acobertar, dar dinheiro que possa ser usado para drogas, etc.).\n"
        "-   Estabelecer limites claros e consistentes.\n"
        "-   Participar de grupos de apoio para familiares (como Al-Anon, Nar-Anon) e/ou terapia familiar.\n"
        "-   Incentivar a busca e a manutenção do tratamento pela pessoa."
    ),
    "o que e caps": (
        "CAPS é a sigla para Centro de Atenção Psicossocial. São unidades públicas do SUS que oferecem atendimento em saúde mental. Existem diferentes tipos, como o CAPS AD, especializado em álcool e outras drogas. O tratamento no CAPS é gratuito e geralmente ambulatorial (a pessoa vai ao centro durante o dia), sendo uma alternativa importante, especialmente quando a internação não é necessária ou viável."
    ),
    "como agendar consulta": (
        "Para agendar a consulta inicial online, que tem o valor de R$100, basta me confirmar seu interesse. Se você confirmar, eu te enviarei um link seguro para realizar o pagamento. Após a confirmação do pagamento, o horário será agendado e você receberá todas as instruções."
    ),
    "qual o preco da consulta": (
        "A consulta inicial de avaliação online tem o valor de R$100. Ela é realizada por um profissional especializado para entender em detalhes a situação, oferecer orientações e, se for o caso, indicar o tratamento mais adequado, seja ele ambulatorial ou internação."
    ),
    "consulta online funciona": (
        "Sim, a consulta online é muito eficaz para a avaliação inicial e orientação. Ela permite que um profissional especializado analise o caso com privacidade e comodidade, entenda a necessidade, forneça direcionamento e, se necessário, um laudo para encaminhamento. Caso uma intervenção presencial seja indicada, como uma internação, o profissional fará essa recomendação durante a consulta."
    )
    # Adicionar mais FAQs conforme necessário
}



########## End Path: ./utils/faq_respostas.py ##########


##################################################
########## Path: ./utils/questionario_pos_pagamento.py
##################################################

# ===========================================================
# Arquivo: utils/questionario_pos_pagamento.py
# ===========================================================
import asyncio
# Ajuste o import se mensageria.py estiver em um diretório diferente
from .mensageria import enviar_mensagem
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Definição das Perguntas ---

# Perguntas Fatuais (Originais ou Adaptadas)
PERGUNTAS_FACTUAIS = [
    "Vamos começar com algumas perguntas rápidas para ajudar nosso médico a entender melhor. Qual o nome completo da pessoa que será avaliada?",
    "Qual a idade aproximada dela?",
    "Qual o seu grau de parentesco com essa pessoa (você é filho(a), esposa(o), irmão(ã), amigo(a), ou a própria pessoa)?",
    "Quais são as principais substâncias que ela está usando atualmente (por exemplo: álcool, cocaína, crack, maconha, medicamentos controlados sem prescrição)?",
    "Há quanto tempo, aproximadamente, esse uso se tornou um problema ou se intensificou?",
    "A pessoa já passou por algum tipo de tratamento para dependência química antes? Se sim, qual(is) e quando?",
    "Além da dependência, existe alguma outra condição de saúde importante, física ou mental (como diabetes, pressão alta, depressão, ansiedade, esquizofrenia), que devemos saber?",
    "Em qual cidade e estado a pessoa se encontra neste momento?"
]

# Perguntas Emocionais (Adicionadas para a Trilha Emocional)
PERGUNTAS_EMOCIONAIS = [
    "Pensando na situação atual, quais são as maiores preocupações ou medos que você (ou a pessoa a ser avaliada, se não for você) tem enfrentado recentemente?",
    "Olhando para frente, o que você (ou a pessoa) mais deseja ou espera alcançar ao buscar ajuda ou iniciar um tratamento?",
    "Em relação aos sentimentos, existe algum que tem sido muito presente ultimamente por causa dessa situação (por exemplo: culpa, vergonha, raiva, medo, frustração, tristeza, mas também esperança ou alívio)?",
    "De que forma você percebe que essa situação tem impactado o dia a dia, o trabalho/estudos e os relacionamentos familiares?"
]

# Combina as perguntas na ordem desejada para o questionário completo
# Pode ajustar a ordem se preferir intercalar fatuais e emocionais
QUESTIONARIO_COMPLETO_POS_PAGAMENTO = PERGUNTAS_FACTUAIS + PERGUNTAS_EMOCIONAIS

# --- Função para Iniciar o Questionário ---

async def iniciar_questionario_pos_pagamento(telefone: str):
    """
    Envia a primeira pergunta do questionário pós-pagamento.
    A lógica de salvar o questionário no contexto e enviar as perguntas
    subsequentes é gerenciada por nlp.py.
    """
    total_perguntas = len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO)
    logging.info(f"QUESTIONARIO: 📋 Preparando para iniciar ({total_perguntas} perguntas) para {telefone}")

    # Verifica se a lista de perguntas não está vazia
    if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
        # Pega a primeira pergunta da lista combinada
        primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
        try:
            # Envia a primeira pergunta para o usuário
            await enviar_mensagem(telefone, primeira_pergunta)
            logging.info(f"QUESTIONARIO: Enviada primeira pergunta para {telefone}.")
            # A continuação do fluxo (salvar contexto, enviar próximas perguntas)
            # será tratada em nlp.py quando a resposta do usuário chegar.
        except Exception as e:
            logging.error(f"QUESTIONARIO: ❌ Erro ao enviar a primeira pergunta para {telefone}: {e}")
            # Considerar o que fazer neste caso: tentar novamente? Notificar? Mudar estado?
    else:
        # Loga um aviso se a lista de perguntas estiver vazia
        logging.warning(f"QUESTIONARIO: ⚠️ Nenhuma pergunta definida. Questionário não iniciado para {telefone}.")



########## End Path: ./utils/questionario_pos_pagamento.py ##########


##################################################
########## Path: ./utils/ollama.py
##################################################

# ===========================================================
# Arquivo: utils/ollama.py
# ===========================================================
import httpx
import logging
import json
import re
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str | None, dict | None, list | None]:
    """
    Chama a API do Ollama com o prompt fornecido.
    Tenta extrair um JSON do final da resposta.

    Args:
        prompt (str): O prompt completo a ser enviado para a IA.
        telefone (str): O número de telefone do usuário (para logging).

    Returns:
        tuple[str | None, dict | None, list | None]:
            - resposta_textual (str | None): A parte textual da resposta da IA.
            - json_extraido (dict | None): O dicionário JSON extraído do final, ou None.
            - tokens (list | None): Informações sobre tokens (se a API retornar, atualmente None).
    """
    # Validação inicial
    if not OLLAMA_API_URL or not OLLAMA_MODEL:
        logging.error("❌ OLLAMA: Configurações (OLLAMA_API_URL ou OLLAMA_MODEL) ausentes.")
        return "⚠️ Desculpe, estou com problemas técnicos para acessar minha inteligência. Tente novamente mais tarde.", None, None

    # Payload para a API do Ollama
    payload = {
        "model": OLLAMA_MODEL, # Modelo configurado
        "prompt": prompt,
        "stream": False, # Não usar streaming para facilitar extração do JSON
        # "options": {"temperature": 0.7} # Exemplo de opções de geração
        # Tenta forçar JSON se o prompt explicitamente pedir (pode ser ajustado)
        "format": "json" if "json" in prompt.lower()[-150:] else None # Verifica só o final do prompt por "json"
    }
    # Remove format se for None para não enviar chave vazia
    if payload["format"] is None:
        del payload["format"]

    headers = {"Content-Type": "application/json"}
    resposta_textual = None
    json_extraido = None
    tokens = None # Placeholder para informações de tokens

    try:
        # Usar httpx para chamadas HTTP assíncronas
        # Timeout aumentado para 45 segundos para dar tempo à IA
        async with httpx.AsyncClient(timeout=45.0) as client:
            logging.info(f"OLLAMA: Enviando prompt (modelo: {OLLAMA_MODEL}) para {telefone}...")
            # Faz a requisição POST para a API do Ollama
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            # Levanta uma exceção para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            dados = response.json()
            logging.info(f"OLLAMA: ✅ Resposta recebida da IA para {telefone}.")
            # logging.debug(f"OLLAMA: Resposta completa: {dados}") # Log detalhado opcional

            # Extrai a resposta principal do JSON retornado pela API
            resposta_bruta = dados.get("response", "").strip()
            # TODO: Extrair informações de tokens se disponíveis em 'dados' (ex: dados.get("eval_count"), etc.)
            # tokens = {"eval_count": dados.get("eval_count"), ...}

            # Verifica se a resposta não está vazia
            if not resposta_bruta:
                logging.warning(f"OLLAMA: ⚠️ Resposta vazia para {telefone}.")
                return None, None, tokens

            # Tenta extrair JSON do final da resposta bruta
            # Primeiro tenta com ```json ... ``` (com ou sem espaço antes do {)
            match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```$", resposta_bruta, re.IGNORECASE | re.DOTALL)
            if not match: # Se não encontrar, tenta apenas com { ... } no final
                 match = re.search(r"(\{[\s\S]*?\})$", resposta_bruta, re.DOTALL)

            if match:
                # Se encontrou um padrão JSON, extrai o conteúdo
                json_str = match.group(1)
                try:
                    # Tenta converter a string JSON em um dicionário Python
                    json_extraido = json.loads(json_str)
                    # Remove a parte JSON (e os ``` se presentes) da resposta textual
                    resposta_textual = resposta_bruta[:match.start()].strip()
                    logging.info(f"OLLAMA: JSON extraído com sucesso para {telefone}.")
                except json.JSONDecodeError as json_err:
                    # Se o JSON for inválido, loga um aviso e trata a resposta inteira como texto
                    logging.warning(f"OLLAMA: ⚠️ JSON inválido no final da resposta para {telefone}: {json_err}. Retornando resposta bruta como textual.")
                    resposta_textual = resposta_bruta
                    json_extraido = None
            else:
                # Se não encontrou JSON no final, toda a resposta é considerada textual
                logging.info(f"OLLAMA: Nenhum JSON encontrado no final da resposta para {telefone}.")
                resposta_textual = resposta_bruta
                json_extraido = None

            # Garante que a resposta textual não seja vazia se o JSON foi extraído com sucesso
            if not resposta_textual and json_extraido is not None:
                 resposta_textual = "Ok." # Retorna um texto mínimo

            return resposta_textual, json_extraido, tokens

    # Tratamento de exceções específicas do httpx e genéricas
    except httpx.TimeoutException as e:
        logging.error(f"OLLAMA: ❌ Erro: Timeout ao chamar para {telefone} ({str(e)})")
        # Retorna uma mensagem de erro amigável para o usuário
        return "⚠️ Desculpe, demorei muito para pensar. Poderia tentar de novo?", None, None
    except httpx.HTTPStatusError as e:
        # Loga o erro HTTP e retorna mensagem de erro
        logging.error(f"OLLAMA: ❌ Erro HTTP {e.response.status_code} para {telefone}: {e.response.text}")
        return f"⚠️ Ocorreu um erro de comunicação com a inteligência artificial ({e.response.status_code}). Por favor, tente mais tarde.", None, None
    except Exception as e:
        # Loga qualquer outro erro inesperado
        logging.exception(f"OLLAMA: ❌ Erro desconhecido ao chamar para {telefone}:")
        return "⚠️ Ocorreu um erro inesperado ao processar sua solicitação. Tente novamente mais tarde.", None, None



########## End Path: ./utils/ollama.py ##########


##################################################
########## Path: ./utils/prompt_builder.py
##################################################

import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura – certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"❌ ERRO ao carregar prompt mestre: {e}")
        return (
            "Você é um assistente virtual especializado em saúde mental e dependência química. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usuário: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"❌ ERRO ao buscar histórico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histórico."
    else:
        trecho_historico = "Histórico indisponível (sem conexão DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Histórico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usuário:
{pergunta_atual.strip()}
---
Instruções para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no máximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construído para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final


########## End Path: ./utils/prompt_builder.py ##########


##################################################
########## Path: ./utils/mensageria.py
##################################################

# ===========================================================
# Arquivo: utils/mensageria.py
# Envio robusto de mensagens via WhatsApp Cloud API
# ===========================================================
from __future__ import annotations

import httpx
import logging
from typing import Any, Dict
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN

logger = logging.getLogger("famdomes.mensageria")

HEADERS = {
    "Authorization": f"Bearer {WHATSAPP_TOKEN}",
    "Content-Type": "application/json",
}
TIMEOUT = httpx.Timeout(timeout=20.0, connect=5.0)


async def enviar_mensagem(telefone: str, mensagem: str) -> Dict[str, Any]:
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logger.error("❌ MENSAGERIA: API URL ou Token não configurados.")
        return {"status": "erro_config", "erro": "WhatsApp API não configurada"}

    if not telefone or not mensagem:
        logger.warning("⚠️ MENSAGERIA: Telefone ou mensagem vazios.")
        return {"status": "erro_input", "erro": "Telefone ou mensagem ausente"}

    payload: Dict[str, Any] = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem},
    }

    try:
        url = str(WHATSAPP_API_URL)  # 🔧 cast definitivo
        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            resp = await client.post(url, json=payload, headers=HEADERS)
            resp.raise_for_status()

        logger.info("✅ Mensagem enviada a %s (HTTP %s)", telefone, resp.status_code)
        return {"status": "enviado", "code": resp.status_code, "retorno": resp.json()}

    except httpx.HTTPStatusError as exc:
        logger.error("❌ WHATSAPP %s – %s", exc.response.status_code, exc.response.text)
        return {"status": "erro_api", "code": exc.response.status_code, "erro": exc.response.text}
    except httpx.TimeoutException as exc:
        logger.error("⏰ Timeout WhatsApp: %s", exc)
        return {"status": "erro_timeout", "erro": str(exc)}
    except httpx.RequestError as exc:
        logger.error("🌐 Erro de conexão WhatsApp: %s", exc)
        return {"status": "erro_conexao", "erro": str(exc)}
    except Exception as exc:  # pragma: no cover
        logger.exception("💥 Erro inesperado WhatsApp: %s", exc)
        return {"status": "erro_desconhecido", "erro": str(exc)}


########## End Path: ./utils/mensageria.py ##########


##################################################
########## Path: ./utils/contexto.py
##################################################

# ===========================================================
# Arquivo: utils/contexto.py
# Persiste contexto de conversa + histórico da IA no MongoDB
# ===========================================================
from __future__ import annotations

import logging
from datetime import datetime, timezone
from pymongo import MongoClient, ASCENDING
from app.config import MONGO_URI

logger = logging.getLogger("famdomes.contexto")

# ----------------------------------------------------------------------
# Conexão e índices
mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
contextos_db = db["contextos"]          # estado por telefone
respostas_ia_db = db["respostas_ia"]    # log IA

try:
    contextos_db.create_index("tel", unique=True, background=True)
    respostas_ia_db.create_index("telefone", background=True)
    respostas_ia_db.create_index([("criado_em", ASCENDING)], background=True)
except Exception:
    pass  # índices já existem

# ----------------------------------------------------------------------
def salvar_contexto(
    telefone: str,
    texto: str | None = None,
    novo_estado: str | None = None,
    meta_conversa: dict | None = None,
    trilha_cursor: dict | None = None,
    ultimo_texto_bot: str | None = None,
) -> None:
    """
    Atualiza (ou cria) o documento de contexto do telefone.
    Campos são opcionais; somente os passados são alterados.
    """
    set_fields: dict = {"ts": datetime.now(timezone.utc)}

    if texto is not None:
        set_fields["ultimo_texto"] = texto
    if novo_estado is not None:
        set_fields["estado"] = novo_estado
    if meta_conversa is not None:
        set_fields["meta_conversa"] = meta_conversa
    if trilha_cursor is not None:
        set_fields["trilha_cursor"] = trilha_cursor
    if ultimo_texto_bot is not None:
        set_fields["ultimo_texto_bot"] = ultimo_texto_bot

    contextos_db.update_one(
        {"tel": telefone},
        {"$set": set_fields, "$inc": {"interacoes": 1}},
        upsert=True,
    )
    logger.debug("Contexto salvo %s – %s", telefone, novo_estado or "(estado inalterado)")

# ----------------------------------------------------------------------
def obter_contexto(telefone: str) -> dict:
    """
    Recupera o contexto atual. Garante chaves mínimas.
    """
    doc = contextos_db.find_one({"tel": telefone}, {"_id": 0}) or {}
    doc.setdefault("estado", "INICIAL")
    doc.setdefault("meta_conversa", {})
    return doc

# ----------------------------------------------------------------------
def salvar_resposta_ia(
    telefone: str,
    canal: str,
    mensagem_usuario: str,
    resposta_gerada: str,
    intent: str,
    entidades: dict,
    risco: bool,
    sentimento: str | None = None,
) -> None:
    """
    Grava no histórico cada interação envolvendo IA.
    """
    try:
        respostas_ia_db.insert_one(
            {
                "telefone": telefone,
                "canal": canal,
                "mensagem_usuario": mensagem_usuario,
                "resposta_gerada": resposta_gerada,
                "intent": intent,
                "entidades": entidades or {},
                "risco": bool(risco),
                "sentimento_detectado": sentimento,
                "criado_em": datetime.utcnow(),
            }
        )
    except Exception as exc:
        logger.exception("Falha ao salvar resposta IA para %s: %s", telefone, exc)

# ----------------------------------------------------------------------
def limpar_contexto(telefone: str) -> bool:
    """
    Remove contexto e histórico IA de um telefone.
    Retorna True se algo foi apagado.
    """
    ctx_del = contextos_db.delete_one({"tel": telefone}).deleted_count
    hist_del = respostas_ia_db.delete_many({"telefone": telefone}).deleted_count
    return bool(ctx_del or hist_del)


########## End Path: ./utils/contexto.py ##########


##################################################
########## Path: ./utils/offnlp.py
##################################################

# ===========================================================
# Arquivo: utils/nlp.py
# (v7 - Implementada a nova estratégia de fluxo inicial)
# ===========================================================
import logging
import json
import re
import os # Importado para carregar prompt
from datetime import datetime

# Ajuste os imports conforme a estrutura do seu projeto
from app.utils.ollama import chamar_ollama
# Acesso direto às variáveis globais de contexto.py para DB
from app.utils.contexto import (
    obter_contexto, salvar_contexto, salvar_resposta_ia,
    respostas_ia_db # Acesso à coleção do histórico
)
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.utils.risco import analisar_risco
from app.routes.ia import processar_comando # Para ações como agendar
from app.config import (
    WHATSAPP_FAMILIAR, BASE_DIR, # Importa o número para notificação e diretório base
    ROCKETCHAT_URL, ROCKETCHAT_TOKEN, ROCKETCHAT_USER_ID, # Configs para RocketChat
    OLLAMA_API_URL # Necessário para checar se Ollama está configurado
)
from app.utils.mensageria import enviar_mensagem # Para enviar notificações
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO # Importa a lista correta
import httpx # Para notificação RocketChat

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes e Textos Padrão ---
# MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Nova versão da estratégia
MENSAGEM_INICIAL = '''🧠 Olá! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Mantendo a original por enquanto, ajustar se necessário
# Mensagem combinada (Validação + Emocional + Qualificação) - A validação será adicionada dinamicamente
PERGUNTA_COMBINADA_TEMPLATE = "Como você está se sentindo com toda essa situação neste momento? E só para eu direcionar melhor, a ajuda que você busca é para você mesmo ou para outra pessoa (ex: filho, esposa, irmão)?"
RESPOSTA_EXPLICACAO_CONSULTA = '''👨‍⚕️ A consulta médica do FAMDOMES é online, com um profissional que entende profundamente casos de dependência química e sofrimento familiar.

📌 Ela serve para avaliar a situação, oferecer um laudo se necessário, orientar o melhor caminho e — se for o caso — encaminhar para uma clínica parceira com segurança e sigilo.

💳 O valor é R$100 e pode ser pago online de forma rápida.

Posso te enviar o link para agendar agora?'''
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informações, elas são muito importantes para a consulta."
MENSAGEM_ERRO_PADRAO = "🤖 Desculpe, não consegui processar sua mensagem agora. Poderia tentar novamente ou reformular?"
MENSAGEM_ERRO_IA = "🤖 Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
MENSAGEM_RISCO_DIRECIONAMENTO = "Percebi que você pode estar passando por um momento muito difícil. Se precisar de ajuda urgente, ligue para o CVV (188) ou SAMU (192). Não hesite em buscar apoio."
MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO = "Entendido. Já notifiquei nossa equipe. Alguém entrará em contato com você por aqui assim que possível."

RESPOSTAS_AFIRMATIVAS = ["sim", "claro", "quero", "vamos", "ok", "pode ser", "tá bom", "aceito", "sim por favor", "sim quero", "com certeza", "tô dentro", "pode sim", "por favor", "gostaria", "desejo"]
RESPOSTAS_NEGATIVAS = ["não", "nao", "agora não", "talvez depois", "ainda não", "obrigado não", "não quero", "nao quero"]
PALAVRAS_CHAVE_HUMANO = ["humano", "atendente", "pessoa", "falar com alguem", "alguém", "falar com um especialista", "falar com vc", "falar contigo"]
# ----------------------------------

# --- Funções Auxiliares Implementadas ---

async def analisar_sentimento(texto: str, telefone: str) -> str | None:
    """
    [Trilha Emocional] Analisa o sentimento do texto usando Ollama.
    Retorna 'positivo', 'negativo', 'neutro' ou None em caso de erro.
    """
    if not OLLAMA_API_URL:
        logging.warning("NLP: Análise de sentimento pulada - OLLAMA_API_URL não configurado.")
        return "neutro"

    logging.info(f"NLP: [Trilha Emocional] Analisando sentimento para {telefone}: '{texto[:30]}...'")
    prompt_sentimento = f"""
    Analise o sentimento predominante na seguinte mensagem do usuário.
    Responda APENAS com uma das seguintes palavras: 'positivo', 'negativo', 'neutro'.

    Mensagem: "{texto}"

    Sentimento:"""
    try:
        resposta_txt, _, _ = await chamar_ollama(prompt_sentimento, telefone)
        if resposta_txt:
            sentimento_retornado = resposta_txt.strip().lower().replace(".", "")
            if sentimento_retornado in ["positivo", "negativo", "neutro"]:
                logging.info(f"NLP: Sentimento detectado pela IA para {telefone}: {sentimento_retornado}")
                return sentimento_retornado
            else:
                logging.warning(f"NLP: Sentimento retornado pela IA não reconhecido ('{sentimento_retornado}'). Usando 'neutro'.")
                return "neutro"
        else:
            logging.warning(f"NLP: IA não retornou resposta para análise de sentimento de {telefone}. Usando 'neutro'.")
            return "neutro"
    except Exception as e:
        logging.error(f"NLP: Erro ao chamar IA para análise de sentimento de {telefone}: {e}")
        return None

async def buscar_historico_formatado(telefone: str, limite: int = 5) -> str:
     """ Busca e formata o histórico recente do MongoDB para o prompt da IA. """
     if respostas_ia_db is None:
         logging.warning(f"NLP: Histórico indisponível para {telefone} (DB não conectado).")
         return "Histórico indisponível (DB não conectado)."
     logging.debug(f"NLP: Buscando histórico para {telefone} (limite: {limite})")
     try:
         historico_cursor = respostas_ia_db.find(
             {"telefone": telefone},
             {"mensagem_usuario": 1, "resposta_gerada": 1, "_id": 0}
         ).sort("criado_em", -1).limit(limite)
         historico_lista = list(historico_cursor)
         historico_lista.reverse()
         if not historico_lista:
             return "Nenhuma conversa anterior registrada."
         historico_formatado = ""
         for item in historico_lista:
             if msg_usr := item.get("mensagem_usuario"):
                 historico_formatado += f"Usuário: {msg_usr}\n"
             if msg_bot := item.get("resposta_gerada"):
                 if len(msg_bot) > 150:
                      msg_bot = msg_bot[:150] + "..."
                 historico_formatado += f"Assistente: {msg_bot}\n"
         return historico_formatado.strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao buscar histórico para {telefone}: {e}")
         return "Erro ao carregar histórico."

async def construir_prompt_para_ia(telefone: str, pergunta_atual: str, estado: str, meta_conversa: dict) -> str:
     """
     Constrói o prompt para o Ollama, incorporando estado, histórico e contexto emocional.
     Carrega o prompt mestre do arquivo PROMPT_MESTRE.txt.
     """
     historico_recente_formatado = await buscar_historico_formatado(telefone)
     sentimento_anterior = meta_conversa.get("ultimo_sentimento_detectado", None)
     prompt_mestre_path = os.path.join(BASE_DIR, "PROMPT_MESTRE.txt")
     try:
         with open(prompt_mestre_path, "r", encoding="utf-8") as f:
             PROMPT_MESTRE = f.read().strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao carregar prompt mestre de {prompt_mestre_path}: {e}. Usando prompt padrão.")
         PROMPT_MESTRE = """Você é Domo, um assistente virtual empático da FAMDOMES. Responda com clareza e empatia."""

     meta_filtrada = {
         k: v for k, v in meta_conversa.items()
         if k not in ['questionario_completo', 'historico_recente_formatado'] and not k.startswith('sentimento_q')
     }

     prompt_final = f"""{PROMPT_MESTRE}

     ---
     Contexto da Conversa Atual:
     Telefone: {telefone}
     Estado da Conversa: {estado}
     Sentimento Percebido na Última Interação: {sentimento_anterior or 'N/A'}
     Dados Conhecidos (meta_conversa): {json.dumps(meta_filtrada, indent=2, ensure_ascii=False, default=str)}
     ---
     Histórico Recente da Conversa:
     {historico_recente_formatado}
     ---
     Nova Mensagem do Usuário:
     {pergunta_atual.strip()}
     ---
     Instruções para sua Resposta OBRIGATÓRIAS:
     1. Analise a 'Nova Mensagem do Usuário' considerando o 'Contexto da Conversa Atual'.
     2. Responda em português brasileiro, de forma EMPÁTICA e ACOLHEDORA, especialmente se o sentimento detectado for negativo.
     3. Mantenha o foco nos serviços da FAMDOMES (consulta, tratamento de dependência química).
     4. Siga o fluxo indicado pelo 'Estado da Conversa'. Se for 'SUPORTE_FAQ', responda a dúvida. Se for 'AGUARDANDO_RESPOSTA_QUALIFICACAO', processe a resposta e siga para explicar a consulta ou responder dúvidas. Se for outro estado, guie o usuário para o próximo passo lógico.
     5. Use no máximo 400 caracteres na sua resposta textual.
     6. AO FINAL DA SUA RESPOSTA DE TEXTO, inclua OBRIGATORIAMENTE um JSON VÁLIDO contendo:
        - "intent": A intenção principal que você identificou na mensagem do usuário (ex: "duvida_preco", "confirmou_agendamento", "relato_sentimento", "pergunta_tratamento", "resposta_qualificacao", "desconhecida").
        - "sentimento_detectado": O sentimento predominante na mensagem do usuário (ex: "positivo", "negativo", "neutro", "ansioso", "esperançoso", "frustrado", "confuso").
        - "entidades": Um dicionário com quaisquer entidades relevantes extraídas (ex: {{"nome_paciente": "Carlos", "substancia": "álcool", "para_quem": "filho"}}). Se não houver, use {{}}.
     Exemplo de JSON OBRIGATÓRIO no final:
     ```json
     {{"intent": "duvida_preco", "sentimento_detectado": "ansioso", "entidades": {{}} }}
     ```
     Outro Exemplo:
     ```json
     {{"intent": "resposta_qualificacao", "sentimento_detectado": "negativo", "entidades": {{"para_quem": "filho"}} }}
     ```
     ---
     Assistente (responda aqui e adicione o JSON obrigatório no final):"""
     logging.info(f"NLP: Prompt construído para {telefone} (Estado: {estado}). Tamanho: {len(prompt_final)} chars.")
     return prompt_final

async def notificar_risco(telefone: str, mensagem: str, analise: dict):
    """ Envia notificação de risco para o número configurado. """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    alerta = f"⚠️ ALERTA DE RISCO ({timestamp}) ⚠️\n\nTelefone: {telefone}\nMensagem: \"{mensagem}\"\nAnálise: {analise}\n\nRevisão humana URGENTE necessária."
    logging.warning(f"NLP: Enviando alerta de risco para {WHATSAPP_FAMILIAR}...")
    if WHATSAPP_FAMILIAR:
        try:
            resultado_envio = await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)
            if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                 logging.info(f"NLP: ✅ Alerta de risco enviado com sucesso para {WHATSAPP_FAMILIAR}.")
            else:
                 logging.error(f"NLP: ❌ Falha ao enviar alerta de risco para {WHATSAPP_FAMILIAR}: {resultado_envio.get('erro', resultado_envio)}")
        except Exception as e:
            logging.error(f"NLP: ❌ Exceção ao tentar enviar alerta de risco: {e}")
    else:
        logging.warning("NLP: WHATSAPP_FAMILIAR não configurado. Não foi possível enviar alerta de risco.")

async def notificar_escalacao_humana(telefone: str, contexto: dict):
    """ Envia notificação para a equipe sobre pedido de atendente humano via RocketChat. """
    if not ROCKETCHAT_URL or not ROCKETCHAT_TOKEN or not ROCKETCHAT_USER_ID:
        logging.error("NLP: ❌ Configurações do RocketChat incompletas. Não é possível notificar a equipe.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    estado_anterior = contexto.get("estado", "N/A")
    nome_contato = contexto.get("meta_conversa", {}).get("nome_paciente", contexto.get("nome", "Desconhecido"))
    respostas_recentes = {k: v for k, v in contexto.get('meta_conversa', {}).items() if k.startswith('resposta_q')}
    contexto_resumido = json.dumps(respostas_recentes, indent=2, ensure_ascii=False, default=str)
    if len(contexto_resumido) > 1000:
        contexto_resumido = contexto_resumido[:1000] + "\n... (truncado)"

    mensagem_notificacao = (
        f"🙋 **Pedido de Atendimento Humano** ({timestamp}) 🙋\n\n"
        f"**Telefone:** {telefone}\n"
        f"**Nome Contato:** {nome_contato}\n"
        f"**Estado Anterior:** {estado_anterior}\n\n"
        f"**Últimas Respostas (Questionário/Meta):**\n"
        f"```json\n{contexto_resumido}\n```\n\n"
        f"Por favor, assumir a conversa."
    )
    logging.warning(f"NLP: 🙋 PEDIDO HUMANO ({timestamp}) - Telefone: {telefone} | Notificando equipe via RocketChat...")

    headers = {
        "X-Auth-Token": ROCKETCHAT_TOKEN,
        "X-User-Id": ROCKETCHAT_USER_ID,
        "Content-Type": "application/json"
    }
    room_id_destino = os.getenv("ROCKETCHAT_ROOM_ID_SUPORTE", "GENERAL")
    payload = {"message": {"rid": room_id_destino, "msg": mensagem_notificacao}}
    post_message_url = f"{ROCKETCHAT_URL}/api/v1/chat.postMessage"

    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            response = await client.post(post_message_url, headers=headers, json=payload)
            response.raise_for_status()
            resposta_api = response.json()
            if resposta_api.get("success"):
                logging.info(f"NLP: ✅ Notificação de escalação enviada com sucesso para RocketChat (Sala: {room_id_destino}).")
            else:
                logging.error(f"NLP: ❌ Falha ao enviar notificação para RocketChat (Sala: {room_id_destino}). Resposta API: {resposta_api}")
    except httpx.HTTPStatusError as e:
        logging.error(f"NLP: ❌ Erro HTTP {e.response.status_code} ao enviar para RocketChat: {e.response.text}")
    except httpx.RequestError as e:
        logging.error(f"NLP: ❌ Erro de conexão ao enviar para RocketChat: {e}")
    except Exception as e:
        logging.exception("NLP: ❌ Erro inesperado ao enviar notificação para RocketChat:")


# --- Função Principal de Processamento ---

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    """
    Processa a mensagem do usuário com base no estado atual da conversa,
    realiza análise de sentimento/risco, atualiza o estado e retorna a resposta.
    """
    global meta_conversa
    logging.info(f"NLP: 🔄 Processando mensagem de {telefone}...")
    contexto = obter_contexto(telefone)
    estado_atual = contexto.get("estado", "INICIAL")
    meta_conversa = contexto.get("meta_conversa", {})
    texto_mensagem = mensagem.strip()
    texto_lower = texto_mensagem.lower()

    if not isinstance(meta_conversa, dict):
        logging.warning(f"NLP: Meta conversa para {telefone} não era um dicionário. Resetando para {{}}.")
        meta_conversa = {}

    logging.info(f"NLP: 📞 Telefone: {telefone} | Estado Atual: {estado_atual} | Mensagem: '{texto_mensagem[:50]}...'")

    # --- 1. Análise de Risco ---
    analise_risco_resultado = analisar_risco(texto_mensagem)
    risco_detectado = analise_risco_resultado.get("risco_vida") or analise_risco_resultado.get("urgencia_medica")

    if risco_detectado:
        logging.warning(f"NLP: 🚨 RISCO DETECTADO para {telefone}! Análise: {analise_risco_resultado}")
        novo_estado = "RISCO_DETECTADO"
        resposta_final = MENSAGEM_RISCO_DIRECIONAMENTO
        meta_conversa["ultimo_risco"] = datetime.utcnow().isoformat()
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "risco_detectado", meta_conversa, True, None)
        await notificar_risco(telefone, texto_mensagem, analise_risco_resultado)
        return {"resposta": resposta_final, "estado": novo_estado}

    # --- 2. Verificação de Comandos Especiais ---
    if texto_lower == "melancia vermelha":
        logging.info(f"NLP: Comando 'melancia vermelha' recebido de {telefone}. Resetando contexto.")
        limpar_contexto(telefone)
        resposta_final = MENSAGEM_INICIAL # Envia apenas a saudação inicial após reset
        novo_estado = "IDENTIFICANDO_NECESSIDADE" # Espera a primeira resposta do usuário
        intent = "reset_comando_e_inicio"
        meta_conversa = {}
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": {}})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, {}, False, None)
        return {"resposta": resposta_final, "estado": novo_estado}

    if any(palavra in texto_lower for palavra in PALAVRAS_CHAVE_HUMANO):
         logging.info(f"NLP: Pedido de atendente humano detectado para {telefone}.")
         estado_antes_pedido = estado_atual
         novo_estado = "AGUARDANDO_ATENDENTE"
         resposta_final = MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO
         contexto_para_notificacao = contexto.copy()
         contexto_para_notificacao["estado"] = estado_antes_pedido
         salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
         salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "pedido_humano", meta_conversa, False, None)
         await notificar_escalacao_humana(telefone, contexto_para_notificacao)
         return {"resposta": resposta_final, "estado": novo_estado}

    # --- 3. Lógica Baseada no Estado Atual ---
    resposta_final = MENSAGEM_ERRO_PADRAO
    novo_estado = estado_atual
    intent = "desconhecida"
    entidades = {}
    sentimento = await analisar_sentimento(texto_mensagem, telefone)
    if meta_conversa is not None:
        meta_conversa["ultimo_sentimento_detectado"] = sentimento
    else:
        meta_conversa = {"ultimo_sentimento_detectado": sentimento}

    try:
        # Lógica para estado INICIAL (Bot acabou de enviar a saudação)
        # Não deveria receber mensagem do usuário neste estado, mas por segurança:
        if estado_atual == "INICIAL":
            logging.warning(f"NLP: Mensagem recebida no estado INICIAL de {telefone}. Tratando como IDENTIFICANDO_NECESSIDADE.")
            estado_atual = "IDENTIFICANDO_NECESSIDADE" # Força a transição

        # Lógica para IDENTIFICANDO_NECESSIDADE (Usuário respondeu à saudação inicial)
        if estado_atual == "IDENTIFICANDO_NECESSIDADE":
            # Validação simples (pode ser melhorada com IA se necessário)
            validacao = "Entendi. " # Validação genérica inicial
            if sentimento == "negativo":
                validacao = "Sinto muito que esteja se sentindo assim. "
            elif sentimento == "positivo":
                 validacao = "Que bom ouvir isso. "

            # Constrói a pergunta combinada
            resposta_final = validacao + PERGUNTA_COMBINADA_TEMPLATE
            novo_estado = "AGUARDANDO_RESPOSTA_QUALIFICACAO"
            intent = "primeira_resposta_usuario" # Intent da mensagem recebida (pode ser refinado)

        # Lógica para AGUARDANDO_RESPOSTA_QUALIFICACAO (Usuário respondeu à pergunta combinada)
        elif estado_atual == "AGUARDANDO_RESPOSTA_QUALIFICACAO":
            logging.info(f"NLP: Processando resposta de qualificação de {telefone}.")
            meta_conversa["sentimento_resposta_qualificacao"] = sentimento
            # Tenta extrair para quem é a ajuda usando IA ou regras simples
            # Exemplo com regras simples (melhorar com IA/extração de entidades no prompt)
            para_quem = "desconhecido"
            if "filho" in texto_lower or "filha" in texto_lower:
                para_quem = "filho(a)"
            elif "esposo" in texto_lower or "marido" in texto_lower:
                para_quem = "esposo"
            elif "esposa" in texto_lower or "mulher" in texto_lower:
                 para_quem = "esposa"
            elif "irmão" in texto_lower or "irma" in texto_lower:
                 para_quem = "irmao(a)"
            elif "amigo" in texto_lower or "amiga" in texto_lower:
                 para_quem = "amigo(a)"
            elif "para mim" in texto_lower or "eu mesmo" in texto_lower or "pra mim" in texto_lower:
                 para_quem = "proprio_usuario"
            meta_conversa["para_quem"] = para_quem
            entidades["para_quem"] = para_quem # Salva entidade específica desta interação

            # Validação da resposta emocional
            agradecimento = "Obrigado por compartilhar." if sentimento != "negativo" else "Agradeço a confiança em compartilhar."

            # Decide o próximo passo
            # Se perguntou preço especificamente, responde primeiro
            if "preço" in texto_lower or "valor" in texto_lower or "custo" in texto_lower:
                 resposta_final = f"{agradecimento} A consulta inicial online tem o valor de R$100. Ela é importante para avaliar o caso e definir o melhor caminho. Gostaria que eu explicasse mais sobre como ela funciona?"
                 novo_estado = "SUPORTE_FAQ" # Fica em suporte após responder preço
                 intent = "resposta_qualificacao_com_preco"
            else:
                 # Se não pediu preço, explica a consulta
                 if para_quem != "desconhecido" and para_quem != "proprio_usuario":
                      resposta_final = f"{agradecimento} Entendi que a busca é para {para_quem}. Para esses casos, o primeiro passo recomendado é a nossa consulta inicial online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 else: # Se for para o próprio usuário ou desconhecido
                      resposta_final = f"{agradecimento} Sabendo que a ajuda é para você (ou se ainda não tiver certeza, a consulta ajuda a definir), o caminho inicial que oferecemos é a consulta de avaliação online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 novo_estado = "EXPLICANDO_CONSULTA"
                 intent = "resposta_qualificacao_segue_fluxo"


        # Lógica para EXPLICANDO_CONSULTA (Usuário respondeu à explicação da consulta)
        elif estado_atual == "EXPLICANDO_CONSULTA":
             if texto_lower in RESPOSTAS_AFIRMATIVAS:
                 logging.info(f"NLP: Usuário {telefone} confirmou interesse em agendar.")
                 meta_conversa["sentimento_confirmacao_agendamento"] = sentimento
                 try:
                     nome_cliente = contexto.get("nome", meta_conversa.get("nome_paciente", "Cliente"))
                     resultado_comando = await processar_comando({
                         "telefone": telefone,
                         "nome": nome_cliente,
                         "comando": "quero agendar"
                     })
                     resposta_final = resultado_comando.get("mensagem", "Link para pagamento enviado!")
                     if resultado_comando.get("status") == "link_gerado":
                          novo_estado = "AGUARDANDO_PAGAMENTO"
                          intent = "confirmou_agendamento"
                     else:
                          resposta_final = resultado_comando.get("mensagem", MENSAGEM_ERRO_PADRAO)
                          novo_estado = "EXPLICANDO_CONSULTA"
                          intent = "erro_gerar_link"
                 except Exception as e:
                     logging.error(f"NLP: Erro ao processar comando 'quero agendar' para {telefone}: {e}")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     novo_estado = "EXPLICANDO_CONSULTA"
                     intent = "erro_processar_comando"

             elif texto_lower in RESPOSTAS_NEGATIVAS:
                 logging.info(f"NLP: Usuário {telefone} recusou o agendamento por enquanto.")
                 meta_conversa["sentimento_recusa_agendamento"] = sentimento
                 resposta_final = "Entendido. Sem problemas. Se mudar de ideia ou tiver mais alguma dúvida, estou à disposição!"
                 novo_estado = "SUPORTE_FAQ"
                 intent = "recusou_agendamento"
             else:
                 logging.info(f"NLP: Resposta não conclusiva em EXPLICANDO_CONSULTA para {telefone}. Usando IA.")
                 novo_estado = "SUPORTE_FAQ"
                 # IA será chamada no fallback

        # Lógica para AGUARDANDO_PAGAMENTO
        elif estado_atual == "AGUARDANDO_PAGAMENTO":
             logging.info(f"NLP: Mensagem recebida de {telefone} enquanto aguarda pagamento. Encaminhando para IA.")
             resposta_final = "Recebi sua mensagem enquanto aguardo a confirmação do pagamento. Se tiver alguma dúvida sobre o processo ou outra questão, pode perguntar."
             novo_estado = "SUPORTE_FAQ"
             # IA será chamada no fallback

        # Lógica para CONFIRMANDO_AGENDAMENTO
        elif estado_atual == "CONFIRMANDO_AGENDAMENTO":
             logging.info(f"NLP: Iniciando questionário pós-pagamento para {telefone}")
             meta_conversa["questionario_completo"] = QUESTIONARIO_COMPLETO_POS_PAGAMENTO
             meta_conversa["num_pergunta_atual"] = 0
             if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 proxima_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta_final = proxima_pergunta
                 novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                 intent = "iniciou_questionario"
                 salvar_contexto(telefone, {
                     "estado": novo_estado,
                     "meta_conversa": meta_conversa,
                     "ultima_resposta_bot": resposta_final
                 })
                 salvar_resposta_ia(telefone, canal, "Sistema: Iniciou Questionário", resposta_final, intent, meta_conversa, False, None)
                 return {"resposta": resposta_final, "estado": novo_estado}
             else:
                 logging.warning(f"NLP: Questionário pós-pagamento vazio para {telefone}. Finalizando onboarding.")
                 resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                 novo_estado = "FINALIZANDO_ONBOARDING"
                 intent = "questionario_vazio"


        # Lógica para COLETANDO_RESPOSTA_QUESTIONARIO
        elif estado_atual == "COLETANDO_RESPOSTA_QUESTIONARIO":
             num_pergunta_respondida_idx = meta_conversa.get("num_pergunta_atual", 0)
             perguntas_questionario = meta_conversa.get("questionario_completo", [])

             if not isinstance(perguntas_questionario, list):
                 logging.error(f"NLP: Erro: 'questionario_completo' não é uma lista no contexto de {telefone}")
                 perguntas_questionario = []

             if num_pergunta_respondida_idx < len(perguntas_questionario):
                 pergunta_respondida_texto = perguntas_questionario[num_pergunta_respondida_idx]
                 chave_resposta = f"resposta_q{num_pergunta_respondida_idx+1}"
                 chave_sentimento = f"sentimento_q{num_pergunta_respondida_idx+1}"
                 meta_conversa[chave_resposta] = texto_mensagem
                 meta_conversa[chave_sentimento] = sentimento
                 logging.info(f"NLP: Resposta Q{num_pergunta_respondida_idx+1} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}. Sentimento: {sentimento}")

                 num_proxima_pergunta_idx = num_pergunta_respondida_idx + 1
                 meta_conversa["num_pergunta_atual"] = num_proxima_pergunta_idx

                 if num_proxima_pergunta_idx < len(perguntas_questionario):
                     proxima_pergunta_texto = perguntas_questionario[num_proxima_pergunta_idx]
                     resposta_final = proxima_pergunta_texto
                     novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                     intent = f"respondeu_questionario_{num_pergunta_respondida_idx+1}"
                 else:
                     resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                     novo_estado = "FINALIZANDO_ONBOARDING"
                     intent = "finalizou_questionario"
                     meta_conversa.pop("num_pergunta_atual", None)
                     meta_conversa.pop("questionario_completo", None)
                     logging.info(f"NLP: Questionário finalizado para {telefone}.")
             else:
                 logging.error(f"NLP: Erro de lógica no questionário para {telefone}. Estado: {estado_atual}, Contador: {num_pergunta_respondida_idx}, Total Perguntas: {len(perguntas_questionario)}")
                 resposta_final = MENSAGEM_ERRO_PADRAO
                 novo_estado = "SUPORTE_FAQ"
                 intent = "erro_logica_questionario"


        # --- 4. Fallback com IA ---
        if novo_estado == estado_atual and estado_atual not in ["RISCO_DETECTADO", "AGUARDANDO_ATENDENTE", "FINALIZANDO_ONBOARDING", "CONFIRMANDO_AGENDAMENTO"]:
            logging.info(f"NLP: Nenhuma regra específica tratou a mensagem de {telefone} no estado {estado_atual}. Usando IA como fallback.")

            faq_key_norm = texto_lower.replace("?", "").replace(".", "").replace("!", "").strip()
            matched_faq_key = None
            if faq_key_norm in FAQ_RESPOSTAS:
                matched_faq_key = faq_key_norm
            else:
                for key in FAQ_RESPOSTAS:
                    if key in faq_key_norm:
                        matched_faq_key = key
                        break

            if matched_faq_key:
                 logging.info(f"NLP: Respondendo com FAQ para chave: {matched_faq_key}")
                 resposta_final = FAQ_RESPOSTAS[matched_faq_key]
                 novo_estado = "SUPORTE_FAQ"
                 intent = f"faq_{matched_faq_key.replace(' ', '_')}"
            else:
                 if not OLLAMA_API_URL:
                     logging.error("NLP: ❌ Fallback para IA falhou - OLLAMA_API_URL não configurado.")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     intent = "erro_config_ia"
                     novo_estado = "SUPORTE_FAQ"
                 else:
                     logging.info(f"NLP: Chamando Ollama para {telefone}...")
                     prompt = await construir_prompt_para_ia(telefone, texto_mensagem, estado_atual, meta_conversa)
                     resposta_textual_ia, json_extraido_ia, tokens_ollama = await chamar_ollama(prompt, telefone)

                     if resposta_textual_ia is None or "⚠️" in resposta_textual_ia:
                         resposta_final = resposta_textual_ia or MENSAGEM_ERRO_IA
                         intent = "erro_ia_fallback"
                         novo_estado = "SUPORTE_FAQ"
                     else:
                         resposta_final = resposta_textual_ia

                         if json_extraido_ia and isinstance(json_extraido_ia, dict):
                             logging.info(f"NLP: JSON extraído da IA: {json_extraido_ia}")
                             intent = json_extraido_ia.get("intent", "ia_generica")
                             entidades_ia = json_extraido_ia.get("entidades", {})
                             if isinstance(entidades_ia, dict):
                                  meta_conversa = atualizar_meta_conversa(meta_conversa, entidades_ia)
                                  entidades = entidades_ia
                             else:
                                  logging.warning(f"NLP: Entidades retornadas pela IA não são um dicionário: {entidades_ia}")

                             sentimento_ia = json_extraido_ia.get("sentimento_detectado")
                             if sentimento_ia and isinstance(sentimento_ia, str):
                                  sentimento = sentimento_ia
                                  meta_conversa["ultimo_sentimento_detectado"] = sentimento
                             else:
                                  logging.warning(f"NLP: Sentimento retornado pela IA inválido ou ausente: {sentimento_ia}. Usando sentimento analisado anteriormente: {sentimento}")
                         else:
                              logging.warning("NLP: ⚠️ IA não retornou JSON reconhecível no final da resposta.")
                              intent = "ia_generica_sem_json"

                         novo_estado = "SUPORTE_FAQ"

    except Exception as e:
        logging.exception(f"NLP: ❌ ERRO INESPERADO durante processamento da mensagem para {telefone}:")
        resposta_final = MENSAGEM_ERRO_PADRAO
        intent = "erro_processamento_geral"
        novo_estado = estado_atual

    # --- 5. Atualizar Contexto e Salvar Histórico ---
    meta_conversa_final = meta_conversa if isinstance(meta_conversa, dict) else {}
    contexto_para_salvar = {
        "estado": novo_estado,
        "ultima_resposta_bot": resposta_final,
        "meta_conversa": meta_conversa_final
    }

    salvar_contexto(telefone, contexto_para_salvar)
    salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, entidades, risco_detectado, sentimento)

    logging.info(f"NLP: ✅ Processamento concluído para {telefone}. Novo estado: {novo_estado}. Resposta: '{resposta_final[:50]}...'")
    return {"resposta": resposta_final, "estado": novo_estado}



########## End Path: ./utils/offnlp.py ##########


##################################################
########## Path: ./utils/risco.py
##################################################

# ===========================================================
# Arquivo: utils/risco.py
# ===========================================================
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Listas de Palavras-Chave para Detecção de Risco ---

# Lista de palavras/frases críticas indicando risco de vida (suicídio, automutilação)
# ATENÇÃO: Esta lista é um ponto de partida e deve ser refinada com cuidado.
PALAVRAS_CRITICAS_VIDA = [
    "suicídio", "me matar", "quero morrer", "não aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperança", "adeus mundo", "não quero viver",
    "me cortar", "me machucar", "automutilação", "tirar minha vida", "fim da linha",
    "não vejo saída", "desistir de tudo"
]

# Lista de palavras/frases que indicam URGÊNCIA MÉDICA (Overdose, sintomas graves)
PALAVRAS_URGENCIA_MEDICA = [
    "overdose", "passando muito mal", "não consigo respirar", "dor no peito forte",
    "desmaiado", "convulsão", "sangrando muito", "veneno", "infarto", "avc",
    "muita dor", "sem ar", "falta de ar", "alucinação grave", "delírio intenso",
    "tomou muito remédio", "ingeriu substância"
]

# --- Função de Análise de Risco ---

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (risco de vida, urgência médica).
    Retorna um dicionário com booleanos para 'risco_vida' e 'urgencia_medica'.

    Args:
        texto (str): O texto da mensagem do usuário a ser analisada.

    Returns:
        dict: Dicionário contendo:
            - 'risco_vida' (bool): True se detectar palavras críticas de risco de vida.
            - 'urgencia_medica' (bool): True se detectar palavras de urgência médica.
    """
    # Retorna False para ambos se o texto for vazio ou nulo
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    # Converte o texto para minúsculas para comparação case-insensitive
    texto_lower = texto.lower()

    # Verifica se alguma palavra/frase da lista de risco de vida está presente no texto
    # Usar busca de substring para pegar variações (ex: "quero me matar agora")
    risco_vida_detectado = any(palavra in texto_lower for palavra in PALAVRAS_CRITICAS_VIDA)

    # Verifica se alguma palavra/frase da lista de urgência médica está presente no texto
    urgencia_medica_detectada = any(palavra in texto_lower for palavra in PALAVRAS_URGENCIA_MEDICA)

    # Loga um aviso se algum risco for detectado (o log principal será feito em nlp.py)
    # if risco_vida_detectado:
    #     logging.debug(f"RISCO: Risco de vida potencialmente detectado em '{texto[:50]}...'")
    # if urgencia_medica_detectada:
    #     logging.debug(f"RISCO: Urgência médica potencialmente detectada em '{texto[:50]}...'")

    # Retorna o dicionário com os resultados da análise
    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }


########## End Path: ./utils/risco.py ##########


##################################################
########## Path: ./utils/agenda.py
##################################################

# ===========================================================
# Arquivo: utils/agenda.py
# (Implementação das funções de agendamento com DB)
# ===========================================================
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure, DuplicateKeyError
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
import logging
import pytz # Para lidar com fusos horários corretamente

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes de Configuração da Agenda ---
DURACAO_CONSULTA_MINUTOS = 20 # Duração de cada bloco de consulta
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias úteis)
HORARIO_OPERACAO_INICIO = 9 # Horário de início das consultas (9:00)
HORARIO_OPERACAO_FIM = 18  # Horário de fim (não agenda às 18:00, último bloco começa antes)
DIAS_UTEIS = [0, 1, 2, 3, 4] # 0=Segunda, 1=Terça, ..., 4=Sexta
FUSO_HORARIO_LOCAL = 'America/Sao_Paulo' # Fuso horário de operação

# --- Conexão com MongoDB ---
mongo_agenda = None
db_agenda = None
consultas_db = None

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_agenda = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_agenda.server_info() # Testa a conexão
        db_agenda = mongo_agenda["famdomes"] # Nome do banco de dados
        consultas_db = db_agenda["consultas_agendadas"] # Coleção para agendamentos
        # Cria índice único para garantir que não haja duas consultas no mesmo horário (UTC)
        consultas_db.create_index("horario_utc", unique=True)
        consultas_db.create_index("telefone") # Índice para busca por telefone
        consultas_db.create_index([("status", 1), ("horario_utc", 1)]) # Índice composto
        logging.info("AGENDA: Conexão com MongoDB estabelecida e índices verificados/criados.")
    else:
        logging.error("AGENDA: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"AGENDA: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"AGENDA: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_agenda = None
    db_agenda = None
    consultas_db = None

# --- Funções Auxiliares ---

def _proximo_horario_util(inicio_base_utc: datetime) -> datetime:
    """
    Avança o horário UTC para o próximo bloco de X minutos disponível
    dentro do horário de operação e dias úteis definidos.
    """
    horario_utc = inicio_base_utc.replace(tzinfo=timezone.utc) # Garante que está ciente do fuso UTC
    tz_local = pytz.timezone(FUSO_HORARIO_LOCAL)

    while True:
        # Arredonda para o início do próximo bloco de N minutos (para cima)
        minutos_atuais = horario_utc.minute
        minutos_para_proximo_bloco = (DURACAO_CONSULTA_MINUTOS - (minutos_atuais % DURACAO_CONSULTA_MINUTOS)) % DURACAO_CONSULTA_MINUTOS
        if minutos_para_proximo_bloco == 0 and (horario_utc.second > 0 or horario_utc.microsecond > 0):
            # Se já está no início do bloco mas tem segundos, avança um bloco inteiro
             horario_utc += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        elif minutos_para_proximo_bloco > 0 :
            # Avança para o início do próximo bloco
            horario_utc += timedelta(minutes=minutos_para_proximo_bloco)

        # Zera segundos e microssegundos
        horario_utc = horario_utc.replace(second=0, microsecond=0)

        # Converte para o fuso local para verificar horário de operação e dia da semana
        horario_local = horario_utc.astimezone(tz_local)

        # Verifica se está dentro do horário de operação
        if horario_local.hour < HORARIO_OPERACAO_INICIO:
            # Se for antes do início, ajusta para o início do dia no fuso local e converte de volta para UTC
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        if horario_local.hour >= HORARIO_OPERACAO_FIM:
            # Se for depois do fim, avança para o dia seguinte e ajusta para o início
            horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Verifica se é dia útil (no fuso local)
        if horario_local.weekday() not in DIAS_UTEIS:
            # Se não for dia útil, avança para o próximo dia e ajusta para o início
            # Loop para garantir que caia em um dia útil
            while horario_local.weekday() not in DIAS_UTEIS:
                 horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horário

        # Se passou por todas as verificações, o horário é válido
        return horario_utc

def formatar_horario_local(horario_utc: datetime | None, fuso_destino: str = FUSO_HORARIO_LOCAL) -> str:
    """Formata um horário UTC para uma string legível no fuso horário local."""
    if not horario_utc or not isinstance(horario_utc, datetime):
        return "Indisponível"
    try:
        # Garante que o datetime de entrada está ciente do fuso (UTC)
        if horario_utc.tzinfo is None:
            horario_utc = pytz.utc.localize(horario_utc)

        tz_destino = pytz.timezone(fuso_destino)
        horario_local = horario_utc.astimezone(tz_destino)
        # Formato: DD/MM/AAAA HH:MM (ex: 05/08/2025 14:30)
        return horario_local.strftime("%d/%m/%Y %H:%M")
    except ImportError:
        logging.warning("AGENDA: Biblioteca pytz não instalada. Usando formatação UTC.")
        return horario_utc.strftime("%d/%m/%Y %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"AGENDA: Erro ao formatar horário {horario_utc} para fuso {fuso_destino}: {e}")
        return "Erro na formatação"

# --- Funções Principais da Agenda ---

def agendar_consulta(telefone: str, nome: str, email: str | None = None) -> datetime | None:
    """
    Encontra o próximo horário livre e tenta agendar a consulta.
    Retorna o datetime UTC do horário agendado ou None se não conseguir.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível agendar: Sem conexão com DB.")
        return None

    # Usar UTC para armazenamento e lógica interna
    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar X minutos à frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        # Encontra o próximo bloco de horário válido (dia útil, horário de operação)
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Tenta inserir o agendamento no horário encontrado
        consulta_doc = {
            "telefone": telefone,
            "nome": nome,
            "email": email,
            "horario_utc": horario_tentativa_utc, # Armazena em UTC
            "status": "agendado", # Status inicial
            "criado_em": agora_utc
        }
        try:
            # Tenta inserir o documento. Se o horário já estiver ocupado,
            # o índice único ("horario_utc") causará um DuplicateKeyError.
            result = consultas_db.insert_one(consulta_doc)
            if result.inserted_id:
                horario_formatado = formatar_horario_local(horario_tentativa_utc)
                logging.info(f"AGENDA: ✅ Consulta marcada para {nome} ({telefone}) em {horario_formatado} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna o horário em UTC
            else:
                # Caso improvável de falha na inserção sem exceção
                logging.error(f"AGENDA: ❌ Falha desconhecida ao inserir agendamento para {horario_tentativa_utc}.")
                return None

        except DuplicateKeyError:
            # Horário ocupado, avança a procura para depois deste bloco
            logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado. Tentando próximo.")
            inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min para recalcular próximo bloco
            continue # Tenta o próximo horário

        except Exception as e:
            # Outro erro durante a inserção
            logging.error(f"AGENDA: ❌ ERRO ao tentar inserir agendamento para {horario_tentativa_utc}: {e}")
            return None # Falha no agendamento

    # Se o loop terminar sem encontrar horário
    logging.warning(f"AGENDA: ⚠️ Não foram encontrados horários disponíveis para {telefone} ({nome}) após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def cancelar_consulta(telefone: str) -> int:
    """
    Cancela todas as consultas futuras com status 'agendado' para um telefone.
    Retorna o número de consultas canceladas.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível cancelar: Sem conexão com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Filtro para encontrar consultas futuras e agendadas do telefone
        filtro = {
            "telefone": telefone,
            "horario_utc": {"$gt": agora_utc}, # Apenas horários futuros
            "status": "agendado" # Apenas consultas que ainda estão agendadas
        }
        # Atualiza o status para 'cancelado_usuario' em vez de deletar (mantém histórico)
        resultado = consultas_db.update_many(
            filtro,
            {"$set": {"status": "cancelado_usuario", "cancelado_em": agora_utc}}
        )

        canceladas = resultado.modified_count
        if canceladas > 0:
            logging.info(f"AGENDA: 🗑️ Cancelada(s) {canceladas} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"AGENDA: Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return canceladas
    except Exception as e:
        logging.error(f"AGENDA: ❌ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """
    Consulta o próximo horário disponível sem agendar.
    Retorna o datetime UTC do horário ou None se não encontrar/erro.
    """
    if consultas_db is None:
        logging.error("AGENDA: ❌ Não é possível consultar horário: Sem conexão com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    # Começa a procurar um pouco à frente
    inicio_procura_utc = agora_utc + timedelta(minutes=5) # Pequena margem

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            # Verifica se existe alguma consulta agendada ou confirmada para este horário
            filtro_conflito = {
                "horario_utc": horario_tentativa_utc,
                "status": {"$in": ["agendado", "confirmado"]} # Considera ambos como ocupados
            }
            conflito = consultas_db.find_one(filtro_conflito)
            if not conflito:
                # Encontrou horário livre
                logging.info(f"AGENDA: Próximo horário disponível encontrado: {formatar_horario_local(horario_tentativa_utc)} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna horário em UTC
            else:
                # Horário ocupado, avança para o próximo bloco
                logging.debug(f"AGENDA: Horário {horario_tentativa_utc.isoformat()} UTC ocupado (Status: {conflito.get('status')}). Tentando próximo.")
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # Avança 1 min
                continue
        except Exception as e:
            logging.error(f"AGENDA: ❌ ERRO ao consultar próximo horário ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro na consulta

    # Se o loop terminar
    logging.warning(f"AGENDA: ⚠️ Nenhum horário disponível encontrado na consulta após {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None


########## End Path: ./utils/agenda.py ##########


##################################################
########## Path: ./utils/leads.py
##################################################

from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )


########## End Path: ./utils/leads.py ##########


##################################################
########## Path: ./utils/ia_fallback.py
##################################################

from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens


########## End Path: ./utils/ia_fallback.py ##########


##################################################
########## Path: ./utils/gerar_intents.py
##################################################

"""
Gera intents/intents.json a partir de 'MAPEAMENTO DE INTENÇÕES – DOMO (FAM.txt)'.

Uso:
    python utils/gerar_intents.py > intents/intents.json
"""
import re, json, pathlib, sys

RAIZ = pathlib.Path(__file__).resolve().parents[1]
MAPA = RAIZ / "FAM.txt"

BASE = {
    "ACOLHIMENTO": {
        "triggers": ["", ""],
        "resposta": "Olá! Eu sou o DOMO. Estou aqui para te acompanhar. Como posso ajudar?",
        "escala_humano": False,
    },
    "PRESENCA_VIVA": {
        "triggers": [],
        "resposta": "Só passando para lembrar que estou aqui com você. Qualquer coisa, é só chamar. 🤗",
        "escala_humano": False,
    },
}

def parse():
    txt = MAPA.read_text(encoding="utf-8")
    blocos = re.split(r"\n────────────────────────────\n", txt)
    for bloco in blocos:
        m_id = re.search(r"INTENT\s+(\d+):\s+(.+)", bloco)
        if not m_id:
            continue
        intent_id = f"INTENT_{m_id.group(1).zfill(3)}"
        triggers = re.findall(r"TRIGGERS:\s+(.+)", bloco)
        resposta = re.findall(r"RESPOSTA:\s+(.+)", bloco)
        escala = "✅" in bloco or "⚠️" in bloco or "✅✅" in bloco
        yield intent_id, {
            "triggers": [t.strip("“”\" ") for t in (triggers[0].split("”,") if triggers else [])],
            "resposta": resposta[0] if resposta else "",
            "escala_humano": escala,
        }

def main():
    data = {**BASE, **{k: v for k, v in parse()}}
    json.dump(data, sys.stdout, ensure_ascii=False, indent=2)

if __name__ == "__main__":
    main()


########## End Path: ./utils/gerar_intents.py ##########


##################################################
########## Path: ./utils/followup.py
##################################################

# ===========================================================
# Arquivo: utils/followup.py
# (Implementação das funções de acompanhamento de pagamento)
# ===========================================================
from datetime import datetime, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure
# Ajuste o import se config.py estiver em um diretório diferente
from app.config import MONGO_URI
# Importa a função de agendamento para ser chamada após o pagamento
# Ajuste o import se agenda.py estiver em um diretório diferente
from app.utils.agenda import agendar_consulta, formatar_horario_local
import logging

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Conexão com MongoDB ---
mongo_followup = None
db_followup = None
pagamentos_db = None # Coleção para rastrear status de pagamento

try:
    # Estabelece conexão com MongoDB
    if MONGO_URI:
        mongo_followup = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_followup.server_info() # Testa a conexão
        db_followup = mongo_followup["famdomes"] # Nome do banco de dados
        pagamentos_db = db_followup["pagamentos"] # Coleção para pagamentos
        # Cria índices se não existirem
        pagamentos_db.create_index("telefone")
        pagamentos_db.create_index("id_sessao_stripe", sparse=True, unique=True) # ID da sessão deve ser único
        pagamentos_db.create_index("status")
        pagamentos_db.create_index("criado_em")
        logging.info("FOLLOWUP: Conexão com MongoDB estabelecida para Pagamentos.")
    else:
        logging.error("FOLLOWUP: ❌ MONGO_URI não definido. Não foi possível conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"FOLLOWUP: ❌ Falha na conexão com MongoDB: {e}")
except Exception as e:
    logging.error(f"FOLLOWUP: ❌ ERRO ao conectar com MongoDB ou criar índices: {e}")
    mongo_followup = None
    db_followup = None
    pagamentos_db = None

# --- Funções de Follow-up ---

def iniciar_sessao(telefone: str, nome: str, id_sessao_stripe: str | None = None):
    """
    Registra o início de uma tentativa de pagamento no banco de dados.
    Chamado quando o link de pagamento é gerado. Usa update_one com upsert=True
    para criar ou atualizar o registro baseado no id_sessao_stripe, se fornecido.

    Args:
        telefone (str): Telefone do usuário.
        nome (str): Nome do usuário.
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao iniciar sessão: DB indisponível.")
        return

    try:
        agora = datetime.now(timezone.utc)
        # Filtro: usa id_sessao_stripe se disponível, senão cria um novo (ou atualiza baseado em telefone?)
        # É mais seguro basear no id_sessao_stripe para evitar sobrescrever sessões ativas
        filtro = {"id_sessao_stripe": id_sessao_stripe} if id_sessao_stripe else {"telefone": telefone, "status": "link_gerado"} # Se sem ID, atualiza último link gerado

        update_data = {
            "$set": {
                "telefone": telefone,
                "nome": nome,
                "status": "link_gerado", # Garante o status correto
                "ultima_atualizacao": agora
            },
            "$setOnInsert": { # Define apenas na criação
                 "id_sessao_stripe": id_sessao_stripe, # Só define ID na criação se filtro não o usou
                 "criado_em": agora
            }
        }
        # Se o filtro usou id_sessao_stripe, garante que ele seja definido no $set também
        if id_sessao_stripe:
            update_data["$set"]["id_sessao_stripe"] = id_sessao_stripe


        result = pagamentos_db.update_one(filtro, update_data, upsert=True)

        if result.upserted_id:
            logging.info(f"FOLLOWUP: 📍 Nova sessão de pagamento iniciada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        elif result.modified_count > 0:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento atualizada para {telefone} ({nome}). Sessão: {id_sessao_stripe or 'N/A'}.")
        else:
             logging.info(f"FOLLOWUP: 📍 Sessão de pagamento para {telefone} ({nome}) não modificada (Sessão: {id_sessao_stripe or 'N/A'}).")

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO ao iniciar/atualizar sessão de pagamento para {telefone}:")

def marcar_pagamento(
    telefone: str | None = None,
    id_sessao_stripe: str | None = None,
    email_cliente: str | None = None,
    nome_cliente: str | None = None
) -> tuple[datetime | None, str | None]:
    """
    Marca um pagamento como concluído no banco de dados e tenta agendar a consulta.
    Chamado pelo webhook do Stripe após 'checkout.session.completed'.

    Args:
        telefone (str | None): Telefone do usuário (vindo dos metadados do Stripe).
        id_sessao_stripe (str | None): ID da sessão de checkout do Stripe.
        email_cliente (str | None): Email do cliente (vindo da sessão Stripe).
        nome_cliente (str | None): Nome do cliente (vindo da sessão Stripe ou metadados).

    Returns:
        tuple[datetime | None, str | None]:
            - horario_agendado_utc: O horário UTC da consulta agendada, ou None se falhar.
            - nome_final: O nome usado para o agendamento.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: DB indisponível.")
        return None, None

    # Precisa do id_sessao para garantir que estamos atualizando o pagamento correto
    if not id_sessao_stripe:
        logging.error("FOLLOWUP: ❌ Falha ao marcar pagamento: ID da sessão Stripe ausente.")
        # Poderia tentar buscar por telefone, mas é arriscado se houver links antigos
        return None, None

    # Monta o filtro para encontrar o registro da sessão de pagamento pelo ID
    filtro = {"id_sessao_stripe": id_sessao_stripe}

    try:
        agora_utc = datetime.now(timezone.utc)
        # Dados para atualizar o registro
        update_data = {
            "$set": {
                "status": "pago", # Marca como pago
                "pago_em": agora_utc,
                "ultima_atualizacao": agora_utc,
                "email_stripe": email_cliente,
                # Atualiza telefone e nome se vieram do Stripe (podem ter sido preenchidos lá)
                "telefone": telefone if telefone else "$telefone", # Mantém o original se não veio
                "nome": nome_cliente if nome_cliente else "$nome" # Mantém o original se não veio
            }
        }

        # Encontra e atualiza o registro do pagamento
        # Retorna o documento APÓS a atualização para pegar os dados mais recentes
        pagamento_atualizado = pagamentos_db.find_one_and_update(
            filtro,
            update_data,
            return_document=ReturnDocument.AFTER # Pega o documento atualizado
        )

        if pagamento_atualizado:
            logging.info(f"FOLLOWUP: 💰 Pagamento confirmado para sessão {id_sessao_stripe} (Telefone: {pagamento_atualizado.get('telefone')}).")
            # Usa os dados atualizados para agendar
            tel_para_agendar = pagamento_atualizado.get('telefone')
            nome_para_agendar = pagamento_atualizado.get('nome', 'Cliente')
            email_para_agendar = pagamento_atualizado.get('email_stripe') # Usa o email do Stripe

            # Verifica se temos telefone para agendar
            if not tel_para_agendar:
                 logging.error(f"FOLLOWUP: ❌ Telefone ausente no registro de pagamento {id_sessao_stripe} após atualização. Não é possível agendar.")
                 return None, nome_para_agendar # Retorna nome para possível notificação

            # --- Tenta Agendar a Consulta ---
            logging.info(f"FOLLOWUP: Tentando agendar consulta para {nome_para_agendar} ({tel_para_agendar})...")
            horario_agendado_utc = agendar_consulta(
                telefone=tel_para_agendar,
                nome=nome_para_agendar,
                email=email_para_agendar
            )

            if horario_agendado_utc:
                logging.info(f"FOLLOWUP: ✅ Consulta agendada com sucesso para {tel_para_agendar} em {formatar_horario_local(horario_agendado_utc)}.")
                # Salva o horário agendado no registro de pagamento
                pagamentos_db.update_one(
                    {"_id": pagamento_atualizado["_id"]},
                    {"$set": {"horario_consulta_agendada_utc": horario_agendado_utc, "status": "agendado"}} # Atualiza status final
                )
                return horario_agendado_utc, nome_para_agendar
            else:
                logging.error(f"FOLLOWUP: ❌ Falha ao agendar consulta para {tel_para_agendar} após pagamento.")
                # O pagamento foi marcado, mas o agendamento falhou. Requer atenção manual.
                pagamentos_db.update_one(
                     {"_id": pagamento_atualizado["_id"]},
                     {"$set": {"status": "pago_erro_agendamento"}} # Marca status especial
                )
                return None, nome_para_agendar # Retorna None para horário, mas nome para possível notificação
        else:
            logging.warning(f"FOLLOWUP: ⚠️ Nenhum registro de pagamento encontrado para ID Sessão Stripe: {id_sessao_stripe}. Pagamento pode já ter sido processado ou ID inválido.")
            return None, None

    except Exception as e:
        logging.exception(f"FOLLOWUP: ❌ ERRO CRÍTICO ao marcar pagamento/agendar para ID Sessão {id_sessao_stripe}:")
        return None, None

# TODO: Adicionar função para checar follow-ups (ex: pagamentos com link_gerado > X horas) se necessário.
# async def checar_followups(): ...



########## End Path: ./utils/followup.py ##########


##################################################
########## Path: ./schemas/ia_comando.py
##################################################

from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str


########## End Path: ./schemas/ia_comando.py ##########


##################################################
########## Path: ./routes/resetar.py
##################################################

from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone é obrigatório.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")


########## End Path: ./routes/resetar.py ##########


##################################################
########## Path: ./routes/pagamentos.py
##################################################

from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"✅ Olá {nome}, seu agendamento está confirmado!\n"
            f"🕒 Horário: {horario.strftime('%d/%m %H:%M')}\n"
            "Você será chamado pelo profissional nesse horário. Até lá!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"👨‍⚕️ Novo agendamento: {nome} ({telefone}) às {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}


########## End Path: ./routes/pagamentos.py ##########


##################################################
########## Path: ./routes/painel.py
##################################################

from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessão está confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}


########## End Path: ./routes/painel.py ##########


##################################################
########## Path: ./routes/nlp.py
##################################################

from fastapi import APIRouter, Request
from app.utils.offnlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado


########## End Path: ./routes/nlp.py ##########


##################################################
########## Path: ./routes/stripe.py
##################################################

# ===========================================================
# Arquivo: routes/stripe.py
# (Implementação do webhook do Stripe)
# ===========================================================
from fastapi import APIRouter, Request, Header, HTTPException, BackgroundTasks
import stripe # Importa a biblioteca do Stripe
import logging

# Ajuste os imports conforme a estrutura do seu projeto
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
# Importa funções de followup e agenda
from app.utils.followup import marcar_pagamento
from app.utils.agenda import formatar_horario_local
# Importa função para salvar contexto e enviar mensagem
from app.utils.contexto import salvar_contexto
from app.utils.mensageria import enviar_mensagem

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/webhook", tags=["Stripe"]) # Adiciona prefixo e tag

# Define a chave secreta do Stripe (carregada da configuração)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("STRIPE Route: Chave secreta do Stripe configurada.")
else:
    logging.error("STRIPE Route: ❌ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada. Webhook não funcionará.")
    # A aplicação pode iniciar, mas o webhook falhará

@router.post("/stripe/", summary="Recebe eventos do webhook do Stripe")
async def stripe_webhook(request: Request, background_tasks: BackgroundTasks, stripe_signature: str = Header(None)):
    """
    Endpoint para receber eventos do Stripe via webhook.
    Verifica a assinatura e processa eventos relevantes (ex: checkout.session.completed).
    Processa a lógica principal em background.
    """
    # Verifica se a chave do webhook está configurada
    if not STRIPE_WEBHOOK_SECRET:
        logging.error("STRIPE Route: ❌ Chave secreta do webhook Stripe (STRIPE_WEBHOOK_SECRET) não configurada.")
        raise HTTPException(status_code=500, detail="Configuração de webhook incompleta no servidor.")

    # Obtém o corpo bruto da requisição
    payload = await request.body()

    # Verifica a assinatura do webhook para garantir que veio do Stripe
    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
        logging.info(f"STRIPE Route: Evento recebido tipo: {event['type']} (ID: {event['id']})")
    except ValueError as e:
        # Payload inválido
        logging.error(f"STRIPE Route: ❌ Erro ao decodificar payload do webhook: {e}")
        raise HTTPException(status_code=400, detail="Payload inválido.")
    except stripe.error.SignatureVerificationError as e:
        # Assinatura inválida
        logging.error(f"STRIPE Route: ❌ Erro na verificação da assinatura do webhook: {e}")
        raise HTTPException(status_code=400, detail="Assinatura inválida.")
    except Exception as e:
        logging.exception("STRIPE Route: ❌ Erro inesperado ao construir evento do webhook:")
        raise HTTPException(status_code=500, detail="Erro interno ao processar webhook.")

    # --- Processamento do Evento (em Background) ---
    # Adiciona a tarefa de processar o evento em background
    background_tasks.add_task(processar_evento_stripe, event)

    # Retorna 200 OK imediatamente para o Stripe
    return {"status": "recebido"}

async def processar_evento_stripe(event: dict):
    """
    Função executada em background para processar o evento do Stripe.
    """
    event_type = event["type"]
    session = event["data"]["object"] # O objeto da sessão de checkout

    logging.info(f"STRIPE BG Task: Processando evento tipo: {event_type} (Sessão ID: {session.get('id', 'N/A')})")

    # --- Evento: Checkout Concluído com Sucesso ---
    if event_type == "checkout.session.completed":
        # Extrai metadados e informações do cliente da sessão Stripe
        metadata = session.get("metadata", {})
        telefone_cliente = metadata.get("telefone")
        nome_cliente_meta = metadata.get("nome") # Nome dos metadados (pode ser mais confiável)

        customer_details = session.get("customer_details", {})
        email_cliente = customer_details.get("email")
        nome_cliente_stripe = customer_details.get("name") # Nome direto do Stripe

        # Usa o nome dos metadados como prioridade, senão o do Stripe
        nome_final = nome_cliente_meta or nome_cliente_stripe or "Cliente"

        id_sessao_stripe = session.get("id")

        # Verifica se temos o telefone (essencial para continuar)
        if not telefone_cliente:
            logging.error(f"STRIPE BG Task: ❌ Evento {event_type} (Sessão: {id_sessao_stripe}) sem 'telefone' nos metadados. Não é possível prosseguir.")
            return # Aborta o processamento

        logging.info(f"STRIPE BG Task: Checkout concluído para {nome_final} ({telefone_cliente}). Sessão: {id_sessao_stripe}")

        # Tenta marcar o pagamento e agendar a consulta
        horario_agendado_utc, nome_agendado = await asyncio.to_thread(
             marcar_pagamento, # Executa a função síncrona em uma thread separada
             telefone=telefone_cliente,
             id_sessao_stripe=id_sessao_stripe,
             email_cliente=email_cliente,
             nome_cliente=nome_final
        )
        # horario_agendado_utc, nome_agendado = marcar_pagamento( # Se marcar_pagamento fosse async
        #     telefone=telefone_cliente,
        #     id_sessao_stripe=id_sessao_stripe,
        #     email_cliente=email_cliente,
        #     nome_cliente=nome_final
        # )


        if horario_agendado_utc:
            # Agendamento bem-sucedido!
            horario_formatado = formatar_horario_local(horario_agendado_utc)
            # Monta mensagem de confirmação para o paciente
            msg_paciente = (
                f"✅ Olá {nome_agendado}, pagamento confirmado!\n\n"
                f"Sua consulta inicial está agendada para:\n"
                f"🗓️ **{horario_formatado}** (Horário de Brasília).\n\n"
                f"O profissional entrará em contato com você por aqui neste horário. Até lá!"
            )
            # Envia a confirmação para o paciente
            await enviar_mensagem(telefone_cliente, msg_paciente)

            # Monta notificação para o médico/equipe (opcional)
            # TODO: Definir número/canal do médico em config.py
            numero_medico = os.getenv("WHATSAPP_MEDICO_AVISO")
            if numero_medico:
                msg_medico = f"👨‍⚕️ Novo agendamento confirmado:\n\nPaciente: {nome_agendado}\nTelefone: {telefone_cliente}\nHorário: {horario_formatado}"
                await enviar_mensagem(numero_medico, msg_medico)

            # --- ATUALIZA O ESTADO DA CONVERSA ---
            # Muda o estado para iniciar o questionário na próxima interação
            logging.info(f"STRIPE BG Task: Atualizando estado para CONFIRMANDO_AGENDAMENTO para {telefone_cliente}")
            salvar_contexto(telefone_cliente, {
                "estado": "CONFIRMANDO_AGENDAMENTO",
                "nome": nome_agendado, # Salva/Atualiza o nome no contexto
                "meta_conversa": {"email_cliente": email_cliente} # Salva email na meta
            })

        else:
            # Falha no agendamento após pagamento
            logging.error(f"STRIPE BG Task: ❌ Pagamento confirmado para {telefone_cliente}, mas FALHA AO AGENDAR consulta.")
            # Envia mensagem de erro para o paciente
            msg_erro_agendamento = (
                f"⚠️ Olá {nome_agendado}, seu pagamento foi confirmado, mas houve um problema ao agendar automaticamente sua consulta.\n\n"
                f"Não se preocupe, nossa equipe já foi notificada e entrará em contato em breve para finalizar o agendamento manualmente. Obrigado pela compreensão."
            )
            await enviar_mensagem(telefone_cliente, msg_erro_agendamento)
            # TODO: Notificar equipe interna sobre a falha no agendamento automático

    # --- Outros Eventos (Opcional) ---
    # elif event_type == "checkout.session.async_payment_failed":
    #     logging.warning(f"STRIPE BG Task: Pagamento assíncrono falhou para sessão {session.get('id')}")
    #     # Lógica para lidar com falha (ex: notificar usuário)
    # elif event_type == "checkout.session.expired":
    #      logging.info(f"STRIPE BG Task: Sessão de checkout expirada: {session.get('id')}")
         # Lógica para lidar com expiração (ex: marcar no DB)

    else:
        # Evento não tratado
        logging.info(f"STRIPE BG Task: Evento tipo '{event_type}' não tratado.")

    logging.info(f"STRIPE BG Task: Processamento do evento concluído.")

# Importar asyncio e json se não estiverem importados
import asyncio
import json
import os # Para getenv


########## End Path: ./routes/stripe.py ##########


##################################################
########## Path: ./routes/admin.py
##################################################

from fastapi import APIRouter, Response, Depends, HTTPException
from app.core.metrics import prometheus_response, json_response
from app.config import settings

router = APIRouter(prefix="/admin", tags=["Admin"])

def _auth(token: str):
    if token != getattr(settings, "API_KEY", None):
        raise HTTPException(status_code=403)

@router.get("/metrics")
def metrics(token: str = Depends(_auth)):
    data, content_type = prometheus_response()
    return Response(content=data, media_type=content_type)

@router.get("/stats")
def stats(token: str = Depends(_auth)):
    return json_response()


########## End Path: ./routes/admin.py ##########


##################################################
########## Path: ./routes/entrada.py
##################################################


"""
Webhook de entrada para mensagens (WhatsApp ou futuro canal).
Encaminha para o MCP Orquestrador.
"""
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, constr
from app.core.mcp_orquestrador import MCPOrquestrador

router = APIRouter(tags=["Entrada"])

class MensagemIn(BaseModel):
    telefone: constr(strip_whitespace=True, min_length=8)
    texto:    constr(strip_whitespace=True, min_length=1)

@router.post("/", status_code=status.HTTP_202_ACCEPTED)
async def receber_mensagem(msg: MensagemIn):
    try:
        await MCPOrquestrador().processar_mensagem(msg.telefone, msg.texto)
    except Exception as exc:  # pragma: no cover
        raise HTTPException(500, "Erro interno ao processar mensagem") from exc
    return {"status": "aceito"}


########## End Path: ./routes/entrada.py ##########


##################################################
########## Path: ./routes/rocketchat.py
##################################################

from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda não tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }


########## End Path: ./routes/rocketchat.py ##########


##################################################
########## Path: ./routes/agendamento.py
##################################################

# ===========================================================
# Arquivo: routes/agendamento.py
# (Corrigido para importar a função correta de agenda.py)
# ===========================================================
from fastapi import APIRouter, HTTPException
import logging

# Ajuste o import conforme a estrutura do seu projeto
# Importa a função correta para consultar o próximo horário
from app.utils.agenda import consultar_proximo_horario_disponivel, formatar_horario_local

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter(prefix="/agenda", tags=["Agendamento"]) # Adiciona prefixo e tag

@router.get("/proximo", summary="Consulta o próximo horário de agendamento disponível")
async def proximo_agendamento_disponivel():
    """
    Endpoint para verificar o próximo horário livre na agenda.
    Retorna o horário formatado ou uma mensagem indicando indisponibilidade.
    """
    logging.info("AGENDAMENTO Route: Consultando próximo horário disponível...")
    try:
        # Chama a função correta para obter o próximo horário UTC
        horario_utc = consultar_proximo_horario_disponivel()

        if horario_utc:
            # Formata o horário para o fuso local
            horario_formatado = formatar_horario_local(horario_utc)
            logging.info(f"AGENDAMENTO Route: Próximo horário encontrado: {horario_formatado}")
            return {"proximo_horario_disponivel": horario_formatado, "horario_utc": horario_utc.isoformat()}
        else:
            # Se a função retornar None (sem horário ou erro no DB)
            logging.info("AGENDAMENTO Route: Nenhum horário disponível encontrado.")
            return {"proximo_horario_disponivel": None, "mensagem": "Nenhum horário disponível encontrado no momento."}
    except Exception as e:
        # Captura qualquer erro inesperado durante a consulta
        logging.exception("AGENDAMENTO Route: ❌ Erro inesperado ao consultar próximo horário:")
        raise HTTPException(status_code=500, detail="Erro interno ao consultar a agenda.")



########## End Path: ./routes/agendamento.py ##########


##################################################
########## Path: ./routes/whatsapp.py
##################################################

# ===========================================================
# Arquivo: routes/whatsapp.py
# Webhook Cloud API → MCPOrquestrador
# ===========================================================
from __future__ import annotations

import json
import logging
from fastapi import APIRouter, BackgroundTasks, Request, Response, status, HTTPException
from pydantic import BaseModel, constr
from app.config import WHATSAPP_VERIFY_TOKEN
from app.core.mcp_orquestrador import MCPOrquestrador
from app.utils.mensageria import enviar_mensagem
from app.utils.contexto import limpar_contexto

logger = logging.getLogger("famdomes.whatsapp")

router = APIRouter(prefix="/chat/webhook/whatsapp", tags=["WhatsApp"])

# ----------------------------------------------------------------------
# 1 · Verificação inicial da Meta
@router.get("/", summary="Verifica webhook do WhatsApp")
async def verificar_webhook(request: Request) -> Response:
    args = request.query_params
    if (
        args.get("hub.mode") == "subscribe"
        and args.get("hub.verify_token") == WHATSAPP_VERIFY_TOKEN
    ):
        logger.info("Webhook WhatsApp verificado com sucesso.")
        return Response(content=args.get("hub.challenge"), media_type="text/plain")
    logger.warning("Falha na verificação do webhook – token incorreto.")
    raise HTTPException(status_code=403, detail="Token inválido")

# ----------------------------------------------------------------------
# 2 · Modelo interno para facilitar debug (não exposto na API)
class _WhatsappMsg(BaseModel):
    telefone: constr(strip_whitespace=True, min_length=8)
    texto: constr(strip_whitespace=True, min_length=1)

# ----------------------------------------------------------------------
# 3 · Recepção de mensagens
@router.post("/", status_code=status.HTTP_200_OK, summary="Webhook WhatsApp (POST)")
async def receber_mensagem(
    request: Request,
    background_tasks: BackgroundTasks,
) -> Response:
    """
    Recebe payload da Cloud API, extrai texto e delega ao MCP
    em task de background (latência mínima p/ Meta).
    """
    data = await request.json()
    try:
        entry = data["entry"][0]
        changes = entry["changes"][0]
        value = changes["value"]
    except (KeyError, IndexError, TypeError):
        # payload diferente (status, etc.) ⇒ apenas 200
        return Response(status_code=200)

    # Eventos de status não contêm 'messages'
    messages = value.get("messages", [])
    if not messages:
        return Response(status_code=200)

    msg = messages[0]
    if "text" not in msg or "body" not in msg["text"]:
        return Response(status_code=200)  # apenas mídia, voice, etc.

    texto = msg["text"]["body"].strip()
    telefone = msg["from"]

    # Comando de reset (não vai ao MCP)
    gatilho_reset = texto.lower().replace("\u200b", "").strip()  # remove zero‑width
    if gatilho_reset.startswith("melancia") and "vermelha" in gatilho_reset:
        background_tasks.add_task(_resetar_conversa, telefone)
        return Response(status_code=200)

    # Normal: delega ao MCP em background
    background_tasks.add_task(_processar_mcp, telefone, texto)
    return Response(status_code=200)

# ----------------------------------------------------------------------
# 4 · Task: reset
async def _resetar_conversa(telefone: str) -> None:
    limpar_contexto(telefone)        # ignoramos retorno: sempre zera
    await enviar_mensagem(
        telefone,
        "🔄 Sua conversa foi reiniciada. Pode começar de novo!",
    )
    logger.info("Reset concluído para %s", telefone)


# ----------------------------------------------------------------------
# 5 · Task: encaminhar para MCP
async def _processar_mcp(telefone: str, texto: str) -> None:
    try:
        await MCPOrquestrador().processar_mensagem(telefone, texto)
    except Exception as exc:  # pragma: no cover
        logger.exception("MCP erro para %s: %s", telefone, exc)
        await enviar_mensagem(
            telefone,
            "⚠️ Desculpe, houve um erro interno. Tente novamente em instantes.",
        )


########## End Path: ./routes/whatsapp.py ##########


##################################################
########## Path: ./routes/ia.py
##################################################

# ===========================================================
# Arquivo: routes/ia.py
# (Contém a lógica para processar comandos específicos como agendar)
# ===========================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import logging
import stripe # Importa a biblioteca do Stripe
from datetime import datetime, timedelta # Para expiração da sessão

# Ajuste os imports das funções utilitárias conforme a estrutura do seu projeto
# Assume que estão em app/utils/
from app.utils.agenda import (
    agendar_consulta,
    cancelar_consulta,
    consultar_proximo_horario_disponivel,
    formatar_horario_local
)
from app.utils.mensageria import enviar_mensagem
# Assume que followup.py existe e tem iniciar_sessao (se usado)
# from app.utils.followup import iniciar_sessao
# Assume que config.py existe e tem a chave do Stripe
from app.config import STRIPE_SECRET_KEY

# Configuração básica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este módulo
router = APIRouter()

# Define a chave secreta do Stripe (carregada da configuração)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("IA Route: Chave secreta do Stripe configurada.")
else:
    logging.warning("IA Route: ⚠️ Chave secreta do Stripe (STRIPE_SECRET_KEY) não configurada.")
    # Considerar levantar um erro ou desabilitar funcionalidade de pagamento

# Modelo Pydantic para validar a entrada da API /ia-comando (se usada)
class ComandoIAInput(BaseModel):
    telefone: str
    nome: str
    comando: str # Ex: "quero agendar", "ver horário", "cancelar"

# --- Endpoint da API (Opcional) ---
@router.post("/ia-comando", summary="Processa comandos específicos da IA", tags=["IA"])
async def processar_comando_post(dados: ComandoIAInput):
    """
    Recebe um comando específico (agendar, cancelar, ver horário)
    e executa a ação correspondente. (Endpoint HTTP opcional)
    """
    # Verifica se a API do Stripe está configurada antes de prosseguir com agendamento
    if "agendar" in dados.comando.lower() and not STRIPE_SECRET_KEY:
         logging.error("IA Route: ❌ Tentativa de agendamento via API sem STRIPE_SECRET_KEY.")
         raise HTTPException(status_code=503, detail="Funcionalidade de pagamento indisponível.")

    # Chama a função principal que processa o comando
    resultado = await processar_comando(dados.dict())
    # Retorna o resultado da função
    return resultado

# --- Função Principal de Processamento de Comandos ---
# Esta função é chamada pelo endpoint acima e também diretamente por nlp.py

async def processar_comando(dados: dict) -> dict:
    """
    Processa comandos específicos vindos da interação do usuário ou da IA.

    Args:
        dados (dict): Dicionário contendo 'telefone', 'nome' e 'comando'.

    Returns:
        dict: Dicionário com o status da operação e mensagens relevantes.
    """
    telefone = dados.get("telefone")
    nome = dados.get("nome", "Cliente") # Usa 'Cliente' como nome padrão
    comando = dados.get("comando", "").lower() # Pega o comando e converte para minúsculas

    # Validação básica de entrada
    if not telefone or not comando:
        logging.warning("IA Route: Comando recebido sem telefone ou comando.")
        # Retorna um erro ou uma resposta padrão indicando falha
        # Não levanta HTTPException aqui pois pode ser chamado internamente por nlp.py
        return {"status": "erro_input", "mensagem": "Dados insuficientes para processar comando."}

    logging.info(f"IA Route: Processando comando '{comando}' para {telefone} ({nome})...")

    # --- Lógica para Comando "agendar" ---
    if "agendar" in comando:
        # Verifica novamente se Stripe está configurado
        if not STRIPE_SECRET_KEY:
            logging.error("IA Route: ❌ Tentativa de agendamento sem STRIPE_SECRET_KEY configurada.")
            msg_erro = "Desculpe, a opção de agendamento online não está disponível no momento."
            # Não envia mensagem aqui, pois nlp.py tratará a resposta
            # await enviar_mensagem(telefone, msg_erro)
            return {"status": "erro_config_stripe", "mensagem": msg_erro}

        # TODO: Descomentar se a função iniciar_sessao for usada para tracking
        # Inicia a sessão de pagamento/follow-up (se aplicável)
        # iniciar_sessao(telefone, nome) # Registra a tentativa no DB de follow-up

        try:
            # Cria uma sessão de checkout no Stripe
            logging.info(f"IA Route: Criando sessão Stripe Checkout para {telefone}...")
            # Define o URL base (pode vir do .env)
            base_url = os.getenv("APP_BASE_URL", "[https://famdomes.com.br](https://famdomes.com.br)") # Exemplo
            success_url = f"{base_url}/sucesso?session_id={{CHECKOUT_SESSION_ID}}"
            cancel_url = f"{base_url}/cancelado"

            session = stripe.checkout.Session.create(
                payment_method_types=["card", "boleto"], # Aceita cartão e boleto
                line_items=[{
                    "price_data": {
                        "currency": "brl", # Moeda brasileira
                        "product_data": {"name": "Consulta Inicial FAMDOMES"}, # Nome do produto
                        "unit_amount": 10000, # Preço em centavos (R$ 100,00)
                    },
                    "quantity": 1, # Quantidade
                }],
                mode="payment", # Modo de pagamento único
                # URLs para redirecionamento após sucesso ou cancelamento
                success_url=success_url,
                cancel_url=cancel_url,
                # Metadados para identificar o cliente no webhook
                metadata={
                    "telefone": telefone,
                    "nome": nome
                },
                # Configuração para Boleto (opcional, mas recomendada)
                payment_intent_data={
                     # 'setup_future_usage': 'off_session' # Pode não ser necessário para pagamentos únicos
                },
                # Expiração da sessão de checkout (ex: 2 horas)
                expires_at=int((datetime.now() + timedelta(hours=2)).timestamp())
            )
            logging.info(f"IA Route: Sessão Stripe criada com ID: {session.id} para {telefone}")

            # Monta a mensagem com o link de pagamento para o usuário
            msg_link = f"✅ Ótimo! Para agendar sua consulta inicial (valor R$100,00), por favor, realize o pagamento seguro através deste link:\n{session.url}\n\nO link expira em breve."
            # A mensagem será enviada por nlp.py, aqui apenas retornamos os dados
            # await enviar_mensagem(telefone, msg_link)
            # Retorna o status e a URL de checkout
            return {"status": "link_gerado", "checkout_url": session.url, "mensagem": msg_link}

        except stripe.error.StripeError as e:
             # Erro específico do Stripe
             logging.error(f"IA Route: ❌ Erro Stripe ao criar checkout para {telefone}: {e}")
             msg_erro = "❌ Desculpe, ocorreu um erro ao tentar gerar o link de pagamento com nosso parceiro. Por favor, tente novamente mais tarde ou entre em contato conosco."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_stripe", "mensagem": msg_erro}
        except Exception as e:
             # Outro erro inesperado
             logging.exception(f"IA Route: ❌ Erro inesperado ao criar checkout para {telefone}:")
             msg_erro = "❌ Desculpe, ocorreu um erro inesperado ao gerar seu link de pagamento. Tente novamente mais tarde."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_desconhecido", "mensagem": msg_erro}

    # --- Lógica para Comando "cancelar" ---
    elif "cancelar" in comando:
        logging.info(f"IA Route: Processando cancelamento de consulta para {telefone}...")
        # Chama a função para cancelar consultas futuras
        # TODO: Implementar a função cancelar_consulta em utils/agenda.py
        consultas_canceladas = cancelar_consulta(telefone) # Assume que retorna int
        if consultas_canceladas > 0:
            msg = f"✅ Sua(s) {consultas_canceladas} consulta(s) futura(s) foi(ram) cancelada(s) com sucesso."
            # await enviar_mensagem(telefone, msg)
            return {"status": "consulta_cancelada", "quantidade": consultas_canceladas, "mensagem": msg}
        else:
            msg = "Não encontrei nenhuma consulta futura agendada para cancelar em seu nome."
            # await enviar_mensagem(telefone, msg)
            return {"status": "nenhuma_consulta_encontrada", "mensagem": msg}

    # --- Lógica para Comando "horário" ou "disponível" ---
    elif "horário" in comando or "disponível" in comando or "disponivel" in comando:
        logging.info(f"IA Route: Consultando próximo horário disponível para {telefone}...")
        # Chama a função para consultar o próximo horário livre
        # TODO: Implementar consultar_proximo_horario_disponivel e formatar_horario_local em utils/agenda.py
        proximo_horario_utc = consultar_proximo_horario_disponivel() # Assume que retorna datetime UTC ou None
        if proximo_horario_utc:
            # Formata o horário para o fuso local antes de enviar
            horario_formatado = formatar_horario_local(proximo_horario_utc, 'America/Sao_Paulo') # Exemplo de fuso
            msg = f"📅 O próximo horário disponível para agendamento é: {horario_formatado} (Horário de Brasília)."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_enviado", "horario_utc": proximo_horario_utc.isoformat(), "horario_formatado": horario_formatado, "mensagem": msg}
        else:
            msg = "📅 Desculpe, não consegui encontrar um horário disponível no momento. Por favor, tente novamente mais tarde."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_indisponivel", "mensagem": msg}

    # --- Comando Desconhecido ---
    else:
        logging.warning(f"IA Route: Comando IA desconhecido recebido de {telefone}: '{comando}'")
        # Mensagem padrão para comandos não reconhecidos
        msg = "🤖 Desculpe, não entendi o que você deseja fazer. Você pode me pedir para 'agendar consulta', 'cancelar consulta' ou 'ver próximo horário disponível'."
        # await enviar_mensagem(telefone, msg)
        return {"status": "comando_desconhecido", "mensagem": msg}

# Adicionar import timedelta se não estiver presente
from datetime import timedelta



########## End Path: ./routes/ia.py ##########


##################################################
########## Path: ./routes/followup.py
##################################################

# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}


########## End Path: ./routes/followup.py ##########


##################################################
########## Path: ./main.py
##################################################

# ===========================================================
# Arquivo: main.py  –  Versão consolidada para MCP Server
# ===========================================================
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging, time
from app.core.scheduler import iniciar as iniciar_scheduler
# Configurações centralizadas
from app.config import settings

# Roteadores herdados
from app.routes import whatsapp, ia, stripe, agendamento
# Novo roteador de entrada (MCP)
from app.routes.entrada import router as entrada_router
from app.routes.admin import router as admin_router

# ---------- Logging ----------
logging.basicConfig(level=settings.LOG_LEVEL,
                    format="%(asctime)s %(levelname)s [%(name)s] %(message)s")
logger = logging.getLogger("famdomes.main")

# ---------- FastAPI ----------
app = FastAPI(
    title="FAMDOMES API",
    description="Servidor MCP do FAMDOMES – cuidado emocional e dependência química",
    version="1.1.0",
)

# ---------- CORS ----------
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost", "http://localhost:3000", "https://famdomes.com.br"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------- Middleware de logging ----------
@app.middleware("http")
async def log_requests(request: Request, call_next):
    ini = time.time()
    resp = await call_next(request)
    logger.info("%s %s → %s • %.3fs",
                request.method, request.url.path, resp.status_code, time.time()-ini)
    return resp

# ---------- Roteadores ----------
app.include_router(whatsapp.router)
app.include_router(ia.router)
app.include_router(stripe.router)
app.include_router(agendamento.router)
app.include_router(entrada_router, prefix="/v1")   # <‑‑ NOVO
app.include_router(admin_router)
# ---------- Health / root ----------
@app.get("/", tags=["Root"])
async def root(): return {"status": "ok", "mcp": True}

# ---------- Eventos ----------
@app.on_event("startup")
async def _startup():  logger.info("▶️ API iniciada na porta %s", settings.API_PORT)
iniciar_scheduler()
@app.on_event("shutdown")
async def _shutdown(): logger.info("⏹️ API finalizada")


########## End Path: ./main.py ##########


##################################################
########## Path: ./agents/domo_escuta.py
##################################################

"""
Agente mínimo de acolhimento inicial.
Usa intents.json → 'ACOLHIMENTO' ou fallback genérico.
"""
from app.agents.agente_base import AgenteBase

class DomoEscuta(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        return await self._carregar_mensagem_intent("ACOLHIMENTO")


########## End Path: ./agents/domo_escuta.py ##########


##################################################
########## Path: ./agents/domo_generativo.py
##################################################

from app.agents.agente_base import AgenteBase
from app.core.ia_direct import gerar_resposta_ia

class DomoGenerativo(AgenteBase):
    async def _gerar_resposta(self, telefone, mensagem_original):
        return await gerar_resposta_ia({"tel": telefone, "msg": mensagem_original})


########## End Path: ./agents/domo_generativo.py ##########


##################################################
########## Path: ./agents/domo_integrador.py
##################################################

"""
Encapsula chamada à API WhatsApp para manter padrão único.
Outros agentes devem usar enviar_mensagem de utils.mensageria diretamente,
mas este agente permite ações administrativas (ex: envio em lote).
"""
from app.agents.agente_base import AgenteBase
from app.utils.mensageria import enviar_mensagem

class DomoIntegrador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        # Apenas ecoa mensagem administrativa (não usado no fluxo paciente)
        await enviar_mensagem(telefone, "Operação concluída.")
        return None


########## End Path: ./agents/domo_integrador.py ##########


##################################################
########## Path: ./agents/domo_comercial.py
##################################################

from __future__ import annotations
from app.agents.agente_base import AgenteBase
from app.core.scoring import score_lead
from app.utils.contexto import salvar_contexto, obter_contexto
from app.core.ia_direct import gerar_resposta_ia

PERGUNTAS = [
    "1/3 – Você procura ajuda para si ou para um familiar?",
    "2/3 – Prefere atendimento online ou presencial?",
    "3/3 – Consegue investir num cuidado profissional mensal?",
]

class DomoComercial(AgenteBase):
    async def _gerar_resposta(self, telefone: str, msg: str) -> str | None:
        ctx = obter_contexto(telefone)
        estado = ctx.get("estado", "INICIAL")
        meta = ctx.get("meta_conversa", {})
        etapa = meta.get("etapa_quali", 0)
        score = meta.get("score_lead", 0)

        # ---------------- Fluxo ----------------
        if estado == "INICIAL":
            salvar_contexto(telefone, novo_estado="MICRO", meta_conversa={"etapa_quali": 0})
            resposta = "Posso fazer 3 perguntas rápidas pra personalizar sua ajuda? 🙂"

        elif estado == "MICRO":
            if etapa < 3:
                prox = etapa + 1
                salvar_contexto(telefone, meta_conversa={"etapa_quali": prox})
                resposta = PERGUNTAS[etapa]
            else:
                score = score_lead(msg)
                salvar_contexto(
                    telefone, novo_estado="PITCH",
                    meta_conversa={"score_lead": score}
                )
                resposta = (
                    "Excelente! Recomendo o Plano Premium (R$ 199/mês). Topa conhecer?"
                    if score >= 4 else
                    "Perfeito! Temos Plano Essencial por R$ 79/mês. Quer saber mais?"
                )

        elif estado == "PITCH":
            salvar_contexto(telefone, novo_estado="CTA")
            resposta = "Segue o link de pagamento Pix instantâneo: https://pay.famdomes.com/px"

        elif estado == "CTA":
            if "sim" in msg.lower():
                salvar_contexto(telefone, novo_estado="AGUARDANDO_PAGTO")
                resposta = "Ótimo! Assim que o pagamento confirmar, começamos a triagem. 💚"
            else:
                salvar_contexto(telefone, novo_estado="RECUSA")
                resposta = "Sem problemas. Posso enviar conteúdo gratuito sobre primeiros passos?"

        else:
            resposta = None  # queda para generativo

        # ---------- Antiloop ----------
        if resposta:
            ultimo = ctx.get("ultimo_texto_bot", "")
            if resposta.strip().lower() == ultimo.strip().lower():
                resposta = await gerar_resposta_ia({"tel": telefone, "msg": msg})

        return resposta


########## End Path: ./agents/domo_comercial.py ##########


##################################################
########## Path: ./agents/domo_presenca.py
##################################################

"""
Mantém presença viva: envia mensagens breves de acompanhamento sem exigir resposta.
"""
from app.agents.agente_base import AgenteBase

class DomoPresenca(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        return await self._carregar_mensagem_intent("PRESENCA_VIVA")


########## End Path: ./agents/domo_presenca.py ##########


##################################################
########## Path: ./agents/agente_base.py
##################################################

# ===========================================================
# Arquivo: agents/agente_base.py
# Classe‑base para todos os agentes DOMO
# – carrega intents de qualquer JSON em app/intents/
# – disponibiliza utilitário de resposta por intent
# ===========================================================
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, Any, Optional

from app.core.intents import obter_intent


class AgenteBase:
    """
    Classe que todos os agentes devem herdar.
    Each agent implementa _gerar_resposta().
    """

    def __init__(self, intent: str, sentimento: Dict[str, Any] | None = None) -> None:
        self.intent = intent
        self.sentimento = sentimento or {}
        self.nome = self.__class__.__name__

    # ------------------------------------------------------
    async def executar(self, telefone: str, mensagem_original: str) -> None:
        """
        Método chamado pelo MCP. Gera texto e envia via mensageria.
        """
        from app.utils.mensageria import enviar_mensagem

        resposta = await self._gerar_resposta(telefone, mensagem_original)
        if resposta:
            await enviar_mensagem(telefone, resposta)
        else:
            # opcional: logar “não respondeu”
            import logging

            logging.info("ℹ️  %s optou por não responder (intent=%s)", self.nome, self.intent)

    # ------------------------------------------------------
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        """
        Cada agente concreto sobrescreve este método.
        Deve devolver texto pronto para enviar ou None.
        """
        raise NotImplementedError

    # ------------------------------------------------------
    async def _carregar_mensagem_intent(self, intent_id: str) -> Optional[str]:
        """
        Busca resposta em qualquer arquivo intents/*.json
        """
        intent = obter_intent(intent_id)
        return intent.get("resposta") if intent else None


########## End Path: ./agents/agente_base.py ##########


##################################################
########## Path: ./agents/domo_orientador.py
##################################################

"""
Responde dúvidas genéricas com base nas intents FAQ_*.
"""
from app.agents.agente_base import AgenteBase

class DomoOrientador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        # Mapeamento simples: intenção já contém a chave FAQ_...
        return await self._carregar_mensagem_intent(self.intent)


########## End Path: ./agents/domo_orientador.py ##########


##################################################
########## Path: ./agents/domo_escalonador.py
##################################################

"""
Detecta risco e avisa equipe humana. Não responde ao paciente.
"""
import logging, asyncio
from app.agents.agente_base import AgenteBase
from app.utils.mensageria import enviar_mensagem

logger = logging.getLogger("famdomes.escalonador")

EQUIPE_SUPORTE = ["+5511999990000"]  # ajuste para números reais

class DomoEscalonador(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        aviso = f"⚠️ Atenção: possível crise detectada do paciente {telefone}."
        await asyncio.gather(*(enviar_mensagem(dest, aviso) for dest in EQUIPE_SUPORTE))
        logger.info("Equipe humana notificada para %s", telefone)
        return None          # nada enviado ao paciente



########## End Path: ./agents/domo_escalonador.py ##########


##################################################
########## Path: ./agents/domo_followup.py
##################################################

from app.agents.agente_base import AgenteBase

class DomoFollowUp(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str):
        return await self._carregar_mensagem_intent("FOLLOW_UP_24H")


########## End Path: ./agents/domo_followup.py ##########


##################################################
########## Path: ./agents/domo_triagem.py
##################################################

"""
Aplica as 12 perguntas de triagem, persistindo cursor por telefone.
"""
from pathlib import Path
import json
from app.agents.agente_base import AgenteBase
from app.utils.contexto import obter_contexto, salvar_contexto

TRILHA_ID = "POS_TRIAGEM"
TRILHA_PATH = Path(__file__).resolve().parent.parent / "trilhas" / "trilha_pos_triagem.json"
TRILHA = json.loads(TRILHA_PATH.read_text(encoding="utf-8"))["etapas"]
TOTAL = len(TRILHA)

class DomoTriagem(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        ctx = obter_contexto(telefone)
        cursor = ctx.get("trilha_cursor", {"id": TRILHA_ID, "etapa": 0})
        if cursor["id"] != TRILHA_ID:
            cursor = {"id": TRILHA_ID, "etapa": 0}

        prox = cursor["etapa"] + 1
        if prox > TOTAL:
            # trilha concluída, muda estado
            salvar_contexto(telefone, novo_estado="TRIAGEM_CONCLUIDA", trilha_cursor=None)
            return "Obrigado! Triagem concluída. Em breve um profissional analisará suas respostas. 🙏"

        pergunta = TRILHA[str(prox)]["pergunta"]
        salvar_contexto(telefone, trilha_cursor={"id": TRILHA_ID, "etapa": prox})
        return pergunta


########## End Path: ./agents/domo_triagem.py ##########


##################################################
########## Path: ./agents/domo_monitor.py
##################################################

"""
Avalia padrão emocional ao longo do tempo e decide escalonar ou ajustar trilha.
Por ora, apenas registra – sem resposta.
"""
from app.agents.agente_base import AgenteBase
from app.core.rastreamento import registrar_evento

class DomoMonitor(AgenteBase):
    async def _gerar_resposta(self, telefone: str, mensagem_original: str) -> str | None:
        registrar_evento(telefone, etapa="monitor", dados=self.sentimento)
        return None



########## End Path: ./agents/domo_monitor.py ##########


##################################################
########## Path: ./models/pagamentos.py
##################################################

from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str


########## End Path: ./models/pagamentos.py ##########


##################################################
########## Path: ./models/atendimento.py
##################################################

from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str


########## End Path: ./models/atendimento.py ##########


##################################################
########## Path: ./models/leads.py
##################################################

from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"


########## End Path: ./models/leads.py ##########


##################################################
########## Path: ./config.py
##################################################

"""
Configurações centralizadas usando Pydantic.
Qualquer módulo deve importar a instância `settings`
em vez de ler variáveis de ambiente diretamente.
"""
import os
from functools import lru_cache
from pathlib import Path
from pydantic_settings import BaseSettings
from pydantic import Field, AnyHttpUrl,ConfigDict

class Settings(BaseSettings):
    # ➜ Aceita variáveis extras e carrega .env
    model_config = ConfigDict(
        extra='allow',               
        env_file='.env',
        env_file_encoding='utf-8',
        case_sensitive=True,
    )
# ─── Novas linhas ───
    BASE_DIR: str = Field(
        default=str(Path(__file__).resolve().parent), env="BASE_DIR"
    )
    
   
    API_PORT: int = Field(8000, env="API_PORT")
    LOG_LEVEL: str = Field("INFO", env="LOG_LEVEL")

    MONGO_URI: str = Field(..., env="MONGO_URI")

    WHATSAPP_API_URL: AnyHttpUrl = Field(..., env="WHATSAPP_API_URL")
    WHATSAPP_TOKEN: str = Field(..., env="WHATSAPP_TOKEN")

    OLLAMA_API_URL: AnyHttpUrl = Field(..., env="OLLAMA_API_URL")
    OLLAMA_MODEL: str = Field("gemma:3b", env="OLLAMA_MODEL")

    MCP_TIMEOUT_S: int = Field(10, env="MCP_TIMEOUT_S")

@lru_cache
def _cached_settings() -> Settings:
    return Settings()

settings: Settings = _cached_settings()

globals().update({k: getattr(settings, k) for k in dir(settings) if k.isupper()})

@lru_cache
def _cached_settings() -> Settings:
    return Settings()

settings: Settings = _cached_settings()

globals().update({k: v for k, v in settings.model_dump().items()})
# --------------

########## End Path: ./config.py ##########


##################################################
########## Path: ./core/intents.py
##################################################

# ===========================================================
# carrega e pesquisa intents de TODOS os arquivos .json
# ===========================================================
from __future__ import annotations
from pathlib import Path
import json, re, difflib
from functools import lru_cache
from typing import Dict, Any, Tuple

PASTA = Path(__file__).resolve().parents[1] / "intents"
RGX_CLEAN = re.compile(r"[^a-z0-9 ]")

def _normalizar(txt: str) -> str:
    return RGX_CLEAN.sub("", txt.casefold())

@lru_cache
def _carga() -> Dict[str, Dict[str, Any]]:
    dados: Dict[str, Dict[str, Any]] = {}
    for arq in PASTA.glob("*.json"):
        with arq.open(encoding="utf-8") as f:
            dados.update(json.load(f))
    # index de triggers normalizados
    for k, v in dados.items():
        v["triggers_norm"] = [_normalizar(t) for t in v.get("triggers", [])]
    return dados

# ---------- API pública ----------
def obter_intent(id_intent: str) -> Dict[str, Any] | None:
    return _carga().get(id_intent)

def buscar_por_trigger(texto: str, limiar: float = 0.75) -> Tuple[str | None, float]:
    txt_norm = _normalizar(texto)
    melhor, score = None, 0.0
    for intent_id, info in _carga().items():
        for trg in info["triggers_norm"]:
            if not trg:
                continue
            s = difflib.SequenceMatcher(None, txt_norm, trg).ratio()
            if s > score:
                melhor, score = intent_id, s
    return (melhor, score) if score >= limiar else (None, score)


########## End Path: ./core/intents.py ##########


##################################################
########## Path: ./core/scoring.py
##################################################

"""
Score simples de lead (0‑6) para escolher pitch.
"""
import re

PAT_URGENCIA = re.compile(r"\b(crise|desesperad[oa]|suic[ií]dio)\b", re.I)
PAT_PAGANTE  = re.compile(r"\b(cart[aã]o|pix|particular)\b", re.I)
PAT_NEG_PRECO = re.compile(r"\b(caro|muito caro|sem dinheiro|nao posso)\b", re.I)

def score_lead(texto: str) -> int:
    s = 0
    if PAT_URGENCIA.search(texto):
        s += 3
    if PAT_PAGANTE.search(texto):
        s += 2
    if PAT_NEG_PRECO.search(texto):
        s -= 2
    return max(0, min(6, s))


########## End Path: ./core/scoring.py ##########


##################################################
########## Path: ./core/ia_direct.py
##################################################

# ===========================================================
# Gera resposta alternativa curta via Ollama local
# ===========================================================
from __future__ import annotations
import httpx, logging
from app.config import settings

logger = logging.getLogger("famdomes.ia-fallback")

async def gerar_resposta_ia(contexto: dict) -> str:
    prompt = (
        "Você é um vendedor empático. Responda em até 140 caracteres, "
        "sem jargões técnicos, incentivando o próximo passo.\n\n"
        f"{contexto}\nResposta:"
    )
    body = {"model": settings.OLLAMA_MODEL, "prompt": prompt, "stream": False}

    try:
        async with httpx.AsyncClient(timeout=20, follow_redirects=True) as cli:
            r = await cli.post(f"{settings.OLLAMA_API_URL.rstrip('/')}/api/generate", json=body)
            r.raise_for_status()
            return r.json().get("response", "").strip()
    except Exception as exc:
        logger.warning("IA-fallback falhou: %s", exc)
        return "Entendo! Quer mais detalhes ou ajuda humana?"


########## End Path: ./core/ia_direct.py ##########


##################################################
########## Path: ./core/rastreamento.py
##################################################

"""
Persistência de logs de decisão e telemetria.
"""
from datetime import datetime, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

mongo = MongoClient(MONGO_URI)
col_eventos = mongo["famdomes"]["eventos"]

logger = logging.getLogger("famdomes.trace")

def registrar_evento(telefone: str, *, etapa: str, dados: dict) -> None:
    doc = {
        "telefone": telefone,
        "etapa": etapa,
        "dados": dados,
        "timestamp": datetime.now(timezone.utc),
    }
    try:
        col_eventos.insert_one(doc)
    except Exception as exc:  # pragma: no cover
        logger.warning("Falha ao gravar evento em MongoDB: %s", exc)


########## End Path: ./core/rastreamento.py ##########


##################################################
########## Path: ./core/mcp_orquestrador.py
##################################################

# ===========================================================
# Orquestrador principal – versão completa com:
# • fuzzy trigger antes da IA
# • guard‑rail triagem
# • scoring lead
# • fallback generativo
# ===========================================================
from __future__ import annotations
import logging
from importlib import import_module
from typing import Dict, Type

from app.core.ia_analisador import detectar_intencao, analisar_sentimento
from app.core.intents import buscar_por_trigger
from app.core.scoring import score_lead
from app.utils.contexto import obter_contexto, salvar_contexto
from app.core.rastreamento import registrar_evento
from app.agents.agente_base import AgenteBase

logger = logging.getLogger("famdomes.mcp")

_INTENT_MAP: Dict[str, str] = {
    # clínicas
    "ACOLHIMENTO": "app.agents.domo_escuta.DomoEscuta",
    "PRESENCA_VIVA": "app.agents.domo_presenca.DomoPresenca",
    "TRIAGEM_INICIAL": "app.agents.domo_triagem.DomoTriagem",
    "ESCALONAR_HUMANO": "app.agents.domo_escalonador.DomoEscalonador",
    # comerciais
    "MICRO_COMPROMISSO": "app.agents.domo_comercial.DomoComercial",
    "PITCH_PLANO3": "app.agents.domo_comercial.DomoComercial",
    "PITCH_PLANO1": "app.agents.domo_comercial.DomoComercial",
    "CALL_TO_ACTION": "app.agents.domo_comercial.DomoComercial",
    "RECUSA_PRECO": "app.agents.domo_comercial.DomoComercial",
    # FAQ
    "FAQ_COMO_FUNCIONA": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_PAGAMENTO": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_CANCELAMENTO": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_ROBO": "app.agents.domo_orientador.DomoOrientador",
    # fallback
    "DEFAULT": "app.agents.domo_generativo.DomoGenerativo",
}

class MCPOrquestrador:
    _inst: "MCPOrquestrador | None" = None
    def __new__(cls):
        if not cls._inst:
            cls._inst = super().__new__(cls)
        return cls._inst

    # ------------------------------------------------------
    async def processar_mensagem(self, tel: str, texto: str) -> None:
        logger.info("MCP ▶ tel=%s texto=%s", tel, texto)
        ctx = obter_contexto(tel)
        estado = ctx.get("estado", "INICIAL")

        # 1. fuzzy trigger
        intent, _ = buscar_por_trigger(texto.lower())

        # 2. IA se necessário
        if not intent:
            intent = await detectar_intencao(texto)

        # 3. guard‑rails
        if intent == "ACOLHIMENTO":
            intent = "MICRO_COMPROMISSO"
        if intent == "TRIAGEM_INICIAL" and ctx.get("estado") != "PAGAMENTO_OK":
            intent = "FAQ_COMO_FUNCIONA"

        # 4. sentimento + score
        sentimento = await analisar_sentimento(texto)
        s_lead = score_lead(texto) if estado in {"INICIAL", "MICRO"} else ctx.get("meta_conversa", {}).get("score_lead", 0)
        salvar_contexto(tel, texto=texto, meta_conversa={"score_lead": s_lead})
        registrar_evento(tel, etapa="análise", dados={"intent": intent, "score": s_lead})

        # 5. agente
        agente_cls = self._resolver_agente(intent)
        agente: AgenteBase = agente_cls(intent=intent, sentimento=sentimento)

        try:
            await agente.executar(tel, texto)
            registrar_evento(tel, etapa="execução", dados={"agente": agente.nome})
        except Exception as exc:
            logger.exception("MCP erro %s", exc)
            registrar_evento(tel, etapa="erro", dados={"err": str(exc)})

    # ------------------------------------------------------
    def _resolver_agente(self, intent: str) -> Type[AgenteBase]:
        caminho = _INTENT_MAP.get(intent, _INTENT_MAP["DEFAULT"])
        mod_path, _, cls_name = caminho.rpartition(".")
        return getattr(import_module(mod_path), cls_name)


########## End Path: ./core/mcp_orquestrador.py ##########


##################################################
########## Path: ./core/scheduler.py
##################################################

"""
Scheduler assíncrono (apscheduler) para tarefas recorrentes.
"""
import asyncio, logging
from datetime import datetime, timedelta, timezone
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from app.utils.contexto import obter_contexto
from app.agents.domo_followup import DomoFollowUp

logger = logging.getLogger("famdomes.scheduler")
sched = AsyncIOScheduler()

async def _job_followup():
    limite = datetime.now(timezone.utc) - timedelta(hours=24)
    from pymongo import MongoClient
    from app.config import MONGO_URI
    mongo = MongoClient(MONGO_URI)
    col = mongo["famdomes"]["contextos"]

    # contexto em PITCH ou CTA sem pagamento há >24 h
    filtro = {
        "estado": {"$in": ["PITCH", "CTA"]},
        "ts": {"$lt": limite}
    }
    for ctx in col.find(filtro):
        tel = ctx["tel"]
        logger.info("Follow‑up 24 h → %s", tel)
        await DomoFollowUp(intent="FOLLOW_UP_24H").executar(telefone=tel, mensagem_original="")

def iniciar():
    sched.add_job(_job_followup, "interval", hours=1, id="followup24h")
    sched.start()


########## End Path: ./core/scheduler.py ##########


##################################################
########## Path: ./core/metrics.py
##################################################

"""
Coleta KPIs e expõe para Prometheus + JSON.
"""
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from prometheus_client import Gauge, generate_latest, CONTENT_TYPE_LATEST

from app.config import MONGO_URI

# ---------- Gauges ----------
LEADS         = Gauge("domo_leads_total", "Leads captados nas últimas 24h")
QUALIFICADOS  = Gauge("domo_qualificados_total", "Leads com score >=2 últimas 24h")
PAGOS         = Gauge("domo_pagamentos_total", "Pagamentos confirmados últimas 24h")
TEMPO_PG_SECS = Gauge("domo_tempo_medio_pg_segundos", "Tempo médio lead→pagamento (s)")

# ---------- Coleta ----------
def atualizar():
    mongo = MongoClient(MONGO_URI)
    ctx   = mongo["famdomes"]["contextos"]

    ini = datetime.now(timezone.utc) - timedelta(days=1)

    # Leads = primeira interação nas 24h
    leads = ctx.count_documents({"ts": {"$gt": ini}, "interacoes": 1})
    LEADS.set(leads)

    # Qualificados = score_lead >=2
    qual = ctx.count_documents({"ts": {"$gt": ini}, "meta_conversa.score_lead": {"$gte": 2}})
    QUALIFICADOS.set(qual)

    # Pagos
    pagos = ctx.count_documents({"ts": {"$gt": ini}, "estado": "PAGAMENTO_OK"})
    PAGOS.set(pagos)

    # Tempo médio até pagamento
    pipeline = [
        {"$match": {"estado": "PAGAMENTO_OK", "ts": {"$gt": ini}}},
        {"$project": {"delta": {"$subtract": ["$ts", "$criado_em"]}}},
        {"$group": {"_id": None, "avg": {"$avg": "$delta"}}},
    ]
    res = list(ctx.aggregate(pipeline))
    TEMPO_PG_SECS.set(res[0]["avg"] / 1000 if res else 0)  # ms→s

def prometheus_response():
    atualizar()
    return generate_latest(), CONTENT_TYPE_LATEST

def json_response():
    atualizar()
    return {
        "leads": LEADS.collect()[0].samples[0].value,
        "qualificados": QUALIFICADOS.collect()[0].samples[0].value,
        "pagamentos": PAGOS.collect()[0].samples[0].value,
        "tempo_medio_pg_s": TEMPO_PG_SECS.collect()[0].samples[0].value,
    }


########## End Path: ./core/metrics.py ##########


##################################################
########## Path: ./core/ia_analisador.py
##################################################

# ===========================================================
# Arquivo: core/ia_analisador.py
# ===========================================================
from __future__ import annotations

import httpx, json, logging
from typing import Dict
from app.config import settings

logger = logging.getLogger("famdomes.ia")


async def _chamar_ollama(prompt: str) -> str | None:
    url = f"{str(settings.OLLAMA_API_URL).rstrip('/')}/api/generate"
    body = {"model": settings.OLLAMA_MODEL, "prompt": prompt, "stream": False}

    try:
        async with httpx.AsyncClient(timeout=settings.MCP_TIMEOUT_S) as cli:
            resp = await cli.post(url, json=body)
        resp.raise_for_status()
        return resp.json().get("response")
    except Exception as exc:  # pragma: no cover
        logger.warning("OLLAMA: ❌ %s", exc)
        return None


async def detectar_intencao(texto: str) -> str:
    sistema = (
        "Você é um classificador. Responda SOMENTE com uma "
        "das opções: ESCALONAR_HUMANO, TRIAGEM_INICIAL, PRESENCA_VIVA, ACOLHIMENTO."
    )
    resp = await _chamar_ollama(f"{sistema}\n\nUsuário: {texto}\nIntenção:")
    intent = (resp or "").strip().split()[0].upper()
    return intent if intent in {"ESCALONAR_HUMANO", "TRIAGEM_INICIAL", "PRESENCA_VIVA"} else "ACOLHIMENTO"


async def analisar_sentimento(texto: str) -> Dict[str, float]:
    prompt = (
        "Avalie o sentimento do texto em JSON no formato "
        "{'positivo':0‑1,'negativo':0‑1,'neutro':0‑1}:\n" + texto
    )
    resp = await _chamar_ollama(prompt)
    try:
        dados = json.loads(resp) if resp else {}
        if all(k in dados for k in ("positivo", "negativo", "neutro")):
            return dados
    except Exception:
        pass
    logger.warning("Sentimento inválido – usando fallback neutro.")
    return {"positivo": 0.33, "negativo": 0.33, "neutro": 0.34}


########## End Path: ./core/ia_analisador.py ##########



# Arquivo: app/models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Arquivo: app/models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Arquivo: app/models/leads.py
from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"

# Arquivo: app/config.py
"""
Configurações centralizadas usando Pydantic.
Qualquer módulo deve importar a instância `settings`
em vez de ler variáveis de ambiente diretamente.
"""
import os
from functools import lru_cache
from pathlib import Path
from pydantic_settings import BaseSettings
from pydantic import Field, AnyHttpUrl,ConfigDict

class Settings(BaseSettings):
    # ➜ Aceita variáveis extras e carrega .env
    model_config = ConfigDict(
        extra='allow',               
        env_file='.env',
        env_file_encoding='utf-8',
        case_sensitive=True,
    )
# ─── Novas linhas ───
    BASE_DIR: str = Field(
        default=str(Path(__file__).resolve().parent), env="BASE_DIR"
    )
    
   
    API_PORT: int = Field(8000, env="API_PORT")
    LOG_LEVEL: str = Field("INFO", env="LOG_LEVEL")

    MONGO_URI: str = Field(..., env="MONGO_URI")

    WHATSAPP_API_URL: AnyHttpUrl = Field(..., env="WHATSAPP_API_URL")
    WHATSAPP_TOKEN: str = Field(..., env="WHATSAPP_TOKEN")

    OLLAMA_API_URL: AnyHttpUrl = Field(..., env="OLLAMA_API_URL")
    OLLAMA_MODEL: str = Field("gemma:3b", env="OLLAMA_MODEL")

    MCP_TIMEOUT_S: int = Field(10, env="MCP_TIMEOUT_S")

@lru_cache
def _cached_settings() -> Settings:
    return Settings()

settings: Settings = _cached_settings()

globals().update({k: getattr(settings, k) for k in dir(settings) if k.isupper()})

@lru_cache
def _cached_settings() -> Settings:
    return Settings()

settings: Settings = _cached_settings()

globals().update({k: v for k, v in settings.model_dump().items()})
# --------------
# Arquivo: app/codigos_famdomes.txt


# ===== ./utils/faq_respostas.py =====



# ===== ./utils/questionario_pos_pagamento.py =====



# ===== ./utils/ollama.py =====



# ===== ./utils/prompt_builder.py =====



# ===== ./utils/mensageria.py =====



# ===== ./utils/contexto.py =====



# ===== ./utils/nlp.py =====



# ===== ./utils/risco.py =====



# ===== ./utils/agenda.py =====



# ===== ./utils/leads.py =====



# ===== ./utils/ia_fallback.py =====



# ===== ./utils/followup.py =====



# ===== ./schemas/ia_comando.py =====



# ===== ./routes/resetar.py =====



# ===== ./routes/pagamentos.py =====



# ===== ./routes/painel.py =====



# ===== ./routes/nlp.py =====



# ===== ./routes/stripe.py =====



# ===== ./routes/rocketchat.py =====



# ===== ./routes/agendamento.py =====



# ===== ./routes/whatsapp.py =====



# ===== ./routes/ia.py =====



# ===== ./routes/followup.py =====



# ===== ./main.py =====



# ===== ./models/pagamentos.py =====



# ===== ./models/atendimento.py =====



# ===== ./models/leads.py =====



# ===== ./config.py =====


# Arquivo: app/trilhas/trilha_presenca_viva.json
{
  "nome": "Presença Viva",
  "etapas": {
    "1": { "mensagem": "Estou aqui com você. Respire fundo. 🌱" },
    "2": { "mensagem": "Como passaram as últimas horas? Se quiser conversar, estou pronto." },
    "3": { "mensagem": "Lembrando: cada passo conta. Você não está só." }
  }
}

# Arquivo: app/trilhas/trilha_pos_triagem.json
{
  "nome": "Triagem Pós‑Pagamento",
  "etapas": {
    "1":  { "pergunta": "Você já foi diagnosticado anteriormente por um profissional? Se sim, qual diagnóstico?" },
    "2":  { "pergunta": "Está em tratamento ou usando medicação atualmente? Qual?" },
    "3":  { "pergunta": "Com que frequência consome substâncias (álcool, drogas, jogo, etc.)?" },
    "4":  { "pergunta": "Já tentou parar ou reduzir antes? O que aconteceu?" },
    "5":  { "pergunta": "Existe histórico familiar de dependência ou transtornos mentais?" },
    "6":  { "pergunta": "Qual foi o gatilho mais recente para o consumo ou crise?" },
    "7":  { "pergunta": "Tem rede de apoio hoje (família, amigos)?" },
    "8":  { "pergunta": "Como está seu sono e alimentação nas últimas semanas?" },
    "9":  { "pergunta": "Você sente ideação suicida ou pensamentos de automutilação?" },
    "10": { "pergunta": "Alguma condição médica que devamos considerar?" },
    "11": { "pergunta": "Quais são suas maiores metas ou preocupações neste momento?" },
    "12": { "pergunta": "Como prefere que o cuidado aconteça: online, presencial ou híbrido?" }
  }
}

# Arquivo: app/trilhas/trilha_acolhimento.json
{
  "nome": "Acolhimento Inicial",
  "etapas": {
    "1": { "pergunta": "Como você está se sentindo agora?" },
    "2": { "pergunta": "Quer me contar um pouco do que te trouxe aqui hoje?" }
  }
}

# Arquivo: app/core/auth.py
# ===========================================================
# Arquivo: app/core/auth.py
# Implementa autenticação básica.
# ATENÇÃO: NÃO USE USUÁRIO/SENHA FIXOS EM PRODUÇÃO!
# Adicionado logging para depuração do erro 401.
# CORRIGIDO: Indentação do bloco try/except e definição final de classe.
# ===========================================================
import os
import logging # Adicionado para logs
from datetime import datetime, timedelta, timezone
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext

# Importa dos schemas (garanta que o caminho está correto)
try:
    from app.schemas.dashboard import User, UserInDB, Token
# CORREÇÃO: Indentação do except e das classes fallback
except ImportError:
    # Fallback ou log de erro se o import falhar
    logging.critical("AUTH: Falha ao importar schemas de app.schemas.dashboard")
    # Definições básicas para evitar erros, mas idealmente corrigir o import
    # Indentação correta para as classes dentro do except
    class User:
        username: str
        disabled: Optional[bool] = None
    class UserInDB(User):
        hashed_password: str
    class Token:
        access_token: str
        token_type: str


logger = logging.getLogger("famdomes.auth") # Logger específico

# --- Configuração ---
SECRET_KEY = os.getenv("DASHBOARD_SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7") # Mantenha esta chave segura!
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("DASHBOARD_TOKEN_EXPIRE_MINUTES", 60 * 24)) # 1 dia

# --- Banco de Dados Falso de Usuários ---
# ATENÇÃO: Substitua o valor de "hashed_password" pelo HASH GERADO NO TERMINAL!
FAKE_USERS_DB = {
    "admin": {
        "username": "admin",
        # COLE O HASH GERADO AQUI DENTRO DAS ASPAS:
        "hashed_password": "$2b$12$EixZaYVK1fsbwAp2rqm.y.eMAx2z1.PNgQOfnS2z5.l3N4fZtQmGO", # <--- SUBSTITUA ESTE VALOR!!!
        "disabled": False,
    }
}

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/dashboard/token") # Rota de login no backend

# --- Funções de Autenticação ---

def verify_password(plain_password, hashed_password):
    logger.debug("Verificando senha...")
    try:
        result = pwd_context.verify(plain_password, hashed_password)
        logger.debug(f"Resultado da verificação da senha: {result}")
        return result
    except Exception as e:
        logger.error(f"Erro durante verify_password: {e}")
        return False

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(username: str) -> Optional[UserInDB]:
    logger.debug(f"Buscando usuário: {username}")
    if username in FAKE_USERS_DB:
        user_dict = FAKE_USERS_DB[username]
        logger.debug(f"Usuário '{username}' encontrado no DB falso.")
        # Retorna um objeto UserInDB (assumindo que foi importado ou definido no fallback)
        return UserInDB(username=user_dict["username"], hashed_password=user_dict["hashed_password"], disabled=user_dict["disabled"])
    logger.debug(f"Usuário '{username}' NÃO encontrado no DB falso.")
    return None

def authenticate_user(username: str, password: str) -> Optional[User]:
    logger.info(f"Tentando autenticar usuário: {username}")
    user = get_user(username)
    if not user:
        logger.warning(f"Autenticação falhou: Usuário '{username}' não encontrado.")
        return None
    # Acessa o atributo 'disabled' do objeto user
    if user.disabled:
         logger.warning(f"Autenticação falhou: Usuário '{username}' está desabilitado.")
         return None

    # Acessa o atributo 'hashed_password' do objeto user
    if not verify_password(password, user.hashed_password):
        logger.warning(f"Autenticação falhou: Senha incorreta para usuário '{username}'.")
        return None

    logger.info(f"Usuário '{username}' autenticado com sucesso.")
    # Retorna um objeto User (sem o hash)
    return User(username=user.username, disabled=user.disabled)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_active_user(token: str = Depends(oauth2_scheme)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: Optional[str] = payload.get("sub")
        if username is None:
            logger.warning("Token JWT inválido: sem 'sub' (username).")
            raise credentials_exception
    except JWTError as e:
        logger.warning(f"Erro ao decodificar token JWT: {e}")
        raise credentials_exception from e

    user = get_user(username=username)
    if user is None:
        logger.warning(f"Token válido, mas usuário '{username}' não encontrado no sistema.")
        raise credentials_exception
    if user.disabled:
         logger.warning(f"Token válido, mas usuário '{username}' está desabilitado.")
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    # Retorna um objeto User
    return User(username=user.username, disabled=user.disabled)

# CORREÇÃO: Bloco final para definir UserInDB se a importação falhou
# Garante que a verificação e a definição da classe estejam no nível superior do módulo (sem indentação extra)
try:
    # Verifica se UserInDB foi importado corretamente e é uma classe
    if not isinstance(UserInDB, type) or not issubclass(UserInDB, User):
        # Se não foi importado corretamente ou não é subclasse, define o fallback
        logger.warning("AUTH: UserInDB não importado corretamente ou inválido. Definindo fallback.")
        class UserInDB(User):
             hashed_password: str
except NameError:
     # Se UserInDB nem sequer está definido (ImportError grave)
     logger.error("AUTH: UserInDB não está definido. Definindo fallback.")
     class UserInDB(User):
          hashed_password: str


# Arquivo: app/core/init.py

# Arquivo: app/core/intents.py
# ===========================================================
# carrega e pesquisa intents de TODOS os arquivos .json
# ===========================================================
from __future__ import annotations
from pathlib import Path
import json, re, difflib
from functools import lru_cache
from typing import Dict, Any, Tuple

PASTA = Path(__file__).resolve().parents[1] / "intents"
RGX_CLEAN = re.compile(r"[^a-z0-9 ]")

def _normalizar(txt: str) -> str:
    return RGX_CLEAN.sub("", txt.casefold())

@lru_cache
def _carga() -> Dict[str, Dict[str, Any]]:
    dados: Dict[str, Dict[str, Any]] = {}
    for arq in PASTA.glob("*.json"):
        with arq.open(encoding="utf-8") as f:
            dados.update(json.load(f))
    # index de triggers normalizados
    for k, v in dados.items():
        v["triggers_norm"] = [_normalizar(t) for t in v.get("triggers", [])]
    return dados

# ---------- API pública ----------
def obter_intent(id_intent: str) -> Dict[str, Any] | None:
    return _carga().get(id_intent)

def buscar_por_trigger(texto: str, limiar: float = 0.75) -> Tuple[str | None, float]:
    txt_norm = _normalizar(texto)
    melhor, score = None, 0.0
    for intent_id, info in _carga().items():
        for trg in info["triggers_norm"]:
            if not trg:
                continue
            s = difflib.SequenceMatcher(None, txt_norm, trg).ratio()
            if s > score:
                melhor, score = intent_id, s
    return (melhor, score) if score >= limiar else (None, score)

# Arquivo: app/core/scoring.py
"""
Score simples de lead (0‑6) para escolher pitch.
"""
import re

PAT_URGENCIA = re.compile(r"\b(crise|desesperad[oa]|suic[ií]dio)\b", re.I)
PAT_PAGANTE  = re.compile(r"\b(cart[aã]o|pix|particular)\b", re.I)
PAT_NEG_PRECO = re.compile(r"\b(caro|muito caro|sem dinheiro|nao posso)\b", re.I)

def score_lead(texto: str) -> int:
    s = 0
    if PAT_URGENCIA.search(texto):
        s += 3
    if PAT_PAGANTE.search(texto):
        s += 2
    if PAT_NEG_PRECO.search(texto):
        s -= 2
    return max(0, min(6, s))

# Arquivo: app/core/ia_direct.py
# ===========================================================
# Gera resposta alternativa curta via Ollama local
# ===========================================================
from __future__ import annotations
import httpx, logging
from app.config import settings

logger = logging.getLogger("famdomes.ia-fallback")

async def gerar_resposta_ia(contexto: dict) -> str:
    prompt = (
        "Você é um vendedor empático. Responda em até 140 caracteres, "
        "sem jargões técnicos, incentivando o próximo passo.\n\n"
        f"{contexto}\nResposta:"
    )
    body = {"model": settings.OLLAMA_MODEL, "prompt": prompt, "stream": False}

    try:
        async with httpx.AsyncClient(timeout=20, follow_redirects=True) as cli:
            r = await cli.post(f"{settings.OLLAMA_API_URL.rstrip('/')}/api/generate", json=body)
            r.raise_for_status()
            return r.json().get("response", "").strip()
    except Exception as exc:
        logger.warning("IA-fallback falhou: %s", exc)
        return "Entendo! Quer mais detalhes ou ajuda humana?"

# Arquivo: app/core/rastreamento.py
"""
Persistência de logs de decisão e telemetria.
"""
from datetime import datetime, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

mongo = MongoClient(MONGO_URI)
col_eventos = mongo["famdomes"]["eventos"]

logger = logging.getLogger("famdomes.trace")

def registrar_evento(telefone: str, *, etapa: str, dados: dict) -> None:
    doc = {
        "telefone": telefone,
        "etapa": etapa,
        "dados": dados,
        "timestamp": datetime.now(timezone.utc),
    }
    try:
        col_eventos.insert_one(doc)
    except Exception as exc:  # pragma: no cover
        logger.warning("Falha ao gravar evento em MongoDB: %s", exc)

# Arquivo: app/core/mcp_orquestrador.py
# ===========================================================
# Arquivo: core/mcp_orquestrador.py
# Orquestrador principal – versão aprimorada com:
# • Passagem de sentimento para agentes
# • Análise de sentimento mais consistente
# • Melhor tratamento de estado inicial e fallback
# • Chamada de agente com mensagem original
# • Tratamento de erro mais robusto
# • CORRIGIDO: Chamada para salvar_contexto com argumento 'estado' correto.
# ===========================================================
from __future__ import annotations
import logging
from importlib import import_module
from typing import Dict, Type, Any

# Funções core e utils
from app.core.ia_analisador import detectar_intencao, analisar_sentimento
from app.core.intents import buscar_por_trigger, obter_intent
from app.core.scoring import score_lead
from app.utils.contexto import obter_contexto, salvar_contexto
from app.core.rastreamento import registrar_evento
from app.utils.mensageria import enviar_mensagem # Para fallback de erro

# Classe base do agente
from app.agents.agente_base import AgenteBase

logger = logging.getLogger("famdomes.mcp")

# Mapeamento de Intents para Classes de Agentes (Manter atualizado)
_INTENT_MAP: Dict[str, str] = {
    # Clínicas / Acolhimento
    "ACOLHIMENTO": "app.agents.domo_escuta.DomoEscuta",
    "PRESENCA_VIVA": "app.agents.domo_presenca.DomoPresenca",
    "TRIAGEM_INICIAL": "app.agents.domo_triagem.DomoTriagem", # Disparado após pagamento
    "ESCALONAR_HUMANO": "app.agents.domo_escalonador.DomoEscalonador", # Ou intent específica de risco
    "RISCO_DETECTADO": "app.agents.domo_escalonador.DomoEscalonador", # Se usar intent de risco

    # Comerciais / Vendas
    "MICRO_COMPROMISSO": "app.agents.domo_comercial.DomoComercial",
    "PITCH_PLANO3": "app.agents.domo_comercial.DomoComercial",
    "PITCH_PLANO1": "app.agents.domo_comercial.DomoComercial",
    "CALL_TO_ACTION": "app.agents.domo_comercial.DomoComercial",
    "RECUSA_PRECO": "app.agents.domo_comercial.DomoComercial",
    "COMERCIAL_DETALHES_PLANO": "app.agents.domo_comercial.DomoComercial",

    # Follow-up (Disparado pelo Scheduler ou outras lógicas)
    "FOLLOW_UP_QUALIFICACAO": "app.agents.domo_followup.DomoFollowUp",
    "FOLLOW_UP_24H": "app.agents.domo_followup.DomoFollowUp", # Follow-up de pagamento

    # FAQ / Orientação
    "FAQ_COMO_FUNCIONA": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_PAGAMENTO": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_CANCELAMENTO": "app.agents.domo_orientador.DomoOrientador",
    "FAQ_ROBO": "app.agents.domo_orientador.DomoOrientador",
    # Adicionar outras intents FAQ mapeadas para DomoOrientador
    "INTENT_091": "app.agents.domo_orientador.DomoOrientador", # FAQ Internação
    "INTENT_097": "app.agents.domo_orientador.DomoOrientador", # FAQ Sigilo
    "INTENT_036": "app.agents.domo_orientador.DomoOrientador", # FAQ Internação Involuntária
    # ... mapear outras intents de FAQ ...

    # Default / Generativo / Fallback
    "DEFAULT": "app.agents.domo_generativo.DomoGenerativo",
    # Mapear intents não-FAQ que devem ir para o generativo
    "INTENT_001": "app.agents.domo_generativo.DomoGenerativo",
    "INTENT_006": "app.agents.domo_generativo.DomoGenerativo",
    "INTENT_271": "app.agents.domo_generativo.DomoGenerativo",
    "INTENT_273": "app.agents.domo_generativo.DomoGenerativo",
    "INTENT_276": "app.agents.domo_generativo.DomoGenerativo",
    "INTENT_278": "app.agents.domo_generativo.DomoGenerativo", # Não falar agora -> IA pode dar espaço
    "INTENT_280": "app.agents.domo_generativo.DomoGenerativo", # Desaparecer -> IA pode acolher
    "INTENT_281": "app.agents.domo_generativo.DomoGenerativo", # Recomeçar
    "INTENT_283": "app.agents.domo_generativo.DomoGenerativo", # Fugir
    "INTENT_285": "app.agents.domo_generativo.DomoGenerativo", # Agradecimento -> IA responde
    "INTENT_241": "app.agents.domo_generativo.DomoGenerativo", # Cuidado físico -> IA orienta
    "INTENT_246": "app.agents.domo_generativo.DomoGenerativo", # Desesperança -> IA acolhe
    "INTENT_249": "app.agents.domo_generativo.DomoGenerativo", # Travado -> IA valida
    "INTENT_251": "app.agents.domo_generativo.DomoGenerativo", # Parar cigarro -> IA apoia
    "INTENT_254": "app.agents.domo_generativo.DomoGenerativo", # Rotina saudável -> IA incentiva
    "INTENT_256": "app.agents.domo_generativo.DomoGenerativo", # Nada resta -> IA acolhe
    "INTENT_258": "app.agents.domo_generativo.DomoGenerativo", # Culpa/sujeira -> IA acolhe
    "INTENT_211": "app.agents.domo_generativo.DomoGenerativo", # Recaída -> IA acolhe
    "INTENT_216": "app.agents.domo_generativo.DomoGenerativo", # Autoestima baixa -> IA valida
    "INTENT_220": "app.agents.domo_generativo.DomoGenerativo", # Resolver sozinho -> IA valida/oferece ajuda
    "INTENT_222": "app.agents.domo_generativo.DomoGenerativo", # Vontade de usar -> IA acolhe/oferece ajuda
    "INTENT_224": "app.agents.domo_generativo.DomoGenerativo", # Planos futuros -> IA incentiva
    "INTENT_226": "app.agents.domo_generativo.DomoGenerativo", # Vício como companhia -> IA acolhe
    "INTENT_228": "app.agents.domo_generativo.DomoGenerativo", # Falha em terapia -> IA valida/oferece nova chance
    "INTENT_181": "app.agents.domo_generativo.DomoGenerativo", # Brigas -> IA acolhe/oferece escuta
    "INTENT_186": "app.agents.domo_generativo.DomoGenerativo", # Quero ajudar -> IA orienta
    "INTENT_189": "app.agents.domo_generativo.DomoGenerativo", # Você é esperto? -> IA responde
    "INTENT_151": "app.agents.domo_generativo.DomoGenerativo", # Trauma religioso -> IA acolhe
    "INTENT_153": "app.agents.domo_generativo.DomoGenerativo", # Você sente? -> IA responde
    "INTENT_155": "app.agents.domo_generativo.DomoGenerativo", # Descrença -> IA valida/oferece alternativa
    "INTENT_157": "app.agents.domo_generativo.DomoGenerativo", # Recaída frequente -> IA acolhe
    "INTENT_159": "app.agents.domo_generativo.DomoGenerativo", # Quero acertar -> IA incentiva
    "INTENT_161": "app.agents.domo_generativo.DomoGenerativo", # Insônia -> IA oferece técnica/escuta
    "INTENT_163": "app.agents.domo_generativo.DomoGenerativo", # Reza por mim -> IA responde com respeito
    "INTENT_165": "app.agents.domo_generativo.DomoGenerativo", # Me distrai -> IA oferece história
    "INTENT_121": "app.agents.domo_generativo.DomoGenerativo", # Ansiedade -> IA acolhe
    "INTENT_126": "app.agents.domo_generativo.DomoGenerativo", # Ajuda casal -> IA orienta
    "INTENT_129": "app.agents.domo_generativo.DomoGenerativo", # Agressividade -> IA acolhe
    "INTENT_131": "app.agents.domo_generativo.DomoGenerativo", # Ser melhor pai/mãe -> IA incentiva
    "INTENT_133": "app.agents.domo_generativo.DomoGenerativo", # Solidão -> IA acolhe
    "INTENT_135": "app.agents.domo_generativo.DomoGenerativo", # Voluntariado -> IA encaminha
    "INTENT_137": "app.agents.domo_generativo.DomoGenerativo", # PCD -> IA acolhe/adapta
    "INTENT_093": "app.agents.domo_generativo.DomoGenerativo", # Culpa -> IA acolhe
    "INTENT_095": "app.agents.domo_generativo.DomoGenerativo", # Ódio -> IA acolhe/oferece espaço seguro
    "INTENT_099": "app.agents.domo_generativo.DomoGenerativo", # Abandono familiar -> IA acolhe
    "INTENT_106": "app.agents.domo_generativo.DomoGenerativo", # Luto -> IA acolhe
    "INTENT_061": "app.agents.domo_generativo.DomoGenerativo", # Espiritualidade -> IA acolhe/integra
    "INTENT_063": "app.agents.domo_generativo.DomoGenerativo", # Afastado/ improdutivo -> IA valida/oferece ajuda
    "INTENT_065": "app.agents.domo_generativo.DomoGenerativo", # Grupos -> IA informa/convida
    "INTENT_073": "app.agents.domo_generativo.DomoGenerativo", # Outra cidade -> IA informa opções
    "INTENT_075": "app.agents.domo_generativo.DomoGenerativo", # Sem dinheiro -> IA acolhe/oferece alternativas
    # Intents de risco devem ir para DomoEscalonador
    "INTENT_031": "app.agents.domo_escalonador.DomoEscalonador", # Risco de suicídio
}

class MCPOrquestrador:
    _inst: "MCPOrquestrador | None" = None
    def __new__(cls):
        if not cls._inst:
            cls._inst = super().__new__(cls)
        return cls._inst

    # ------------------------------------------------------
    async def processar_mensagem(self, tel: str, texto: str) -> None:
        """
        Processa uma mensagem recebida, determina a intenção,
        analisa o sentimento, seleciona e executa o agente apropriado.
        """
        logger.info(f"MCP ▶ Iniciando processamento para tel={tel}, texto='{texto[:50]}...'")
        ctx = obter_contexto(tel)
        # Garante que ctx seja um dicionário antes de prosseguir
        if not isinstance(ctx, dict):
             logger.error(f"MCP: Falha ao obter contexto válido para {tel}. Abortando processamento.")
             # Tentar enviar mensagem de erro genérica
             await enviar_mensagem(tel, "Desculpe, ocorreu um erro ao carregar sua conversa. Tente novamente.")
             return

        estado_anterior = ctx.get("estado", "INICIAL")
        meta_conversa = ctx.get("meta_conversa", {})
        # Garante que meta_conversa seja um dicionário
        if not isinstance(meta_conversa, dict):
            logger.warning(f"MCP: meta_conversa para {tel} não era um dicionário. Resetando para {{}}.")
            meta_conversa = {}


        # --- 1. Detecção de Risco (Executada primeiro, se aplicável) ---
        # (A lógica de risco pode estar aqui ou integrada na detecção de intenção)
        # Exemplo simplificado:
        # if "quero morrer" in texto.lower() or "me matar" in texto.lower(): # Usar app.utils.risco para análise robusta
        #     intent = "INTENT_031" # Força intent de risco
        #     logger.warning(f"MCP: Risco potencial detectado para {tel}. Intent definida como {intent}.")
        #     sentimento_atual = {"negativo": 1.0, "positivo": 0.0, "neutro": 0.0}
        #     meta_conversa["ultimo_sentimento_detectado"] = sentimento_atual
        #     await self._executar_agente(tel, texto, intent, sentimento_atual, meta_conversa, estado_anterior)
        #     return

        # --- 2. Análise de Sentimento da Mensagem Atual ---
        try:
            sentimento_atual = await analisar_sentimento(texto)
            # Atualiza o sentimento na meta_conversa ANTES de salvar o contexto intermediário
            meta_conversa["ultimo_sentimento_detectado"] = sentimento_atual
            logger.info(f"MCP: Sentimento detectado para {tel}: {sentimento_atual}")
        except Exception as e:
            logger.error(f"MCP: Erro ao analisar sentimento para {tel}: {e}. Usando neutro.")
            sentimento_atual = {"positivo": 0.33, "negativo": 0.33, "neutro": 0.34}
            meta_conversa["ultimo_sentimento_detectado"] = sentimento_atual

        # --- 3. Detecção de Intenção ---
        intent = "DEFAULT" # Começa com default
        try:
            intent_trigger, score_trigger = buscar_por_trigger(texto.lower())
            if intent_trigger:
                logger.info(f"MCP: Intent por trigger '{intent_trigger}' (score: {score_trigger:.2f}) para {tel}")
                intent = intent_trigger
            else:
                logger.info(f"MCP: Nenhum trigger encontrado. Usando IA para detectar intenção para {tel}.")
                intent_ia = await detectar_intencao(texto)
                if intent_ia in _INTENT_MAP or obter_intent(intent_ia): # Verifica mapeamento ou existência no JSON
                     intent = intent_ia
                     logger.info(f"MCP: Intent por IA '{intent}' para {tel}")
                else:
                     logger.warning(f"MCP: Intent da IA '{intent_ia}' não mapeada/encontrada. Usando DEFAULT para {tel}.")
                     intent = "DEFAULT"
        except Exception as e:
            logger.error(f"MCP: Erro ao detectar intenção para {tel}: {e}. Usando DEFAULT.")
            intent = "DEFAULT"

        # --- 4. Guard-rails e Lógica de Fluxo (Ajustes) ---
        # Se acabou de receber acolhimento, a próxima intent provavelmente inicia a qualificação
        if estado_anterior == "ACOLHIMENTO_ENVIADO" and intent != "ESCALONAR_HUMANO": # Exemplo de estado pós-acolhimento
             intent = "MICRO_COMPROMISSO"
             logger.info(f"MCP: Estado anterior era ACOLHIMENTO_ENVIADO. Forçando intent para {intent} para {tel}.")

        # Não permitir triagem antes do pagamento
        if intent == "TRIAGEM_INICIAL" and estado_anterior != "PAGAMENTO_OK":
            logger.warning(f"MCP: Tentativa de acessar TRIAGEM_INICIAL no estado {estado_anterior} para {tel}. Redirecionando.")
            intent = "FAQ_COMO_FUNCIONA" # Ou outra intent informativa

        # --- 5. Scoring de Lead (se aplicável) ---
        score_atual = meta_conversa.get("score_lead", 0)
        # Recalcula score em estados iniciais ou de qualificação
        if estado_anterior in ["INICIAL", "ACOLHIMENTO_ENVIADO", "MICRO_COMPROMISSO"]:
            try:
                score_atual = score_lead(texto) # Usa texto atual para score inicial
                meta_conversa["score_lead"] = score_atual
                logger.info(f"MCP: Score de lead calculado/atualizado para {tel}: {score_atual}")
            except Exception as e:
                logger.error(f"MCP: Erro ao calcular score para {tel}: {e}")

        # --- 6. Salvar Contexto Intermediário (Importante!) ---
        # Salva o estado ANTES da execução do agente, incluindo a intent detectada e meta atualizada
        sucesso_save_interm = salvar_contexto(
            telefone=tel,
            texto_usuario=texto,
            # CORREÇÃO: Usar o argumento 'estado' para salvar o estado ANTERIOR aqui
            estado=estado_anterior,
            meta_conversa=meta_conversa, # Inclui sentimento e score atualizados
            intent_detectada=intent, # Salva a intent que será usada pelo agente
            incrementar_interacoes=True # Incrementa aqui, antes do agente
        )
        if not sucesso_save_interm:
             logger.error(f"MCP: Falha ao salvar contexto intermediário para {tel}. Risco de inconsistência.")
             # Considerar abortar ou logar criticamente
        else:
            registrar_evento(tel, etapa="analise_concluida", dados={"intent": intent, "score": score_atual, "sentimento": sentimento_atual, "estado_anterior": estado_anterior})

        # --- 7. Executar Agente ---
        # Passa a intent detectada e o sentimento atualizado para o agente
        await self._executar_agente(tel, texto, intent, sentimento_atual, meta_conversa, estado_anterior)

    # ------------------------------------------------------
    def _resolver_agente(self, intent: str) -> Type[AgenteBase] | None:
        """Resolve a classe do agente com base na intent."""
        caminho_agente = _INTENT_MAP.get(intent)
        if not caminho_agente:
            intent_info = obter_intent(intent)
            if intent_info:
                 # Se a intent existe no JSON mas não no MAP, decidir o que fazer
                 # Ex: Se for FAQ -> Orientador, se for outra -> Generativo
                 if intent.startswith("FAQ_"):
                     caminho_agente = "app.agents.domo_orientador.DomoOrientador"
                     logger.info(f"MCP: Intent {intent} não mapeada explicitamente, mas identificada como FAQ. Usando DomoOrientador.")
                 else: # Outras intents não mapeadas explicitamente vão para o generativo
                      caminho_agente = "app.agents.domo_generativo.DomoGenerativo"
                      logger.info(f"MCP: Intent {intent} não mapeada explicitamente. Usando DomoGenerativo.")
            else:
                 logger.warning(f"MCP: Intent '{intent}' não encontrada no mapeamento nem nos arquivos JSON. Usando DEFAULT.")
                 caminho_agente = _INTENT_MAP.get("DEFAULT", "app.agents.domo_generativo.DomoGenerativo")

        try:
            mod_path, _, cls_name = caminho_agente.rpartition(".")
            modulo = import_module(mod_path)
            agente_cls = getattr(modulo, cls_name)
            if not issubclass(agente_cls, AgenteBase):
                 logger.error(f"MCP: Classe {caminho_agente} não herda de AgenteBase.")
                 return None # Retorna None para indicar falha na resolução
            return agente_cls
        except (ImportError, AttributeError, Exception) as e:
            logger.exception(f"MCP: Erro ao resolver agente para intent '{intent}' (caminho: {caminho_agente}): {e}")
            # Tenta resolver para o DEFAULT em caso de erro
            try:
                caminho_default = _INTENT_MAP.get("DEFAULT", "app.agents.domo_generativo.DomoGenerativo")
                mod_path, _, cls_name = caminho_default.rpartition(".")
                return getattr(import_module(mod_path), cls_name)
            except Exception:
                 logger.critical("MCP: Falha CRÍTICA ao resolver até mesmo o agente DEFAULT.")
                 return None

    # ------------------------------------------------------
    async def _executar_agente(self, tel: str, texto_usuario: str, intent: str, sentimento: dict, meta_conversa: dict, estado_anterior: str):
        """Instancia e executa o agente selecionado."""
        agente_cls = self._resolver_agente(intent)

        if not agente_cls:
            logger.error(f"MCP: Não foi possível resolver um agente para a intent '{intent}'. Nenhuma resposta será enviada.")
            registrar_evento(tel, etapa="erro_resolucao_agente", dados={"intent": intent})
            await enviar_mensagem(tel, "Desculpe, tive um problema interno para processar sua solicitação.")
            return

        agente_nome = agente_cls.__name__
        logger.info(f"MCP: Selecionado Agente '{agente_nome}' para intent '{intent}' (Telefone: {tel})")

        agente: AgenteBase = agente_cls(intent=intent, sentimento=sentimento)

        try:
            # Executa o agente
            await agente.executar(tel, texto_usuario)
            logger.info(f"MCP: Agente '{agente_nome}' executado com sucesso para {tel}.")
            registrar_evento(tel, etapa="execucao_agente_sucesso", dados={"agente": agente_nome, "intent": intent})

            # --- Atualização de Estado Pós-Agente ---
            # O agente pode ter chamado salvar_contexto e alterado o estado ou meta.
            # Recarregamos para garantir que o estado final seja o correto.
            ctx_final = obter_contexto(tel)
            estado_final = ctx_final.get("estado", estado_anterior) # Usa estado atualizado se o agente mudou
            meta_final = ctx_final.get("meta_conversa", meta_conversa)
            ultimo_bot = ctx_final.get("ultimo_texto_bot", "") # Resposta que o agente enviou (se ele salvou)

            # Salva o ESTADO FINAL definido pelo agente (ou o anterior se não mudou)
            # Não precisa salvar outros campos aqui se o agente já salvou via executar()
            # Apenas garante que o estado final esteja correto
            if estado_final != estado_anterior:
                 logger.info(f"MCP: Agente '{agente_nome}' alterou estado para '{estado_final}' para {tel}.")
                 # O salvar_contexto dentro de agente.executar() já deve ter salvo o estado novo.
                 # Se quisermos ter certeza, podemos chamar salvar_contexto aqui APENAS com o estado:
                 # salvar_contexto(telefone=tel, estado=estado_final, incrementar_interacoes=False)
            else:
                 logger.info(f"MCP: Estado final para {tel} após agente '{agente_nome}': {estado_final} (inalterado pelo agente)")


        except Exception as exc:
            logger.exception(f"MCP: Erro durante execução do Agente '{agente_nome}' para {tel}: {exc}")
            registrar_evento(tel, etapa="erro_execucao_agente", dados={"agente": agente_nome, "intent": intent, "err": str(exc)})
            try:
                await enviar_mensagem(tel, "Desculpe, ocorreu um erro ao processar sua solicitação. Tente novamente.")
            except Exception as send_err:
                 logger.error(f"MCP: Falha ao enviar mensagem de erro para {tel} após falha do agente: {send_err}")


# Arquivo: app/core/scheduler.py
# ===========================================================
# Arquivo: core/scheduler.py
# Scheduler assíncrono (apscheduler) para tarefas recorrentes.
# - Implementa follow-up para qualificação parada.
# - Implementa follow-up para pagamento pendente.
# - Usa flags no contexto para evitar envios repetidos.
# ===========================================================
import asyncio
import logging
from datetime import datetime, timedelta, timezone
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from pymongo import MongoClient

# Imports de configuração e agentes/orquestrador
from app.config import MONGO_URI, settings # Usar settings para robustez
from app.agents.domo_followup import DomoFollowUp
# from app.core.mcp_orquestrador import MCPOrquestrador # Descomentar se usar orquestrador

logger = logging.getLogger("famdomes.scheduler")

# --- Configurações do Scheduler ---
# Usar fuso horário local relevante (ex: 'America/Sao_Paulo')
TIMEZONE_SCHEDULER = getattr(settings, "TIMEZONE_SCHEDULER", "America/Sao_Paulo")
try:
    sched = AsyncIOScheduler(timezone=TIMEZONE_SCHEDULER)
except Exception as e:
    logger.error(f"SCHEDULER: Erro ao inicializar com timezone '{TIMEZONE_SCHEDULER}': {e}. Usando UTC.")
    sched = AsyncIOScheduler(timezone="UTC")


# Intervalos de verificação e follow-up (em horas)
INTERVALO_CHECK_JOB_HORAS = getattr(settings, "SCHEDULER_CHECK_INTERVAL_HOURS", 1)
INTERVALO_FOLLOWUP_QUALIFICACAO_HORAS = getattr(settings, "SCHEDULER_FOLLOWUP_QUAL_HOURS", 4)
INTERVALO_FOLLOWUP_PAGAMENTO_HORAS = getattr(settings, "SCHEDULER_FOLLOWUP_PAY_HOURS", 24)

# Intents a serem usadas para o follow-up (devem existir nos JSONs)
INTENT_FOLLOWUP_QUALIFICACAO = "FOLLOW_UP_QUALIFICACAO"
INTENT_FOLLOWUP_PAGAMENTO = "FOLLOW_UP_24H" # Ou outra intent específica

# Estados que indicam qualificação/pitch em andamento
ESTADOS_QUALIFICACAO_ATIVOS = [
    "MICRO_COMPROMISSO", # Durante as perguntas
    "PITCH_PLANO1",      # Após apresentar plano 1
    "PITCH_PLANO3",      # Após apresentar plano 3
    "COMERCIAL_DETALHES_PLANO" # Após dar detalhes
]
# Estado que indica link de pagamento enviado
ESTADO_AGUARDANDO_PAGAMENTO = "AGUARDANDO_PAGAMENTO" # Ou "CALL_TO_ACTION" se for o último antes do link

async def _job_verificar_followups():
    """
    Job executado periodicamente para verificar usuários que precisam de follow-up.
    """
    logger.info("SCHEDULER: Iniciando verificação de follow-ups...")
    try:
        mongo = MongoClient(MONGO_URI)
        db = mongo["famdomes"] # Usar nome do DB de settings se disponível
        col_contextos = db["contextos"]
    except Exception as e:
        logger.exception(f"SCHEDULER: Erro ao conectar ao MongoDB: {e}")
        return # Aborta a job se não conectar ao DB

    agora_utc = datetime.now(timezone.utc)
    # orquestrador = MCPOrquestrador() # Instanciar se for chamar via orquestrador

    # --- 1. Follow-up para Qualificação Incompleta ---
    try:
        limite_qualificacao = agora_utc - timedelta(hours=INTERVALO_FOLLOWUP_QUALIFICACAO_HORAS)
        filtro_qualificacao = {
            "estado": {"$in": ESTADOS_QUALIFICACAO_ATIVOS},
            "ts": {"$lt": limite_qualificacao}, # Última interação foi há muito tempo
            # Verifica se o follow-up específico JÁ foi enviado
            "meta_conversa.followup_qualificacao_enviado": {"$ne": True}
        }
        # Busca apenas o telefone para evitar carregar dados desnecessários
        usuarios_qualificacao = list(col_contextos.find(filtro_qualificacao, {"tel": 1, "_id": 0}))
        logger.info(f"SCHEDULER: {len(usuarios_qualificacao)} usuários encontrados para follow-up de qualificação.")

        for user_data in usuarios_qualificacao:
            tel = user_data.get("tel")
            if not tel: continue

            logger.info(f"SCHEDULER: Enviando follow-up de qualificação para {tel}")
            try:
                # --- Execução do Agente de Follow-up ---
                # Opção 1: Chamar diretamente o agente (mais simples)
                agente_followup = DomoFollowUp(intent=INTENT_FOLLOWUP_QUALIFICACAO, sentimento={}) # Sentimento vazio para msg de sistema
                await agente_followup.executar(telefone=tel, mensagem_original="") # Mensagem original vazia

                # Opção 2: Chamar via Orquestrador (garante fluxo completo, mais complexo)
                # await orquestrador.processar_mensagem(tel, f"trigger:{INTENT_FOLLOWUP_QUALIFICACAO}")

                # --- Marcar Follow-up como Enviado ---
                # Atualiza a flag DENTRO da meta_conversa para evitar poluir o doc principal
                col_contextos.update_one(
                    {"tel": tel},
                    {"$set": {"meta_conversa.followup_qualificacao_enviado": True}}
                )
                await asyncio.sleep(0.1) # Pequena pausa para não sobrecarregar

            except Exception as e:
                logger.error(f"SCHEDULER: Erro ao processar follow-up de qualificação para {tel}: {e}")

    except Exception as e:
        logger.exception(f"SCHEDULER: Erro geral ao buscar usuários para follow-up de qualificação: {e}")


    # --- 2. Follow-up para Pagamento Pendente ---
    try:
        limite_pagamento = agora_utc - timedelta(hours=INTERVALO_FOLLOWUP_PAGAMENTO_HORAS)
        filtro_pagamento = {
            "estado": ESTADO_AGUARDANDO_PAGAMENTO,
            "ts": {"$lt": limite_pagamento},
            "meta_conversa.followup_pagamento_enviado": {"$ne": True}
        }
        usuarios_pagamento = list(col_contextos.find(filtro_pagamento, {"tel": 1, "_id": 0}))
        logger.info(f"SCHEDULER: {len(usuarios_pagamento)} usuários encontrados para follow-up de pagamento.")

        for user_data in usuarios_pagamento:
            tel = user_data.get("tel")
            if not tel: continue

            logger.info(f"SCHEDULER: Enviando follow-up de pagamento para {tel}")
            try:
                # --- Execução do Agente de Follow-up ---
                agente_followup = DomoFollowUp(intent=INTENT_FOLLOWUP_PAGAMENTO, sentimento={})
                await agente_followup.executar(telefone=tel, mensagem_original="")

                # --- Marcar Follow-up como Enviado ---
                col_contextos.update_one(
                    {"tel": tel},
                    {"$set": {"meta_conversa.followup_pagamento_enviado": True}}
                )
                await asyncio.sleep(0.1)

            except Exception as e:
                logger.error(f"SCHEDULER: Erro ao processar follow-up de pagamento para {tel}: {e}")

    except Exception as e:
        logger.exception(f"SCHEDULER: Erro geral ao buscar usuários para follow-up de pagamento: {e}")

    # --- Limpeza de Flags Antigas (Opcional) ---
    # Para permitir novos follow-ups após um tempo, pode-se remover as flags
    # Ex: Remover flags de follow-up de qualificação após 3 dias
    # limite_limpeza = agora_utc - timedelta(days=3)
    # col_contextos.update_many(
    #     {"meta_conversa.followup_qualificacao_enviado": True, "ts": {"$lt": limite_limpeza}},
    #     {"$unset": {"meta_conversa.followup_qualificacao_enviado": ""}}
    # )

    logger.info("SCHEDULER: Verificação de follow-ups concluída.")


def iniciar():
    """Adiciona a job ao scheduler e o inicia, se ainda não estiver rodando."""
    if not sched.running:
        try:
            # Adiciona a job para rodar a cada X horas
            sched.add_job(
                _job_verificar_followups,
                "interval",
                hours=INTERVALO_CHECK_JOB_HORAS,
                id="verificar_followups_diarios", # ID único para a job
                replace_existing=True, # Substitui se já existir com mesmo ID
                next_run_time=datetime.now(pytz.timezone(TIMEZONE_SCHEDULER)) + timedelta(seconds=15) # Roda logo após iniciar
            )
            sched.start()
            logger.info(f"SCHEDULER: Agendador iniciado no timezone '{TIMEZONE_SCHEDULER}'. Verificações a cada {INTERVALO_CHECK_JOB_HORAS} hora(s).")
        except Exception as e:
             logger.exception(f"SCHEDULER: Falha ao iniciar o agendador: {e}")
    else:
        logger.info("SCHEDULER: Agendador já está em execução.")

def parar():
    """Para o scheduler de forma graciosa."""
    if sched.running:
        try:
            sched.shutdown()
            logger.info("SCHEDULER: Agendador parado.")
        except Exception as e:
            logger.exception(f"SCHEDULER: Erro ao parar o agendador: {e}")

# Importar pytz para lidar com timezones corretamente na inicialização da job
try:
    import pytz
except ImportError:
    logger.error("SCHEDULER: Biblioteca 'pytz' não instalada. Timezones podem não funcionar corretamente. Execute: pip install pytz")
    pytz = None # Define como None para evitar erros posteriores se não conseguir importar

# Certifique-se de chamar iniciar() no startup da sua aplicação FastAPI (main.py)
# e parar() no shutdown.


# Arquivo: app/core/metrics.py
"""
Coleta KPIs e expõe para Prometheus + JSON.
"""
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from prometheus_client import Gauge, generate_latest, CONTENT_TYPE_LATEST

from app.config import MONGO_URI

# ---------- Gauges ----------
LEADS         = Gauge("domo_leads_total", "Leads captados nas últimas 24h")
QUALIFICADOS  = Gauge("domo_qualificados_total", "Leads com score >=2 últimas 24h")
PAGOS         = Gauge("domo_pagamentos_total", "Pagamentos confirmados últimas 24h")
TEMPO_PG_SECS = Gauge("domo_tempo_medio_pg_segundos", "Tempo médio lead→pagamento (s)")

# ---------- Coleta ----------
def atualizar():
    mongo = MongoClient(MONGO_URI)
    ctx   = mongo["famdomes"]["contextos"]

    ini = datetime.now(timezone.utc) - timedelta(days=1)

    # Leads = primeira interação nas 24h
    leads = ctx.count_documents({"ts": {"$gt": ini}, "interacoes": 1})
    LEADS.set(leads)

    # Qualificados = score_lead >=2
    qual = ctx.count_documents({"ts": {"$gt": ini}, "meta_conversa.score_lead": {"$gte": 2}})
    QUALIFICADOS.set(qual)

    # Pagos
    pagos = ctx.count_documents({"ts": {"$gt": ini}, "estado": "PAGAMENTO_OK"})
    PAGOS.set(pagos)

    # Tempo médio até pagamento
    pipeline = [
        {"$match": {"estado": "PAGAMENTO_OK", "ts": {"$gt": ini}}},
        {"$project": {"delta": {"$subtract": ["$ts", "$criado_em"]}}},
        {"$group": {"_id": None, "avg": {"$avg": "$delta"}}},
    ]
    res = list(ctx.aggregate(pipeline))
    TEMPO_PG_SECS.set(res[0]["avg"] / 1000 if res else 0)  # ms→s

def prometheus_response():
    atualizar()
    return generate_latest(), CONTENT_TYPE_LATEST

def json_response():
    atualizar()
    return {
        "leads": LEADS.collect()[0].samples[0].value,
        "qualificados": QUALIFICADOS.collect()[0].samples[0].value,
        "pagamentos": PAGOS.collect()[0].samples[0].value,
        "tempo_medio_pg_s": TEMPO_PG_SECS.collect()[0].samples[0].value,
    }

# Arquivo: app/core/ia_analisador.py
# ===========================================================
# Arquivo: core/ia_analisador.py
# ===========================================================
from __future__ import annotations

import httpx, json, logging
from typing import Dict
from app.config import settings

logger = logging.getLogger("famdomes.ia")


async def _chamar_ollama(prompt: str) -> str | None:
    url = f"{str(settings.OLLAMA_API_URL).rstrip('/')}/api/generate"
    body = {"model": settings.OLLAMA_MODEL, "prompt": prompt, "stream": False}

    try:
        async with httpx.AsyncClient(timeout=settings.MCP_TIMEOUT_S) as cli:
            resp = await cli.post(url, json=body)
        resp.raise_for_status()
        return resp.json().get("response")
    except Exception as exc:  # pragma: no cover
        logger.warning("OLLAMA: ❌ %s", exc)
        return None


async def detectar_intencao(texto: str) -> str:
    sistema = (
        "Você é um classificador. Responda SOMENTE com uma "
        "das opções: ESCALONAR_HUMANO, TRIAGEM_INICIAL, PRESENCA_VIVA, ACOLHIMENTO."
    )
    resp = await _chamar_ollama(f"{sistema}\n\nUsuário: {texto}\nIntenção:")
    intent = (resp or "").strip().split()[0].upper()
    return intent if intent in {"ESCALONAR_HUMANO", "TRIAGEM_INICIAL", "PRESENCA_VIVA"} else "ACOLHIMENTO"


async def analisar_sentimento(texto: str) -> Dict[str, float]:
    prompt = (
        "Avalie o sentimento do texto em JSON no formato "
        "{'positivo':0‑1,'negativo':0‑1,'neutro':0‑1}:\n" + texto
    )
    resp = await _chamar_ollama(prompt)
    try:
        dados = json.loads(resp) if resp else {}
        if all(k in dados for k in ("positivo", "negativo", "neutro")):
            return dados
    except Exception:
        pass
    logger.warning("Sentimento inválido – usando fallback neutro.")
    return {"positivo": 0.33, "negativo": 0.33, "neutro": 0.34}

# Arquivo: domo_hub_frontend/arvore_frontend.txt
.
├── arvore_frontend.txt
└── domo-hub-app
    ├── README.md
    ├── eslint.config.js
    ├── index.html
    ├── package-lock.json
    ├── package.json
    ├── public
    │   └── vite.svg
    ├── src
    │   ├── App.tsx
    │   ├── assets
    │   ├── components
    │   │   ├── ChatMessage.tsx
    │   │   ├── KanbanCard.tsx
    │   │   ├── KanbanColumn.tsx
    │   │   └── ProtectedRoute.tsx
    │   ├── contexts
    │   │   └── AuthContext.tsx
    │   ├── hooks
    │   ├── index.css
    │   ├── main.tsx
    │   ├── pages
    │   │   ├── AnalyticsView.tsx
    │   │   ├── ChatView.tsx
    │   │   ├── DashboardLayout.tsx
    │   │   ├── KanbanView.tsx
    │   │   └── LoginPage.tsx
    │   ├── services
    │   │   └── api.ts
    │   ├── types
    │   │   └── index.ts
    │   └── vite-env.d.ts
    ├── tailwind.config.js
    ├── tsconfig.app.json
    ├── tsconfig.json
    ├── tsconfig.node.json
    └── vite.config.ts

11 directories, 28 files

# Arquivo: domo_hub_frontend/domo-hub-app/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';                 // <-- sem “.tsx”
import { ConversaModalProvider } from '@/contexts/ModalConversaContext';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ConversaModalProvider>
      <App />
    </ConversaModalProvider>
  </React.StrictMode>,
);

# Arquivo: domo_hub_frontend/domo-hub-app/src/types/recharts-fix.d.ts
// Ajuste de tipagem para compatibilidade TS5 + bundler
declare module 'recharts' {
    export * from 'recharts/types'
  }
  
# Arquivo: domo_hub_frontend/domo-hub-app/src/types/index.ts
// File: src/types/index.ts
// Define tipos TypeScript para os dados usados no frontend.

export interface UserData {
  username: string;
  disabled?: boolean;
}

export interface ConversationCardData {
  tel: string;
  nome?: string;
  estado: string;
  ultima_interacao_ts: string; // Vem como string ISO do backend
  ultima_mensagem_snippet?: string;
  sentimento_predominante?: 'positivo' | 'negativo' | 'neutro';
  score_lead?: number;
  risco_detectado?: boolean;
  atendente_humano_necessario?: boolean;
}

export interface KanbanColumnData {
  id: string;
  title: string;
  cards: ConversationCardData[];
}

export interface KanbanBoardData {
  columns: KanbanColumnData[];
}

export interface MessageData {
  id: string;
  timestamp: string; // Vem como string ISO
  sender: 'user' | 'bot' | 'human';
  text: string;
  intent?: string;
  sentimento?: Record<string, number>; // {positivo: 0.8, ...}
}

export interface ConversationDetailData {
  tel: string;
  nome?: string;
  estado: string;
  contexto: any; // Objeto de contexto completo (pode tipar melhor depois)
  historico: MessageData[];
}

// Tipo para o estado do Kanban no frontend (para react-beautiful-dnd)
export interface KanbanState {
    columns: {
        [key: string]: KanbanColumnData; // Usa o ID da coluna como chave
    };
    columnOrder: string[]; // Array com a ordem dos IDs das colunas
}

# Arquivo: domo_hub_frontend/domo-hub-app/src/types/analytics.ts
export interface AnalyticsData {
    leads: number
    qualificados: number
    pagos: number
    tempo_pg_segundos: number
  }
  
# Arquivo: domo_hub_frontend/domo-hub-app/src/services/api.ts
/* ---------------------------------------------------------------------------
Wrapper Axios ‑ Compatível com rotas NOVAS (/kanban, /sugestao)
e rotas LEGADAS (/dashboard/…)
--------------------------------------------------------------------------- */

import axios from 'axios';
import type { ColunaNome } from '@/pages/DashboardKanban';
import type { KanbanCardProps } from '@/components/KanbanCard';
import type { KanbanBoardData, ConversationDetailData, AnalyticsData } from '../types';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8000',
  timeout: 10000,
});

/* =====================================================================
   NOVA API – USADA PELO NOVO KANBAN
   ===================================================================== */
export interface KanbanQuadroResp {
  colunas: Record<ColunaNome, KanbanCardProps[]>;
}

export const obterQuadroKanban = async (): Promise<KanbanQuadroResp> => {
  const { data } = await api.get('/kanban');
  return data;
};

export const moverConversa = async (
  telefone: string,
  novoEstado: ColunaNome,
): Promise<void> => {
  await api.put(`/kanban/${telefone}`, { novo_estado: novoEstado });
};

export const obterConversaCompleta = async (
  telefone: string,
): Promise<Record<string, unknown>[]> => {
  const { data } = await api.get(`/kanban/conversa/${telefone}`);
  return data;
};

export const responderHumano = async (
  telefone: string,
  texto: string,
  respondente = 'Profissional',
): Promise<void> => {
  await api.post('/kanban/responder_humano', { telefone, mensagem: texto, respondente });
};

export const obterSugestaoIA = async (telefone: string): Promise<string> => {
  const { data } = await api.get(`/sugestao/${telefone}`);
  return data.sugestao;
};

/* =====================================================================
   ⬇️  FUNÇÕES LEGADAS  — mantidas p/ arquivos antigos
   ===================================================================== */

/* ---- KanbanBoard / legacy ---- */
export const getKanbanBoard = async (): Promise<KanbanBoardData> => {
  const { data } = await api.get('/dashboard/kanban');
  return data;
};

export const updateConversationState = async (
  telefone: string,
  novoEstado: string,
): Promise<void> => {
  await api.put(`/dashboard/conversations/${telefone}/state`, { novo_estado: novoEstado });
};

/* ---- Conversa detalhada / legacy ---- */
export const getConversationDetail = async (
  telefone: string,
): Promise<ConversationDetailData> => {
  const { data } = await api.get(`/dashboard/conversations/${telefone}`);
  return data;
};

export const sendHumanMessage = async (
  telefone: string,
  texto: string,
): Promise<{ status: string }> => {
  const { data } = await api.post(`/dashboard/conversations/${telefone}/send_human`, { texto });
  return data;
};

export const simulateUserMessage = async (
  telefone: string,
  texto: string,
): Promise<unknown> => {
  const { data } = await api.post(`/dashboard/conversations/${telefone}/simulate_user`, { texto });
  return data;
};

/* ---- Analytics / legacy ---- */
export const getAnalytics = async (): Promise<AnalyticsData> => {
  const { data } = await api.get('/dashboard/analytics');
  return data;
};

export default api;

# Arquivo: domo_hub_frontend/domo-hub-app/src/hooks/useAnalytics.ts
import { useEffect, useState } from 'react'
import { getAnalytics } from '../services/api'
import type { AnalyticsData } from '../types/analytics'

export const useAnalytics = () => {
  const [data, setData] = useState<AnalyticsData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetch = async () => {
      try {
        const res = await getAnalytics()
        setData(res)
      } catch (e) {
        setError('Erro ao carregar KPIs')
      } finally {
        setLoading(false)
      }
    }
    fetch()
    const id = setInterval(fetch, 60_000) // refresh 1 min
    return () => clearInterval(id)
  }, [])

  return { data, loading, error }
}

# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/DashboardLayout.tsx
// File: src/pages/DashboardLayout.tsx
// Define o layout principal do dashboard com sidebar e área de conteúdo.

import React from 'react';
import { Outlet, Link, useLocation } from 'react-router-dom';
// import { useAuth } from '../contexts/AuthContext'; // Descomentar quando usar login
import { LayoutDashboard, MessageSquare, BarChart3, LogOut } from 'lucide-react'; // Ícones

const DashboardLayout: React.FC = () => {
  // const { user, logout } = useAuth(); // Descomentar quando usar login
  const location = useLocation(); // Hook para obter a localização atual

  /**
   * Verifica se um link da sidebar deve ser considerado ativo.
   * @param path - O caminho do link (ex: '/kanban', '/chat').
   * @returns boolean - True se o link estiver ativo, false caso contrário.
   */
  const isActive = (path: string): boolean => {
    // Trata o Kanban como ativo também na rota raiz '/'
    if (path === '/kanban') {
      return location.pathname === '/' || location.pathname === '/kanban';
    }
    // Para outras rotas, verifica se o pathname atual começa com o path do link
    // Isso garante que /chat/123 marque /chat como ativo
    return location.pathname.startsWith(path) && path !== '/';
  };

  // Função placeholder para logout
  const handleLogout = () => {
    console.log("Logout clicado - implementar lógica real com AuthContext");
    // logout(); // Chamar logout do AuthContext quando reimplementado
  };

  return (
    // Container Flex principal que ocupa toda a altura da tela
    <div className="flex h-screen bg-slate-100 font-sans">

      {/* Barra Lateral (Sidebar) */}
      <aside className="w-60 flex flex-col bg-gradient-to-b from-slate-800 to-slate-900 text-slate-100 shadow-lg flex-shrink-0">
        {/* Cabeçalho da Sidebar */}
        <div className="px-5 py-5 border-b border-slate-700">
          <h1 className="text-2xl font-bold text-white tracking-tight">Domo Hub</h1>
          {/* Exibir nome do usuário logado (quando AuthContext estiver ativo) */}
          {/* <span className="text-xs text-slate-400 block mt-1">Usuário: {user?.username || 'Admin'}</span> */}
        </div>

        {/* Navegação Principal */}
        <nav className="flex-1 mt-6 px-3 space-y-1.5">
          {/* Link para Kanban */}
          <Link
            to="/kanban"
            // Classes dinâmicas para estado ativo/hover
            className={`flex items-center px-3 py-2.5 rounded-md text-sm font-medium transition-colors duration-150 group ${
              isActive('/kanban')
                ? 'bg-slate-700 text-white shadow-inner' // Estilo ativo
                : 'text-slate-300 hover:bg-slate-700 hover:text-white' // Estilo padrão/hover
            }`}
          >
            {/* Ícone */}
            <LayoutDashboard className={`mr-3 h-5 w-5 flex-shrink-0 ${isActive('/kanban') ? 'text-white' : 'text-slate-400 group-hover:text-slate-300'}`} />
            {/* Texto do Link */}
            <span>Kanban</span>
          </Link>

          {/* Link para Conversas */}
          <Link
            to="/chat" // Link genérico para a seção de chat
            className={`flex items-center px-3 py-2.5 rounded-md text-sm font-medium transition-colors duration-150 group ${
              isActive('/chat')
                ? 'bg-slate-700 text-white shadow-inner'
                : 'text-slate-300 hover:bg-slate-700 hover:text-white'
            }`}
          >
            <MessageSquare className={`mr-3 h-5 w-5 flex-shrink-0 ${isActive('/chat') ? 'text-white' : 'text-slate-400 group-hover:text-slate-300'}`} />
            <span>Conversas</span>
          </Link>

          {/* Link para Analytics */}
          <Link
            to="/analytics"
            className={`flex items-center px-3 py-2.5 rounded-md text-sm font-medium transition-colors duration-150 group ${
              isActive('/analytics')
                ? 'bg-slate-700 text-white shadow-inner'
                : 'text-slate-300 hover:bg-slate-700 hover:text-white'
            }`}
          >
            <BarChart3 className={`mr-3 h-5 w-5 flex-shrink-0 ${isActive('/analytics') ? 'text-white' : 'text-slate-400 group-hover:text-slate-300'}`} />
            <span>Analytics</span>
          </Link>
        </nav>

        {/* Rodapé da Sidebar com Botão Sair */}
        <div className="px-3 py-4 mt-auto border-t border-slate-700">
          <button
            onClick={handleLogout}
            className="w-full flex items-center justify-center px-3 py-2 rounded-md text-sm font-medium bg-red-600 hover:bg-red-700 text-white transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-slate-800"
          >
            <LogOut className="mr-2 h-5 w-5" />
            Sair
          </button>
        </div>
      </aside>

      {/* Conteúdo Principal */}
      <main className="flex-1 flex flex-col overflow-hidden">
         {/* Área de Conteúdo Rolável */}
         <div className="flex-1 overflow-x-hidden overflow-y-auto bg-slate-50 p-4 md:p-6 lg:p-8">
           {/* O Outlet renderiza o componente da rota filha correspondente */}
           <Outlet />
         </div>
      </main>
    </div>
  );
};

export default DashboardLayout;

# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/ChatView.tsx
// File: src/pages/ChatView.tsx
// Exibe a lista de conversas ou o detalhe de uma conversa específica.

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom'; // Hooks para parâmetros de URL e navegação
// Funções da API e Tipos
import { getConversationDetail, sendHumanMessage, simulateUserMessage, updateConversationState } from '../services/api';
import type { ConversationDetailData, MessageData } from '../types';
// Componente Filho
import ChatMessage from '../components/ChatMessage';
// Ícones
import {
  Loader2,
  Send,
  Bot,
  AlertTriangle,
  ArrowLeft,
  Info,
  MessageSquare, // Ícone para placeholder
  ChevronDown, // Ícone para dropdown
  CheckCircle, // Ícone para sucesso
  XCircle, // Ícone para erro
} from 'lucide-react';

const ChatView: React.FC = () => {
  // Obtém o parâmetro 'telefone' da URL, se existir
  const { telefone } = useParams<{ telefone?: string }>();

  // Estados do componente
  const [conversation, setConversation] = useState<ConversationDetailData | null>(null); // Armazena dados da conversa
  const [isLoading, setIsLoading] = useState(false); // Controla o estado de carregamento
  const [error, setError] = useState<string | null>(null); // Armazena mensagens de erro
  const [humanMessage, setHumanMessage] = useState(''); // Mensagem a ser enviada pelo atendente
  const [simulateMessage, setSimulateMessage] = useState(''); // Mensagem a ser simulada pelo usuário
  const [isSendingHuman, setIsSendingHuman] = useState(false); // Controla o envio da mensagem humana
  const [isSimulating, setIsSimulating] = useState(false); // Controla a simulação
  const [showContext, setShowContext] = useState(false); // Controla a visibilidade do painel de contexto
  const [sendSuccess, setSendSuccess] = useState<string | null>(null); // Feedback de sucesso
  const [sendError, setSendError] = useState<string | null>(null); // Feedback de erro
  const messagesEndRef = useRef<HTMLDivElement>(null); // Ref para scroll automático

  /**
   * Busca os detalhes da conversa da API.
   * useCallback para memorizar a função.
   */
  const fetchConversation = useCallback(async (tel: string) => {
    setIsLoading(true);
    setError(null);
    setConversation(null);
    console.log(`Buscando conversa para: ${tel}`);
    try {
      const data = await getConversationDetail(tel);
      setConversation(data);
    } catch (err: any) {
      console.error(`Erro ao buscar conversa ${tel}:`, err);
      setError(
        err.response?.status === 404
          ? `Conversa com telefone ${tel} não encontrada.`
          : "Falha ao carregar a conversa. Verifique a conexão com a API."
      );
    } finally {
      setIsLoading(false);
    }
  }, []); // Sem dependências externas

  // useEffect para buscar a conversa quando o parâmetro 'telefone' mudar
  useEffect(() => {
    if (telefone) {
      fetchConversation(telefone);
    } else {
      // Limpa o estado se não houver telefone na URL
      setConversation(null);
      setIsLoading(false);
      setError(null);
    }
  }, [telefone, fetchConversation]); // Depende de 'telefone' e 'fetchConversation'

  // useEffect para rolar para a última mensagem quando o histórico for atualizado
  useEffect(() => {
    const timer = setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }, 150); // Pequeno delay para garantir renderização
    return () => clearTimeout(timer);
  }, [conversation?.historico]);

  // useEffect para limpar mensagens de feedback (sucesso/erro) após um tempo
  useEffect(() => {
    let timer: number | undefined; // CORRIGIDO: Usar 'number' para o tipo do timer do browser
    if (sendSuccess || sendError) {
      timer = setTimeout(() => {
        setSendSuccess(null);
        setSendError(null);
      }, 4000); // 4 segundos
    }
    return () => clearTimeout(timer); // Limpa o timer ao desmontar ou se o feedback mudar
  }, [sendSuccess, sendError]);

  /**
   * Handler para enviar uma mensagem como atendente humano.
   */
  const handleSendHumanMessage = async (e?: React.FormEvent) => {
    if (e) e.preventDefault(); // Previne recarregamento da página se for evento de form
    if (!humanMessage.trim() || !telefone || isSendingHuman) return; // Validações

    setIsSendingHuman(true);
    setSendError(null);
    setSendSuccess(null);
    const messageText = humanMessage;
    setHumanMessage(''); // Limpa o input

    try {
      await sendHumanMessage(telefone, messageText);
      // Adiciona mensagem à UI otimisticamente
      const newMessage: MessageData = {
        id: `human_${Date.now()}`,
        timestamp: new Date().toISOString(),
        sender: 'human',
        text: messageText,
      };
      setConversation(prev => prev ? ({ ...prev, historico: [...prev.historico, newMessage] }) : null);
      setSendSuccess("Mensagem enviada!");
    } catch (err: any) {
      console.error("Erro ao enviar mensagem humana:", err);
      const errorMsg = err.response?.data?.detail || err.message || "Falha ao enviar.";
      setSendError(`Erro: ${errorMsg}`);
      setHumanMessage(messageText); // Restaura texto no input
    } finally {
      setIsSendingHuman(false);
    }
  };

   /**
    * Handler para simular uma mensagem do usuário (testar o bot).
    */
   const handleSimulateUserMessage = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    if (!simulateMessage.trim() || !telefone || isSimulating) return;

    setIsSimulating(true);
    setSendError(null);
    setSendSuccess(null);
    const messageText = simulateMessage;
    setSimulateMessage('');

    try {
      const result = await simulateUserMessage(telefone, messageText);
      console.log("Resultado da simulação:", result);
      setSendSuccess("Simulação enviada. Atualizando...");
      await fetchConversation(telefone); // Re-busca a conversa para ver a resposta
    } catch (err: any) {
      console.error("Erro ao simular mensagem:", err);
      const errorMsg = err.response?.data?.detail || err.message || "Falha ao simular.";
      setSendError(`Erro simulação: ${errorMsg}`);
      setSimulateMessage(messageText); // Restaura texto no input
    } finally {
      setIsSimulating(false);
    }
  };

  /**
   * Handler para alterar manualmente o estado da conversa.
   */
  const handleStateChange = async (event: React.ChangeEvent<HTMLSelectElement>) => {
      const novoEstado = event.target.value;
      if (!telefone || !novoEstado || novoEstado === conversation?.estado) return; // Validações

      const originalState = conversation?.estado;
      setConversation(prev => prev ? ({...prev, estado: novoEstado}) : null); // Atualiza UI otimisticamente
      setSendError(null);
      setSendSuccess(null);

      try {
          await updateConversationState(telefone, novoEstado);
          setSendSuccess(`Estado atualizado para ${novoEstado}.`);
      } catch (err: any) {
          console.error("Erro ao atualizar estado:", err);
          const errorMsg = err.response?.data?.detail || err.message || "Falha ao atualizar.";
          setSendError(`Erro estado: ${errorMsg}`);
          setConversation(prev => prev ? ({...prev, estado: originalState ?? prev.estado}) : null); // Reverte UI
      }
  }

  // --- Renderização ---

  // 1. Placeholder quando nenhuma conversa está selecionada
  if (!telefone) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-slate-500 p-10 text-center bg-white rounded-lg shadow">
        <MessageSquare size={60} className="mb-5 text-slate-300" />
        <h3 className="text-xl font-semibold mb-2 text-slate-700">Selecione uma Conversa</h3>
        <p className="max-w-md">Para visualizar os detalhes e interagir, clique em um card no quadro Kanban.</p>
      </div>
    );
  }

  // 2. Indicador de Carregamento
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
        <span className="ml-3 text-slate-600">Carregando conversa...</span>
      </div>
    );
  }

  // 3. Mensagem de Erro (se não conseguiu carregar a conversa)
  if (error && !conversation) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-red-600 p-6 bg-red-50 rounded-lg border border-red-200 relative">
         <Link to="/kanban" className="absolute top-4 left-4 text-slate-500 hover:text-slate-700 flex items-center text-sm bg-white px-2 py-1 rounded border border-slate-300 shadow-sm">
             <ArrowLeft size={16} className="mr-1"/> Kanban
         </Link>
        <AlertTriangle className="h-10 w-10 mb-3 text-red-500" />
        <p className="text-center font-medium mb-4">{error}</p>
        <button
            onClick={() => fetchConversation(telefone)}
            className="mt-2 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
        >
            Tentar Novamente
        </button>
      </div>
    );
  }

  // 4. Caso a conversa não seja encontrada após o carregamento
  if (!conversation) {
    return (
         <div className="flex flex-col items-center justify-center h-full text-slate-500 p-6 bg-slate-50 rounded-lg border relative">
             <Link to="/kanban" className="absolute top-4 left-4 text-slate-500 hover:text-slate-700 flex items-center text-sm bg-white px-2 py-1 rounded border border-slate-300 shadow-sm">
                 <ArrowLeft size={16} className="mr-1"/> Kanban
             </Link>
             <p>Não foi possível carregar os dados desta conversa.</p>
        </div>
    );
  }

  // 5. Renderização Principal da Conversa Detalhada
  return (
    // Container Flex principal que limita a altura
    <div className="flex h-full max-h-[calc(100vh-4rem)]"> {/* Ajuste a altura conforme necessário */}

      {/* Coluna Principal do Chat */}
      <div className="flex flex-col flex-1 h-full bg-white rounded-lg shadow-lg overflow-hidden border border-slate-200">

        {/* Cabeçalho do Chat */}
        <header className="bg-slate-50 p-3 border-b border-slate-200 flex items-center justify-between flex-shrink-0 sticky top-0 z-10">
           {/* Lado Esquerdo: Voltar, Nome, Estado */}
           <div className='flex items-center min-w-0'> {/* min-w-0 para truncar corretamente */}
               <Link to="/kanban" className="text-slate-500 hover:text-slate-700 mr-3 p-1 rounded-full hover:bg-slate-200" title="Voltar ao Kanban">
                   <ArrowLeft size={20} />
               </Link>
               <h2 className="text-lg font-semibold text-slate-800 truncate mr-3" title={conversation.tel}>
                 {conversation.nome || conversation.tel}
               </h2>
               {/* Dropdown para Mudar Estado */}
               <div className="relative inline-block text-left">
                  <select
                      value={conversation.estado}
                      onChange={handleStateChange}
                      title={`Estado atual: ${conversation.estado}. Clique para alterar.`}
                      className="appearance-none text-xs font-semibold bg-blue-100 text-blue-800 px-3 py-1 rounded-full border border-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-1 cursor-pointer pr-6"
                  >
                      {/* Opção atual (desabilitada para seleção) */}
                      <option value={conversation.estado} disabled>{conversation.estado}</option>
                      {/* Lista de Estados disponíveis para mudança */}
                      <option value="entrada">Entrada</option>
                      <option value="qualificacao">Qualificação</option>
                      <option value="proposta">Proposta</option>
                      <option value="pagamento_pendente">Pagamento Pendente</option>
                      <option value="triagem">Triagem Pós-Pgto</option>
                      <option value="agendado">Agendado</option>
                      <option value="atendimento_humano">Atendimento Humano</option>
                      <option value="followup">Follow-up</option>
                      <option value="concluido">Concluído/Perdido</option>
                  </select>
                  {/* Ícone de Seta para o Dropdown */}
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-1.5 text-blue-700">
                      <ChevronDown size={14} />
                  </div>
              </div>
           </div>
           {/* Lado Direito: Botão de Contexto */}
           <button
              onClick={() => setShowContext(!showContext)}
              className={`p-1.5 rounded-full transition-colors ${showContext ? 'bg-blue-100 text-blue-700' : 'text-slate-500 hover:text-slate-800 hover:bg-slate-100'}`}
              title={showContext ? "Ocultar Contexto" : "Mostrar Contexto"}
            >
              <Info size={18} />
            </button>
        </header>

        {/* Área de Histórico de Mensagens */}
        <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-gradient-to-b from-slate-50 to-slate-100 scrollbar-thin scrollbar-thumb-slate-300 scrollbar-track-slate-100">
          {conversation.historico.length === 0 && (
            <p className="text-center text-slate-400 text-sm mt-10 px-4">Nenhuma mensagem para exibir.</p>
          )}
          {/* Mapeia e renderiza cada mensagem */}
          {conversation.historico.map((msg) => (
            <ChatMessage key={msg.id} message={msg} />
          ))}
          {/* Elemento invisível no final para ajudar no scroll */}
          <div ref={messagesEndRef} />
        </div>

        {/* Rodapé com Inputs e Feedback */}
        <footer className="p-3 border-t border-slate-200 bg-white flex-shrink-0 space-y-2">
          {/* Input para Mensagem Humana */}
          <form onSubmit={handleSendHumanMessage} className="flex items-center">
            <input
              type="text"
              value={humanMessage}
              onChange={(e) => setHumanMessage(e.target.value)}
              placeholder="Mensagem do atendente..."
              disabled={isSendingHuman}
              className="flex-1 px-3 py-2 border border-slate-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500 text-sm transition-colors"
            />
            <button
              type="submit"
              disabled={isSendingHuman || !humanMessage.trim()}
              className="px-4 py-2 bg-green-600 text-white rounded-r-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-green-500 disabled:opacity-60 disabled:cursor-not-allowed transition-opacity duration-150 flex items-center justify-center h-[40px] w-[50px]"
              title="Enviar como Atendente"
            >
              {isSendingHuman ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send size={16} />}
            </button>
          </form>

          {/* Input para Simular Mensagem do Usuário */}
          <form onSubmit={handleSimulateUserMessage} className="flex items-center">
            <input
              type="text"
              value={simulateMessage}
              onChange={(e) => setSimulateMessage(e.target.value)}
              placeholder="Simular mensagem do usuário..."
              disabled={isSimulating}
              className="flex-1 px-3 py-2 border border-slate-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-orange-500 focus:border-orange-500 text-sm transition-colors"
            />
            <button
              type="submit"
              disabled={isSimulating || !simulateMessage.trim()}
              className="px-3 py-2 bg-orange-500 text-white rounded-r-md hover:bg-orange-600 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-orange-400 disabled:opacity-60 disabled:cursor-not-allowed flex items-center h-[40px]"
              title="Enviar esta mensagem como se fosse o usuário (para testar o bot)"
            >
              <Bot size={16} />
              <span className="ml-1 text-xs hidden sm:inline">Simular</span>
            </button>
          </form>

           {/* Área de Feedback (Sucesso/Erro) */}
           <div className="h-4 mt-1 text-center"> {/* Altura fixa para evitar pulos de layout */}
             {sendSuccess && (
               <p className="text-xs text-green-600 flex items-center justify-center animate-pulse"> {/* Animação sutil */}
                 <CheckCircle size={12} className="mr-1" /> {sendSuccess}
               </p>
             )}
             {sendError && (
               <p className="text-xs text-red-600 flex items-center justify-center">
                 <XCircle size={12} className="mr-1" /> {sendError}
               </p>
             )}
           </div>
        </footer>
      </div> {/* Fim da Coluna Principal do Chat */}

      {/* Painel Lateral de Contexto (Condicional e com Transição) */}
      <aside className={`transition-all duration-300 ease-in-out overflow-hidden ${showContext ? 'w-80 lg:w-96 border-l' : 'w-0 border-l-0'} border-slate-200 flex-shrink-0`}>
        {/* Conteúdo do painel só é renderizado se showContext for true */}
        {showContext && (
          <div className="p-4 h-full overflow-y-auto bg-slate-50">
            {/* Cabeçalho do Painel de Contexto */}
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-base font-semibold text-slate-700">Contexto da Conversa</h3>
              {/* Botão para fechar o painel */}
              <button onClick={() => setShowContext(false)} className="text-slate-400 hover:text-slate-600 p-1 rounded-full hover:bg-slate-200" title="Fechar Contexto">
                ✕ {/* Caractere 'X' */}
              </button>
            </div>
            {/* Container para o JSON formatado */}
            <div className="text-xs bg-white p-3 rounded border border-slate-200 shadow-sm">
              {/* Tag <pre> preserva formatação e permite scroll */}
              <pre className="whitespace-pre-wrap break-all scrollbar-thin scrollbar-thumb-slate-300 scrollbar-track-slate-100 max-h-[calc(100vh-10rem)]">
                {JSON.stringify(conversation.contexto, null, 2)}
              </pre>
            </div>
          </div>
        )}
      </aside> {/* Fim do Painel Lateral de Contexto */}

    </div> // Fim do Container Flex principal
  );
};

export default ChatView;

# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/AnalyticsView.tsx
import React from 'react'
import { Loader2 } from 'lucide-react'
import { useAnalytics } from '../hooks/useAnalytics'
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  Legend,
} from 'recharts'

const AnalyticsView: React.FC = () => {
  const { data, loading, error } = useAnalytics()

  if (loading)
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="animate-spin h-6 w-6 text-brand-secondary" />
      </div>
    )

  if (error || !data)
    return <p className="text-center text-red-600">{error ?? 'Sem dados'}</p>

  const chartData = [
    { nome: 'Leads', valor: data.leads },
    { nome: 'Qualificados', valor: data.qualificados },
    { nome: 'Pagos', valor: data.pagos },
  ]

  return (
    <div className="p-6 space-y-6">
      <h2 className="text-2xl font-semibold text-slate-700">Painel de KPIs</h2>

      {/* Cartões resumidos */}
      <div className="grid grid-cols-1 sm:grid-cols-4 gap-4">
        <StatCard label="Leads 24 h" value={data.leads} />
        <StatCard label="Qualificados 24 h" value={data.qualificados} />
        <StatCard label="Pagamentos 24 h" value={data.pagos} />
        <StatCard
          label="⌀ Lead → Pgto (s)"
          value={data.tempo_pg_segundos.toFixed(0)}
        />
      </div>

      {/* Gráfico de barras */}
      <div className="bg-white p-6 rounded-lg shadow">
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="nome" />
            <YAxis allowDecimals={false} />
            <Tooltip />
            <Legend />
            <Bar dataKey="valor" name="Total" />
          </BarChart>
        </ResponsiveContainer>
      </div>
    </div>
  )
}

const StatCard = ({ label, value }: { label: string; value: number | string }) => (
  <div className="bg-white rounded-lg shadow p-4 text-center">
    <p className="text-sm text-slate-500">{label}</p>
    <p className="text-3xl font-bold text-brand-primary mt-1">{value}</p>
  </div>
)

export default AnalyticsView

# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/DashboardKanban.tsx
/* ---------------------------------------------------------------------------
Dashboard Kanban de Conversas
--------------------------------------------------------------------------- */

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import {
  DndContext,
  closestCenter,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  arrayMove,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import dayjs from 'dayjs';

import { obterQuadroKanban, moverConversa } from '@/services/api';
import KanbanColumn from '@/components/KanbanColumn';
import type { KanbanCardProps } from '@/components/KanbanCard';

export type ColunaNome =
  | 'Novos'
  | 'IA Respondendo'
  | 'Triagem Emocional'
  | 'Aguardando Agendamento'
  | 'Com Profissional'
  | 'Escalonado'
  | 'Finalizado';

type Quadro = Record<ColunaNome, KanbanCardProps[]>;

const DashboardKanban: React.FC = () => {
  const [quadro, setQuadro] = useState<Quadro>({
    Novos: [],
    'IA Respondendo': [],
    'Triagem Emocional': [],
    'Aguardando Agendamento': [],
    'Com Profissional': [],
    Escalonado: [],
    Finalizado: [],
  });
  const [latencia, setLatencia] = useState(0);

  const carregarQuadro = useCallback(async () => {
    const ini = performance.now();
    const dados = await obterQuadroKanban();
    setLatencia(Math.round(performance.now() - ini));
    setQuadro(dados.colunas as Quadro);
  }, []);

  useEffect(() => {
    carregarQuadro();
    const id = setInterval(carregarQuadro, 30_000);
    return () => clearInterval(id);
  }, [carregarQuadro]);

  /* ---------- DnD ---------- */
  const sensors = useSensors(useSensor(PointerSensor));

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;
    if (!over || active.id === over.id) return;

    const origem = active.data.current?.coluna as ColunaNome;
    const destino = over.data.current?.coluna as ColunaNome;
    if (!origem || !destino || origem === destino) return;

    const card = quadro[origem].find((c) => c.id === active.id);
    if (!card) return;

    await moverConversa(String(card.id), destino);

    setQuadro((prev) => {
      const sem = prev[origem].filter((c) => c.id !== active.id);
      return {
        ...prev,
        [origem]: sem,
        [destino]: [card, ...prev[destino]],
      };
    });
  };

  const colunas: ColunaNome[] = useMemo(
    () => [
      'Novos',
      'IA Respondendo',
      'Triagem Emocional',
      'Aguardando Agendamento',
      'Com Profissional',
      'Escalonado',
      'Finalizado',
    ],
    [],
  );

  return (
    <div className="p-4 bg-slate-100 min-h-screen overflow-x-auto">
      <h1 className="text-2xl font-semibold mb-4">Painel de Conversas</h1>

      <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <div className="flex gap-4">
          {colunas.map((col) => (
            <SortableContext
              key={col}
              items={quadro[col].map((c) => c.id)}
              strategy={verticalListSortingStrategy}
            >
              <KanbanColumn nome={col} cards={quadro[col]} className="w-72" />
            </SortableContext>
          ))}
        </div>
      </DndContext>

      <div className="mt-6 text-xs text-slate-500">
        Latência API: {latencia} ms • Atualizado {dayjs().format('HH:mm:ss')}
      </div>
    </div>
  );
};

export default DashboardKanban;

# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/LoginPage.tsx
// ===========================================================
// Arquivo: src/pages/LoginPage.tsx
// Página de login simples.
// CORRIGIDO: Importação.
// ===========================================================
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { Navigate } from 'react-router-dom'; // Garanta que react-router-dom está instalado

const LoginPage: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const { login, isAuthenticated, isLoading } = useAuth();

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setError(null);
    setIsLoggingIn(true);
    try {
      await login(username, password);
      // O redirecionamento acontecerá automaticamente se isAuthenticated mudar para true
    } catch (err) {
      setError('Falha no login. Verifique usuário e senha.');
      console.error(err);
    } finally {
       setIsLoggingIn(false);
    }
  };

  // Redireciona se já estiver autenticado E o loading inicial tiver terminado
  if (!isLoading && isAuthenticated) {
    return <Navigate to="/" replace />;
  }

  // Mostra loading apenas durante a verificação inicial do token
  if (isLoading && !isAuthenticated && !isLoggingIn) {
      return (
          <div className="flex items-center justify-center min-h-screen bg-slate-100">
              <div className="text-center">
                  <p className="text-xl font-semibold text-slate-700">Verificando autenticação...</p>
                  {/* Adicionar um spinner/loading visual aqui */}
              </div>
          </div>
      );
  }

  // Renderiza o formulário de login
  return (
    <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-brand-accent to-blue-100">
      <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-xl">
        <h2 className="text-3xl font-bold text-center text-slate-800">
          Domo Hub Login
        </h2>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label
              htmlFor="username"
              className="block text-sm font-medium text-slate-700"
            >
              Usuário
            </label>
            <input
              id="username"
              name="username"
              type="text"
              autoComplete="username" // Adiciona autocomplete
              required
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="block w-full px-3 py-2 mt-1 text-slate-900 placeholder-slate-500 border border-slate-300 rounded-md shadow-sm appearance-none focus:outline-none focus:ring-brand-secondary focus:border-brand-secondary sm:text-sm"
              placeholder="admin"
            />
          </div>
          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-slate-700"
            >
              Senha
            </label>
            <input
              id="password"
              name="password"
              type="password"
              autoComplete="current-password" // Adiciona autocomplete
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="block w-full px-3 py-2 mt-1 text-slate-900 placeholder-slate-500 border border-slate-300 rounded-md shadow-sm appearance-none focus:outline-none focus:ring-brand-secondary focus:border-brand-secondary sm:text-sm"
              placeholder="password"
            />
          </div>

          {error && (
            <p className="text-sm text-center text-red-600">{error}</p>
          )}

          <div>
            <button
              type="submit"
              disabled={isLoggingIn || (isLoading && !isAuthenticated)} // Desabilita durante loading inicial também
              className="relative flex justify-center w-full px-4 py-2 text-sm font-medium text-white bg-brand-secondary border border-transparent rounded-md group hover:bg-brand-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-primary disabled:opacity-50 disabled:cursor-not-allowed"
            >
               {isLoggingIn ? 'Entrando...' : 'Entrar'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default LoginPage;


# Arquivo: domo_hub_frontend/domo-hub-app/src/pages/KanbanView.tsx
// File: src/pages/KanbanView.tsx
// Componente principal para a visualização do Kanban.

import React, { useState, useEffect, useCallback } from 'react';
import {
  DragDropContext,
  Droppable,
} from '@hello-pangea/dnd'; // Biblioteca para Drag and Drop
// Usa 'import type' para tipos específicos do DND
import type { DropResult } from '@hello-pangea/dnd';
// Funções da API e Tipos da Aplicação
import { getKanbanBoard, updateConversationState } from '../services/api'; // Importa funções da API
import type { KanbanBoardData, KanbanState, KanbanColumnData } from '../types'; // Importa tipos
// Componentes Filhos
import KanbanColumn from '../components/KanbanColumn';
// Ícones
import { Loader2, AlertTriangle, RefreshCw } from 'lucide-react'; // Adicionado RefreshCw

const KanbanView: React.FC = () => {
  // Estado para armazenar os dados do quadro Kanban
  const [boardState, setBoardState] = useState<KanbanState | null>(null);
  // Estado para controlar o carregamento inicial e refresh
  const [isLoading, setIsLoading] = useState(true);
  // Estado para armazenar mensagens de erro
  const [error, setError] = useState<string | null>(null);

  /**
   * Função assíncrona para buscar os dados do Kanban da API.
   * Usa useCallback para memorizar a função.
   */
  const fetchBoardData = useCallback(async (isRefreshing = false) => {
    if (!isRefreshing) {
        setError(null); // Limpa erros apenas no load inicial
        setIsLoading(true); // Ativa loading apenas no load inicial
    } else {
        console.log("Refreshing Kanban data..."); // Log para refresh
    }

    try {
      // Chama a função da API para obter os dados
      const boardData: KanbanBoardData = await getKanbanBoard();

      // Transforma os dados recebidos (array de colunas) em um mapa (objeto)
      const columnsMap: { [key: string]: KanbanColumnData } = {};
      boardData.columns.forEach(col => {
        // Garante que cards seja sempre um array, mesmo que a API retorne null/undefined
        columnsMap[col.id] = { ...col, cards: Array.isArray(col.cards) ? col.cards : [] };
      });

      // Define o estado inicial ou atualizado do Kanban
      const newState: KanbanState = {
        columns: columnsMap,
        columnOrder: boardData.columns.map(col => col.id), // Array com a ordem das colunas
      };
      setBoardState(newState); // Atualiza o estado do componente
      if (isRefreshing) setError(null); // Limpa erro se o refresh funcionou

    } catch (err: any) { // Especifica 'any' para o erro capturado
      console.error("Erro ao buscar dados do Kanban:", err);
      // Define a mensagem de erro de forma mais detalhada
      const errorMsg = err.code === 'ERR_NETWORK'
          ? "Erro de rede: Não foi possível conectar à API. Verifique se o backend está rodando e acessível."
          : err.response?.data?.detail || err.message || "Falha ao carregar o quadro Kanban.";
      setError(errorMsg);
      // Mantém o estado antigo em caso de erro no refresh para não limpar a tela
      if (!isRefreshing) setBoardState(null);
    } finally {
      // Desativa o indicador de carregamento (apenas no load inicial)
      if (!isRefreshing) setIsLoading(false);
    }
  }, []); // useCallback sem dependências externas diretas

  // useEffect para buscar os dados quando o componente é montado
  useEffect(() => {
    fetchBoardData();
  }, [fetchBoardData]); // Executa a função fetchBoardData na montagem

  /**
   * Handler chamado quando uma operação de arrastar e soltar termina.
   */
  const onDragEnd = useCallback(async (result: DropResult) => {
    const { destination, source, draggableId, type } = result;

    // 1. Validações Iniciais
    if (type !== 'CARD' || !destination) return;
    if (
      destination.droppableId === source.droppableId &&
      destination.index === source.index
    ) return;
    if (!boardState) return;

    // 2. Obtém colunas e card
    const startColumn = boardState.columns[source.droppableId];
    const endColumn = boardState.columns[destination.droppableId];
    if (!startColumn || !endColumn) return;

    const startCards = Array.from(startColumn.cards);
    const draggedCardIndex = startCards.findIndex(card => card.tel === draggableId);
    if (draggedCardIndex === -1) return;
    const [draggedCard] = startCards.splice(draggedCardIndex, 1);

    // Guarda o estado original para possível reversão
    const originalState = JSON.parse(JSON.stringify(boardState)); // Deep copy

    // 3. Atualização Otimista da UI
    const newEndCards = Array.from(endColumn.cards);
    newEndCards.splice(destination.index, 0, draggedCard);

    const newState: KanbanState = {
      ...boardState,
      columns: {
        ...boardState.columns,
        [startColumn.id]: { ...startColumn, cards: startCards },
        [endColumn.id]: { ...endColumn, cards: newEndCards },
      },
    };
    setBoardState(newState); // Atualiza a UI

    // 4. Chamada API para Persistir
    const novoEstadoBackend = destination.droppableId;
    try {
      await updateConversationState(draggableId, novoEstadoBackend);
      console.log(`Backend update success: State for ${draggableId} set to ${novoEstadoBackend}.`);
      // Opcional: feedback visual de sucesso
    } catch (err: any) { // Especifica 'any'
      console.error(`Erro ao atualizar estado no backend para ${draggableId}:`, err);
      setError(`Falha ao mover o card ${draggableId}. Tentando reverter...`);
      // Reverte a UI para o estado original em caso de erro na API
      setBoardState(originalState);
      // Opcional: Tentar buscar dados novamente após um delay
      // setTimeout(() => fetchBoardData(true), 1000);
    }
  }, [boardState]); // Depende do boardState

  // --- Renderização Condicional ---

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full pt-10">
        <Loader2 className="h-10 w-10 animate-spin text-blue-600" />
        <span className="ml-3 text-lg text-slate-600">Carregando Kanban...</span>
      </div>
    );
  }

  // Renderização de Erro (com botão de tentar novamente)
  if (error && !boardState) { // Mostra erro apenas se não houver dados antigos
    return (
      <div className="flex flex-col items-center justify-center h-full text-red-600 p-6 bg-red-50 rounded-lg border border-red-200">
        <AlertTriangle className="h-12 w-12 mb-3 text-red-500" />
        <p className="text-center font-medium mb-1">Erro ao Carregar Kanban</p>
        <p className="text-center text-sm text-red-700 mb-4">{error}</p>
        <button
            onClick={() => fetchBoardData()} // Re-busca os dados
            className="mt-2 px-5 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 flex items-center"
        >
            <RefreshCw size={16} className="mr-2"/>
            Tentar Novamente
        </button>
      </div>
    );
  }

  // Renderização de Quadro Vazio (se a API retornar vazio)
  if (!boardState || boardState.columnOrder.length === 0) {
    return (
        <div className="flex flex-col items-center justify-center h-full text-slate-500 p-6 bg-slate-100 rounded-lg">
             <h2 className="text-2xl font-semibold text-slate-800 mb-5 px-1 flex-shrink-0">
                Fluxo de Atendimento
             </h2>
             <p className="text-center">Nenhuma coluna ou dado para exibir no Kanban.</p>
             <p className="text-center text-sm mt-2">Verifique a API ou aguarde novas conversas.</p>
             <button
                onClick={() => fetchBoardData(true)} // Botão para refresh manual
                className="mt-4 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 flex items-center"
                title="Atualizar dados do Kanban"
             >
                <RefreshCw size={16} className="mr-2"/>
                Atualizar
             </button>
        </div>
    );
  }

  // --- Renderização do Quadro Kanban ---
  return (
    <div className="flex flex-col h-full">
       {/* Cabeçalho com Título e Botão de Refresh */}
       <div className="flex justify-between items-center mb-5 px-1 flex-shrink-0">
           <h2 className="text-2xl font-semibold text-slate-800">
             Fluxo de Atendimento
           </h2>
           {/* Exibe erro persistente mesmo com dados na tela */}
           {error && (
               <div className="text-xs text-red-600 flex items-center border border-red-200 bg-red-50 px-2 py-1 rounded">
                   <AlertTriangle size={14} className="mr-1"/> {error}
               </div>
           )}
           <button
             onClick={() => fetchBoardData(true)} // Botão para refresh manual
             className="p-2 text-slate-500 bg-white border border-slate-300 rounded-md hover:bg-slate-100 hover:text-slate-700 transition-colors focus:outline-none focus:ring-1 focus:ring-blue-400"
             title="Atualizar dados do Kanban"
           >
             <RefreshCw size={16} />
           </button>
       </div>

       {/* Contexto Principal do Drag and Drop */}
       <DragDropContext onDragEnd={onDragEnd}>
         {/* Container Dropável para as Colunas */}
         <Droppable droppableId="all-columns" direction="horizontal" type="COLUMN">
            {(provided) => (
                // Container Flex que organiza as colunas horizontalmente e permite scroll
                <div
                    {...provided.droppableProps}
                    ref={provided.innerRef}
                    className="flex flex-1 space-x-4 overflow-x-auto pb-4 px-1 scrollbar-thin scrollbar-thumb-slate-300 scrollbar-track-slate-100" // Estilo customizado da barra de scroll
                >
                {/* Mapeia a ordem das colunas e renderiza cada KanbanColumn */}
                {boardState.columnOrder.map((columnId) => {
                    const column = boardState.columns[columnId];
                    // Renderiza a coluna apenas se ela existir nos dados
                    if (!column) {
                        console.warn(`Coluna com ID ${columnId} não encontrada no estado.`);
                        return null;
                    }
                    return <KanbanColumn key={column.id} column={column} />;
                })}
                {/* Placeholder para espaço durante o arraste de colunas (se habilitado) */}
                {provided.placeholder}
                </div>
            )}
         </Droppable>
       </DragDropContext>
    </div>
  );
};

export default KanbanView;

# Arquivo: domo_hub_frontend/domo-hub-app/src/layouts/DomoShell.tsx
/* Estrutura simples: topo + conteúdo central */
import React, { type ReactNode } from 'react';
import { Link, Outlet } from 'react-router-dom';
import { KanbanSquare, MessagesSquare, BarChart2 } from 'lucide-react';

interface Props { children?: ReactNode }

const DomoShell: React.FC<Props> = ({ children }) => (
  <div className="min-h-screen flex flex-col">
    {/* topo */}
    <header className="h-12 flex items-center px-4 bg-slate-800 text-slate-100">
      <h1 className="text-lg font-semibold mr-6">Domo Hub</h1>
      <nav className="flex gap-4 text-sm">
        <Link className="flex items-center gap-1 hover:text-emerald-300" to="/kanban">
          <KanbanSquare size={16} /> Kanban
        </Link>
        <Link className="flex items-center gap-1 hover:text-emerald-300" to="/conversas">
          <MessagesSquare size={16} /> Conversas
        </Link>
        <Link className="flex items-center gap-1 hover:text-emerald-300" to="/analytics">
          <BarChart2 size={16} /> Analytics
        </Link>
      </nav>
    </header>

    {/* conteúdo */}
    <main className="flex-1 bg-slate-100 p-4 overflow-auto">
      {children ?? <Outlet />}
    </main>
  </div>
);

export default DomoShell;

# Arquivo: domo_hub_frontend/domo-hub-app/src/vite-env.d.ts
/// <reference types="vite/client" />

# Arquivo: domo_hub_frontend/domo-hub-app/src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

body { @apply bg-slate-100 text-slate-800 antialiased; }

# Arquivo: domo_hub_frontend/domo-hub-app/src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import DomoShell from '@/layouts/DomoShell';
import DashboardKanban from '@/pages/DashboardKanban';
import KanbanView from '@/pages/KanbanView';           // legado
import ChatView from '@/pages/ChatView';               // legado
import AnalyticsView from '@/pages/AnalyticsView';     // legado

const App: React.FC = () => (
  <BrowserRouter>
    <Routes>
      <Route element={<DomoShell />}>
        {/* novo painel */}
        <Route path="/kanban" element={<DashboardKanban />} />

        {/* rotas antigas para não quebrar nada */}
        <Route path="/kanban-old" element={<KanbanView />} />
        <Route path="/conversas" element={<ChatView />} />
        <Route path="/analytics" element={<AnalyticsView />} />

        {/* fallback */}
        <Route path="*" element={<Navigate to="/kanban" replace />} />
      </Route>
    </Routes>
  </BrowserRouter>
);

export default App;

# Arquivo: domo_hub_frontend/domo-hub-app/src/contexts/ModalConversaContext.tsx
/* ---------------------------------------------------------------------------
Contexto global para abrir/fechar <ConversaModal />
--------------------------------------------------------------------------- */

import React, { createContext, useState, useContext, ReactNode } from 'react';
import ConversaModal from '@/components/ConversaModal';

interface ModalCtx {
  abrir: (telefone: string) => void;
}

const Ctx = createContext<ModalCtx | null>(null);

export const useConversaModal = (): ModalCtx => {
  const ctx = useContext(Ctx);
  if (!ctx) throw new Error('ConversaModalProvider ausente');
  return ctx;
};

export const ConversaModalProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [telefoneAtivo, setTelefoneAtivo] = useState<string | null>(null);

  const abrir = (tel: string) => setTelefoneAtivo(tel);
  const fechar = () => setTelefoneAtivo(null);

  return (
    <Ctx.Provider value={{ abrir }}>
      {children}
      <ConversaModal telefone={telefoneAtivo} aberto={!!telefoneAtivo} onClose={fechar} />
    </Ctx.Provider>
  );
};

# Arquivo: domo_hub_frontend/domo-hub-app/src/contexts/AuthContext.tsx
// ===========================================================
// Arquivo: src/contexts/AuthContext.tsx
// Gerencia o estado de autenticação (token, usuário) na aplicação.
// CORRIGIDO: Importações de tipo.
// ===========================================================
import React, { createContext, useState, useContext, useEffect } from 'react';
import type { ReactNode } from 'react'; // Usa 'import type'
import { login as apiLogin, getCurrentUser } from '../services/api';
import type { User } from '../types'; // Usa 'import type'

interface AuthContextType {
  token: string | null;
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [token, setToken] = useState<string | null>(() => localStorage.getItem('authToken')); // Lê inicial do localStorage
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  useEffect(() => {
    const verifyToken = async () => {
      const storedToken = localStorage.getItem('authToken'); // Pega o token atual
      if (storedToken) {
        console.log("AuthContext: Token encontrado no localStorage, verificando...");
        setToken(storedToken); // Garante que o estado local tenha o token
        try {
          const currentUser = await getCurrentUser();
          setUser(currentUser);
          console.log("AuthContext: Token válido, usuário:", currentUser.username);
        } catch (error: any) {
          console.error("AuthContext: Falha ao verificar token (provavelmente expirado ou inválido):", error.response?.data || error.message);
          localStorage.removeItem('authToken');
          setToken(null);
          setUser(null);
        }
      } else {
         console.log("AuthContext: Nenhum token no localStorage.");
      }
      setIsLoading(false);
    };
    verifyToken();
  }, []); // Roda apenas uma vez na montagem inicial

  const login = async (username: string, password: string) => {
    try {
      setIsLoading(true);
      const data = await apiLogin(username, password);
      localStorage.setItem('authToken', data.access_token);
      setToken(data.access_token); // Atualiza o token no estado
      // Busca dados do usuário IMEDIATAMENTE após setar o token
      const currentUser = await getCurrentUser();
      setUser(currentUser);
      console.log("AuthContext: Login bem-sucedido, usuário:", currentUser.username);
      setIsLoading(false);
    } catch (error) {
      setIsLoading(false);
      console.error("AuthContext: Erro no login:", error);
      // Limpa qualquer token antigo em caso de falha
      localStorage.removeItem('authToken');
      setToken(null);
      setUser(null);
      throw error; // Re-lança o erro
    }
  };

  const logout = () => {
    console.log("AuthContext: Executando logout...");
    localStorage.removeItem('authToken');
    setToken(null);
    setUser(null);
    // Opcional: redirecionar para /login aqui se necessário,
    // mas o ProtectedRoute fará isso automaticamente.
  };

  // Recalcula isAuthenticated sempre que token ou user mudar
  const isAuthenticated = !!token && !!user;

  // Não renderiza children até que a verificação inicial esteja completa
  // if (isLoading) {
  //   return <div>Verificando autenticação...</div>; // Ou um spinner global
  // }

  return (
    <AuthContext.Provider value={{ token, user, isAuthenticated, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth deve ser usado dentro de um AuthProvider');
  }
  return context;
};

# Arquivo: domo_hub_frontend/domo-hub-app/src/components/KanbanCard.tsx
/* ---------------------------------------------------------------------------
Card de paciente para o Kanban
--------------------------------------------------------------------------- */

import React from 'react';
import { useSortable, defaultAnimateLayoutChanges } from '@dnd-kit/sortable';
import type { AnimateLayoutChanges } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import type { UniqueIdentifier } from '@dnd-kit/core';
import type { CSSProperties } from 'react';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { useConversaModal } from '@/contexts/ModalConversaContext';

dayjs.extend(relativeTime);

/* -----------------------  Tipos ----------------------- */
export interface KanbanCardProps {
  id: UniqueIdentifier;            // telefone
  nome: string;
  emoji_sentimento: string;
  risco: boolean;
  ultima_mensagem_ts: string | Date;
}

/* -----------------------  Animations ------------------ */
const animateLayoutChanges: AnimateLayoutChanges = (args) =>
  defaultAnimateLayoutChanges(args);   // sem wasDragged

/* -----------------------  Componente ------------------ */
const KanbanCard: React.FC<KanbanCardProps> = ({
  id,
  nome,
  emoji_sentimento,
  risco,
  ultima_mensagem_ts,
}) => {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } =
    useSortable({ id });

  const { abrir } = useConversaModal();

  const style: CSSProperties = {
    transform: CSS.Translate.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="bg-white shadow rounded-lg p-3 mb-2 border border-slate-200"
      {...attributes}
      {...listeners}
    >
      <div className="flex justify-between items-center">
        <span className="font-medium truncate">{nome}</span>
        <span className="text-xl">{emoji_sentimento}</span>
      </div>

      <div className="text-xs text-slate-500 mt-1">
        Última mensagem: {dayjs(ultima_mensagem_ts).fromNow()}
      </div>

      {risco && (
        <div className="mt-1 text-xs text-red-600 font-semibold">
          ⚠ Risco Detectado
        </div>
      )}

      <button
        className="mt-2 w-full text-xs px-2 py-1 bg-slate-200 hover:bg-slate-300 rounded"
        onClick={() => abrir(String(id))}
      >
        ver conversa
      </button>
    </div>
  );
};

export default KanbanCard;

# Arquivo: domo_hub_frontend/domo-hub-app/src/components/ProtectedRoute.tsx
// File: src/components/ProtectedRoute.tsx
// Componente para proteger rotas que exigem autenticação.
// ATUALMENTE DESABILITADO para permitir acesso direto durante o desenvolvimento.

import React from 'react';
// import { Navigate, Outlet } from 'react-router-dom'; // Removido Navigate não utilizado
import { Outlet } from 'react-router-dom';
// import { useAuth } from '../contexts/AuthContext'; // Descomentar quando usar login

const ProtectedRoute: React.FC = () => {
  // --- Lógica de Autenticação (Descomentar quando reimplementar) ---
  // const { isAuthenticated, isLoading } = useAuth();

  // // Mostra um estado de carregamento enquanto verifica o token inicial
  // if (isLoading) {
  //   return (
  //       <div className="flex items-center justify-center h-screen bg-slate-100">
  //           <div className="text-xl font-semibold text-slate-700">Verificando autenticação...</div>
  //           {/* Adicionar um spinner/loading visual aqui seria ideal */}
  //       </div>
  //   );
  // }

  // // Redireciona para a página de login se não estiver autenticado
  // if (!isAuthenticated) {
  //   console.log("ProtectedRoute: Não autenticado, redirecionando para /login");
  //   // O parâmetro 'replace' evita que a rota protegida entre no histórico do navegador
  //   return <Navigate to="/login" replace />;
  // }
  // --------------------------------------------------------------

  // Renderiza o conteúdo da rota filha (Outlet) se autenticado (ou se a proteção estiver desabilitada)
  // console.log("ProtectedRoute: Autenticado (ou proteção desabilitada), renderizando Outlet");
  return <Outlet />;
};

export default ProtectedRoute;

# Arquivo: domo_hub_frontend/domo-hub-app/src/components/KanbanColumn.tsx
/* ---------------------------------------------------------------------------
Coluna do Kanban
--------------------------------------------------------------------------- */

import React from 'react';
import { useDroppable } from '@dnd-kit/core';
import type { KanbanCardProps } from './KanbanCard';
import KanbanCard from './KanbanCard';

interface KanbanColumnProps extends React.HTMLAttributes<HTMLDivElement> {
  nome: string;
  cards: KanbanCardProps[];
}

const KanbanColumn: React.FC<KanbanColumnProps> = ({ nome, cards, className = '', ...rest }) => {
  const { setNodeRef, isOver } = useDroppable({ id: nome, data: { coluna: nome } });

  return (
    <div
      ref={setNodeRef}
      className={`flex flex-col bg-slate-50 rounded-lg border border-slate-300 p-3 ${className}`}
      {...rest}
    >
      <h2 className="text-sm font-semibold mb-2 uppercase tracking-wide">
        {nome} ({cards.length})
      </h2>

      <div className={`flex-1 overflow-y-auto ${isOver ? 'bg-emerald-50 border' : ''}`}>
        {cards.map((card) => (
          <KanbanCard key={card.id} {...card} />
        ))}
        {cards.length === 0 && (
          <div className="text-xs text-slate-400 text-center mt-4">Sem conversas</div>
        )}
      </div>
    </div>
  );
};

export default KanbanColumn;

# Arquivo: domo_hub_frontend/domo-hub-app/src/components/ConversaModal.tsx
/* ---------------------------------------------------------------------------
Arquivo: src/components/ConversaModal.tsx
Modal lateral para exibir conversa completa e responder manualmente
--------------------------------------------------------------------------- */

import React, { Fragment, useEffect, useState } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import dayjs from 'dayjs';
import {
  obterConversaCompleta,
  responderHumano,
  obterSugestaoIA,
} from '@/services/api';

interface Mensagem {
  criado_em: string;
  remetente: string;
  texto: string;
  intent?: string;
  fallback?: boolean;
}

interface ConversaModalProps {
  telefone: string | null;
  aberto: boolean;
  onClose: () => void;
}

const ConversaModal: React.FC<ConversaModalProps> = ({
  telefone,
  aberto,
  onClose,
}) => {
  const [mensagens, setMensagens] = useState<Mensagem[]>([]);
  const [loading, setLoading] = useState(false);
  const [mensagemResp, setMensagemResp] = useState('');
  const [sugestao, setSugestao] = useState<string | null>(null);

  useEffect(() => {
    if (!telefone) return;
    setLoading(true);
    obterConversaCompleta(telefone)
      .then((msgs: unknown) => setMensagens(msgs as Mensagem[]))
      .finally(() => setLoading(false));
  }, [telefone]);

  const enviarResposta = async () => {
    if (!telefone || !mensagemResp.trim()) return;
    await responderHumano(telefone, mensagemResp.trim(), 'Profissional');
    setMensagemResp('');
    onClose();
  };

  const pedirSugestao = async () => {
    if (!telefone) return;
    const txt = await obterSugestaoIA(telefone);
    setSugestao(txt);
  };

  return (
    <Transition show={aberto} as={Fragment}>
      <Dialog as="div" className="relative z-20" onClose={onClose}>
        {/* backdrop */}
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black/30 backdrop-blur-sm" />
        </Transition.Child>

        {/* painel */}
        <div className="fixed inset-0 flex justify-end">
          <Transition.Child
            as={Fragment}
            enter="transform transition ease-out duration-300"
            enterFrom="translate-x-full"
            enterTo="translate-x-0"
            leave="transform transition ease-in duration-200"
            leaveFrom="translate-x-0"
            leaveTo="translate-x-full"
          >
            <Dialog.Panel className="w-full max-w-lg bg-white shadow-xl p-6 flex flex-col">
              <Dialog.Title className="text-lg font-semibold mb-4">
                Conversa – {telefone ?? ''}
              </Dialog.Title>

              {/* mensagens */}
              <div className="flex-1 overflow-y-auto space-y-3 pr-1">
                {loading && <div>Carregando...</div>}
                {mensagens.map((m, idx) => (
                  <div
                    key={idx}
                    className={`rounded p-2 text-sm ${
                      m.remetente === 'paciente'
                        ? 'bg-slate-100'
                        : m.remetente.startsWith('[HUMANO')
                        ? 'bg-sky-100'
                        : m.fallback
                        ? 'bg-amber-100'
                        : 'bg-green-100'
                    }`}
                  >
                    <div className="text-xs text-slate-500 mb-1">
                      {m.remetente} • {dayjs(m.criado_em).format('DD/MM HH:mm')}
                      {m.fallback && ' • fallback'}
                    </div>
                    <div className="whitespace-pre-wrap">{m.texto}</div>
                  </div>
                ))}
              </div>

              {/* resposta manual */}
              <textarea
                className="border w-full p-2 mt-4 rounded h-24 resize-none"
                placeholder="Responder como humano..."
                value={mensagemResp}
                onChange={(e) => setMensagemResp(e.target.value)}
              />

              {sugestao && (
                <div className="mt-2 p-2 text-xs bg-emerald-50 rounded border border-emerald-200">
                  <strong>Sugestão IA:</strong> {sugestao}
                </div>
              )}

              <div className="flex gap-2 mt-3">
                <button
                  className="flex-1 bg-slate-200 hover:bg-slate-300 rounded p-2 text-sm"
                  onClick={pedirSugestao}
                >
                  pedir sugestão IA
                </button>
                <button
                  className="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white rounded p-2 text-sm"
                  onClick={enviarResposta}
                >
                  enviar resposta
                </button>
              </div>

              <button
                className="absolute top-2 right-3 text-slate-500 hover:text-slate-700"
                onClick={onClose}
              >
                ✕
              </button>
            </Dialog.Panel>
          </Transition.Child>
        </div>
      </Dialog>
    </Transition>
  );
};

export default ConversaModal;

# Arquivo: domo_hub_frontend/domo-hub-app/src/components/ChatMessage.tsx
// File: src/components/ChatMessage.tsx
// Componente para exibir uma única mensagem na tela de chat.

import React from 'react';
// Usa 'import type' para tipos
import type { MessageData } from '../types';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Bot, User, UserCog } from 'lucide-react'; // Ícones para identificar remetente

interface ChatMessageProps {
  message: MessageData;
}

const ChatMessage: React.FC<ChatMessageProps> = ({ message }) => {
  // Determina o tipo de remetente
  const isUser = message.sender === 'user';
  const isBot = message.sender === 'bot';
  // const isHuman = message.sender === 'human'; // Removido - não estava sendo usado na lógica abaixo

  // Formata o timestamp da mensagem
  const formattedTime = message.timestamp
    ? format(new Date(message.timestamp), 'dd/MM HH:mm', { locale: ptBR })
    : ''; // Fallback se não houver timestamp

  // Define classes CSS para o balão da mensagem com base no remetente
  const bubbleClasses = isUser
    ? 'bg-blue-600 text-white rounded-tr-none shadow-md' // Usuário: Azul, canto superior direito reto
    : isBot
    ? 'bg-slate-200 text-slate-800 rounded-tl-none shadow-sm' // Bot: Cinza, canto superior esquerdo reto
    : 'bg-green-100 text-green-900 border border-green-200 rounded-tl-none shadow-sm'; // Humano: Verde, canto superior esquerdo reto

  // Define o alinhamento da mensagem (direita para usuário, esquerda para outros)
  const alignmentClasses = isUser ? 'items-end' : 'items-start';
  const senderName = isUser ? 'Você' : isBot ? 'Domo' : 'Atendente';

  // Seleciona o ícone apropriado para o remetente
  const SenderIcon = isUser ? User : isBot ? Bot : UserCog;
  const iconColor = isUser ? 'text-blue-400' : isBot ? 'text-slate-500' : 'text-green-600';

  return (
    <div className={`flex flex-col w-full my-2 ${alignmentClasses}`}>
      {/* Container para Ícone, Nome e Hora */}
      <div className={`flex items-center mb-1 text-xs ${isUser ? 'flex-row-reverse' : 'flex-row'}`}>
        {/* Ícone do Remetente */}
        <SenderIcon size={14} className={`mx-1.5 ${iconColor} flex-shrink-0`} />
        {/* Nome do Remetente */}
        <span className="font-medium text-slate-600">{senderName}</span>
        {/* Separador */}
        <span className="text-slate-400 mx-1.5">•</span>
        {/* Timestamp */}
        <span className="text-slate-400">{formattedTime}</span>
      </div>

      {/* Balão da Mensagem */}
      <div
        className={`max-w-[75%] md:max-w-[65%] px-3 py-2 rounded-lg ${bubbleClasses}`}
      >
        {/* Texto da Mensagem */}
        <p className="text-sm whitespace-pre-wrap break-words">{message.text}</p>

        {/* Informações Adicionais (Intent/Sentimento) - Apenas para Usuário */}
        {isUser && (message.intent || message.sentimento) && (
          <div className="mt-1 pt-1 border-t border-white/20 text-xs opacity-80 italic flex flex-wrap gap-x-2">
            {/* Exibe a Intent detectada */}
            {message.intent && <span>Intent: {message.intent}</span>}
            {/* Exibe o Sentimento detectado (formatado) */}
            {message.sentimento && (
              <span>
                Sent: {Object.entries(message.sentimento)
                  .sort(([, a], [, b]) => b - a) // Ordena por score decrescente
                  .map(([key, value]) => `${key.substring(0, 3)}: ${Math.round(value * 100)}%`) // Formata (ex: pos: 80%)
                  .join(', ')}
              </span>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default ChatMessage;

# Arquivo: domo_hub_frontend/domo-hub-app/tsconfig.app.json
{
  "compilerOptions": {
    /* Saída e build‑cache */
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",

    /* Alvo JS + libs */
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],

    /* Módulos / bundler */
    "module": "ESNext",
    "moduleResolution": "node",
    "resolvePackageJsonExports": false,
    "noEmit": true,

    /* JSX moderno */
    "jsx": "react-jsx",
    "allowSyntheticDefaultImports": true,
    "verbatimModuleSyntax": true,
    "useDefineForClassFields": true,

    /* Qualidade de código */
    "strict": true,
    "skipLibCheck": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "erasableSyntaxOnly": true,

    /* Tipos adicionais + alias @/ */
    "typeRoots": ["./src/types", "./node_modules/@types"],
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"],
      "recharts": ["./node_modules/recharts/types/index.d.ts"]
    }
  },
  "include": ["src"]
}

# Arquivo: domo_hub_frontend/domo-hub-app/eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

# Arquivo: domo_hub_frontend/domo-hub-app/tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

# Arquivo: domo_hub_frontend/domo-hub-app/package.json
{
  "name": "domo-hub-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "tailwind:init": "tailwindcss init -p"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@headlessui/react": "^2.2.2",
    "@hello-pangea/dnd": "^18.0.1",
    "axios": "^1.9.0",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "lucide-react": "^0.507.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.5.3",
    "recharts": "^2.8.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@tailwindcss/cli": "^4.1.5",
    "@tailwindcss/postcss": "^4.1.5",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22.15.11",
    "@types/react": "^19.1.3",
    "@types/react-beautiful-dnd": "^13.1.8",
    "@types/react-dom": "^19.1.3",
    "@types/recharts": "^1.8.24",
    "@vitejs/plugin-react": "^4.4.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.1.5",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

# Arquivo: domo_hub_frontend/domo-hub-app/postcss.config.js
export default {
  plugins: {
    '@tailwindcss/postcss': {},   // usa o plugin novo
    autoprefixer: {},
  },
};

# Arquivo: domo_hub_frontend/domo-hub-app/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import * as path from 'node:path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'), // habilita "@/..."
    },
  },
});

# Arquivo: domo_hub_frontend/domo-hub-app/tailwind.config.js
/** @type {import('tailwindcss').Config} */
import colors from 'tailwindcss/colors.js';

export default {
  content: ['./index.html', './src/**/*.{ts,tsx}'],
  safelist: [
    { pattern: /(bg|text|border|ring|outline|stroke|fill)-neutral-(50|100|200|300|400|500|600|700|800|900)/ },
  ],
  theme: {
    extend: {
      colors: {
        neutral: colors.neutral,      // reintroduz escala
        primary: { DEFAULT: '#047857' },
      },
    },
  },
  plugins: [require('@tailwindcss/typography')],
};

# Arquivo: domo_hub_frontend/domo-hub-app/public/vite.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
# Arquivo: domo_hub_frontend/domo-hub-app/package-lock.json
{
  "name": "domo-hub-app",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "domo-hub-app",
      "version": "0.0.0",
      "dependencies": {
        "@dnd-kit/core": "^6.3.1",
        "@dnd-kit/sortable": "^10.0.0",
        "@dnd-kit/utilities": "^3.2.2",
        "@headlessui/react": "^2.2.2",
        "@hello-pangea/dnd": "^18.0.1",
        "@tailwindcss/typography": "^0.5.16",
        "axios": "^1.9.0",
        "date-fns": "^4.1.0",
        "dayjs": "^1.11.13",
        "lucide-react": "^0.507.0",
        "react": "^19.1.0",
        "react-dom": "^19.1.0",
        "react-router-dom": "^7.5.3",
        "recharts": "^2.8.0"
      },
      "devDependencies": {
        "@eslint/js": "^9.25.0",
        "@types/node": "^22.15.11",
        "@types/react": "^19.1.3",
        "@types/react-beautiful-dnd": "^13.1.8",
        "@types/react-dom": "^19.1.3",
        "@types/recharts": "^1.8.24",
        "@vitejs/plugin-react": "^4.4.1",
        "autoprefixer": "^10.4.21",
        "eslint": "^9.25.0",
        "eslint-plugin-react-hooks": "^5.2.0",
        "eslint-plugin-react-refresh": "^0.4.19",
        "globals": "^16.0.0",
        "postcss": "^8.5.3",
        "tailwindcss": "^4.1.5",
        "typescript": "~5.8.3",
        "typescript-eslint": "^8.30.1",
        "vite": "^6.3.5"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.27.1.tgz",
      "integrity": "sha512-Q+E+rd/yBzNQhXkG+zQnF58e4zoZfBedaxwzPmicKsiK3nt8iJYrSrDbjwFFDGC4f+rPafqRaPH6TsDoSvMf7A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.27.1.tgz",
      "integrity": "sha512-IaaGWsQqfsQWVLqMn9OB92MNN7zukfVA4s7KKAI0KfrrDsZ0yhi5uV4baBuLuN7n3vsZpwP8asPPcVwApxvjBQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.27.1",
        "@babel/helper-compilation-targets": "^7.27.1",
        "@babel/helper-module-transforms": "^7.27.1",
        "@babel/helpers": "^7.27.1",
        "@babel/parser": "^7.27.1",
        "@babel/template": "^7.27.1",
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.27.1.tgz",
      "integrity": "sha512-UnJfnIpc/+JO0/+KRVQNGU+y5taA5vCbwN8+azkX6beii/ZF+enZJSOKo11ZSzGJjlNfJHfQtmQT8H+9TXPG2w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.27.1",
        "@babel/types": "^7.27.1",
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.25",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.1.tgz",
      "integrity": "sha512-2YaDd/Rd9E598B5+WIc8wJPmWETiiJXFYVE60oX8FDohv7rAUU3CQj+A1MgeEmcsk2+dQuEjIe/GDvig0SqL4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.27.1.tgz",
      "integrity": "sha512-9yHn519/8KvTU5BjTVEEeIM3w9/2yXNKoD82JifINImhpKkARMJKPP59kLo+BafpdN5zgNeIcS4jsGDmd3l58g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.1.tgz",
      "integrity": "sha512-FCvFTm0sWV8Fxhpp2McP5/W53GPllQ9QeQ7SiqGWjMf/LVG07lFa5+pgK05IRhVwtvafT22KF+ZSnM9I545CvQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.1.tgz",
      "integrity": "sha512-I0dZ3ZpCrJ1c04OqlNsQcKiZlsrXf/kkE4FXzID9rIOYICsAbA8mMDzhW/luRNAHdCNt7os/u8wenklZDlUVUQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.1"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.1.tgz",
      "integrity": "sha512-1x3D2xEk2fRo3PAhwQwu5UubzgiVWSXTBfWpVd2Mx2AzRqJuDJCsgaDVZ7HB5iGzDW1Hl1sWN2mFyKjmR9uAog==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.1.tgz",
      "integrity": "sha512-Fyo3ghWMqkHHpHQCoBs2VnYjR4iWFFjguTDEqA5WgZDOrFesVjMhMM2FSqTKSoUSDO1VQtavj8NFpdRBEvJTtg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.27.1.tgz",
      "integrity": "sha512-ZCYtZciz1IWJB4U61UPu4KEaqyfj+r5T1Q5mqPo+IBpcG9kHv30Z0aD8LXPgC1trYa6rK0orRyAhqUgk4MjmEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.27.1",
        "@babel/parser": "^7.27.1",
        "@babel/template": "^7.27.1",
        "@babel/types": "^7.27.1",
        "debug": "^4.3.1",
        "globals": "^11.1.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse/node_modules/globals": {
      "version": "11.12.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.1.tgz",
      "integrity": "sha512-+EzkxvLNfiUeKMgy/3luqfsCWFRXLb7U6wNQTk60tovuckwB15B191tJWvpp4HjiQWdJkCxO3Wbvc6jlk3Xb2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@dnd-kit/accessibility": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/@dnd-kit/accessibility/-/accessibility-3.1.1.tgz",
      "integrity": "sha512-2P+YgaXF+gRsIihwwY1gCsQSYnu9Zyj2py8kY5fFvUM1qm2WA2u639R6YNVfU4GWr+ZM5mqEsfHZZLoRONbemw==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0"
      }
    },
    "node_modules/@dnd-kit/core": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/@dnd-kit/core/-/core-6.3.1.tgz",
      "integrity": "sha512-xkGBRQQab4RLwgXxoqETICr6S5JlogafbhNsidmrkVv2YRs5MLwpjoF2qpiGjQt8S9AoxtIV603s0GIUpY5eYQ==",
      "license": "MIT",
      "dependencies": {
        "@dnd-kit/accessibility": "^3.1.1",
        "@dnd-kit/utilities": "^3.2.2",
        "tslib": "^2.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@dnd-kit/sortable": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@dnd-kit/sortable/-/sortable-10.0.0.tgz",
      "integrity": "sha512-+xqhmIIzvAYMGfBYYnbKuNicfSsk4RksY2XdmJhT+HAC01nix6fHCztU68jooFiMUB01Ky3F0FyOvhG/BZrWkg==",
      "license": "MIT",
      "dependencies": {
        "@dnd-kit/utilities": "^3.2.2",
        "tslib": "^2.0.0"
      },
      "peerDependencies": {
        "@dnd-kit/core": "^6.3.0",
        "react": ">=16.8.0"
      }
    },
    "node_modules/@dnd-kit/utilities": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/@dnd-kit/utilities/-/utilities-3.2.2.tgz",
      "integrity": "sha512-+MKAJEOfaBe5SmV6t34p80MMKhjvUz0vRrvVJbPT0WElzaOJ/1xs+D+KDv+tD/NE5ujfrChEcshd4fLn0wpiqg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.3.tgz",
      "integrity": "sha512-W8bFfPA8DowP8l//sxjJLSLkD8iEjMc7cBVyP+u4cEv9sM7mdUCkgsj+t0n/BWPFtv7WWCN5Yzj0N6FJNUUqBQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.3.tgz",
      "integrity": "sha512-PuwVXbnP87Tcff5I9ngV0lmiSu40xw1At6i3GsU77U7cjDDB4s0X2cyFuBiDa1SBk9DnvWwnGvVaGBqoFWPb7A==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.3.tgz",
      "integrity": "sha512-XelR6MzjlZuBM4f5z2IQHK6LkK34Cvv6Rj2EntER3lwCBFdg6h2lKbtRjpTTsdEjD/WSe1q8UyPBXP1x3i/wYQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.3.tgz",
      "integrity": "sha512-ogtTpYHT/g1GWS/zKM0cc/tIebFjm1F9Aw1boQ2Y0eUQ+J89d0jFY//s9ei9jVIlkYi8AfOjiixcLJSGNSOAdQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.3.tgz",
      "integrity": "sha512-eESK5yfPNTqpAmDfFWNsOhmIOaQA59tAcF/EfYvo5/QWQCzXn5iUSOnqt3ra3UdzBv073ykTtmeLJZGt3HhA+w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.3.tgz",
      "integrity": "sha512-Kd8glo7sIZtwOLcPbW0yLpKmBNWMANZhrC1r6K++uDR2zyzb6AeOYtI6udbtabmQpFaxJ8uduXMAo1gs5ozz8A==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.3.tgz",
      "integrity": "sha512-EJiyS70BYybOBpJth3M0KLOus0n+RRMKTYzhYhFeMwp7e/RaajXvP+BWlmEXNk6uk+KAu46j/kaQzr6au+JcIw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.3.tgz",
      "integrity": "sha512-Q+wSjaLpGxYf7zC0kL0nDlhsfuFkoN+EXrx2KSB33RhinWzejOd6AvgmP5JbkgXKmjhmpfgKZq24pneodYqE8Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.3.tgz",
      "integrity": "sha512-dUOVmAUzuHy2ZOKIHIKHCm58HKzFqd+puLaS424h6I85GlSDRZIA5ycBixb3mFgM0Jdh+ZOSB6KptX30DD8YOQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.3.tgz",
      "integrity": "sha512-xCUgnNYhRD5bb1C1nqrDV1PfkwgbswTTBRbAd8aH5PhYzikdf/ddtsYyMXFfGSsb/6t6QaPSzxtbfAZr9uox4A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.3.tgz",
      "integrity": "sha512-yplPOpczHOO4jTYKmuYuANI3WhvIPSVANGcNUeMlxH4twz/TeXuzEP41tGKNGWJjuMhotpGabeFYGAOU2ummBw==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.3.tgz",
      "integrity": "sha512-P4BLP5/fjyihmXCELRGrLd793q/lBtKMQl8ARGpDxgzgIKJDRJ/u4r1A/HgpBpKpKZelGct2PGI4T+axcedf6g==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.3.tgz",
      "integrity": "sha512-eRAOV2ODpu6P5divMEMa26RRqb2yUoYsuQQOuFUexUoQndm4MdpXXDBbUoKIc0iPa4aCO7gIhtnYomkn2x+bag==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.3.tgz",
      "integrity": "sha512-ZC4jV2p7VbzTlnl8nZKLcBkfzIf4Yad1SJM4ZMKYnJqZFD4rTI+pBG65u8ev4jk3/MPwY9DvGn50wi3uhdaghg==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.3.tgz",
      "integrity": "sha512-LDDODcFzNtECTrUUbVCs6j9/bDVqy7DDRsuIXJg6so+mFksgwG7ZVnTruYi5V+z3eE5y+BJZw7VvUadkbfg7QA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.3.tgz",
      "integrity": "sha512-s+w/NOY2k0yC2p9SLen+ymflgcpRkvwwa02fqmAwhBRI3SC12uiS10edHHXlVWwfAagYSY5UpmT/zISXPMW3tQ==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.3.tgz",
      "integrity": "sha512-nQHDz4pXjSDC6UfOE1Fw9Q8d6GCAd9KdvMZpfVGWSJztYCarRgSDfOVBY5xwhQXseiyxapkiSJi/5/ja8mRFFA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.3.tgz",
      "integrity": "sha512-1QaLtOWq0mzK6tzzp0jRN3eccmN3hezey7mhLnzC6oNlJoUJz4nym5ZD7mDnS/LZQgkrhEbEiTn515lPeLpgWA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.3.tgz",
      "integrity": "sha512-i5Hm68HXHdgv8wkrt+10Bc50zM0/eonPb/a/OFVfB6Qvpiirco5gBA5bz7S2SHuU+Y4LWn/zehzNX14Sp4r27g==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.3.tgz",
      "integrity": "sha512-zGAVApJEYTbOC6H/3QBr2mq3upG/LBEXr85/pTtKiv2IXcgKV0RT0QA/hSXZqSvLEpXeIxah7LczB4lkiYhTAQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.3.tgz",
      "integrity": "sha512-fpqctI45NnCIDKBH5AXQBsD0NDPbEFczK98hk/aa6HJxbl+UtLkJV2+Bvy5hLSLk3LHmqt0NTkKNso1A9y1a4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.3.tgz",
      "integrity": "sha512-ROJhm7d8bk9dMCUZjkS8fgzsPAZEjtRJqCAmVgB0gMrvG7hfmPmz9k1rwO4jSiblFjYmNvbECL9uhaPzONMfgA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.3.tgz",
      "integrity": "sha512-YWcow8peiHpNBiIXHwaswPnAXLsLVygFwCB3A7Bh5jRkIBFWHGmNQ48AlX4xDvQNoMZlPYzjVOQDYEzWCqufMQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.3.tgz",
      "integrity": "sha512-qspTZOIGoXVS4DpNqUYUs9UxVb04khS1Degaw/MnfMe7goQ3lTfQ13Vw4qY/Nj0979BGvMRpAYbs/BAxEvU8ew==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.3.tgz",
      "integrity": "sha512-ICgUR+kPimx0vvRzf+N/7L7tVSQeE3BYY+NhHRHXS1kBuPO7z2+7ea2HbhDyZdTephgvNvKrlDDKUexuCVBVvg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.7.0.tgz",
      "integrity": "sha512-dyybb3AcajC7uha6CvhdVRJqaKyn7w2YKqKyAN37NKYgZT36w+iRb0Dymmc5qEJ549c/S31cMMSFd75bteCpCw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
      "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.20.0",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.20.0.tgz",
      "integrity": "sha512-fxlS1kkIjx8+vy2SjuCB94q3htSNrufYTXubwiBFeaQHbH6Ipi43gFJq2zCMt6PHhImH3Xmr0NksKDvchWlpQQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.6",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.2.2.tgz",
      "integrity": "sha512-+GPzk8PlG0sPpzdU5ZvIRMPidzAnZDl/s9L+y13iodqvb8leL53bTannOrQ/Im7UkpsmFU5Ily5U60LWixnmLg==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.13.0.tgz",
      "integrity": "sha512-yfkgDw1KR66rkT5A8ci4irzDysN7FRpq3ttJolR88OqQikAWqwA8j5VZyas+vjyBNFIJ7MfybJ9plMILI2UrCw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.1.tgz",
      "integrity": "sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.26.0",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.26.0.tgz",
      "integrity": "sha512-I9XlJawFdSMvWjDt6wksMCrgns5ggLNfFwFvnShsleWruvXM514Qxk8V246efTw+eo9JABvVz+u3q2RiAowKxQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.6",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.6.tgz",
      "integrity": "sha512-RBMg5FRL0I0gs51M/guSAj5/e14VQ4tpZnQNWwuDT66P14I43ItmPfIZRhO9fUVIPOAQXU47atlywZ/czoqFPA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.2.8",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.2.8.tgz",
      "integrity": "sha512-ZAoA40rNMPwSm+AeHpCq8STiNAwzWLJuP8Xv4CHIc9wv/PSuExjMrmjfYNj682vW0OOiZ1HKxzvjQr9XZIisQA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.13.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.7.0.tgz",
      "integrity": "sha512-FRdBLykrPPA6P76GGGqlex/e7fbe0F1ykgxHYNXQsH/iTEtjMj/f9bpY5oQqbjt5VgZvgz/uKXbGuROijh3VLA==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.7.0.tgz",
      "integrity": "sha512-lGTor4VlXcesUMh1cupTUTDoCxMb0V6bm3CnxHzQcw8Eaf1jQbgQX4i02fYgT0vJ82tb5MZ4CZk1LRGkktJCzg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.7.0",
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/react": {
      "version": "0.26.28",
      "resolved": "https://registry.npmjs.org/@floating-ui/react/-/react-0.26.28.tgz",
      "integrity": "sha512-yORQuuAtVpiRjpMhdc0wJj06b9JFjrYF4qp96j++v2NBpbi6SEGF7donUJ3TMieerQ6qVkAv1tgr7L4r5roTqw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.1.2",
        "@floating-ui/utils": "^0.2.8",
        "tabbable": "^6.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.2.tgz",
      "integrity": "sha512-06okr5cgPzMNBy+Ycse2A6udMi4bqwW/zgBF/rwjcNqWkyr82Mcg8b0vjX8OJpZFy/FKjJmw6wV7t44kK6kW7A==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.9",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.9.tgz",
      "integrity": "sha512-MDWhGtE+eHw5JW7lq4qhc5yRLS11ERl1c7Z6Xd0a58DozHES6EnNNwUWbMiG4J9Cgj053Bhk8zvlhFYKVhULwg==",
      "license": "MIT"
    },
    "node_modules/@headlessui/react": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@headlessui/react/-/react-2.2.2.tgz",
      "integrity": "sha512-zbniWOYBQ8GHSUIOPY7BbdIn6PzUOq0z41RFrF30HbjsxG6Rrfk+6QulR8Kgf2Vwj2a/rE6i62q5vo+2gI5dJA==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react": "^0.26.16",
        "@react-aria/focus": "^3.17.1",
        "@react-aria/interactions": "^3.21.3",
        "@tanstack/react-virtual": "^3.13.6",
        "use-sync-external-store": "^1.5.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "react": "^18 || ^19 || ^19.0.0-rc",
        "react-dom": "^18 || ^19 || ^19.0.0-rc"
      }
    },
    "node_modules/@hello-pangea/dnd": {
      "version": "18.0.1",
      "resolved": "https://registry.npmjs.org/@hello-pangea/dnd/-/dnd-18.0.1.tgz",
      "integrity": "sha512-xojVWG8s/TGrKT1fC8K2tIWeejJYTAeJuj36zM//yEm/ZrnZUSFGS15BpO+jGZT1ybWvyXmeDJwPYb4dhWlbZQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@babel/runtime": "^7.26.7",
        "css-box-model": "^1.2.1",
        "raf-schd": "^4.0.3",
        "react-redux": "^9.2.0",
        "redux": "^5.0.1"
      },
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.6",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.6.tgz",
      "integrity": "sha512-YuI2ZHQL78Q5HbhDiBA1X4LmYdXCKCMQIfw0pw7piHJwyREFebJUvrQN4cMssyES6x+vfUbx1CIpaQUKYdQZOw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.3.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node/node_modules/@humanwhocodes/retry": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.3.1.tgz",
      "integrity": "sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.2.tgz",
      "integrity": "sha512-xeO57FpIu4p1Ri3Jq/EXq4ClRm86dVF2z/+kvFnyqVYRavTZmaFaUBbWCOuuTh0o/g7DSsk6kc2vrS4Vl5oPOQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.8",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.8.tgz",
      "integrity": "sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.2.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/set-array": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz",
      "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.25",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz",
      "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@modelcontextprotocol/sdk": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.11.0.tgz",
      "integrity": "sha512-k/1pb70eD638anoi0e8wUGAlbMJXyvdV4p62Ko+EZ7eBe1xMx8Uhak1R5DgfoofsK5IBBnRwsYGTaLZl+6/+RQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "cors": "^2.8.5",
        "cross-spawn": "^7.0.3",
        "eventsource": "^3.0.2",
        "express": "^5.0.1",
        "express-rate-limit": "^7.5.0",
        "pkce-challenge": "^5.0.0",
        "raw-body": "^3.0.0",
        "zod": "^3.23.8",
        "zod-to-json-schema": "^3.24.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@react-aria/focus": {
      "version": "3.20.2",
      "resolved": "https://registry.npmjs.org/@react-aria/focus/-/focus-3.20.2.tgz",
      "integrity": "sha512-Q3rouk/rzoF/3TuH6FzoAIKrl+kzZi9LHmr8S5EqLAOyP9TXIKG34x2j42dZsAhrw7TbF9gA8tBKwnCNH4ZV+Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/interactions": "^3.25.0",
        "@react-aria/utils": "^3.28.2",
        "@react-types/shared": "^3.29.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/interactions": {
      "version": "3.25.0",
      "resolved": "https://registry.npmjs.org/@react-aria/interactions/-/interactions-3.25.0.tgz",
      "integrity": "sha512-GgIsDLlO8rDU/nFn6DfsbP9rfnzhm8QFjZkB9K9+r+MTSCn7bMntiWQgMM+5O6BiA8d7C7x4zuN4bZtc0RBdXQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.8",
        "@react-aria/utils": "^3.28.2",
        "@react-stately/flags": "^3.1.1",
        "@react-types/shared": "^3.29.0",
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/ssr": {
      "version": "3.9.8",
      "resolved": "https://registry.npmjs.org/@react-aria/ssr/-/ssr-3.9.8.tgz",
      "integrity": "sha512-lQDE/c9uTfBSDOjaZUJS8xP2jCKVk4zjQeIlCH90xaLhHDgbpCdns3xvFpJJujfj3nI4Ll9K7A+ONUBDCASOuw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "engines": {
        "node": ">= 12"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-aria/utils": {
      "version": "3.28.2",
      "resolved": "https://registry.npmjs.org/@react-aria/utils/-/utils-3.28.2.tgz",
      "integrity": "sha512-J8CcLbvnQgiBn54eeEvQQbIOfBF3A1QizxMw9P4cl9MkeR03ug7RnjTIdJY/n2p7t59kLeAB3tqiczhcj+Oi5w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@react-aria/ssr": "^3.9.8",
        "@react-stately/flags": "^3.1.1",
        "@react-stately/utils": "^3.10.6",
        "@react-types/shared": "^3.29.0",
        "@swc/helpers": "^0.5.0",
        "clsx": "^2.0.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1",
        "react-dom": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-stately/flags": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/@react-stately/flags/-/flags-3.1.1.tgz",
      "integrity": "sha512-XPR5gi5LfrPdhxZzdIlJDz/B5cBf63l4q6/AzNqVWFKgd0QqY5LvWJftXkklaIUpKSJkIKQb8dphuZXDtkWNqg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      }
    },
    "node_modules/@react-stately/utils": {
      "version": "3.10.6",
      "resolved": "https://registry.npmjs.org/@react-stately/utils/-/utils-3.10.6.tgz",
      "integrity": "sha512-O76ip4InfTTzAJrg8OaZxKU4vvjMDOpfA/PGNOytiXwBbkct2ZeZwaimJ8Bt9W1bj5VsZ81/o/tW4BacbdDOMA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@swc/helpers": "^0.5.0"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@react-types/shared": {
      "version": "3.29.0",
      "resolved": "https://registry.npmjs.org/@react-types/shared/-/shared-3.29.0.tgz",
      "integrity": "sha512-IDQYu/AHgZimObzCFdNl1LpZvQW/xcfLt3v20sorl5qRucDVj4S9os98sVTZ4IRIBjmS+MkjqpR5E70xan7ooA==",
      "license": "Apache-2.0",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0-rc.1 || ^18.0.0 || ^19.0.0-rc.1"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.40.1.tgz",
      "integrity": "sha512-kxz0YeeCrRUHz3zyqvd7n+TVRlNyTifBsmnmNPtk3hQURUyG9eAB+usz6DAwagMusjx/zb3AjvDUvhFGDAexGw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.40.1.tgz",
      "integrity": "sha512-PPkxTOisoNC6TpnDKatjKkjRMsdaWIhyuMkA4UsBXT9WEZY4uHezBTjs6Vl4PbqQQeu6oION1w2voYZv9yquCw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.40.1.tgz",
      "integrity": "sha512-VWXGISWFY18v/0JyNUy4A46KCFCb9NVsH+1100XP31lud+TzlezBbz24CYzbnA4x6w4hx+NYCXDfnvDVO6lcAA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.40.1.tgz",
      "integrity": "sha512-nIwkXafAI1/QCS7pxSpv/ZtFW6TXcNUEHAIA9EIyw5OzxJZQ1YDrX+CL6JAIQgZ33CInl1R6mHet9Y/UZTg2Bw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.40.1.tgz",
      "integrity": "sha512-BdrLJ2mHTrIYdaS2I99mriyJfGGenSaP+UwGi1kB9BLOCu9SR8ZpbkmmalKIALnRw24kM7qCN0IOm6L0S44iWw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.40.1.tgz",
      "integrity": "sha512-VXeo/puqvCG8JBPNZXZf5Dqq7BzElNJzHRRw3vjBE27WujdzuOPecDPc/+1DcdcTptNBep3861jNq0mYkT8Z6Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.40.1.tgz",
      "integrity": "sha512-ehSKrewwsESPt1TgSE/na9nIhWCosfGSFqv7vwEtjyAqZcvbGIg4JAcV7ZEh2tfj/IlfBeZjgOXm35iOOjadcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.40.1.tgz",
      "integrity": "sha512-m39iO/aaurh5FVIu/F4/Zsl8xppd76S4qoID8E+dSRQvTyZTOI2gVk3T4oqzfq1PtcvOfAVlwLMK3KRQMaR8lg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.40.1.tgz",
      "integrity": "sha512-Y+GHnGaku4aVLSgrT0uWe2o2Rq8te9hi+MwqGF9r9ORgXhmHK5Q71N757u0F8yU1OIwUIFy6YiJtKjtyktk5hg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.40.1.tgz",
      "integrity": "sha512-jEwjn3jCA+tQGswK3aEWcD09/7M5wGwc6+flhva7dsQNRZZTe30vkalgIzV4tjkopsTS9Jd7Y1Bsj6a4lzz8gQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.40.1.tgz",
      "integrity": "sha512-ySyWikVhNzv+BV/IDCsrraOAZ3UaC8SZB67FZlqVwXwnFhPihOso9rPOxzZbjp81suB1O2Topw+6Ug3JNegejQ==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-powerpc64le-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-powerpc64le-gnu/-/rollup-linux-powerpc64le-gnu-4.40.1.tgz",
      "integrity": "sha512-BvvA64QxZlh7WZWqDPPdt0GH4bznuL6uOO1pmgPnnv86rpUpc8ZxgZwcEgXvo02GRIZX1hQ0j0pAnhwkhwPqWg==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.40.1.tgz",
      "integrity": "sha512-EQSP+8+1VuSulm9RKSMKitTav89fKbHymTf25n5+Yr6gAPZxYWpj3DzAsQqoaHAk9YX2lwEyAf9S4W8F4l3VBQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.40.1.tgz",
      "integrity": "sha512-n/vQ4xRZXKuIpqukkMXZt9RWdl+2zgGNx7Uda8NtmLJ06NL8jiHxUawbwC+hdSq1rrw/9CghCpEONor+l1e2gA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.40.1.tgz",
      "integrity": "sha512-h8d28xzYb98fMQKUz0w2fMc1XuGzLLjdyxVIbhbil4ELfk5/orZlSTpF/xdI9C8K0I8lCkq+1En2RJsawZekkg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.40.1.tgz",
      "integrity": "sha512-XiK5z70PEFEFqcNj3/zRSz/qX4bp4QIraTy9QjwJAb/Z8GM7kVUsD0Uk8maIPeTyPCP03ChdI+VVmJriKYbRHQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.40.1.tgz",
      "integrity": "sha512-2BRORitq5rQ4Da9blVovzNCMaUlyKrzMSvkVR0D4qPuOy/+pMCrh1d7o01RATwVy+6Fa1WBw+da7QPeLWU/1mQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.40.1.tgz",
      "integrity": "sha512-b2bcNm9Kbde03H+q+Jjw9tSfhYkzrDUf2d5MAd1bOJuVplXvFhWz7tRtWvD8/ORZi7qSCy0idW6tf2HgxSXQSg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.40.1.tgz",
      "integrity": "sha512-DfcogW8N7Zg7llVEfpqWMZcaErKfsj9VvmfSyRjCyo4BI3wPEfrzTtJkZG6gKP/Z92wFm6rz2aDO7/JfiR/whA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.40.1.tgz",
      "integrity": "sha512-ECyOuDeH3C1I8jH2MK1RtBJW+YPMvSfT0a5NN0nHfQYnDSJ6tUiZH3gzwVP5/Kfh/+Tt7tpWVF9LXNTnhTJ3kA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.17",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.17.tgz",
      "integrity": "sha512-5IKx/Y13RsYd+sauPb2x+U/xZikHjolzfuDgTAl/Tdf3Q8rslRvC19NKDLgAJQ6wsqADk10ntlv08nPFw/gO/A==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tailwindcss/typography": {
      "version": "0.5.16",
      "resolved": "https://registry.npmjs.org/@tailwindcss/typography/-/typography-0.5.16.tgz",
      "integrity": "sha512-0wDLwCVF5V3x3b1SGXPCDcdsbDHMBe+lkFzBRaHeLvNi+nrrnZ1lA18u+OTWO8iSWU2GxUOCvlXtDuqftc1oiA==",
      "license": "MIT",
      "dependencies": {
        "lodash.castarray": "^4.4.0",
        "lodash.isplainobject": "^4.0.6",
        "lodash.merge": "^4.6.2",
        "postcss-selector-parser": "6.0.10"
      },
      "peerDependencies": {
        "tailwindcss": ">=3.0.0 || insiders || >=4.0.0-alpha.20 || >=4.0.0-beta.1"
      }
    },
    "node_modules/@tanstack/react-virtual": {
      "version": "3.13.8",
      "resolved": "https://registry.npmjs.org/@tanstack/react-virtual/-/react-virtual-3.13.8.tgz",
      "integrity": "sha512-meS2AanUg50f3FBSNoAdBSRAh8uS0ue01qm7zrw65KGJtiXB9QXfybqZwkh4uFpRv2iX/eu5tjcH5wqUpwYLPg==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/virtual-core": "3.13.8"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/@tanstack/virtual-core": {
      "version": "3.13.8",
      "resolved": "https://registry.npmjs.org/@tanstack/virtual-core/-/virtual-core-3.13.8.tgz",
      "integrity": "sha512-BT6w89Hqy7YKaWewYzmecXQzcJh6HTBbKYJIIkMaNU49DZ06LoTV3z32DWWEdUsgW6n1xTmwTLs4GtWrZC261w==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.20.7",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.7.tgz",
      "integrity": "sha512-dkO5fhS7+/oos4ciWxyEyjWe48zmG6wbCheo/G2ZnHx4fs3EU6YC6UM8rk56gAjNJ9P3MTH2jo5jb92/K6wbng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.7"
      }
    },
    "node_modules/@types/d3-array": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/@types/d3-array/-/d3-array-3.2.1.tgz",
      "integrity": "sha512-Y2Jn2idRrLzUfAKV2LyRImR+y4oa2AntrgID95SHJxuMUrkNXmanDSed71sRNZysveJVt1hLLemQZIady0FpEg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-color": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/@types/d3-color/-/d3-color-3.1.3.tgz",
      "integrity": "sha512-iO90scth9WAbmgv7ogoq57O9YpKmFBbmoEoCHDB2xMBY0+/KVrqAaCDyCE16dUspeOvIxFFRI+0sEtqDqy2b4A==",
      "license": "MIT"
    },
    "node_modules/@types/d3-ease": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-ease/-/d3-ease-3.0.2.tgz",
      "integrity": "sha512-NcV1JjO5oDzoK26oMzbILE6HW7uVXOHLQvHshBUW4UMdZGfiY6v5BeQwh9a9tCzv+CeefZQHJt5SRgK154RtiA==",
      "license": "MIT"
    },
    "node_modules/@types/d3-interpolate": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-interpolate/-/d3-interpolate-3.0.4.tgz",
      "integrity": "sha512-mgLPETlrpVV1YRJIglr4Ez47g7Yxjl1lj7YKsiMCb27VJH9W8NVM6Bb9d8kkpG/uAQS5AmbA48q2IAolKKo1MA==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-color": "*"
      }
    },
    "node_modules/@types/d3-path": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@types/d3-path/-/d3-path-1.0.11.tgz",
      "integrity": "sha512-4pQMp8ldf7UaB/gR8Fvvy69psNHkTpD/pVw3vmEi8iZAB9EPMBruB1JvHO4BIq9QkUUd2lV1F5YXpMNj7JPBpw==",
      "license": "MIT"
    },
    "node_modules/@types/d3-scale": {
      "version": "4.0.9",
      "resolved": "https://registry.npmjs.org/@types/d3-scale/-/d3-scale-4.0.9.tgz",
      "integrity": "sha512-dLmtwB8zkAeO/juAMfnV+sItKjlsw2lKdZVVy6LRr0cBmegxSABiLEpGVmSJJ8O08i4+sGR6qQtb6WtuwJdvVw==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-time": "*"
      }
    },
    "node_modules/@types/d3-shape": {
      "version": "1.3.12",
      "resolved": "https://registry.npmjs.org/@types/d3-shape/-/d3-shape-1.3.12.tgz",
      "integrity": "sha512-8oMzcd4+poSLGgV0R1Q1rOlx/xdmozS4Xab7np0eamFFUYq71AU9pOCJEFnkXW2aI/oXdVYJzw6pssbSut7Z9Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/d3-path": "^1"
      }
    },
    "node_modules/@types/d3-time": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-time/-/d3-time-3.0.4.tgz",
      "integrity": "sha512-yuzZug1nkAAaBlBBikKZTgzCeA+k1uy4ZFwWANOfKw5z5LRhV0gNA7gNkKm7HoK+HRN0wX3EkxGk0fpbWhmB7g==",
      "license": "MIT"
    },
    "node_modules/@types/d3-timer": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-timer/-/d3-timer-3.0.2.tgz",
      "integrity": "sha512-Ps3T8E8dZDam6fUyNiMkekK3XUsaUEik+idO9/YjPtfj2qruF8tFBXS7XhtE4iIXBLxhmLjP3SXpLhVf21I9Lw==",
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.7.tgz",
      "integrity": "sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "22.15.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.11.tgz",
      "integrity": "sha512-rlyK0vuU7VLEYQfXuC7QTFxDvkb6tKhDI7wR4r6ZzM0k8BJd44W0jxo6xmUjqSs4AlYmiYfLJU2f0pAG/FtCRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/react": {
      "version": "19.1.3",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.1.3.tgz",
      "integrity": "sha512-dLWQ+Z0CkIvK1J8+wrDPwGxEYFA4RAyHoZPxHVGspYmFVnwGSNT24cGIhFJrtfRnWVuW8X7NO52gCXmhkVUWGQ==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-beautiful-dnd": {
      "version": "13.1.8",
      "resolved": "https://registry.npmjs.org/@types/react-beautiful-dnd/-/react-beautiful-dnd-13.1.8.tgz",
      "integrity": "sha512-E3TyFsro9pQuK4r8S/OL6G99eq7p8v29sX0PM7oT8Z+PJfZvSQTx4zTQbUJ+QZXioAF0e7TGBEcA1XhYhCweyQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/react": "*"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.1.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.3.tgz",
      "integrity": "sha512-rJXC08OG0h3W6wDMFxQrZF00Kq6qQvw0djHRdzl3U5DnIERz0MRce3WVc7IS6JYBwtaP/DwYtRRjVlvivNveKg==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/@types/recharts": {
      "version": "1.8.29",
      "resolved": "https://registry.npmjs.org/@types/recharts/-/recharts-1.8.29.tgz",
      "integrity": "sha512-ulKklaVsnFIIhTQsQw226TnOibrddW1qUQNFVhoQEyY1Z7FRQrNecFCGt7msRuJseudzE9czVawZb17dK/aPXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/d3-shape": "^1",
        "@types/react": "*"
      }
    },
    "node_modules/@types/use-sync-external-store": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/@types/use-sync-external-store/-/use-sync-external-store-0.0.6.tgz",
      "integrity": "sha512-zFDAD+tlpf2r4asuHEj0XH6pY6i0g5NeAHPn+15wk3BV6JA69eERFXC1gyGThDkVa1zCyKr5jox1+2LbV/AMLg==",
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.32.0.tgz",
      "integrity": "sha512-/jU9ettcntkBFmWUzzGgsClEi2ZFiikMX5eEQsmxIAWMOn4H3D4rvHssstmAHGVvrYnaMqdWWWg0b5M6IN/MTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.10.0",
        "@typescript-eslint/scope-manager": "8.32.0",
        "@typescript-eslint/type-utils": "8.32.0",
        "@typescript-eslint/utils": "8.32.0",
        "@typescript-eslint/visitor-keys": "8.32.0",
        "graphemer": "^1.4.0",
        "ignore": "^5.3.1",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.0.0 || ^8.0.0-alpha.0",
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.32.0.tgz",
      "integrity": "sha512-B2MdzyWxCE2+SqiZHAjPphft+/2x2FlO9YBx7eKE1BCb+rqBlQdhtAEhzIEdozHd55DXPmxBdpMygFJjfjjA9A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.32.0",
        "@typescript-eslint/types": "8.32.0",
        "@typescript-eslint/typescript-estree": "8.32.0",
        "@typescript-eslint/visitor-keys": "8.32.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.32.0.tgz",
      "integrity": "sha512-jc/4IxGNedXkmG4mx4nJTILb6TMjL66D41vyeaPWvDUmeYQzF3lKtN15WsAeTr65ce4mPxwopPSo1yUUAWw0hQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.32.0",
        "@typescript-eslint/visitor-keys": "8.32.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.32.0.tgz",
      "integrity": "sha512-t2vouuYQKEKSLtJaa5bB4jHeha2HJczQ6E5IXPDPgIty9EqcJxpr1QHQ86YyIPwDwxvUmLfP2YADQ5ZY4qddZg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/typescript-estree": "8.32.0",
        "@typescript-eslint/utils": "8.32.0",
        "debug": "^4.3.4",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.32.0.tgz",
      "integrity": "sha512-O5Id6tGadAZEMThM6L9HmVf5hQUXNSxLVKeGJYWNhhVseps/0LddMkp7//VDkzwJ69lPL0UmZdcZwggj9akJaA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.32.0.tgz",
      "integrity": "sha512-pU9VD7anSCOIoBFnhTGfOzlVFQIA1XXiQpH/CezqOBaDppRwTglJzCC6fUQGpfwey4T183NKhF1/mfatYmjRqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.32.0",
        "@typescript-eslint/visitor-keys": "8.32.0",
        "debug": "^4.3.4",
        "fast-glob": "^3.3.2",
        "is-glob": "^4.0.3",
        "minimatch": "^9.0.4",
        "semver": "^7.6.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.32.0.tgz",
      "integrity": "sha512-8S9hXau6nQ/sYVtC3D6ISIDoJzS1NsCK+gluVhLN2YkBPX+/1wkwyUiDKnxRh15579WoOIyVWnoyIf3yGI9REw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.7.0",
        "@typescript-eslint/scope-manager": "8.32.0",
        "@typescript-eslint/types": "8.32.0",
        "@typescript-eslint/typescript-estree": "8.32.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.32.0.tgz",
      "integrity": "sha512-1rYQTCLFFzOI5Nl0c8LUpJT8HxpwVRn9E4CkMsYfuN6ctmQqExjSTzzSk0Tz2apmXy7WU6/6fyaZVVA/thPN+w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.32.0",
        "eslint-visitor-keys": "^4.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.4.1.tgz",
      "integrity": "sha512-IpEm5ZmeXAP/osiBXVVP5KjFMzbWOonMs0NaQQl+xYnUAcq4oHUBsF2+p4MgKWG4YMmFYJU8A6sxRPuowllm6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.26.10",
        "@babel/plugin-transform-react-jsx-self": "^7.25.9",
        "@babel/plugin-transform-react-jsx-source": "^7.25.9",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.14.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.21",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.21.tgz",
      "integrity": "sha512-O+A6LWV5LDHSJD3LjHYoNi4VLsj/Whi7k6zG12xTYaU4cQ8oxQGckXNX8cRHK5yOZ/ppVHe0ZBXGzSV9jXdVbQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.24.4",
        "caniuse-lite": "^1.0.30001702",
        "fraction.js": "^4.3.7",
        "normalize-range": "^0.1.2",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/axios": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.9.0.tgz",
      "integrity": "sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.0",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/body-parser": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.0.tgz",
      "integrity": "sha512-02qvAaxv8tp7fBa/mw1ga98OGm+eCbqzJOKoRt70sLmfEEi+jyBYVTDGfCL/k06/4EMk/z01gCe7HoCH/f2LTg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.0",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.6.3",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.0",
        "type-is": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.24.5",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.5.tgz",
      "integrity": "sha512-FDToo4Wo82hIdgc1CQ+NQD0hEhmpPjrZ3hiUgwgOG6IuTdlpr8jdjyG24P6cNP1yJpTLzS5OcGgSw0xmDU1/Tw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001716",
        "electron-to-chromium": "^1.5.149",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001717",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001717.tgz",
      "integrity": "sha512-auPpttCq6BDEG8ZAuHJIplGw6GODhjw+/11e7IjpnYCxZcW/ONgPs0KVBJ0d1bY3e2+7PRe5RCLyP+PfwVgkYw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/content-disposition": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz",
      "integrity": "sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/css-box-model": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/css-box-model/-/css-box-model-1.2.1.tgz",
      "integrity": "sha512-a7Vr4Q/kd/aw96bnJG332W9V9LkJO69JRcaCYDUqjp6/z0w6VcZjgAcTbgFxEPfBgdnAwlh3iwu+hLopa+flJw==",
      "license": "MIT",
      "dependencies": {
        "tiny-invariant": "^1.0.6"
      }
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "license": "MIT",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/d3-array": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/d3-array/-/d3-array-3.2.4.tgz",
      "integrity": "sha512-tdQAmyA18i4J7wprpYq8ClcxZy3SC31QMeByyCFyRt7BVHdREQZ5lpzoe5mFEYZUWe+oq8HBvk9JjpibyEV4Jg==",
      "license": "ISC",
      "dependencies": {
        "internmap": "1 - 2"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-color": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-color/-/d3-color-3.1.0.tgz",
      "integrity": "sha512-zg/chbXyeBtMQ1LbD/WSoW2DpC3I0mpmPdW+ynRTj/x2DAWYrIY7qeZIHidozwV24m4iavr15lNwIwLxRmOxhA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-ease": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-ease/-/d3-ease-3.0.1.tgz",
      "integrity": "sha512-wR/XK3D3XcLIZwpbvQwQ5fK+8Ykds1ip7A2Txe0yxncXSdq1L9skcG7blcedkOX+ZcgxGAmLX1FrRGbADwzi0w==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-format": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-format/-/d3-format-3.1.0.tgz",
      "integrity": "sha512-YyUI6AEuY/Wpt8KWLgZHsIU86atmikuoOmCfommt0LYHiQSPjvX2AcFc38PX0CBpr2RCyZhjex+NS/LPOv6YqA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-interpolate": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-interpolate/-/d3-interpolate-3.0.1.tgz",
      "integrity": "sha512-3bYs1rOD33uo8aqJfKP3JWPAibgw8Zm2+L9vBKEHJ2Rg+viTR7o5Mmv5mZcieN+FRYaAOWX5SJATX6k1PWz72g==",
      "license": "ISC",
      "dependencies": {
        "d3-color": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-path": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-path/-/d3-path-3.1.0.tgz",
      "integrity": "sha512-p3KP5HCf/bvjBSSKuXid6Zqijx7wIfNW+J/maPs+iwR35at5JCbLUT0LzF1cnjbCHWhqzQTIN2Jpe8pRebIEFQ==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-scale": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/d3-scale/-/d3-scale-4.0.2.tgz",
      "integrity": "sha512-GZW464g1SH7ag3Y7hXjf8RoUuAFIqklOAq3MRl4OaWabTFJY9PN/E1YklhXLh+OQ3fM9yS2nOkCoS+WLZ6kvxQ==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2.10.0 - 3",
        "d3-format": "1 - 3",
        "d3-interpolate": "1.2.0 - 3",
        "d3-time": "2.1.1 - 3",
        "d3-time-format": "2 - 4"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-shape": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/d3-shape/-/d3-shape-3.2.0.tgz",
      "integrity": "sha512-SaLBuwGm3MOViRq2ABk3eLoxwZELpH6zhl3FbAoJ7Vm1gofKx6El1Ib5z23NUEhF9AsGl7y+dzLe5Cw2AArGTA==",
      "license": "ISC",
      "dependencies": {
        "d3-path": "^3.1.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-time/-/d3-time-3.1.0.tgz",
      "integrity": "sha512-VqKjzBLejbSMT4IgbmVgDjpkYrNWUYJnbCGo874u7MMKIWsILRX+OpX/gTk8MqjpT1A/c6HY2dCA77ZN0lkQ2Q==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time-format": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/d3-time-format/-/d3-time-format-4.1.0.tgz",
      "integrity": "sha512-dJxPBlzC7NugB2PDLwo9Q8JiTR3M3e4/XANkreKSUxF8vvXKqm1Yfq4Q5dl8budlunRVlUUaDUgFt7eA8D6NLg==",
      "license": "ISC",
      "dependencies": {
        "d3-time": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-timer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-timer/-/d3-timer-3.0.1.tgz",
      "integrity": "sha512-ndfJ/JxxMd3nw31uyKoY2naivF+r29V+Lc0svZxe1JvvIRmi8hUsrMvdOwgS1o6uBHmiz91geQ0ylPP0aj1VUA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/dayjs": {
      "version": "1.11.13",
      "resolved": "https://registry.npmjs.org/dayjs/-/dayjs-1.11.13.tgz",
      "integrity": "sha512-oaMBel6gjolK862uaPQOVTA7q3TZhuSvuMQAAglQDOWYO9A91IrAOUJEyKVlqJlHE0vq5p5UXxzdPfMH/x6xNg==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js-light": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/decimal.js-light/-/decimal.js-light-2.5.1.tgz",
      "integrity": "sha512-qIMFpTMZmny+MMIitAB6D7iVPEorVw6YQRWkvarTkT4tBeSLLiHzcwj6q0MmYSFCiVpiqPJTJEYIrpcPzVEIvg==",
      "license": "MIT"
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/dom-helpers": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz",
      "integrity": "sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.8.7",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.150",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.150.tgz",
      "integrity": "sha512-rOOkP2ZUMx1yL4fCxXQKDHQ8ZXwisb2OycOQVKHgvB3ZI4CvehOd4y2tfnnLDieJ3Zs1RL1Dlp3cMkyIn7nnXA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.3.tgz",
      "integrity": "sha512-qKA6Pvai73+M2FtftpNKRxJ78GIjmFXFxd/1DVBqGo/qNhLSfv+G12n9pNoWdytJC8U00TrViOwpjT0zgqQS8Q==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.3",
        "@esbuild/android-arm": "0.25.3",
        "@esbuild/android-arm64": "0.25.3",
        "@esbuild/android-x64": "0.25.3",
        "@esbuild/darwin-arm64": "0.25.3",
        "@esbuild/darwin-x64": "0.25.3",
        "@esbuild/freebsd-arm64": "0.25.3",
        "@esbuild/freebsd-x64": "0.25.3",
        "@esbuild/linux-arm": "0.25.3",
        "@esbuild/linux-arm64": "0.25.3",
        "@esbuild/linux-ia32": "0.25.3",
        "@esbuild/linux-loong64": "0.25.3",
        "@esbuild/linux-mips64el": "0.25.3",
        "@esbuild/linux-ppc64": "0.25.3",
        "@esbuild/linux-riscv64": "0.25.3",
        "@esbuild/linux-s390x": "0.25.3",
        "@esbuild/linux-x64": "0.25.3",
        "@esbuild/netbsd-arm64": "0.25.3",
        "@esbuild/netbsd-x64": "0.25.3",
        "@esbuild/openbsd-arm64": "0.25.3",
        "@esbuild/openbsd-x64": "0.25.3",
        "@esbuild/sunos-x64": "0.25.3",
        "@esbuild/win32-arm64": "0.25.3",
        "@esbuild/win32-ia32": "0.25.3",
        "@esbuild/win32-x64": "0.25.3"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.26.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.26.0.tgz",
      "integrity": "sha512-Hx0MOjPh6uK9oq9nVsATZKE/Wlbai7KFjfCuw9UHaguDW3x+HF0O5nIi3ud39TWgrTjTO5nHxmL3R1eANinWHQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.20.0",
        "@eslint/config-helpers": "^0.2.1",
        "@eslint/core": "^0.13.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.26.0",
        "@eslint/plugin-kit": "^0.2.8",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@modelcontextprotocol/sdk": "^1.8.0",
        "@types/estree": "^1.0.6",
        "@types/json-schema": "^7.0.15",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.3.0",
        "eslint-visitor-keys": "^4.2.0",
        "espree": "^10.3.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3",
        "zod": "^3.24.2"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-5.2.0.tgz",
      "integrity": "sha512-+f15FfK64YQwZdJNELETdn5ibXEUQmW1DZL6KXhNnc2heoy/sg9VJJeT7n8TlMWouzWqSWavFkIhHyIbIAEapg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react-refresh": {
      "version": "0.4.20",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-refresh/-/eslint-plugin-react-refresh-0.4.20.tgz",
      "integrity": "sha512-XpbHQ2q5gUF8BGOX4dHe+71qoirYMhApEPZ7sfhF/dNnOF1UXnCMGZf79SFTBO7Bz5YEIT4TMieSlJBWhP9WBA==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "eslint": ">=8.40"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.3.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.3.0.tgz",
      "integrity": "sha512-pUNxi75F8MJ/GdeKtVLSbYg4ZI34J6C0C7sbL4YOp2exGwen7ZsuBqKzUhXd0qMQ362yET3z+uPwKeg/0C2XCQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.0.tgz",
      "integrity": "sha512-UyLnSehNt62FFhSwjZlHmeokpRK59rcz29j+F1/aDgbkbRTk7wIc9XzdoasMUbRNKDM0qQt/+BJ4BrpFeABemw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.3.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.3.0.tgz",
      "integrity": "sha512-0QYC8b24HWY8zjRnDTL6RiHfDbAWn63qb4LMj1Z4b076A4une81+z03Kg7l7mn/48PUTqoLptSXez8oknU8Clg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.14.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
      "license": "MIT"
    },
    "node_modules/eventsource": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/eventsource/-/eventsource-3.0.6.tgz",
      "integrity": "sha512-l19WpE2m9hSuyP06+FbuUUf1G+R0SFLrtQfbRb9PRr+oimOfxQhgGCbVaXg5IvZyyTThJsxh6L/srkMiCeBPDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eventsource-parser": "^3.0.1"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/eventsource-parser": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.1.tgz",
      "integrity": "sha512-VARTJ9CYeuQYb0pZEPbzi740OWFgpHe7AYJ2WFZVnUDUQp5Dk2yJUgF36YsZ81cOyxT0QxmXD2EQpapAouzWVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/express": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/express/-/express-5.1.0.tgz",
      "integrity": "sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.0",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "7.5.0",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.5.0.tgz",
      "integrity": "sha512-eB5zbQh5h+VenMPM3fh+nw1YExi5nMr6HUCR62ELSP11huvxm/Uir1H1QEyTkk5QX6A58pX6NmaTMceKZ0Eodg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": "^4.11 || 5 || ^5.0.0-beta.1"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-equals": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/fast-equals/-/fast-equals-5.2.2.tgz",
      "integrity": "sha512-V7/RktU11J3I36Nwq2JnZEM7tNm17eBJz+u25qdxBZeCKiX6BkVSZQjwWIr+IobgnZy+ag73tTZgZi7tr0LrBw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
      "integrity": "sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz",
      "integrity": "sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.9",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.9.tgz",
      "integrity": "sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.2.tgz",
      "integrity": "sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/form-data/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/form-data/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fraction.js": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-4.3.7.tgz",
      "integrity": "sha512-ZsDfxO51wGAXREY55a7la9LScWpwv9RxIrYABrlvOFBlH/ShPnrtsXeuUIfXKKOVicNxQ+o8JTbJvjS4M89yew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "patreon",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "16.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-16.0.0.tgz",
      "integrity": "sha512-iInW14XItCXET01CQFqudPOWP2jYMl7T+QRQT+UNcR/iQncN/F0UNpgd76iFkBPgNQb4+X3LV9tLJYzwh+Gl3A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graphemer": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
      "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/internmap": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/internmap/-/internmap-2.0.3.tgz",
      "integrity": "sha512-5Hh7Y1wQbvY5ooGgPbDaL5iYLAPzMTUrjMulskHLH6wnv/A+1q5rgEaiuqEjB+oxGXIVZs1FF+R/KPN3ZSQYYg==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.castarray": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/lodash.castarray/-/lodash.castarray-4.4.0.tgz",
      "integrity": "sha512-aVx8ztPv7/2ULbArGJ2Y42bG1mEQ5mGjpdvrbJcJFU3TbYybe+QlLS4pst9zV52ymy2in1KpFPiZnAOATxD4+Q==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.507.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.507.0.tgz",
      "integrity": "sha512-XfgE6gvAHwAtnbUvWiTTHx4S3VGR+cUJHEc0vrh9Ogu672I1Tue2+Cp/8JJqpytgcBHAB1FVI297W4XGNwc2dQ==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz",
      "integrity": "sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-range": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/normalize-range/-/normalize-range-0.1.2.tgz",
      "integrity": "sha512-bdok/XvKII3nUpklnV6P2hxtMNrCboOjAcyBuQnWEhO665FwrSNRxU+AqpsyvO6LgGYPspN+lu5CLtw4jPRKNA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pkce-challenge": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.0.tgz",
      "integrity": "sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16.20.0"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.3",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.3.tgz",
      "integrity": "sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.8",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "6.0.10",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.0.10.tgz",
      "integrity": "sha512-IQ7TZdoaqbT+LCpShg46jnZVlhWD2w6iQYAcYXfHARZ7X1t/UGhhceQDs5X0cGqKvYlHNOuv7Oa1xmb0oQuA3w==",
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/prop-types/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/raf-schd": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/raf-schd/-/raf-schd-4.0.3.tgz",
      "integrity": "sha512-tQkJl2GRWh83ui2DiPTJz9wEiMN20syf+5oKfB03yYP7ioZcJwsIK8FjrtLwH1m7C7e+Tt2yYBlrOpdT+dyeIQ==",
      "license": "MIT"
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
      "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.6.3",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-is": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
      "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
      "license": "MIT"
    },
    "node_modules/react-redux": {
      "version": "9.2.0",
      "resolved": "https://registry.npmjs.org/react-redux/-/react-redux-9.2.0.tgz",
      "integrity": "sha512-ROY9fvHhwOD9ySfrF0wmvu//bKCQ6AeZZq1nJNtbDC+kk5DuSuNX/n6YWYF/SYy7bSba4D4FSz8DJeKY/S/r+g==",
      "license": "MIT",
      "dependencies": {
        "@types/use-sync-external-store": "^0.0.6",
        "use-sync-external-store": "^1.4.0"
      },
      "peerDependencies": {
        "@types/react": "^18.2.25 || ^19",
        "react": "^18.0 || ^19",
        "redux": "^5.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "redux": {
          "optional": true
        }
      }
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-router": {
      "version": "7.5.3",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.5.3.tgz",
      "integrity": "sha512-3iUDM4/fZCQ89SXlDa+Ph3MevBrozBAI655OAfWQlTm9nBR0IKlrmNwFow5lPHttbwvITZfkeeeZFP6zt3F7pw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0",
        "turbo-stream": "2.4.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.5.3",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.5.3.tgz",
      "integrity": "sha512-cK0jSaTyW4jV9SRKAItMIQfWZ/D6WEZafgHuuCb9g+SjhLolY78qc+De4w/Cz9ybjvLzShAmaIMEXt8iF1Cm+A==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.5.3"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/react-router/node_modules/cookie": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.0.2.tgz",
      "integrity": "sha512-9Kr/j4O16ISv8zBBhJoi4bXOYNTkFLOqSL3UDB0njXxCXNezjeyVrJyGOWtgfs/q2km1gwBcfH8q1yEGoMYunA==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/react-smooth": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/react-smooth/-/react-smooth-4.0.4.tgz",
      "integrity": "sha512-gnGKTpYwqL0Iii09gHobNolvX4Kiq4PKx6eWBCYYix+8cdw+cGo3do906l1NBPKkSWx1DghC1dlWG9L2uGd61Q==",
      "license": "MIT",
      "dependencies": {
        "fast-equals": "^5.0.1",
        "prop-types": "^15.8.1",
        "react-transition-group": "^4.4.5"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/react-transition-group": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz",
      "integrity": "sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/runtime": "^7.5.5",
        "dom-helpers": "^5.0.1",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.6.2"
      },
      "peerDependencies": {
        "react": ">=16.6.0",
        "react-dom": ">=16.6.0"
      }
    },
    "node_modules/recharts": {
      "version": "2.15.3",
      "resolved": "https://registry.npmjs.org/recharts/-/recharts-2.15.3.tgz",
      "integrity": "sha512-EdOPzTwcFSuqtvkDoaM5ws/Km1+WTAO2eizL7rqiG0V2UVhTnz0m7J2i0CjVPUCdEkZImaWvXLbZDS2H5t6GFQ==",
      "license": "MIT",
      "dependencies": {
        "clsx": "^2.0.0",
        "eventemitter3": "^4.0.1",
        "lodash": "^4.17.21",
        "react-is": "^18.3.1",
        "react-smooth": "^4.0.4",
        "recharts-scale": "^0.4.4",
        "tiny-invariant": "^1.3.1",
        "victory-vendor": "^36.6.8"
      },
      "engines": {
        "node": ">=14"
      },
      "peerDependencies": {
        "react": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/recharts-scale": {
      "version": "0.4.5",
      "resolved": "https://registry.npmjs.org/recharts-scale/-/recharts-scale-0.4.5.tgz",
      "integrity": "sha512-kivNFO+0OcUNu7jQquLXAxz1FIwZj8nrj+YkOKc5694NbjCvcT6aSZiIzNzd2Kul4o4rTto8QVR9lMNtxD4G1w==",
      "license": "MIT",
      "dependencies": {
        "decimal.js-light": "^2.4.1"
      }
    },
    "node_modules/redux": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/redux/-/redux-5.0.1.tgz",
      "integrity": "sha512-M9/ELqF6fy8FwmkpnF0S3YKOqMyoWJ4+CS5Efg2ct3oY9daQvd/Pc71FpGZsVsbl3Cpb+IIcjBDUnnyBdQbq4w==",
      "license": "MIT"
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.40.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.40.1.tgz",
      "integrity": "sha512-C5VvvgCCyfyotVITIAv+4efVytl5F7wt+/I2i9q9GZcEXW9BP52YYOXC58igUi+LFZVHukErIIqQSWwv/M3WRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.7"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.40.1",
        "@rollup/rollup-android-arm64": "4.40.1",
        "@rollup/rollup-darwin-arm64": "4.40.1",
        "@rollup/rollup-darwin-x64": "4.40.1",
        "@rollup/rollup-freebsd-arm64": "4.40.1",
        "@rollup/rollup-freebsd-x64": "4.40.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.40.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.40.1",
        "@rollup/rollup-linux-arm64-gnu": "4.40.1",
        "@rollup/rollup-linux-arm64-musl": "4.40.1",
        "@rollup/rollup-linux-loongarch64-gnu": "4.40.1",
        "@rollup/rollup-linux-powerpc64le-gnu": "4.40.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.40.1",
        "@rollup/rollup-linux-riscv64-musl": "4.40.1",
        "@rollup/rollup-linux-s390x-gnu": "4.40.1",
        "@rollup/rollup-linux-x64-gnu": "4.40.1",
        "@rollup/rollup-linux-x64-musl": "4.40.1",
        "@rollup/rollup-win32-arm64-msvc": "4.40.1",
        "@rollup/rollup-win32-ia32-msvc": "4.40.1",
        "@rollup/rollup-win32-x64-msvc": "4.40.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/send": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.0.tgz",
      "integrity": "sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.5",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "mime-types": "^3.0.1",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz",
      "integrity": "sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.1.tgz",
      "integrity": "sha512-IOc8uWeOZgnb3ptbCURJWNjWUPcO3ZnTTdzsurqERrP6nPyv+paC55vJM0LpOlT2ne+Ix+9+CRG1MNLlyZ4GjQ==",
      "license": "MIT"
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/tabbable": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/tabbable/-/tabbable-6.2.0.tgz",
      "integrity": "sha512-Cat63mxsVJlzYvN51JmVXIgNoUokrIaT2zLclCXjRd8boZ0004U4KCs/sToJ75C6sdlByWxpYnb5Boif1VSFew==",
      "license": "MIT"
    },
    "node_modules/tailwindcss": {
      "version": "4.1.5",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.5.tgz",
      "integrity": "sha512-nYtSPfWGDiWgCkwQG/m+aX83XCwf62sBgg3bIlNiiOcggnS1x3uVRDAuyelBFL+vJdOPPCGElxv9DjHJjRHiVA==",
      "license": "MIT"
    },
    "node_modules/tiny-invariant": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/tiny-invariant/-/tiny-invariant-1.3.3.tgz",
      "integrity": "sha512-+FbBPE1o9QAYvviau/qC5SE3caw21q3xkvWKBtja5vgqOWIHHJ3ioaq1VPfn/Szqctz2bU/oYeKd9/z5BL+PVg==",
      "license": "MIT"
    },
    "node_modules/tinyglobby": {
      "version": "0.2.13",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.13.tgz",
      "integrity": "sha512-mEwzpUgrLySlveBwEVDMKk5B57bhLPYovRfPAXD5gA/98Opn0rCDj3GtLwFvCvH5RK9uPCExUROW5NjDwvqkxw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.4.4",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.4.4.tgz",
      "integrity": "sha512-1NZP+GK4GfuAv3PqKvxQRDMjdSRZjnkq7KfhlNrCNNlZ0ygQFpebfrnfnq/W7fpUnAv9aGWmY1zKx7FYL3gwhg==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.2.tgz",
      "integrity": "sha512-M7BAV6Rlcy5u+m6oPhAPFgJTzAioX/6B0DxyvDlo9l8+T3nLKbrczg2WLUyzd45L8RqfUMyGPzekbMvX2Ldkwg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.1.0.tgz",
      "integrity": "sha512-CUgTZL1irw8u29bzrOD/nH85jqyc74D6SshFgujOIA7osm2Rz7dYH77agkx7H4FBNxDq7Cjf+IjaX/8zwFW+ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/turbo-stream": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/turbo-stream/-/turbo-stream-2.4.0.tgz",
      "integrity": "sha512-FHncC10WpBd2eOmGwpmQsWLDoK4cqsA/UT/GqNoaKOQnT8uzhtCbg3EoUDMvqpOSAI0S26mr0rkjzbOO6S3v1g==",
      "license": "ISC"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/typescript-eslint": {
      "version": "8.32.0",
      "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.32.0.tgz",
      "integrity": "sha512-UMq2kxdXCzinFFPsXc9o2ozIpYCCOiEC46MG3yEh5Vipq6BO27otTtEBZA1fQ66DulEUgE97ucQ/3YY66CPg0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/eslint-plugin": "8.32.0",
        "@typescript-eslint/parser": "8.32.0",
        "@typescript-eslint/utils": "8.32.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <5.9.0"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.5.0.tgz",
      "integrity": "sha512-Rb46I4cGGVBmjamjphe8L/UnvJD+uPPtTkNvX5mZgqdbavhI4EbgIWJiIHXJ8bc/i9EQGPRh4DwEURJ552Do0A==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/victory-vendor": {
      "version": "36.9.2",
      "resolved": "https://registry.npmjs.org/victory-vendor/-/victory-vendor-36.9.2.tgz",
      "integrity": "sha512-PnpQQMuxlwYdocC8fIJqVXvkeViHYzotI+NJrCuav0ZYFoq912ZHBk3mCeuj+5/VpodOjPe1z0Fk2ihgzlXqjQ==",
      "license": "MIT AND ISC",
      "dependencies": {
        "@types/d3-array": "^3.0.3",
        "@types/d3-ease": "^3.0.0",
        "@types/d3-interpolate": "^3.0.1",
        "@types/d3-scale": "^4.0.2",
        "@types/d3-shape": "^3.1.0",
        "@types/d3-time": "^3.0.0",
        "@types/d3-timer": "^3.0.0",
        "d3-array": "^3.1.6",
        "d3-ease": "^3.0.1",
        "d3-interpolate": "^3.0.1",
        "d3-scale": "^4.0.2",
        "d3-shape": "^3.1.0",
        "d3-time": "^3.0.0",
        "d3-timer": "^3.0.1"
      }
    },
    "node_modules/victory-vendor/node_modules/@types/d3-shape": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/@types/d3-shape/-/d3-shape-3.1.7.tgz",
      "integrity": "sha512-VLvUQ33C+3J+8p+Daf+nYSOsjB4GXp19/S/aGo60m9h1v6XaxjiT82lKVWJCfzhtuZ3yD7i/TPeC/fuKLLOSmg==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-path": "*"
      }
    },
    "node_modules/vite": {
      "version": "6.3.5",
      "resolved": "https://registry.npmjs.org/vite/-/vite-6.3.5.tgz",
      "integrity": "sha512-cZn6NDFE7wdTpINgs++ZJ4N49W2vRp8LCKrn3Ob1kYNtOo21vfDoaV5GzBfLU4MovSAB8uNRm4jgzVQZ+mBzPQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2",
        "postcss": "^8.5.3",
        "rollup": "^4.34.9",
        "tinyglobby": "^0.2.13"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "jiti": ">=1.21.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.4.4",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.4.4.tgz",
      "integrity": "sha512-1NZP+GK4GfuAv3PqKvxQRDMjdSRZjnkq7KfhlNrCNNlZ0ygQFpebfrnfnq/W7fpUnAv9aGWmY1zKx7FYL3gwhg==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.2.tgz",
      "integrity": "sha512-M7BAV6Rlcy5u+m6oPhAPFgJTzAioX/6B0DxyvDlo9l8+T3nLKbrczg2WLUyzd45L8RqfUMyGPzekbMvX2Ldkwg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zod": {
      "version": "3.24.4",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.24.4.tgz",
      "integrity": "sha512-OdqJE9UDRPwWsrHjLN2F8bPxvwJBK22EHLWtanu0LSYr5YqzsaaW3RMgmjwr8Rypg5k+meEJdSPXJZXE/yqOMg==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-to-json-schema": {
      "version": "3.24.5",
      "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.5.tgz",
      "integrity": "sha512-/AuWwMP+YqiPbsJx5D6TfgRTc4kTLjsh5SOcd4bLsfUg2RcEXrFMJl1DGgdHy2aCfsIA/cr/1JM0xcB2GZji8g==",
      "dev": true,
      "license": "ISC",
      "peerDependencies": {
        "zod": "^3.24.1"
      }
    }
  }
}

# Arquivo: domo_hub_frontend/domo-hub-app/tsconfig.node.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

# Arquivo: domo_hub_frontend/domo-hub-app/index.html
<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Domo Hub</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

# Arquivo: domo_hub_frontend/domo-hub-app/README.md
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

# Arquivo: domo_hub_frontend/package.json
{
  "dependencies": {
    "recharts": "^2.15.3"
  }
}

# Arquivo: domo_hub_frontend/fandomestotal.txt

# Arquivo: domo_hub_frontend/package-lock.json
{
  "name": "domo_hub_frontend",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "recharts": "^2.15.3"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.1.tgz",
      "integrity": "sha512-1x3D2xEk2fRo3PAhwQwu5UubzgiVWSXTBfWpVd2Mx2AzRqJuDJCsgaDVZ7HB5iGzDW1Hl1sWN2mFyKjmR9uAog==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@types/d3-array": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/@types/d3-array/-/d3-array-3.2.1.tgz",
      "integrity": "sha512-Y2Jn2idRrLzUfAKV2LyRImR+y4oa2AntrgID95SHJxuMUrkNXmanDSed71sRNZysveJVt1hLLemQZIady0FpEg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-color": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/@types/d3-color/-/d3-color-3.1.3.tgz",
      "integrity": "sha512-iO90scth9WAbmgv7ogoq57O9YpKmFBbmoEoCHDB2xMBY0+/KVrqAaCDyCE16dUspeOvIxFFRI+0sEtqDqy2b4A==",
      "license": "MIT"
    },
    "node_modules/@types/d3-ease": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-ease/-/d3-ease-3.0.2.tgz",
      "integrity": "sha512-NcV1JjO5oDzoK26oMzbILE6HW7uVXOHLQvHshBUW4UMdZGfiY6v5BeQwh9a9tCzv+CeefZQHJt5SRgK154RtiA==",
      "license": "MIT"
    },
    "node_modules/@types/d3-interpolate": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-interpolate/-/d3-interpolate-3.0.4.tgz",
      "integrity": "sha512-mgLPETlrpVV1YRJIglr4Ez47g7Yxjl1lj7YKsiMCb27VJH9W8NVM6Bb9d8kkpG/uAQS5AmbA48q2IAolKKo1MA==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-color": "*"
      }
    },
    "node_modules/@types/d3-path": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/@types/d3-path/-/d3-path-3.1.1.tgz",
      "integrity": "sha512-VMZBYyQvbGmWyWVea0EHs/BwLgxc+MKi1zLDCONksozI4YJMcTt8ZEuIR4Sb1MMTE8MMW49v0IwI5+b7RmfWlg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-scale": {
      "version": "4.0.9",
      "resolved": "https://registry.npmjs.org/@types/d3-scale/-/d3-scale-4.0.9.tgz",
      "integrity": "sha512-dLmtwB8zkAeO/juAMfnV+sItKjlsw2lKdZVVy6LRr0cBmegxSABiLEpGVmSJJ8O08i4+sGR6qQtb6WtuwJdvVw==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-time": "*"
      }
    },
    "node_modules/@types/d3-shape": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/@types/d3-shape/-/d3-shape-3.1.7.tgz",
      "integrity": "sha512-VLvUQ33C+3J+8p+Daf+nYSOsjB4GXp19/S/aGo60m9h1v6XaxjiT82lKVWJCfzhtuZ3yD7i/TPeC/fuKLLOSmg==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-path": "*"
      }
    },
    "node_modules/@types/d3-time": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-time/-/d3-time-3.0.4.tgz",
      "integrity": "sha512-yuzZug1nkAAaBlBBikKZTgzCeA+k1uy4ZFwWANOfKw5z5LRhV0gNA7gNkKm7HoK+HRN0wX3EkxGk0fpbWhmB7g==",
      "license": "MIT"
    },
    "node_modules/@types/d3-timer": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-timer/-/d3-timer-3.0.2.tgz",
      "integrity": "sha512-Ps3T8E8dZDam6fUyNiMkekK3XUsaUEik+idO9/YjPtfj2qruF8tFBXS7XhtE4iIXBLxhmLjP3SXpLhVf21I9Lw==",
      "license": "MIT"
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/d3-array": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/d3-array/-/d3-array-3.2.4.tgz",
      "integrity": "sha512-tdQAmyA18i4J7wprpYq8ClcxZy3SC31QMeByyCFyRt7BVHdREQZ5lpzoe5mFEYZUWe+oq8HBvk9JjpibyEV4Jg==",
      "license": "ISC",
      "dependencies": {
        "internmap": "1 - 2"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-color": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-color/-/d3-color-3.1.0.tgz",
      "integrity": "sha512-zg/chbXyeBtMQ1LbD/WSoW2DpC3I0mpmPdW+ynRTj/x2DAWYrIY7qeZIHidozwV24m4iavr15lNwIwLxRmOxhA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-ease": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-ease/-/d3-ease-3.0.1.tgz",
      "integrity": "sha512-wR/XK3D3XcLIZwpbvQwQ5fK+8Ykds1ip7A2Txe0yxncXSdq1L9skcG7blcedkOX+ZcgxGAmLX1FrRGbADwzi0w==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-format": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-format/-/d3-format-3.1.0.tgz",
      "integrity": "sha512-YyUI6AEuY/Wpt8KWLgZHsIU86atmikuoOmCfommt0LYHiQSPjvX2AcFc38PX0CBpr2RCyZhjex+NS/LPOv6YqA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-interpolate": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-interpolate/-/d3-interpolate-3.0.1.tgz",
      "integrity": "sha512-3bYs1rOD33uo8aqJfKP3JWPAibgw8Zm2+L9vBKEHJ2Rg+viTR7o5Mmv5mZcieN+FRYaAOWX5SJATX6k1PWz72g==",
      "license": "ISC",
      "dependencies": {
        "d3-color": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-path": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-path/-/d3-path-3.1.0.tgz",
      "integrity": "sha512-p3KP5HCf/bvjBSSKuXid6Zqijx7wIfNW+J/maPs+iwR35at5JCbLUT0LzF1cnjbCHWhqzQTIN2Jpe8pRebIEFQ==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-scale": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/d3-scale/-/d3-scale-4.0.2.tgz",
      "integrity": "sha512-GZW464g1SH7ag3Y7hXjf8RoUuAFIqklOAq3MRl4OaWabTFJY9PN/E1YklhXLh+OQ3fM9yS2nOkCoS+WLZ6kvxQ==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2.10.0 - 3",
        "d3-format": "1 - 3",
        "d3-interpolate": "1.2.0 - 3",
        "d3-time": "2.1.1 - 3",
        "d3-time-format": "2 - 4"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-shape": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/d3-shape/-/d3-shape-3.2.0.tgz",
      "integrity": "sha512-SaLBuwGm3MOViRq2ABk3eLoxwZELpH6zhl3FbAoJ7Vm1gofKx6El1Ib5z23NUEhF9AsGl7y+dzLe5Cw2AArGTA==",
      "license": "ISC",
      "dependencies": {
        "d3-path": "^3.1.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-time/-/d3-time-3.1.0.tgz",
      "integrity": "sha512-VqKjzBLejbSMT4IgbmVgDjpkYrNWUYJnbCGo874u7MMKIWsILRX+OpX/gTk8MqjpT1A/c6HY2dCA77ZN0lkQ2Q==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time-format": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/d3-time-format/-/d3-time-format-4.1.0.tgz",
      "integrity": "sha512-dJxPBlzC7NugB2PDLwo9Q8JiTR3M3e4/XANkreKSUxF8vvXKqm1Yfq4Q5dl8budlunRVlUUaDUgFt7eA8D6NLg==",
      "license": "ISC",
      "dependencies": {
        "d3-time": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-timer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-timer/-/d3-timer-3.0.1.tgz",
      "integrity": "sha512-ndfJ/JxxMd3nw31uyKoY2naivF+r29V+Lc0svZxe1JvvIRmi8hUsrMvdOwgS1o6uBHmiz91geQ0ylPP0aj1VUA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/decimal.js-light": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/decimal.js-light/-/decimal.js-light-2.5.1.tgz",
      "integrity": "sha512-qIMFpTMZmny+MMIitAB6D7iVPEorVw6YQRWkvarTkT4tBeSLLiHzcwj6q0MmYSFCiVpiqPJTJEYIrpcPzVEIvg==",
      "license": "MIT"
    },
    "node_modules/dom-helpers": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz",
      "integrity": "sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.8.7",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
      "license": "MIT"
    },
    "node_modules/fast-equals": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/fast-equals/-/fast-equals-5.2.2.tgz",
      "integrity": "sha512-V7/RktU11J3I36Nwq2JnZEM7tNm17eBJz+u25qdxBZeCKiX6BkVSZQjwWIr+IobgnZy+ag73tTZgZi7tr0LrBw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/internmap": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/internmap/-/internmap-2.0.3.tgz",
      "integrity": "sha512-5Hh7Y1wQbvY5ooGgPbDaL5iYLAPzMTUrjMulskHLH6wnv/A+1q5rgEaiuqEjB+oxGXIVZs1FF+R/KPN3ZSQYYg==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/prop-types/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-is": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
      "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
      "license": "MIT"
    },
    "node_modules/react-smooth": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/react-smooth/-/react-smooth-4.0.4.tgz",
      "integrity": "sha512-gnGKTpYwqL0Iii09gHobNolvX4Kiq4PKx6eWBCYYix+8cdw+cGo3do906l1NBPKkSWx1DghC1dlWG9L2uGd61Q==",
      "license": "MIT",
      "dependencies": {
        "fast-equals": "^5.0.1",
        "prop-types": "^15.8.1",
        "react-transition-group": "^4.4.5"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/react-transition-group": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz",
      "integrity": "sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/runtime": "^7.5.5",
        "dom-helpers": "^5.0.1",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.6.2"
      },
      "peerDependencies": {
        "react": ">=16.6.0",
        "react-dom": ">=16.6.0"
      }
    },
    "node_modules/recharts": {
      "version": "2.15.3",
      "resolved": "https://registry.npmjs.org/recharts/-/recharts-2.15.3.tgz",
      "integrity": "sha512-EdOPzTwcFSuqtvkDoaM5ws/Km1+WTAO2eizL7rqiG0V2UVhTnz0m7J2i0CjVPUCdEkZImaWvXLbZDS2H5t6GFQ==",
      "license": "MIT",
      "dependencies": {
        "clsx": "^2.0.0",
        "eventemitter3": "^4.0.1",
        "lodash": "^4.17.21",
        "react-is": "^18.3.1",
        "react-smooth": "^4.0.4",
        "recharts-scale": "^0.4.4",
        "tiny-invariant": "^1.3.1",
        "victory-vendor": "^36.6.8"
      },
      "engines": {
        "node": ">=14"
      },
      "peerDependencies": {
        "react": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/recharts-scale": {
      "version": "0.4.5",
      "resolved": "https://registry.npmjs.org/recharts-scale/-/recharts-scale-0.4.5.tgz",
      "integrity": "sha512-kivNFO+0OcUNu7jQquLXAxz1FIwZj8nrj+YkOKc5694NbjCvcT6aSZiIzNzd2Kul4o4rTto8QVR9lMNtxD4G1w==",
      "license": "MIT",
      "dependencies": {
        "decimal.js-light": "^2.4.1"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT",
      "peer": true
    },
    "node_modules/tiny-invariant": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/tiny-invariant/-/tiny-invariant-1.3.3.tgz",
      "integrity": "sha512-+FbBPE1o9QAYvviau/qC5SE3caw21q3xkvWKBtja5vgqOWIHHJ3ioaq1VPfn/Szqctz2bU/oYeKd9/z5BL+PVg==",
      "license": "MIT"
    },
    "node_modules/victory-vendor": {
      "version": "36.9.2",
      "resolved": "https://registry.npmjs.org/victory-vendor/-/victory-vendor-36.9.2.tgz",
      "integrity": "sha512-PnpQQMuxlwYdocC8fIJqVXvkeViHYzotI+NJrCuav0ZYFoq912ZHBk3mCeuj+5/VpodOjPe1z0Fk2ihgzlXqjQ==",
      "license": "MIT AND ISC",
      "dependencies": {
        "@types/d3-array": "^3.0.3",
        "@types/d3-ease": "^3.0.0",
        "@types/d3-interpolate": "^3.0.1",
        "@types/d3-scale": "^4.0.2",
        "@types/d3-shape": "^3.1.0",
        "@types/d3-time": "^3.0.0",
        "@types/d3-timer": "^3.0.0",
        "d3-array": "^3.1.6",
        "d3-ease": "^3.0.1",
        "d3-interpolate": "^3.0.1",
        "d3-scale": "^4.0.2",
        "d3-shape": "^3.1.0",
        "d3-time": "^3.0.0",
        "d3-timer": "^3.0.1"
      }
    }
  }
}
