.
--------------------------------------------------------------------------------
Arquivo: ./utils/ollama.py
-------------------------------------------------------------------------------
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt construÃ­do.
    Retorna a resposta limpa e quaisquer tokens extraÃ­dos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/histÃ³rico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como nÃ£o-streaming para simplicidade
        # Adicione outros parÃ¢metros do Ollama aqui se necessÃ¡rio (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exceÃ§Ã£o para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("âœ… Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necessÃ¡rio

            resposta_bruta = dados.get("response", "ğŸ¤– Desculpe, nÃ£o consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens ExtraÃ­dos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "âš ï¸ Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"âš ï¸ Ocorreu um erro interno ao processar sua solicitaÃ§Ã£o ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO: Falha na conexÃ£o com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "âš ï¸ NÃ£o consegui me conectar Ã  minha inteligÃªncia artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("âŒ ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "âš ï¸ Ocorreu um erro inesperado. A equipe jÃ¡ foi notificada. Tente novamente mais tarde.", []
Arquivo: ./utils/prompt_builder.py
-------------------------------------------------------------------------------
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# ConfiguraÃ§Ã£o do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ConexÃ£o MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # ColeÃ§Ã£o para histÃ³rico de conversas
    logging.info("ConexÃ£o com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conexÃ£o adequadamente - talvez retornar erro ou usar prompt padrÃ£o
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necessÃ¡rio

def carregar_prompt_mestre() -> str:
    """Carrega o conteÃºdo do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"âŒ ERRO: Arquivo de prompt mestre nÃ£o encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padrÃ£o seguro em caso de falha
        return (
            "VocÃª Ã© um assistente virtual focado em saÃºde mental e dependÃªncia quÃ­mica.\n"
            "Seja empÃ¡tico, claro e objetivo. OfereÃ§a apoio e informaÃ§Ãµes sobre agendamento quando apropriado.\n"
            "Responda em portuguÃªs brasileiro."
        )
    except Exception as e:
        logging.error(f"âŒ ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padrÃ£o seguro
        return (
            "VocÃª Ã© um assistente virtual focado em saÃºde mental e dependÃªncia quÃ­mica.\n"
            "Seja empÃ¡tico, claro e objetivo. OfereÃ§a apoio e informaÃ§Ãµes sobre agendamento quando apropriado.\n"
            "Responda em portuguÃªs brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """ConstrÃ³i o prompt final para a IA, incluindo o mestre, histÃ³rico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as Ãºltimas N interaÃ§Ãµes (usuÃ¡rio + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por criaÃ§Ã£o
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronolÃ³gica

            # Formata o histÃ³rico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usuÃ¡rio
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"UsuÃ¡rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o prÃ³ximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"âŒ ERRO ao buscar histÃ³rico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histÃ³rico."
    else:
        trecho_historico = "HistÃ³rico indisponÃ­vel (sem conexÃ£o DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
NÃºmero do UsuÃ¡rio (ocultar na resposta final): {telefone}
---
HistÃ³rico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do UsuÃ¡rio:
UsuÃ¡rio: {pergunta_atual.strip()}
---
InstruÃ§Ãµes para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom empÃ¡tico, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acessÃ­vel, evitando jargÃµes tÃ©cnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 parÃ¡grafos curtos. Max 400 caracteres se possÃ­vel.
5.  Se a conversa indicar necessidade de agendamento ou mais informaÃ§Ãµes, ofereÃ§a isso proativamente.
6.  NÃƒO inclua o histÃ³rico ou as instruÃ§Ãµes na sua resposta final.
7.  NÃƒO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em portuguÃªs brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt construÃ­do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sensÃ­veis)

    return prompt_final
Arquivo: ./utils/mensageria.py
-------------------------------------------------------------------------------
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("âš ï¸ Tentativa de enviar mensagem vazia ou sem destinatÃ¡rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url Ã© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoÃ¡vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"âœ… Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome PadrÃ£o ClÃ­nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "SatisfaÃ§Ã£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botÃ£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botÃ£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Ãndice do botÃ£o no template
                    # "parameters": [] # ParÃ¢metros especÃ­ficos do botÃ£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"âœ… Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
Arquivo: ./utils/contexto.py
-------------------------------------------------------------------------------
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas assÃ­ncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # ColeÃ§Ã£o para contextos
    logging.info("ConexÃ£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone especÃ­fico.
    'dados_atualizacao' deve ser um dicionÃ¡rio com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel salvar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto invÃ¡lido (sem telefone ou dados invÃ¡lidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modificaÃ§Ã£o
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na criaÃ§Ã£o
            },
            upsert=True # Cria o documento se nÃ£o existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel obter contexto para {telefone}: Sem conexÃ£o com DB.")
        return {} # Retorna dicionÃ¡rio vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicionÃ¡rio vazio se nÃ£o encontrar
    except Exception as e:
        logging.error(f"âŒ ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicionÃ¡rio vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel limpar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"âŒ ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do Ãºltimo acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que sÃ³ atualizarÃ¡ o $currentDate
Arquivo: ./utils/db.py
-------------------------------------------------------------------------------
from datetime import datetime, timedelta

# Simula prÃ³xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravaÃ§Ã£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} Ã s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÃ‰DICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicÃ­dio", "morrer", "nÃ£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

Arquivo: ./utils/risco.py
-------------------------------------------------------------------------------
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases crÃ­ticas (ajuste conforme necessÃ¡rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicÃ­dio", "me matar", "quero morrer", "nÃ£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperanÃ§a", "adeus mundo", "nÃ£o quero viver",
    # Adicionar termos relacionados a auto-mutilaÃ§Ã£o se aplicÃ¡vel
    # Adicionar termos relacionados a ameaÃ§as a terceiros se aplicÃ¡vel
]

# Adicionar palavras/frases que indicam URGÃŠNCIA MÃ‰DICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
    "desmaiado", "convulsÃ£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergÃªncias mÃ©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicÃ­dio, urgÃªncia mÃ©dica).
    Retorna um dicionÃ¡rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"ğŸš¨ RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"ğŸš‘ URGÃŠNCIA MÃ‰DICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
Arquivo: ./utils/agenda.py
-------------------------------------------------------------------------------
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuraÃ§Ã£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias Ãºteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (nÃ£o agenda Ã s 18:00, Ãºltimo Ã© 17:40)

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar Ã­ndice para garantir que nÃ£o haja duas consultas no mesmo horÃ¡rio
    consultas_db.create_index("horario", unique=True)
    logging.info("ConexÃ£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """AvanÃ§a o horÃ¡rio para o prÃ³ximo bloco de X minutos dentro do horÃ¡rio de operaÃ§Ã£o."""
    horario = inicio_base

    # Arredonda para o prÃ³ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no inÃ­cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horÃ¡rio de operaÃ§Ã£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (SÃ¡bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o prÃ³ximo horÃ¡rio livre e agenda a consulta.
    Retorna o datetime do horÃ¡rio agendado ou None se nÃ£o encontrar.
    """
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel agendar: Sem conexÃ£o com DB.")
        return None

    # Usar UTC para armazenamento no DB Ã© uma boa prÃ¡tica
    agora_utc = datetime.now(timezone.utc)
    # ComeÃ§a a procurar X minutos Ã  frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se jÃ¡ existe consulta nesse horÃ¡rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horÃ¡rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horÃ¡rio em UTC
            else:
                # HorÃ¡rio ocupado, avanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificaÃ§Ã£o/inserÃ§Ã£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceÃ§Ã£o

    logging.warning(f"NÃ£o foram encontrados horÃ¡rios disponÃ­veis para {telefone} apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se nÃ£o encontrar horÃ¡rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel cancelar: Sem conexÃ£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda nÃ£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"ğŸ—‘ï¸ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"âŒ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o prÃ³ximo horÃ¡rio disponÃ­vel sem agendar."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel consultar horÃ¡rio: Sem conexÃ£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # ComeÃ§a a procurar um pouco Ã  frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"PrÃ³ximo horÃ¡rio disponÃ­vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horÃ¡rio em UTC
            else:
                # AvanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao consultar prÃ³ximo horÃ¡rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horÃ¡rio disponÃ­vel encontrado na consulta apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horÃ¡rio UTC para uma string legÃ­vel no fuso horÃ¡rio local."""
    if not horario_utc:
        return "IndisponÃ­vel"
    try:
        # Precisa da biblioteca pytz para fusos horÃ¡rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (TerÃ§a-feira, 15 de Abril Ã s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B Ã s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz nÃ£o instalada. Usando formataÃ§Ã£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horÃ¡rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formataÃ§Ã£o"
Arquivo: ./utils/ia_fallback.py
-------------------------------------------------------------------------------
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta

Arquivo: ./utils/followup.py
-------------------------------------------------------------------------------
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a funÃ§Ã£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a funÃ§Ã£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # NÃ£o precisa mais buscar aqui, usa agenda.py
    logging.info("ConexÃ£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- FunÃ§Ãµes de SimulaÃ§Ã£o (Removidas ou SubstituÃ­das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> LÃ³gica estÃ¡ em agenda.py
# avisar_profissional -> Deveria ser chamado apÃ³s agendamento real
# avisar_paciente -> Deveria ser chamado apÃ³s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o inÃ­cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel iniciar sessÃ£o de pagamento: Sem conexÃ£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃƒO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao iniciar sessÃ£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessÃ£o como paga, agenda a consulta e retorna o horÃ¡rio agendado e nome.
    Esta funÃ§Ã£o Ã© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel marcar pagamento: Sem conexÃ£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que sÃ³ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualizaÃ§Ã£o se nÃ£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, entÃ£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome jÃ¡ estÃ¡ lÃ¡ do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessÃ£o ser criada, ou se jÃ¡ foi processado
            logging.warning(f"SessÃ£o de pagamento nÃ£o encontrada ou jÃ¡ processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessÃ£o
        logging.info(f"[SESSÃƒO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessÃ£o com o horÃ¡rio agendado (opcional, mas Ãºtil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessÃ£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possÃ­vel notificaÃ§Ã£o manual

    except Exception as e:
        logging.error(f"âŒ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# FunÃ§Ã£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # LÃ³gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo nÃºmero real ou lÃ³gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"ğŸ‘¨â€âš•ï¸ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) Ã s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("NÃºmero do mÃ©dico nÃ£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# FunÃ§Ã£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessÃµes com pagamento pendente hÃ¡ muito tempo."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel checar followup: Sem conexÃ£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "vocÃª")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"OlÃ¡ {nome}, notei que vocÃª iniciou um agendamento mas parece que nÃ£o foi concluÃ­do. ğŸ˜¥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dÃºvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. ğŸ˜Š"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessÃ£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"âŒ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
Arquivo: ./schemas/ia_comando.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

Arquivo: ./intents/router_intents.py
-------------------------------------------------------------------------------
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigatÃ³rios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }
Arquivo: ./intents/__init__.py
-------------------------------------------------------------------------------

Arquivo: ./intents/intent_executor.py
-------------------------------------------------------------------------------
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o mÃ³dulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que nÃ£o Ã© fÃ¡cil buscar ajuda.\n\n"
    "ğŸ¤ Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "ğŸ“² Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "tÃ´ aqui pra isso", "pode falar", "Ã© isso", "ok", "tÃ¡", "tÃ¡ bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "nÃ£o", "nao", "talvez depois", "nÃ£o agora", "deixa pra depois",
    "tÃ´ sÃ³ olhando", "sÃ³ pesquisando", "agora nÃ£o"
]

# Limiar de confianÃ§a para a intent (ajuste conforme necessÃ¡rio)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui Ã© o|aqui Ã© a|meu nome Ã©|me chamo Ã©)\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)",
        r"nome Ã©\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confianÃ§a alta

    def detectar_intent(self):
        # LÃ³gica de detecÃ§Ã£o de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confianÃ§a para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que vocÃª precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "ğŸ”„ HistÃ³rico de testes apagado com sucesso. Pode comeÃ§ar uma nova simulaÃ§Ã£o.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "olÃ¡", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # MÃ©dia confianÃ§a em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # INÃCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"ğŸ“… Ã“timo! Posso te ajudar a agendar com nosso mÃ©dico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"ğŸ“† O prÃ³ximo horÃ¡rio disponÃ­vel Ã©: {consultar_horario()}. Posso reservar pra vocÃª?",

        # VALORES
        "duvida_valores": "ğŸ’° Temos valores acessÃ­veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIANÃ‡A
        "duvida_geral": "ğŸ“‹ Nosso sistema conecta vocÃª com mÃ©dicos especialistas de verdade. Quer saber como funciona na prÃ¡tica?",
        "desconfianca": "ğŸ” Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPENDÃŠNCIA / RECAÃDA / SINTOMAS
        "duvida_dependencia": "ğŸ§  A dependÃªncia quÃ­mica Ã© tratÃ¡vel. Nosso mÃ©dico pode avaliar sintomas fÃ­sicos e emocionais. Quer agendar?",
        "sou_dependente": "ğŸ’¬ Reconhecer isso Ã© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "ğŸ” RecaÃ­das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "ğŸ˜“ Os sintomas de abstinÃªncia sÃ£o desafiadores. Podemos te orientar com seguranÃ§a. Posso marcar agora?",

        # CRISE / URGÃŠNCIA
        "sintomas_graves": "âš ï¸ Sinais de crise detectados. Posso encaminhar vocÃª para um atendimento urgente. Deseja ajuda agora?",
        "ameaÃ§a_vida": "ğŸš¨ Sua vida importa. Posso ativar nosso acolhimento de urgÃªncia. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "ğŸ‘ª VocÃª quer ajudar alguÃ©m importante. Posso te explicar como funciona e agendar uma escuta para vocÃª ou para ele(a).",
        "familia_pedindo_ajuda": "ğŸ§­ VocÃª estÃ¡ no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "ğŸš¨ SituaÃ§Ã£o familiar crÃ­tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "ğŸ˜” Ã‰ difÃ­cil quando a famÃ­lia nÃ£o apoia. Mas hÃ¡ caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "ğŸ’” Muitas famÃ­lias passam por isso. Podemos ajudar na reconstruÃ§Ã£o. Quer agendar uma orientaÃ§Ã£o especializada?",
        "familiar_violento": "âš ï¸ Em casos de violÃªncia, seguranÃ§a vem primeiro. Posso te mostrar como agir com respaldo mÃ©dico e legal.",

        # INTERNAÃ‡ÃƒO
        "duvida_internacao": "ğŸ¥ A internaÃ§Ã£o pode ser voluntÃ¡ria ou involuntÃ¡ria, sempre com avaliaÃ§Ã£o mÃ©dica. Quer saber como isso funciona?",
        "quero_internar": "âœ… Posso te mostrar o processo completo, legal e clÃ­nico. Posso agendar agora com nosso mÃ©dico?",

        # FUNIL / OBJECÃ•ES / CIRCUNSTÃ‚NCIAS
        "nao_quero_internar": "Tudo bem. InternaÃ§Ã£o nÃ£o Ã© a Ãºnica saÃ­da. Posso te explicar outras opÃ§Ãµes com orientaÃ§Ã£o mÃ©dica.",
        "meu_parente_usa_droga": "ğŸ’¬ Entendo. Posso agendar com o especialista pra avaliar a situaÃ§Ã£o de forma profissional.",
        "crise_agora": "âš ï¸ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "ğŸ’¡ Obrigado por compartilhar. Posso te ajudar com os prÃ³ximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "ğŸ˜” A resistÃªncia Ã© comum. Mesmo assim, a famÃ­lia pode iniciar a aÃ§Ã£o. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "ğŸ‘¥ Se a famÃ­lia nÃ£o colabora, podemos trabalhar com quem estiver disponÃ­vel. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "ğŸ‘ Tranquilo. Se quiser ajudar alguÃ©m ou tirar dÃºvidas, posso te explicar tudo com calma.",

        # INFORMAÃ‡Ã•ES COMPLEMENTARES
        "quero_entender": "ğŸ“˜ Posso te explicar tudo sobre o atendimento, desde a escuta atÃ© o tratamento. Quer comeÃ§ar agora?",
        "curioso": "ğŸ˜„ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulaÃ§Ã£o real?",
        "pergunta_medico": "ğŸ‘¨â€âš•ï¸ O mÃ©dico Ã© especialista em dependÃªncia quÃ­mica e avaliaÃ§Ã£o clÃ­nica. Quer agendar a escuta?",
        "duvida_medicacao": "ğŸ’Š Medicamentos sÃ³ sÃ£o indicados apÃ³s avaliaÃ§Ã£o. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "ğŸ§  Temos psicÃ³logos na equipe. A avaliaÃ§Ã£o inicial Ã© mÃ©dica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "ğŸ” RecomeÃ§ar Ã© possÃ­vel. Estamos aqui pra isso. Quer conversar com o mÃ©dico novamente?",
        "vergonha_de_falar": "ğŸ§¡ Tudo bem. NÃ£o precisa se explicar agora. Posso sÃ³ ouvir, se quiser.",
        "culpa_familiar": "ğŸ¤ A culpa nÃ£o ajuda, mas o cuidado sim. Posso te mostrar como comeÃ§ar com leveza.",
        "busca_ajuda_emocional": "ğŸ’¬ TambÃ©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "ğŸ› Respeitamos todas as crenÃ§as. O acolhimento Ã© humano, com base Ã©tica. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "âš–ï¸ A internaÃ§Ã£o judicial Ã© possÃ­vel. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "ğŸ‘¶ Tratamos casos de menores com responsabilidade. Posso te mostrar os critÃ©rios e caminhos.",
        "direitos_paciente": "ğŸ“œ Tudo Ã© feito conforme a Ã©tica mÃ©dica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "ğŸ“ Temos atendimento online e unidades fÃ­sicas. Quer saber se tem perto de vocÃª?",
        "duvida_profissionais": "ğŸ‘©â€âš•ï¸ Temos mÃ©dicos, terapeutas e psicÃ³logos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "ğŸ”’ Todo atendimento Ã© sigiloso. Nada Ã© compartilhado sem sua autorizaÃ§Ã£o. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"âœ… Consulta cancelada. Se quiser retomar, Ã© sÃ³ me avisar.",
        "teste": "ğŸ§ª EstÃ¡ testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "â¤ï¸ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prÃ¡tica.",
        "erro": "ğŸ” Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "ğŸ¤” NÃ£o entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "ğŸ‘ Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugestÃµes de prÃ³ximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou vocÃª gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou vocÃª tem alguma outra dÃºvida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou vocÃª gostaria de agendar uma consulta?",
            "sou_dependente": "\nVocÃª gostaria de agendar uma consulta ou precisa de mais informaÃ§Ãµes?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVocÃª gostaria de agendar uma consulta para vocÃª ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de internaÃ§Ã£o ou vocÃª gostaria de saber as opÃ§Ãµes de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se vocÃª reformular a pergunta ou gostaria de ver as opÃ§Ãµes de ajuda disponÃ­veis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padrÃ£o
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta
Arquivo: ./intents/intents_map.py
-------------------------------------------------------------------------------
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # ğŸš€ INÃCIO DO FUNIL
    "boas_vindas": [
        "oi", "olÃ¡", "ola", "bom dia", "boa tarde", "boa noite", "e aÃ­", "fala comigo", "tudo bem", "como vai"
    ],

    # ğŸ‘¤ QUERO AGENDAR / HORÃRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um mÃ©dico", "consulta urgente", "quero ajuda mÃ©dica",
        "agendar", "marcar consulta", "atendimento mÃ©dico", "agendar consulta"
    ],
    "ver_horario": [
        "tem horÃ¡rio", "que horas tem", "tem agenda", "qual o prÃ³ximo horÃ¡rio", "quero saber os horÃ¡rios",
        "horÃ¡rios disponÃ­veis", "agenda livre", "consultar horÃ¡rio", "ver agenda"
    ],

    # ğŸ’° VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "preÃ§o", "tem plano", "Ã© caro", "valores da consulta", "paga quanto", "Ã© gratuito?",
        "aceita convÃªnio", "plano de saÃºde", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # â“ DÃšVIDAS GERAIS / CONFIANÃ‡A
    "duvida_geral": [
        "como funciona", "me explica", "o que vocÃªs fazem", "isso Ã© pra quÃª", "como ajudam", "qual o tratamento",
        "o que Ã© isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso Ã© real?", "posso confiar?", "Ã© golpe?", "tem CNPJ?", "quem sÃ£o vocÃªs?", "Ã© confiÃ¡vel?", "funciona mesmo?",
        "Ã© seguro?", "garantia", "Ã© empresa?"
    ],

    # ğŸ“š SOBRE DEPENDÃŠNCIA / VÃCIO
    "duvida_dependencia": [
        "o que Ã© dependÃªncia quÃ­mica", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "vÃ­cio em drogas", "meu caso tem jeito", "isso Ã© doenÃ§a?", "uso mas nÃ£o sou viciado", "tem tratamento",
        "dependÃªncia", "vÃ­cio", "drogas", "alcoolismo", "sintomas de vÃ­cio"
    ],
    "sou_dependente": [
        "sou viciado", "tenho vÃ­cio", "sou dependente quÃ­mico", "tenho problema com droga", "uso todo dia",
        "nÃ£o consigo parar", "preciso parar de usar", "sou alcoÃ³latra", "viciado"
    ],
    "recaida": [
        "tive recaÃ­da", "usei de novo", "nÃ£o consegui parar", "recomecei", "caÃ­ de novo",
        "recaÃ­", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "tÃ´ tremendo", "tÃ´ suando", "nÃ£o tÃ´ bem", "tÃ´ em abstinÃªncia", "tÃ´ agoniado", "tÃ´ passando mal sem usar",
        "sintomas de abstinÃªncia", "fissura", "crise de abstinÃªncia"
    ],

    # ğŸ§  SINTOMAS GRAVES / CRISE / URGÃŠNCIA
    "sintomas_graves": [
        "tÃ¡ surtando", "alucinaÃ§Ã£o", "tÃ¡ agressivo", "nÃ£o dorme hÃ¡ dias", "visÃµes", "delÃ­rio", "tÃ¡ em crise",
        "descontrolado", "sem noÃ§Ã£o do que faz", "paranoia", "confusÃ£o mental", "surto psicÃ³tico"
    ],
    "ameaÃ§a_vida": [ # Risco de suicÃ­dio/auto-mutilaÃ§Ã£o
        "quero morrer", "vou me matar", "nÃ£o quero viver", "quero sumir", "vou acabar com tudo", "vida nÃ£o faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # EmergÃªncia mÃ©dica clara
        "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
        "desmaiado", "convulsÃ£o", "sangrando muito", "veneno", "infarto", "avc", "emergÃªncia"
    ],


    # ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou mÃ£e", "sou pai", "sou esposa", "sou marido", "sou irmÃ£o", "sou irmÃ£", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho tÃ¡ viciado", "minha filha tÃ¡ usando", "meu marido nÃ£o aceita ajuda", "ele nÃ£o quer se tratar",
        "nÃ£o sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela tÃ¡ gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "tÃ¡ se machucando", "tÃ¡ em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele nÃ£o quer ajuda", "ela nÃ£o aceita", "nÃ£o quer tratamento", "nÃ£o admite que tem problema",
        "nÃ£o quer ser internado", "nÃ£o aceita mÃ©dico", "resiste ao tratamento"
    ],

    # ğŸ¥ INTERNAÃ‡ÃƒO
    "duvida_internacao": [
        "como funciona a internaÃ§Ã£o", "quanto tempo dura", "volta pra casa depois?", "como Ã© o lugar",
        "tem visita?", "fica trancado?", "internaÃ§Ã£o involuntÃ¡ria", "Ã© forÃ§ado?", "tem psiquiatra?",
        "internaÃ§Ã£o", "clÃ­nica de recuperaÃ§Ã£o", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como faÃ§o pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "internaÃ§Ã£o compulsÃ³ria", "internaÃ§Ã£o involuntÃ¡ria"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa nÃ£o querer internaÃ§Ã£o
        "nÃ£o quero internar", "sem internaÃ§Ã£o", "tratamento sem internar", "nÃ£o precisa de clÃ­nica",
        "alternativa Ã  internaÃ§Ã£o", "tratamento ambulatorial"
    ],

    # âš–ï¸ QUESTÃ•ES LEGAIS / JURÃDICAS
    "internacao_judicial": [
        "posso pedir pra justiÃ§a?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "internaÃ§Ã£o compulsÃ³ria", "justiÃ§a", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho Ã© menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "crianÃ§a"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele Ã© obrigado?", "isso Ã© legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # ğŸ’¬ OUTRAS SITUAÃ‡Ã•ES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # UsuÃ¡rio falando sobre seu prÃ³prio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida tÃ¡ destruÃ­da",
        "preciso de ajuda com meu vÃ­cio"
    ],
     "resistencia_familiar": [ # Paciente relata que a famÃ­lia nÃ£o apoia/atrapalha
        "minha famÃ­lia nÃ£o me apoia", "minha esposa nÃ£o entende", "meus pais nÃ£o aceitam",
        "famÃ­lia contra o tratamento", "nÃ£o tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que nÃ£o Ã© o paciente
        "nÃ£o sou eu que uso", "Ã© para um amigo", "sÃ³ estou pesquisando", "quero informaÃ§Ã£o para outra pessoa",
        "nÃ£o sou usuÃ¡rio"
    ],

    # â„¹ï¸ BUSCA DE INFORMAÃ‡Ã•ES ADICIONAIS
     "quero_entender": [ # Pedido explÃ­cito para entender o serviÃ§o/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # DemonstraÃ§Ã£o de curiosidade ou teste
        "sÃ³ testando", "kkk", "haha", "curioso", "testando sistema", "sÃ³ vendo como funciona",
        "teste", "simulaÃ§Ã£o"
    ],
    "pergunta_medico": [ # DÃºvida especÃ­fica sobre o profissional mÃ©dico
        "quem Ã© o mÃ©dico?", "qual a especialidade?", "Ã© psiquiatra?", "posso escolher o mÃ©dico?",
        "falar com o mÃ©dico"
    ],
     "duvida_medicacao": [ # DÃºvida sobre remÃ©dios
        "vai precisar de remÃ©dio?", "usam medicaÃ§Ã£o?", "quais remÃ©dios?", "tratamento com remÃ©dio",
        "medicaÃ§Ã£o psiquiÃ¡trica"
    ],
     "duvida_psicologo": [ # DÃºvida sobre psicÃ³logo/terapia
        "tem psicÃ³logo?", "faz terapia?", "atendimento psicolÃ³gico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # DÃºvida sobre local fÃ­sico/online
        "onde fica?", "tem na minha cidade?", "qual o endereÃ§o?", "atende onde?", "Ã© presencial ou online?",
        "atendimento online", "unidade fÃ­sica", "endereÃ§o da clÃ­nica"
    ],
     "duvida_profissionais": [ # DÃºvida geral sobre a equipe
        "quem sÃ£o os profissionais?", "tem terapeuta?", "quem atende?", "Ã© sÃ³ mÃ©dico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # DÃºvida sobre confidencialidade
        "isso Ã© sigiloso?", "meus dados estÃ£o protegidos?", "alguÃ©m vai saber?", "Ã© confidencial?",
        "privacidade", "segredo mÃ©dico"
    ],


    # â¤ï¸ INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # JÃ¡ tentou tratamento antes e parou
        "jÃ¡ tentei parar antes", "desisti do tratamento", "nÃ£o funcionou da outra vez",
        "jÃ¡ fiz tratamento e nÃ£o adiantou", "recomeÃ§ar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ninguÃ©m", "Ã© difÃ­cil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que Ã© culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "tÃ´ mal", "tÃ´ triste", "ansiedade", "crise de pÃ¢nico", "sou depressivo", "tÃ´ vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # QuestÃµes sobre religiÃ£o/espiritualidade
        "Ã© contra religiÃ£o?", "tem algo espiritual?", "sou evangÃ©lico", "sou catÃ³lico", "tem apoio religioso?",
        "minha fÃ©", "igreja"
    ],

    # ğŸ›‘ CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar aÃ§Ã£o atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "nÃ£o quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "nÃ£o posso ir"
    ],
    "confirmacao_positiva": [ # ConfirmaÃ§Ã£o genÃ©rica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "tÃ¡", "tÃ¡ bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # NegaÃ§Ã£o genÃ©rica (nÃ£o, agora nÃ£o)
        "nÃ£o", "nao", "talvez depois", "nÃ£o agora", "deixa pra depois", "agora nÃ£o", "nÃ£o quero", "nÃ£o obrigado"
    ],
    "elogio": [
        "Ã³timo atendimento", "gostei muito", "vocÃªs sÃ£o bons", "obrigado", "atendimento top", "amei",
        "parabÃ©ns", "muito bom", "excelente"
    ],
    "erro": [ # UsuÃ¡rio reporta um erro tÃ©cnico
        "link nÃ£o abre", "deu erro", "nÃ£o consegui pagar", "o site caiu", "nÃ£o carrega",
        "problema tÃ©cnico", "nÃ£o funciona", "bug"
    ],
    "sem_compreensao": [ # Bot nÃ£o entendeu ou mensagem ininteligÃ­vel
        "asdfgh", "oiaueia", "????", "nÃ£o entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "nÃ£o faz sentido"
    ],

    # Adicione intents mais especÃ­ficas conforme necessÃ¡rio
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}
Arquivo: ./routes/pagamentos.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

Arquivo: ./routes/painel.py
-------------------------------------------------------------------------------
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessÃ£o estÃ¡ confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

Arquivo: ./routes/stripe.py
-------------------------------------------------------------------------------
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # ğŸ§  Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # ğŸ§  Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

Arquivo: ./routes/rocketchat.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda nÃ£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

Arquivo: ./routes/agendamento.py
-------------------------------------------------------------------------------
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


Arquivo: ./routes/whatsapp.py
-------------------------------------------------------------------------------
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("âš ï¸ Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # ğŸš¨ Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"âš ï¸ Alerta FAMDOMES: DetecÃ§Ã£o de risco na conversa com {telefone}. "
                f"Mensagem: â€œ{mensagem}â€. Um profissional serÃ¡ alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("âŒ ERRO no webhook:", str(e))
        return {"erro": str(e)}
Arquivo: ./routes/ia_comandos.py
-------------------------------------------------------------------------------
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"âœ… Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando nÃ£o reconhecido.")

Arquivo: ./routes/ia.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# âœ… FunÃ§Ã£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"âœ… Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "âŒ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "âœ… Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in comando or "disponÃ­vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ğŸ¤– Desculpe, nÃ£o entendi o que vocÃª deseja. VocÃª pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horÃ¡rio disponÃ­vel")
        return {"status": "comando_desconhecido"}

Arquivo: ./routes/followup.py
-------------------------------------------------------------------------------
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

Arquivo: ./main.py
-------------------------------------------------------------------------------
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("ğŸ“¥ Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas pÃºblicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # ValidaÃ§Ã£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

Arquivo: ./models/pagamentos.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

Arquivo: ./models/intents.py
-------------------------------------------------------------------------------
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horÃ¡rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horÃ¡rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "jÃ¡ paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que vocÃª faz",
        "me ajuda",
        "como vocÃª pode me ajudar"
    ]
}

Arquivo: ./models/atendimento.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

Arquivo: ./config.py
-------------------------------------------------------------------------------
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

Arquivo: ./nlu/response_generator.py
-------------------------------------------------------------------------------
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que nÃ£o Ã© fÃ¡cil buscar ajuda.\n\n"
    "ğŸ¤ Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "ğŸ“² Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÃCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"ğŸ“… Ã“timo! Posso te ajudar a agendar com nosso mÃ©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"ğŸ“† O prÃ³ximo horÃ¡rio disponÃ­vel Ã©: {consultar_horario()}. Posso reservar pra vocÃª?",

    # VALORES
    "duvida_valores": "ğŸ’° Temos valores acessÃ­veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÃ‡A
    "duvida_geral": "ğŸ“‹ Nosso sistema conecta vocÃª com mÃ©dicos especialistas de verdade. Quer saber como funciona na prÃ¡tica?",
    "desconfianca": "ğŸ” Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÃŠNCIA / RECAÃDA / SINTOMAS
    "duvida_dependencia": "ğŸ§  A dependÃªncia quÃ­mica Ã© tratÃ¡vel. Nosso mÃ©dico pode avaliar sintomas fÃ­sicos e emocionais. Quer agendar?",
    "sou_dependente": "ğŸ’¬ Reconhecer isso Ã© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "ğŸ” RecaÃ­das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "ğŸ˜“ Os sintomas de abstinÃªncia sÃ£o desafiadores. Podemos te orientar com seguranÃ§a. Posso marcar agora?",

    # CRISE / URGÃŠNCIA
    "sintomas_graves": "âš ï¸ Sinais de crise detectados. Posso encaminhar vocÃª para um atendimento urgente. Deseja ajuda agora?",
    "ameaÃ§a_vida": "ğŸš¨ Sua vida importa. Posso ativar nosso acolhimento de urgÃªncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "ğŸ‘ª VocÃª quer ajudar alguÃ©m importante. Posso te explicar como funciona e agendar uma escuta para vocÃª ou para ele(a).",
    "familia_pedindo_ajuda": "ğŸ§­ VocÃª estÃ¡ no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "ğŸš¨ SituaÃ§Ã£o familiar crÃ­tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "ğŸ˜” Ã‰ difÃ­cil quando a famÃ­lia nÃ£o apoia. Mas hÃ¡ caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "ğŸ’” Muitas famÃ­lias passam por isso. Podemos ajudar na reconstruÃ§Ã£o. Quer agendar uma orientaÃ§Ã£o especializada?",
    "familiar_violento": "âš ï¸ Em casos de violÃªncia, seguranÃ§a vem primeiro. Posso te mostrar como agir com respaldo mÃ©dico e legal.",

    # INTERNAÃ‡ÃƒO
    "duvida_internacao": "ğŸ¥ A internaÃ§Ã£o pode ser voluntÃ¡ria ou involuntÃ¡ria, sempre com avaliaÃ§Ã£o mÃ©dica. Quer saber como isso funciona?",
    "quero_internar": "âœ… Posso te mostrar o processo completo, legal e clÃ­nico. Posso agendar agora com nosso mÃ©dico?",

    # FUNIL / OBJECÃ•ES / CIRCUNSTÃ‚NCIAS
    "nao_quero_internar": "Tudo bem. InternaÃ§Ã£o nÃ£o Ã© a Ãºnica saÃ­da. Posso te explicar outras opÃ§Ãµes com orientaÃ§Ã£o mÃ©dica.",
    "meu_parente_usa_droga": "ğŸ’¬ Entendo. Posso agendar com o especialista pra avaliar a situaÃ§Ã£o de forma profissional.",
    "crise_agora": "âš ï¸ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "ğŸ’¡ Obrigado por compartilhar. Posso te ajudar com os prÃ³ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "ğŸ˜” A resistÃªncia Ã© comum. Mesmo assim, a famÃ­lia pode iniciar a aÃ§Ã£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "ğŸ‘¥ Se a famÃ­lia nÃ£o colabora, podemos trabalhar com quem estiver disponÃ­vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "ğŸ‘ Tranquilo. Se quiser ajudar alguÃ©m ou tirar dÃºvidas, posso te explicar tudo com calma.",

    # INFORMAÃ‡Ã•ES COMPLEMENTARES
    "quero_entender": "ğŸ“˜ Posso te explicar tudo sobre o atendimento, desde a escuta atÃ© o tratamento. Quer comeÃ§ar agora?",
    "curioso": "ğŸ˜„ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulaÃ§Ã£o real?",
    "pergunta_medico": "ğŸ‘¨â€âš•ï¸ O mÃ©dico Ã© especialista em dependÃªncia quÃ­mica e avaliaÃ§Ã£o clÃ­nica. Quer agendar a escuta?",
    "duvida_medicacao": "ğŸ’Š Medicamentos sÃ³ sÃ£o indicados apÃ³s avaliaÃ§Ã£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "ğŸ§  Temos psicÃ³logos na equipe. A avaliaÃ§Ã£o inicial Ã© mÃ©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "ğŸ” RecomeÃ§ar Ã© possÃ­vel. Estamos aqui pra isso. Quer conversar com o mÃ©dico novamente?",
    "vergonha_de_falar": "ğŸ§¡ Tudo bem. NÃ£o precisa se explicar agora. Posso sÃ³ ouvir, se quiser.",
    "culpa_familiar": "ğŸ¤ A culpa nÃ£o ajuda, mas o cuidado sim. Posso te mostrar como comeÃ§ar com leveza.",
    "busca_ajuda_emocional": "ğŸ’¬ TambÃ©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "ğŸ› Respeitamos todas as crenÃ§as. O acolhimento Ã© humano, com base Ã©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "âš–ï¸ A internaÃ§Ã£o judicial Ã© possÃ­vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "ğŸ‘¶ Tratamos casos de menores com responsabilidade. Posso te mostrar os critÃ©rios e caminhos.",
    "direitos_paciente": "ğŸ“œ Tudo Ã© feito conforme a Ã©tica mÃ©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "ğŸ“ Temos atendimento online e unidades fÃ­sicas. Quer saber se tem perto de vocÃª?",
    "duvida_profissionais": "ğŸ‘©â€âš•ï¸ Temos mÃ©dicos, terapeutas e psicÃ³logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "ğŸ”’ Todo atendimento Ã© sigiloso. Nada Ã© compartilhado sem sua autorizaÃ§Ã£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "âœ… Consulta cancelada. Se quiser retomar, Ã© sÃ³ me avisar.",
    "teste": "ğŸ§ª EstÃ¡ testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "â¤ï¸ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prÃ¡tica.",
    "erro": "ğŸ” Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ğŸ¤” NÃ£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "ğŸ‘ Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrÃ£o se intent for reconhecida mas sem frase especÃ­fica
        return respostas.get(intent, "TÃ´ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

Arquivo: ./nlu/chatbot_router.py
-------------------------------------------------------------------------------
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier  # Importe a classe
from app.nlu.entidade_extractor import EntidadeExtractor  # Importe a classe
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

# Instancie os classificadores e extratores
nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0  # Inicialmente, confianÃ§a alta

    async def processar(self):
        # Reset manual
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "ğŸ”„ HistÃ³rico apagado. Pode comeÃ§ar de novo.", "risco": False}

        # Detectar intent e extrair entidades
        intent = nlu_classifier.classificar_intent(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Se vocÃª estiver usando um modelo de ML para classificar a intent,
        # vocÃª pode obter a confianÃ§a aqui. Por exemplo:
        # intent, self.intent_confianca = nlu_classifier.classificar_com_confianca(self.mensagem)

        # Atualizar nome se extraÃ­do
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Gerar resposta
        resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
        risco = analisar_risco(self.mensagem)

        # LÃ³gica de baixa confianÃ§a (se aplicÃ¡vel)
        if self.intent_confianca < 0.6 and intent == "desconhecida":
            resposta = "ğŸ¤” Desculpe, nÃ£o entendi. VocÃª pode reformular sua pergunta?"
            logging.warning(f"Baixa confianÃ§a na intent: {intent} ({self.intent_confianca}). Mensagem: {self.mensagem}")

        # Atualizar contexto
        self._atualizar_contexto(intent)

        # HistÃ³rico
        return self._registrar_interacao(intent, resposta, risco)

    def _atualizar_contexto(self, intent):
        salvar_contexto(self.telefone, {
            "ultima_mensagem": self.mensagem,
            "ultima_intent": intent,
            "intent_esperada": None,
            "aguardando_confirmacao": False
        })

    def _registrar_interacao(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}
Arquivo: ./nlu/nlu_classifier.py
-------------------------------------------------------------------------------
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparaÃ§Ã£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuaÃ§Ãµes bÃ¡sicas (exceto espaÃ§os) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaÃ§os extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML nÃ£o encontrados. Usando classificaÃ§Ã£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presenÃ§a de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # ConfianÃ§a base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho estÃ¡ contido no texto
                # Usar `in` Ã© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # LÃ³gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confianÃ§a para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- ClassificaÃ§Ã£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML prÃ©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # NÃ£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, ConfianÃ§a={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificaÃ§Ã£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confianÃ§a.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML nÃ£o estiver ativo ou como mÃ©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- MÃ©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF Ã© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parÃ¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes Ã© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
Arquivo: ./nlu/entidade_extractor.py
-------------------------------------------------------------------------------
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)",
                r"([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)\s+(?:Ã© meu nome|meu nome Ã©|aqui Ã©)" # Novo padrÃ£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)\s+(?:Ã© meu|minha)" # Novo padrÃ£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)",
                r"(?:cidade de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)" # Novo padrÃ£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrÃ£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaÃ­na)"
            ],
            "recaida": [
                r"(reca[Ã­i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[Ã­i]da|escorregada)" # Novo padrÃ£o
            ],
            # Adicione mais entidades e padrÃµes conforme necessÃ¡rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraÃ­da: {entidades[entidade]} (PadrÃ£o: '{padrao}')")
                    break  # Para na primeira correspondÃªncia

        return entidades
==== /home/ubuntu/famdomes_backend/app/utils/ollama.py ====
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt construÃ­do.
    Retorna a resposta limpa e quaisquer tokens extraÃ­dos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/histÃ³rico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como nÃ£o-streaming para simplicidade
        # Adicione outros parÃ¢metros do Ollama aqui se necessÃ¡rio (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exceÃ§Ã£o para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("âœ… Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necessÃ¡rio

            resposta_bruta = dados.get("response", "ğŸ¤– Desculpe, nÃ£o consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens ExtraÃ­dos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "âš ï¸ Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"âš ï¸ Ocorreu um erro interno ao processar sua solicitaÃ§Ã£o ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO: Falha na conexÃ£o com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "âš ï¸ NÃ£o consegui me conectar Ã  minha inteligÃªncia artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("âŒ ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "âš ï¸ Ocorreu um erro inesperado. A equipe jÃ¡ foi notificada. Tente novamente mais tarde.", []


==== /home/ubuntu/famdomes_backend/app/utils/prompt_builder.py ====
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# ConfiguraÃ§Ã£o do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ConexÃ£o MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # ColeÃ§Ã£o para histÃ³rico de conversas
    logging.info("ConexÃ£o com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conexÃ£o adequadamente - talvez retornar erro ou usar prompt padrÃ£o
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necessÃ¡rio

def carregar_prompt_mestre() -> str:
    """Carrega o conteÃºdo do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"âŒ ERRO: Arquivo de prompt mestre nÃ£o encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padrÃ£o seguro em caso de falha
        return (
            "VocÃª Ã© um assistente virtual focado em saÃºde mental e dependÃªncia quÃ­mica.\n"
            "Seja empÃ¡tico, claro e objetivo. OfereÃ§a apoio e informaÃ§Ãµes sobre agendamento quando apropriado.\n"
            "Responda em portuguÃªs brasileiro."
        )
    except Exception as e:
        logging.error(f"âŒ ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padrÃ£o seguro
        return (
            "VocÃª Ã© um assistente virtual focado em saÃºde mental e dependÃªncia quÃ­mica.\n"
            "Seja empÃ¡tico, claro e objetivo. OfereÃ§a apoio e informaÃ§Ãµes sobre agendamento quando apropriado.\n"
            "Responda em portuguÃªs brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """ConstrÃ³i o prompt final para a IA, incluindo o mestre, histÃ³rico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as Ãºltimas N interaÃ§Ãµes (usuÃ¡rio + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por criaÃ§Ã£o
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronolÃ³gica

            # Formata o histÃ³rico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usuÃ¡rio
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"UsuÃ¡rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o prÃ³ximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"âŒ ERRO ao buscar histÃ³rico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histÃ³rico."
    else:
        trecho_historico = "HistÃ³rico indisponÃ­vel (sem conexÃ£o DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
NÃºmero do UsuÃ¡rio (ocultar na resposta final): {telefone}
---
HistÃ³rico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do UsuÃ¡rio:
UsuÃ¡rio: {pergunta_atual.strip()}
---
InstruÃ§Ãµes para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom empÃ¡tico, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acessÃ­vel, evitando jargÃµes tÃ©cnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 parÃ¡grafos curtos. Max 400 caracteres se possÃ­vel.
5.  Se a conversa indicar necessidade de agendamento ou mais informaÃ§Ãµes, ofereÃ§a isso proativamente.
6.  NÃƒO inclua o histÃ³rico ou as instruÃ§Ãµes na sua resposta final.
7.  NÃƒO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em portuguÃªs brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt construÃ­do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sensÃ­veis)

    return prompt_final


==== /home/ubuntu/famdomes_backend/app/utils/mensageria.py ====
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("âš ï¸ Tentativa de enviar mensagem vazia ou sem destinatÃ¡rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url Ã© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoÃ¡vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"âœ… Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome PadrÃ£o ClÃ­nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "SatisfaÃ§Ã£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botÃ£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botÃ£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Ãndice do botÃ£o no template
                    # "parameters": [] # ParÃ¢metros especÃ­ficos do botÃ£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"âœ… Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/utils/contexto.py ====
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas assÃ­ncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # ColeÃ§Ã£o para contextos
    logging.info("ConexÃ£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone especÃ­fico.
    'dados_atualizacao' deve ser um dicionÃ¡rio com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel salvar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto invÃ¡lido (sem telefone ou dados invÃ¡lidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modificaÃ§Ã£o
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na criaÃ§Ã£o
            },
            upsert=True # Cria o documento se nÃ£o existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel obter contexto para {telefone}: Sem conexÃ£o com DB.")
        return {} # Retorna dicionÃ¡rio vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicionÃ¡rio vazio se nÃ£o encontrar
    except Exception as e:
        logging.error(f"âŒ ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicionÃ¡rio vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"NÃ£o foi possÃ­vel limpar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"âŒ ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do Ãºltimo acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que sÃ³ atualizarÃ¡ o $currentDate


==== /home/ubuntu/famdomes_backend/app/utils/db.py ====
from datetime import datetime, timedelta

# Simula prÃ³xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravaÃ§Ã£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} Ã s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÃ‰DICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicÃ­dio", "morrer", "nÃ£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)



==== /home/ubuntu/famdomes_backend/app/utils/risco.py ====
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases crÃ­ticas (ajuste conforme necessÃ¡rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicÃ­dio", "me matar", "quero morrer", "nÃ£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperanÃ§a", "adeus mundo", "nÃ£o quero viver",
    # Adicionar termos relacionados a auto-mutilaÃ§Ã£o se aplicÃ¡vel
    # Adicionar termos relacionados a ameaÃ§as a terceiros se aplicÃ¡vel
]

# Adicionar palavras/frases que indicam URGÃŠNCIA MÃ‰DICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
    "desmaiado", "convulsÃ£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergÃªncias mÃ©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicÃ­dio, urgÃªncia mÃ©dica).
    Retorna um dicionÃ¡rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"ğŸš¨ RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"ğŸš‘ URGÃŠNCIA MÃ‰DICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }


==== /home/ubuntu/famdomes_backend/app/utils/agenda.py ====
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuraÃ§Ã£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias Ãºteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (nÃ£o agenda Ã s 18:00, Ãºltimo Ã© 17:40)

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar Ã­ndice para garantir que nÃ£o haja duas consultas no mesmo horÃ¡rio
    consultas_db.create_index("horario", unique=True)
    logging.info("ConexÃ£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """AvanÃ§a o horÃ¡rio para o prÃ³ximo bloco de X minutos dentro do horÃ¡rio de operaÃ§Ã£o."""
    horario = inicio_base

    # Arredonda para o prÃ³ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no inÃ­cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horÃ¡rio de operaÃ§Ã£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (SÃ¡bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o prÃ³ximo horÃ¡rio livre e agenda a consulta.
    Retorna o datetime do horÃ¡rio agendado ou None se nÃ£o encontrar.
    """
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel agendar: Sem conexÃ£o com DB.")
        return None

    # Usar UTC para armazenamento no DB Ã© uma boa prÃ¡tica
    agora_utc = datetime.now(timezone.utc)
    # ComeÃ§a a procurar X minutos Ã  frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se jÃ¡ existe consulta nesse horÃ¡rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horÃ¡rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horÃ¡rio em UTC
            else:
                # HorÃ¡rio ocupado, avanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificaÃ§Ã£o/inserÃ§Ã£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceÃ§Ã£o

    logging.warning(f"NÃ£o foram encontrados horÃ¡rios disponÃ­veis para {telefone} apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se nÃ£o encontrar horÃ¡rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel cancelar: Sem conexÃ£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda nÃ£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"ğŸ—‘ï¸ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"âŒ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o prÃ³ximo horÃ¡rio disponÃ­vel sem agendar."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel consultar horÃ¡rio: Sem conexÃ£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # ComeÃ§a a procurar um pouco Ã  frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"PrÃ³ximo horÃ¡rio disponÃ­vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horÃ¡rio em UTC
            else:
                # AvanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao consultar prÃ³ximo horÃ¡rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horÃ¡rio disponÃ­vel encontrado na consulta apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horÃ¡rio UTC para uma string legÃ­vel no fuso horÃ¡rio local."""
    if not horario_utc:
        return "IndisponÃ­vel"
    try:
        # Precisa da biblioteca pytz para fusos horÃ¡rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (TerÃ§a-feira, 15 de Abril Ã s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B Ã s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz nÃ£o instalada. Usando formataÃ§Ã£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horÃ¡rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formataÃ§Ã£o"
def consultar_horario():
    return "amanhÃ£ Ã s 10h"



==== /home/ubuntu/famdomes_backend/app/utils/ia_fallback.py ====
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta



==== /home/ubuntu/famdomes_backend/app/utils/followup.py ====
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a funÃ§Ã£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a funÃ§Ã£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # NÃ£o precisa mais buscar aqui, usa agenda.py
    logging.info("ConexÃ£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- FunÃ§Ãµes de SimulaÃ§Ã£o (Removidas ou SubstituÃ­das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> LÃ³gica estÃ¡ em agenda.py
# avisar_profissional -> Deveria ser chamado apÃ³s agendamento real
# avisar_paciente -> Deveria ser chamado apÃ³s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o inÃ­cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel iniciar sessÃ£o de pagamento: Sem conexÃ£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃƒO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao iniciar sessÃ£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessÃ£o como paga, agenda a consulta e retorna o horÃ¡rio agendado e nome.
    Esta funÃ§Ã£o Ã© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel marcar pagamento: Sem conexÃ£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que sÃ³ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualizaÃ§Ã£o se nÃ£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, entÃ£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome jÃ¡ estÃ¡ lÃ¡ do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessÃ£o ser criada, ou se jÃ¡ foi processado
            logging.warning(f"SessÃ£o de pagamento nÃ£o encontrada ou jÃ¡ processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessÃ£o
        logging.info(f"[SESSÃƒO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessÃ£o com o horÃ¡rio agendado (opcional, mas Ãºtil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessÃ£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possÃ­vel notificaÃ§Ã£o manual

    except Exception as e:
        logging.error(f"âŒ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# FunÃ§Ã£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # LÃ³gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo nÃºmero real ou lÃ³gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"ğŸ‘¨â€âš•ï¸ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) Ã s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("NÃºmero do mÃ©dico nÃ£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# FunÃ§Ã£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessÃµes com pagamento pendente hÃ¡ muito tempo."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel checar followup: Sem conexÃ£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "vocÃª")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"OlÃ¡ {nome}, notei que vocÃª iniciou um agendamento mas parece que nÃ£o foi concluÃ­do. ğŸ˜¥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dÃºvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. ğŸ˜Š"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessÃ£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"âŒ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # FunÃ§Ã£o ainda nÃ£o implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0




==== /home/ubuntu/famdomes_backend/app/schemas/ia_comando.py ====
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str



==== /home/ubuntu/famdomes_backend/app/intents/router_intents.py ====
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigatÃ³rios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }


==== /home/ubuntu/famdomes_backend/app/intents/__init__.py ====



==== /home/ubuntu/famdomes_backend/app/intents/intent_executor.py ====
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_proximo_horario_disponivel as consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o mÃ³dulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que nÃ£o Ã© fÃ¡cil buscar ajuda.\n\n"
    "ğŸ¤ Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "ğŸ“² Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "tÃ´ aqui pra isso", "pode falar", "Ã© isso", "ok", "tÃ¡", "tÃ¡ bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "nÃ£o", "nao", "talvez depois", "nÃ£o agora", "deixa pra depois",
    "tÃ´ sÃ³ olhando", "sÃ³ pesquisando", "agora nÃ£o"
]

# Limiar de confianÃ§a para a intent (ajuste conforme necessÃ¡rio)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui Ã© o|aqui Ã© a|meu nome Ã©|me chamo Ã©)\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)",
        r"nome Ã©\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confianÃ§a alta

    def detectar_intent(self):
        # LÃ³gica de detecÃ§Ã£o de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confianÃ§a para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que vocÃª precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "ğŸ”„ HistÃ³rico de testes apagado com sucesso. Pode comeÃ§ar uma nova simulaÃ§Ã£o.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "olÃ¡", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confianÃ§a na confirmaÃ§Ã£o
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # MÃ©dia confianÃ§a em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # INÃCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"ğŸ“… Ã“timo! Posso te ajudar a agendar com nosso mÃ©dico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"ğŸ“† O prÃ³ximo horÃ¡rio disponÃ­vel Ã©: {consultar_horario()}. Posso reservar pra vocÃª?",

        # VALORES
        "duvida_valores": "ğŸ’° Temos valores acessÃ­veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIANÃ‡A
        "duvida_geral": "ğŸ“‹ Nosso sistema conecta vocÃª com mÃ©dicos especialistas de verdade. Quer saber como funciona na prÃ¡tica?",
        "desconfianca": "ğŸ” Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPENDÃŠNCIA / RECAÃDA / SINTOMAS
        "duvida_dependencia": "ğŸ§  A dependÃªncia quÃ­mica Ã© tratÃ¡vel. Nosso mÃ©dico pode avaliar sintomas fÃ­sicos e emocionais. Quer agendar?",
        "sou_dependente": "ğŸ’¬ Reconhecer isso Ã© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "ğŸ” RecaÃ­das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "ğŸ˜“ Os sintomas de abstinÃªncia sÃ£o desafiadores. Podemos te orientar com seguranÃ§a. Posso marcar agora?",

        # CRISE / URGÃŠNCIA
        "sintomas_graves": "âš ï¸ Sinais de crise detectados. Posso encaminhar vocÃª para um atendimento urgente. Deseja ajuda agora?",
        "ameaÃ§a_vida": "ğŸš¨ Sua vida importa. Posso ativar nosso acolhimento de urgÃªncia. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "ğŸ‘ª VocÃª quer ajudar alguÃ©m importante. Posso te explicar como funciona e agendar uma escuta para vocÃª ou para ele(a).",
        "familia_pedindo_ajuda": "ğŸ§­ VocÃª estÃ¡ no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "ğŸš¨ SituaÃ§Ã£o familiar crÃ­tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "ğŸ˜” Ã‰ difÃ­cil quando a famÃ­lia nÃ£o apoia. Mas hÃ¡ caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "ğŸ’” Muitas famÃ­lias passam por isso. Podemos ajudar na reconstruÃ§Ã£o. Quer agendar uma orientaÃ§Ã£o especializada?",
        "familiar_violento": "âš ï¸ Em casos de violÃªncia, seguranÃ§a vem primeiro. Posso te mostrar como agir com respaldo mÃ©dico e legal.",

        # INTERNAÃ‡ÃƒO
        "duvida_internacao": "ğŸ¥ A internaÃ§Ã£o pode ser voluntÃ¡ria ou involuntÃ¡ria, sempre com avaliaÃ§Ã£o mÃ©dica. Quer saber como isso funciona?",
        "quero_internar": "âœ… Posso te mostrar o processo completo, legal e clÃ­nico. Posso agendar agora com nosso mÃ©dico?",

        # FUNIL / OBJECÃ•ES / CIRCUNSTÃ‚NCIAS
        "nao_quero_internar": "Tudo bem. InternaÃ§Ã£o nÃ£o Ã© a Ãºnica saÃ­da. Posso te explicar outras opÃ§Ãµes com orientaÃ§Ã£o mÃ©dica.",
        "meu_parente_usa_droga": "ğŸ’¬ Entendo. Posso agendar com o especialista pra avaliar a situaÃ§Ã£o de forma profissional.",
        "crise_agora": "âš ï¸ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "ğŸ’¡ Obrigado por compartilhar. Posso te ajudar com os prÃ³ximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "ğŸ˜” A resistÃªncia Ã© comum. Mesmo assim, a famÃ­lia pode iniciar a aÃ§Ã£o. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "ğŸ‘¥ Se a famÃ­lia nÃ£o colabora, podemos trabalhar com quem estiver disponÃ­vel. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "ğŸ‘ Tranquilo. Se quiser ajudar alguÃ©m ou tirar dÃºvidas, posso te explicar tudo com calma.",

        # INFORMAÃ‡Ã•ES COMPLEMENTARES
        "quero_entender": "ğŸ“˜ Posso te explicar tudo sobre o atendimento, desde a escuta atÃ© o tratamento. Quer comeÃ§ar agora?",
        "curioso": "ğŸ˜„ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulaÃ§Ã£o real?",
        "pergunta_medico": "ğŸ‘¨â€âš•ï¸ O mÃ©dico Ã© especialista em dependÃªncia quÃ­mica e avaliaÃ§Ã£o clÃ­nica. Quer agendar a escuta?",
        "duvida_medicacao": "ğŸ’Š Medicamentos sÃ³ sÃ£o indicados apÃ³s avaliaÃ§Ã£o. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "ğŸ§  Temos psicÃ³logos na equipe. A avaliaÃ§Ã£o inicial Ã© mÃ©dica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "ğŸ” RecomeÃ§ar Ã© possÃ­vel. Estamos aqui pra isso. Quer conversar com o mÃ©dico novamente?",
        "vergonha_de_falar": "ğŸ§¡ Tudo bem. NÃ£o precisa se explicar agora. Posso sÃ³ ouvir, se quiser.",
        "culpa_familiar": "ğŸ¤ A culpa nÃ£o ajuda, mas o cuidado sim. Posso te mostrar como comeÃ§ar com leveza.",
        "busca_ajuda_emocional": "ğŸ’¬ TambÃ©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "ğŸ› Respeitamos todas as crenÃ§as. O acolhimento Ã© humano, com base Ã©tica. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "âš–ï¸ A internaÃ§Ã£o judicial Ã© possÃ­vel. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "ğŸ‘¶ Tratamos casos de menores com responsabilidade. Posso te mostrar os critÃ©rios e caminhos.",
        "direitos_paciente": "ğŸ“œ Tudo Ã© feito conforme a Ã©tica mÃ©dica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "ğŸ“ Temos atendimento online e unidades fÃ­sicas. Quer saber se tem perto de vocÃª?",
        "duvida_profissionais": "ğŸ‘©â€âš•ï¸ Temos mÃ©dicos, terapeutas e psicÃ³logos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "ğŸ”’ Todo atendimento Ã© sigiloso. Nada Ã© compartilhado sem sua autorizaÃ§Ã£o. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"âœ… Consulta cancelada. Se quiser retomar, Ã© sÃ³ me avisar.",
        "teste": "ğŸ§ª EstÃ¡ testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "â¤ï¸ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prÃ¡tica.",
        "erro": "ğŸ” Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "ğŸ¤” NÃ£o entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "ğŸ‘ Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugestÃµes de prÃ³ximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou vocÃª gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou vocÃª tem alguma outra dÃºvida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou vocÃª gostaria de agendar uma consulta?",
            "sou_dependente": "\nVocÃª gostaria de agendar uma consulta ou precisa de mais informaÃ§Ãµes?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVocÃª gostaria de agendar uma consulta para vocÃª ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de internaÃ§Ã£o ou vocÃª gostaria de saber as opÃ§Ãµes de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se vocÃª reformular a pergunta ou gostaria de ver as opÃ§Ãµes de ajuda disponÃ­veis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padrÃ£o
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta


==== /home/ubuntu/famdomes_backend/app/intents/intents_map.py ====
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # ğŸš€ INÃCIO DO FUNIL
    "boas_vindas": [
        "oi", "olÃ¡", "ola", "bom dia", "boa tarde", "boa noite", "e aÃ­", "fala comigo", "tudo bem", "como vai"
    ],

    # ğŸ‘¤ QUERO AGENDAR / HORÃRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um mÃ©dico", "consulta urgente", "quero ajuda mÃ©dica",
        "agendar", "marcar consulta", "atendimento mÃ©dico", "agendar consulta"
    ],
    "ver_horario": [
        "tem horÃ¡rio", "que horas tem", "tem agenda", "qual o prÃ³ximo horÃ¡rio", "quero saber os horÃ¡rios",
        "horÃ¡rios disponÃ­veis", "agenda livre", "consultar horÃ¡rio", "ver agenda"
    ],

    # ğŸ’° VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "preÃ§o", "tem plano", "Ã© caro", "valores da consulta", "paga quanto", "Ã© gratuito?",
        "aceita convÃªnio", "plano de saÃºde", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # â“ DÃšVIDAS GERAIS / CONFIANÃ‡A
    "duvida_geral": [
        "como funciona", "me explica", "o que vocÃªs fazem", "isso Ã© pra quÃª", "como ajudam", "qual o tratamento",
        "o que Ã© isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso Ã© real?", "posso confiar?", "Ã© golpe?", "tem CNPJ?", "quem sÃ£o vocÃªs?", "Ã© confiÃ¡vel?", "funciona mesmo?",
        "Ã© seguro?", "garantia", "Ã© empresa?"
    ],

    # ğŸ“š SOBRE DEPENDÃŠNCIA / VÃCIO
    "duvida_dependencia": [
        "o que Ã© dependÃªncia quÃ­mica", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "vÃ­cio em drogas", "meu caso tem jeito", "isso Ã© doenÃ§a?", "uso mas nÃ£o sou viciado", "tem tratamento",
        "dependÃªncia", "vÃ­cio", "drogas", "alcoolismo", "sintomas de vÃ­cio"
    ],
    "sou_dependente": [
        "sou viciado", "tenho vÃ­cio", "sou dependente quÃ­mico", "tenho problema com droga", "uso todo dia",
        "nÃ£o consigo parar", "preciso parar de usar", "sou alcoÃ³latra", "viciado"
    ],
    "recaida": [
        "tive recaÃ­da", "usei de novo", "nÃ£o consegui parar", "recomecei", "caÃ­ de novo",
        "recaÃ­", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "tÃ´ tremendo", "tÃ´ suando", "nÃ£o tÃ´ bem", "tÃ´ em abstinÃªncia", "tÃ´ agoniado", "tÃ´ passando mal sem usar",
        "sintomas de abstinÃªncia", "fissura", "crise de abstinÃªncia"
    ],

    # ğŸ§  SINTOMAS GRAVES / CRISE / URGÃŠNCIA
    "sintomas_graves": [
        "tÃ¡ surtando", "alucinaÃ§Ã£o", "tÃ¡ agressivo", "nÃ£o dorme hÃ¡ dias", "visÃµes", "delÃ­rio", "tÃ¡ em crise",
        "descontrolado", "sem noÃ§Ã£o do que faz", "paranoia", "confusÃ£o mental", "surto psicÃ³tico"
    ],
    "ameaÃ§a_vida": [ # Risco de suicÃ­dio/auto-mutilaÃ§Ã£o
        "quero morrer", "vou me matar", "nÃ£o quero viver", "quero sumir", "vou acabar com tudo", "vida nÃ£o faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # EmergÃªncia mÃ©dica clara
        "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
        "desmaiado", "convulsÃ£o", "sangrando muito", "veneno", "infarto", "avc", "emergÃªncia"
    ],


    # ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou mÃ£e", "sou pai", "sou esposa", "sou marido", "sou irmÃ£o", "sou irmÃ£", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho tÃ¡ viciado", "minha filha tÃ¡ usando", "meu marido nÃ£o aceita ajuda", "ele nÃ£o quer se tratar",
        "nÃ£o sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela tÃ¡ gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "tÃ¡ se machucando", "tÃ¡ em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele nÃ£o quer ajuda", "ela nÃ£o aceita", "nÃ£o quer tratamento", "nÃ£o admite que tem problema",
        "nÃ£o quer ser internado", "nÃ£o aceita mÃ©dico", "resiste ao tratamento"
    ],

    # ğŸ¥ INTERNAÃ‡ÃƒO
    "duvida_internacao": [
        "como funciona a internaÃ§Ã£o", "quanto tempo dura", "volta pra casa depois?", "como Ã© o lugar",
        "tem visita?", "fica trancado?", "internaÃ§Ã£o involuntÃ¡ria", "Ã© forÃ§ado?", "tem psiquiatra?",
        "internaÃ§Ã£o", "clÃ­nica de recuperaÃ§Ã£o", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como faÃ§o pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "internaÃ§Ã£o compulsÃ³ria", "internaÃ§Ã£o involuntÃ¡ria"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa nÃ£o querer internaÃ§Ã£o
        "nÃ£o quero internar", "sem internaÃ§Ã£o", "tratamento sem internar", "nÃ£o precisa de clÃ­nica",
        "alternativa Ã  internaÃ§Ã£o", "tratamento ambulatorial"
    ],

    # âš–ï¸ QUESTÃ•ES LEGAIS / JURÃDICAS
    "internacao_judicial": [
        "posso pedir pra justiÃ§a?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "internaÃ§Ã£o compulsÃ³ria", "justiÃ§a", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho Ã© menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "crianÃ§a"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele Ã© obrigado?", "isso Ã© legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # ğŸ’¬ OUTRAS SITUAÃ‡Ã•ES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # UsuÃ¡rio falando sobre seu prÃ³prio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida tÃ¡ destruÃ­da",
        "preciso de ajuda com meu vÃ­cio"
    ],
     "resistencia_familiar": [ # Paciente relata que a famÃ­lia nÃ£o apoia/atrapalha
        "minha famÃ­lia nÃ£o me apoia", "minha esposa nÃ£o entende", "meus pais nÃ£o aceitam",
        "famÃ­lia contra o tratamento", "nÃ£o tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que nÃ£o Ã© o paciente
        "nÃ£o sou eu que uso", "Ã© para um amigo", "sÃ³ estou pesquisando", "quero informaÃ§Ã£o para outra pessoa",
        "nÃ£o sou usuÃ¡rio"
    ],

    # â„¹ï¸ BUSCA DE INFORMAÃ‡Ã•ES ADICIONAIS
     "quero_entender": [ # Pedido explÃ­cito para entender o serviÃ§o/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # DemonstraÃ§Ã£o de curiosidade ou teste
        "sÃ³ testando", "kkk", "haha", "curioso", "testando sistema", "sÃ³ vendo como funciona",
        "teste", "simulaÃ§Ã£o"
    ],
    "pergunta_medico": [ # DÃºvida especÃ­fica sobre o profissional mÃ©dico
        "quem Ã© o mÃ©dico?", "qual a especialidade?", "Ã© psiquiatra?", "posso escolher o mÃ©dico?",
        "falar com o mÃ©dico"
    ],
     "duvida_medicacao": [ # DÃºvida sobre remÃ©dios
        "vai precisar de remÃ©dio?", "usam medicaÃ§Ã£o?", "quais remÃ©dios?", "tratamento com remÃ©dio",
        "medicaÃ§Ã£o psiquiÃ¡trica"
    ],
     "duvida_psicologo": [ # DÃºvida sobre psicÃ³logo/terapia
        "tem psicÃ³logo?", "faz terapia?", "atendimento psicolÃ³gico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # DÃºvida sobre local fÃ­sico/online
        "onde fica?", "tem na minha cidade?", "qual o endereÃ§o?", "atende onde?", "Ã© presencial ou online?",
        "atendimento online", "unidade fÃ­sica", "endereÃ§o da clÃ­nica"
    ],
     "duvida_profissionais": [ # DÃºvida geral sobre a equipe
        "quem sÃ£o os profissionais?", "tem terapeuta?", "quem atende?", "Ã© sÃ³ mÃ©dico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # DÃºvida sobre confidencialidade
        "isso Ã© sigiloso?", "meus dados estÃ£o protegidos?", "alguÃ©m vai saber?", "Ã© confidencial?",
        "privacidade", "segredo mÃ©dico"
    ],


    # â¤ï¸ INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # JÃ¡ tentou tratamento antes e parou
        "jÃ¡ tentei parar antes", "desisti do tratamento", "nÃ£o funcionou da outra vez",
        "jÃ¡ fiz tratamento e nÃ£o adiantou", "recomeÃ§ar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ninguÃ©m", "Ã© difÃ­cil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que Ã© culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "tÃ´ mal", "tÃ´ triste", "ansiedade", "crise de pÃ¢nico", "sou depressivo", "tÃ´ vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # QuestÃµes sobre religiÃ£o/espiritualidade
        "Ã© contra religiÃ£o?", "tem algo espiritual?", "sou evangÃ©lico", "sou catÃ³lico", "tem apoio religioso?",
        "minha fÃ©", "igreja"
    ],

    # ğŸ›‘ CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar aÃ§Ã£o atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "nÃ£o quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "nÃ£o posso ir"
    ],
    "confirmacao_positiva": [ # ConfirmaÃ§Ã£o genÃ©rica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "tÃ¡", "tÃ¡ bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # NegaÃ§Ã£o genÃ©rica (nÃ£o, agora nÃ£o)
        "nÃ£o", "nao", "talvez depois", "nÃ£o agora", "deixa pra depois", "agora nÃ£o", "nÃ£o quero", "nÃ£o obrigado"
    ],
    "elogio": [
        "Ã³timo atendimento", "gostei muito", "vocÃªs sÃ£o bons", "obrigado", "atendimento top", "amei",
        "parabÃ©ns", "muito bom", "excelente"
    ],
    "erro": [ # UsuÃ¡rio reporta um erro tÃ©cnico
        "link nÃ£o abre", "deu erro", "nÃ£o consegui pagar", "o site caiu", "nÃ£o carrega",
        "problema tÃ©cnico", "nÃ£o funciona", "bug"
    ],
    "sem_compreensao": [ # Bot nÃ£o entendeu ou mensagem ininteligÃ­vel
        "asdfgh", "oiaueia", "????", "nÃ£o entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "nÃ£o faz sentido"
    ],

    # Adicione intents mais especÃ­ficas conforme necessÃ¡rio
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}


==== /home/ubuntu/famdomes_backend/app/routes/pagamentos.py ====
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}



==== /home/ubuntu/famdomes_backend/app/routes/painel.py ====
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessÃ£o estÃ¡ confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}



==== /home/ubuntu/famdomes_backend/app/routes/stripe.py ====
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # ğŸ§  Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # ğŸ§  Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}



==== /home/ubuntu/famdomes_backend/app/routes/rocketchat.py ====
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda nÃ£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }



==== /home/ubuntu/famdomes_backend/app/routes/agendamento.py ====
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}




==== /home/ubuntu/famdomes_backend/app/routes/whatsapp.py ====
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("âš ï¸ Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # ğŸš¨ Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"âš ï¸ Alerta FAMDOMES: DetecÃ§Ã£o de risco na conversa com {telefone}. "
                f"Mensagem: â€œ{mensagem}â€. Um profissional serÃ¡ alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("âŒ ERRO no webhook:", str(e))
        return {"erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/routes/ia_comandos.py ====
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"âœ… Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando nÃ£o reconhecido.")



==== /home/ubuntu/famdomes_backend/app/routes/ia.py ====
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# âœ… FunÃ§Ã£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"âœ… Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "âŒ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "âœ… Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in comando or "disponÃ­vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ğŸ¤– Desculpe, nÃ£o entendi o que vocÃª deseja. VocÃª pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horÃ¡rio disponÃ­vel")
        return {"status": "comando_desconhecido"}



==== /home/ubuntu/famdomes_backend/app/routes/followup.py ====
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}



==== /home/ubuntu/famdomes_backend/app/main.py ====
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("ğŸ“¥ Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas pÃºblicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # ValidaÃ§Ã£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)



==== /home/ubuntu/famdomes_backend/app/models/pagamentos.py ====
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str



==== /home/ubuntu/famdomes_backend/app/models/intents.py ====
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horÃ¡rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horÃ¡rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "jÃ¡ paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que vocÃª faz",
        "me ajuda",
        "como vocÃª pode me ajudar"
    ]
}



==== /home/ubuntu/famdomes_backend/app/models/atendimento.py ====
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str



==== /home/ubuntu/famdomes_backend/app/config.py ====
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")



==== /home/ubuntu/famdomes_backend/app/nlu/response_generator.py ====
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que nÃ£o Ã© fÃ¡cil buscar ajuda.\n\n"
    "ğŸ¤ Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "ğŸ“² Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÃCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"ğŸ“… Ã“timo! Posso te ajudar a agendar com nosso mÃ©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"ğŸ“† O prÃ³ximo horÃ¡rio disponÃ­vel Ã©: {consultar_horario()}. Posso reservar pra vocÃª?",

    # VALORES
    "duvida_valores": "ğŸ’° Temos valores acessÃ­veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÃ‡A
    "duvida_geral": "ğŸ“‹ Nosso sistema conecta vocÃª com mÃ©dicos especialistas de verdade. Quer saber como funciona na prÃ¡tica?",
    "desconfianca": "ğŸ” Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÃŠNCIA / RECAÃDA / SINTOMAS
    "duvida_dependencia": "ğŸ§  A dependÃªncia quÃ­mica Ã© tratÃ¡vel. Nosso mÃ©dico pode avaliar sintomas fÃ­sicos e emocionais. Quer agendar?",
    "sou_dependente": "ğŸ’¬ Reconhecer isso Ã© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "ğŸ” RecaÃ­das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "ğŸ˜“ Os sintomas de abstinÃªncia sÃ£o desafiadores. Podemos te orientar com seguranÃ§a. Posso marcar agora?",

    # CRISE / URGÃŠNCIA
    "sintomas_graves": "âš ï¸ Sinais de crise detectados. Posso encaminhar vocÃª para um atendimento urgente. Deseja ajuda agora?",
    "ameaÃ§a_vida": "ğŸš¨ Sua vida importa. Posso ativar nosso acolhimento de urgÃªncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "ğŸ‘ª VocÃª quer ajudar alguÃ©m importante. Posso te explicar como funciona e agendar uma escuta para vocÃª ou para ele(a).",
    "familia_pedindo_ajuda": "ğŸ§­ VocÃª estÃ¡ no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "ğŸš¨ SituaÃ§Ã£o familiar crÃ­tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "ğŸ˜” Ã‰ difÃ­cil quando a famÃ­lia nÃ£o apoia. Mas hÃ¡ caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "ğŸ’” Muitas famÃ­lias passam por isso. Podemos ajudar na reconstruÃ§Ã£o. Quer agendar uma orientaÃ§Ã£o especializada?",
    "familiar_violento": "âš ï¸ Em casos de violÃªncia, seguranÃ§a vem primeiro. Posso te mostrar como agir com respaldo mÃ©dico e legal.",

    # INTERNAÃ‡ÃƒO
    "duvida_internacao": "ğŸ¥ A internaÃ§Ã£o pode ser voluntÃ¡ria ou involuntÃ¡ria, sempre com avaliaÃ§Ã£o mÃ©dica. Quer saber como isso funciona?",
    "quero_internar": "âœ… Posso te mostrar o processo completo, legal e clÃ­nico. Posso agendar agora com nosso mÃ©dico?",

    # FUNIL / OBJECÃ•ES / CIRCUNSTÃ‚NCIAS
    "nao_quero_internar": "Tudo bem. InternaÃ§Ã£o nÃ£o Ã© a Ãºnica saÃ­da. Posso te explicar outras opÃ§Ãµes com orientaÃ§Ã£o mÃ©dica.",
    "meu_parente_usa_droga": "ğŸ’¬ Entendo. Posso agendar com o especialista pra avaliar a situaÃ§Ã£o de forma profissional.",
    "crise_agora": "âš ï¸ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "ğŸ’¡ Obrigado por compartilhar. Posso te ajudar com os prÃ³ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "ğŸ˜” A resistÃªncia Ã© comum. Mesmo assim, a famÃ­lia pode iniciar a aÃ§Ã£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "ğŸ‘¥ Se a famÃ­lia nÃ£o colabora, podemos trabalhar com quem estiver disponÃ­vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "ğŸ‘ Tranquilo. Se quiser ajudar alguÃ©m ou tirar dÃºvidas, posso te explicar tudo com calma.",

    # INFORMAÃ‡Ã•ES COMPLEMENTARES
    "quero_entender": "ğŸ“˜ Posso te explicar tudo sobre o atendimento, desde a escuta atÃ© o tratamento. Quer comeÃ§ar agora?",
    "curioso": "ğŸ˜„ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulaÃ§Ã£o real?",
    "pergunta_medico": "ğŸ‘¨â€âš•ï¸ O mÃ©dico Ã© especialista em dependÃªncia quÃ­mica e avaliaÃ§Ã£o clÃ­nica. Quer agendar a escuta?",
    "duvida_medicacao": "ğŸ’Š Medicamentos sÃ³ sÃ£o indicados apÃ³s avaliaÃ§Ã£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "ğŸ§  Temos psicÃ³logos na equipe. A avaliaÃ§Ã£o inicial Ã© mÃ©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "ğŸ” RecomeÃ§ar Ã© possÃ­vel. Estamos aqui pra isso. Quer conversar com o mÃ©dico novamente?",
    "vergonha_de_falar": "ğŸ§¡ Tudo bem. NÃ£o precisa se explicar agora. Posso sÃ³ ouvir, se quiser.",
    "culpa_familiar": "ğŸ¤ A culpa nÃ£o ajuda, mas o cuidado sim. Posso te mostrar como comeÃ§ar com leveza.",
    "busca_ajuda_emocional": "ğŸ’¬ TambÃ©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "ğŸ› Respeitamos todas as crenÃ§as. O acolhimento Ã© humano, com base Ã©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "âš–ï¸ A internaÃ§Ã£o judicial Ã© possÃ­vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "ğŸ‘¶ Tratamos casos de menores com responsabilidade. Posso te mostrar os critÃ©rios e caminhos.",
    "direitos_paciente": "ğŸ“œ Tudo Ã© feito conforme a Ã©tica mÃ©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "ğŸ“ Temos atendimento online e unidades fÃ­sicas. Quer saber se tem perto de vocÃª?",
    "duvida_profissionais": "ğŸ‘©â€âš•ï¸ Temos mÃ©dicos, terapeutas e psicÃ³logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "ğŸ”’ Todo atendimento Ã© sigiloso. Nada Ã© compartilhado sem sua autorizaÃ§Ã£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "âœ… Consulta cancelada. Se quiser retomar, Ã© sÃ³ me avisar.",
    "teste": "ğŸ§ª EstÃ¡ testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "â¤ï¸ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prÃ¡tica.",
    "erro": "ğŸ” Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ğŸ¤” NÃ£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "ğŸ‘ Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrÃ£o se intent for reconhecida mas sem frase especÃ­fica
        return respostas.get(intent, "TÃ´ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")



==== /home/ubuntu/famdomes_backend/app/nlu/chatbot_router.py ====
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "tÃ´ aqui pra isso", "pode falar", "Ã© isso", "ok", "tÃ¡", "tÃ¡ bom",
    "isso", "por favor", "sim quero", "tÃ´ dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "ğŸ”„ HistÃ³rico apagado. Pode comeÃ§ar de novo.", "risco": False}

        # ClassificaÃ§Ã£o de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se hÃ¡ contexto anterior de confirmaÃ§Ã£o pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no histÃ³rico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"âš ï¸ Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()



==== /home/ubuntu/famdomes_backend/app/nlu/nlu_classifier.py ====
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparaÃ§Ã£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuaÃ§Ãµes bÃ¡sicas (exceto espaÃ§os) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaÃ§os extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML nÃ£o encontrados. Usando classificaÃ§Ã£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presenÃ§a de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # ConfianÃ§a base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho estÃ¡ contido no texto
                # Usar `in` Ã© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # LÃ³gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confianÃ§a para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- ClassificaÃ§Ã£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML prÃ©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # NÃ£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, ConfianÃ§a={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificaÃ§Ã£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confianÃ§a.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML nÃ£o estiver ativo ou como mÃ©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- MÃ©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF Ã© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parÃ¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes Ã© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------


==== /home/ubuntu/famdomes_backend/app/nlu/entidade_extractor.py ====
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)",
                r"([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)\s+(?:Ã© meu nome|meu nome Ã©|aqui Ã©)" # Novo padrÃ£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)\s+(?:Ã© meu|minha)" # Novo padrÃ£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)",
                r"(?:cidade de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)" # Novo padrÃ£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrÃ£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaÃ­na)"
            ],
            "recaida": [
                r"(reca[Ã­i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[Ã­i]da|escorregada)" # Novo padrÃ£o
            ],
            # Adicione mais entidades e padrÃµes conforme necessÃ¡rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraÃ­da: {entidades[entidade]} (PadrÃ£o: '{padrao}')")
                    break  # Para na primeira correspondÃªncia

        return entidades


# ConteÃºdo do arquivo: ./utils/faq_respostas.py
FAQ_RESPOSTAS = {
    "dependencia_quimica": (
        "DependÃªncia quÃ­mica Ã© uma doenÃ§a crÃ´nica caracterizada pelo uso compulsivo de substÃ¢ncias, "
        "apesar das consequÃªncias negativas, afetando o cÃ©rebro e o comportamento."
    ),
    "identificar_dependencia": (
        "Sinais incluem uso constante da substÃ¢ncia, dificuldade em parar, negligÃªncia nas responsabilidades, "
        "mudanÃ§as bruscas de comportamento e sintomas de abstinÃªncia."
    ),
    "tipos_internacao": (
        "Existem trÃªs tipos principais de internaÃ§Ã£o: voluntÃ¡ria (com consentimento), involuntÃ¡ria "
        "(solicitada pela famÃ­lia) e compulsÃ³ria (por ordem judicial)."
    ),
    "como_funciona_tratamento": (
        "O tratamento em clÃ­nica inclui desintoxicaÃ§Ã£o supervisionada, terapias individuais e em grupo, "
        "atividades terapÃªuticas e acompanhamento mÃ©dico constante."
    ),
    "duracao_tratamento": (
        "Normalmente, o tratamento dura entre 3 e 6 meses, podendo variar de acordo com a situaÃ§Ã£o especÃ­fica."
    ),
    "custo_tratamento": (
        "Os valores variam dependendo dos serviÃ§os e acomodaÃ§Ãµes. Para detalhes exatos, podemos agendar uma avaliaÃ§Ã£o."
    ),
    "recusa_ajuda": (
        "Se a pessoa nÃ£o aceita ajuda voluntariamente, pode ser considerado o processo de internaÃ§Ã£o involuntÃ¡ria "
        "com suporte legal e mÃ©dico especializado."
    ),
    "apoio_familiar": (
        "FamÃ­lias podem ajudar oferecendo suporte emocional, participando das terapias familiares e estabelecendo limites claros."
    ),
    "sobre_caps": (
        "O CAPS Ã© um Centro de AtenÃ§Ã£o Psicossocial que oferece tratamento especializado em saÃºde mental e dependÃªncia quÃ­mica."
    ),
    "como_agendar": (
        "VocÃª pode agendar facilmente uma consulta entrando em contato conosco pelo WhatsApp ou pelo nosso site oficial."
    ),
}

# ConteÃºdo do arquivo: ./utils/ollama.py
import httpx
import logging
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt,
        "stream": False
    }
    headers = {"Content-Type": "application/json"}
    try:
        async with httpx.AsyncClient(timeout=60.0) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_API_URL}/{OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            response.raise_for_status()
            dados = response.json()
            logging.info("âœ… Resposta recebida da IA (OLLAMA).")
            resposta_bruta = dados.get("response", "âš ï¸ Erro interno na IA.")
            # Aqui vocÃª pode fazer qualquer limpeza necessÃ¡ria na resposta
            tokens = []  # Se houver tokens, adicione-os
            return resposta_bruta, tokens
    except httpx.TimeoutException as e:
        logging.error(f"âŒ Erro: Timeout ({str(e)})")
        return "âš ï¸ Desculpe, demorei muito para pensar. Tente novamente.", []
    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ Erro: HTTP {e.response.status_code} - {e.response.text}")
        return f"âš ï¸ Ocorreu um erro interno ({e.response.status_code}). Por favor, tente mais tarde.", []
    except Exception as e:
        logging.exception("âŒ Erro desconhecido ao chamar Ollama:")
        return "âš ï¸ Erro inesperado. Tente novamente mais tarde.", []

# ConteÃºdo do arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura â€“ certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"âŒ ERRO ao carregar prompt mestre: {e}")
        return (
            "VocÃª Ã© um assistente virtual especializado em saÃºde mental e dependÃªncia quÃ­mica. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"UsuÃ¡rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"âŒ ERRO ao buscar histÃ³rico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histÃ³rico."
    else:
        trecho_historico = "HistÃ³rico indisponÃ­vel (sem conexÃ£o DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
HistÃ³rico da Conversa:
{trecho_historico}
---
Nova Mensagem do UsuÃ¡rio:
{pergunta_atual.strip()}
---
InstruÃ§Ãµes para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no mÃ¡ximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construÃ­do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# ConteÃºdo do arquivo: ./utils/mensageria.py
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("âš ï¸ Tentativa de enviar mensagem vazia ou sem destinatÃ¡rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url Ã© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razoÃ¡vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"âœ… Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome PadrÃ£o ClÃ­nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "SatisfaÃ§Ã£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com botÃ£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de botÃ£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # Ãndice do botÃ£o no template
                    # "parameters": [] # ParÃ¢metros especÃ­ficos do botÃ£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"âœ… Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"âŒ ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"âŒ ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"âŒ ERRO de ConexÃ£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"âŒ ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
# ConteÃºdo do arquivo: ./utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    contextos_db = db["contexto_conversa"]
    logging.info("ConexÃ£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    if contextos_db is None:
        logging.error(f"NÃ£o foi possÃ­vel salvar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto invÃ¡lido.")
        return False
    try:
        contextos_db.update_one(
            {"telefone": telefone},
            {"$set": dados_atualizacao, "$currentDate": {"ultima_atualizacao": True},
             "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()}},
            upsert=True
        )
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    if contextos_db is None:
        logging.error(f"NÃ£o foi possÃ­vel obter contexto para {telefone}: Sem conexÃ£o com DB.")
        return {}
    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}
    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto is not None:
            return contexto
        return {}
    except Exception as e:
        logging.error(f"âŒ ERRO ao obter contexto para {telefone}: {e}")
        return {}

def limpar_contexto(telefone: str):
    if contextos_db is None:
        logging.error(f"NÃ£o foi possÃ­vel limpar contexto para {telefone}: Sem conexÃ£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False
    try:
        result = contextos_db.delete_one({"telefone": telefone})
        return result.deleted_count > 0
    except Exception as e:
        logging.error(f"âŒ ERRO ao limpar contexto para {telefone}: {e}")
        return False

# ConteÃºdo do arquivo: ./utils/db.py
from datetime import datetime, timedelta

# Simula prÃ³xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula gravaÃ§Ã£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} Ã s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO MÃ‰DICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suicÃ­dio", "morrer", "nÃ£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

# ConteÃºdo do arquivo: ./utils/risco.py
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases crÃ­ticas (ajuste conforme necessÃ¡rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suicÃ­dio", "me matar", "quero morrer", "nÃ£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperanÃ§a", "adeus mundo", "nÃ£o quero viver",
    # Adicionar termos relacionados a auto-mutilaÃ§Ã£o se aplicÃ¡vel
    # Adicionar termos relacionados a ameaÃ§as a terceiros se aplicÃ¡vel
]

# Adicionar palavras/frases que indicam URGÃŠNCIA MÃ‰DICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
    "desmaiado", "convulsÃ£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emergÃªncias mÃ©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suicÃ­dio, urgÃªncia mÃ©dica).
    Retorna um dicionÃ¡rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"ğŸš¨ RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"ğŸš‘ URGÃŠNCIA MÃ‰DICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
# ConteÃºdo do arquivo: ./utils/agenda.py
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configuraÃ§Ã£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias Ãºteis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (nÃ£o agenda Ã s 18:00, Ãºltimo Ã© 17:40)

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar Ã­ndice para garantir que nÃ£o haja duas consultas no mesmo horÃ¡rio
    consultas_db.create_index("horario", unique=True)
    logging.info("ConexÃ£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """AvanÃ§a o horÃ¡rio para o prÃ³ximo bloco de X minutos dentro do horÃ¡rio de operaÃ§Ã£o."""
    horario = inicio_base

    # Arredonda para o prÃ³ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no inÃ­cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o horÃ¡rio de operaÃ§Ã£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (SÃ¡bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o prÃ³ximo horÃ¡rio livre e agenda a consulta.
    Retorna o datetime do horÃ¡rio agendado ou None se nÃ£o encontrar.
    """
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel agendar: Sem conexÃ£o com DB.")
        return None

    # Usar UTC para armazenamento no DB Ã© uma boa prÃ¡tica
    agora_utc = datetime.now(timezone.utc)
    # ComeÃ§a a procurar X minutos Ã  frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se jÃ¡ existe consulta nesse horÃ¡rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou horÃ¡rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o horÃ¡rio em UTC
            else:
                # HorÃ¡rio ocupado, avanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verificaÃ§Ã£o/inserÃ§Ã£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exceÃ§Ã£o

    logging.warning(f"NÃ£o foram encontrados horÃ¡rios disponÃ­veis para {telefone} apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se nÃ£o encontrar horÃ¡rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel cancelar: Sem conexÃ£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda nÃ£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"ğŸ—‘ï¸ Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"âŒ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o prÃ³ximo horÃ¡rio disponÃ­vel sem agendar."""
    if not consultas_db:
        logging.error("NÃ£o Ã© possÃ­vel consultar horÃ¡rio: Sem conexÃ£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # ComeÃ§a a procurar um pouco Ã  frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"PrÃ³ximo horÃ¡rio disponÃ­vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna horÃ¡rio em UTC
            else:
                # AvanÃ§a para o prÃ³ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"âŒ ERRO ao consultar prÃ³ximo horÃ¡rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum horÃ¡rio disponÃ­vel encontrado na consulta apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um horÃ¡rio UTC para uma string legÃ­vel no fuso horÃ¡rio local."""
    if not horario_utc:
        return "IndisponÃ­vel"
    try:
        # Precisa da biblioteca pytz para fusos horÃ¡rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (TerÃ§a-feira, 15 de Abril Ã s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B Ã s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz nÃ£o instalada. Usando formataÃ§Ã£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar horÃ¡rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formataÃ§Ã£o"
def consultar_horario():
    return "amanhÃ£ Ã s 10h"

# ConteÃºdo do arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# ConteÃºdo do arquivo: ./utils/followup.py
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a funÃ§Ã£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a funÃ§Ã£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: OperaÃ§Ãµes sÃ­ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # NÃ£o precisa mais buscar aqui, usa agenda.py
    logging.info("ConexÃ£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"âŒ ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- FunÃ§Ãµes de SimulaÃ§Ã£o (Removidas ou SubstituÃ­das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> LÃ³gica estÃ¡ em agenda.py
# avisar_profissional -> Deveria ser chamado apÃ³s agendamento real
# avisar_paciente -> Deveria ser chamado apÃ³s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o inÃ­cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel iniciar sessÃ£o de pagamento: Sem conexÃ£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESSÃƒO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"âŒ ERRO ao iniciar sessÃ£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sessÃ£o como paga, agenda a consulta e retorna o horÃ¡rio agendado e nome.
    Esta funÃ§Ã£o Ã© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel marcar pagamento: Sem conexÃ£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que sÃ³ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualizaÃ§Ã£o se nÃ£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, entÃ£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome jÃ¡ estÃ¡ lÃ¡ do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sessÃ£o ser criada, ou se jÃ¡ foi processado
            logging.warning(f"SessÃ£o de pagamento nÃ£o encontrada ou jÃ¡ processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sessÃ£o
        logging.info(f"[SESSÃƒO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sessÃ£o com o horÃ¡rio agendado (opcional, mas Ãºtil)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sessÃ£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para possÃ­vel notificaÃ§Ã£o manual

    except Exception as e:
        logging.error(f"âŒ ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# FunÃ§Ã£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # LÃ³gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo nÃºmero real ou lÃ³gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"ğŸ‘¨â€âš•ï¸ Nova consulta agendada: {nome_paciente} ({telefone_paciente}) Ã s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("NÃºmero do mÃ©dico nÃ£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# FunÃ§Ã£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sessÃµes com pagamento pendente hÃ¡ muito tempo."""
    if not sessoes_db:
        logging.error("NÃ£o Ã© possÃ­vel checar followup: Sem conexÃ£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "vocÃª")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"OlÃ¡ {nome}, notei que vocÃª iniciou um agendamento mas parece que nÃ£o foi concluÃ­do. ğŸ˜¥\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma dÃºvida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. ğŸ˜Š"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sessÃ£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"âŒ ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # FunÃ§Ã£o ainda nÃ£o implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0


# ConteÃºdo do arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# ConteÃºdo do arquivo: ./intents/intent_executor.py
import re
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.ia_fallback import chamar_ollama  # FunÃ§Ã£o que chama o Ollama
from app.utils.prompt_builder import construir_prompt
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.intents.intents_map import INTENTS
import logging
import unicodedata

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
historico = mongo["famdomes"]["respostas_ia"]
leads = mongo["famdomes"]["leads"]

MENSAGEM_INICIAL = "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Como posso ajudar vocÃª?"

# Respostas prÃ©-definidas â€“ ajuste conforme sua estratÃ©gia de atendimento e vendas
RESPOSTAS_PREDEFINIDAS = {
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": "ğŸ“… Ã“timo! Vou encaminhar o link para agendar sua consulta.",
    "cancelar": "âœ… Sua consulta foi cancelada. Estamos Ã  disposiÃ§Ã£o para retomar.",
    "duvida_geral": "ğŸ“‹ Nossa equipe estÃ¡ pronta para esclarecer suas dÃºvidas. Fale com a gente!",
    "venda": "ğŸ’° Temos planos especiais para vocÃª. Gostaria de conhecer nossos pacotes?"
}

RESPOSTAS_CONFIRMATIVAS = ["sim", "claro", "com certeza", "prossiga", "quero"]
RESPOSTAS_NEGATIVAS = ["nÃ£o", "nao", "deixa", "cancelar"]

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)
        self.intent_confianca = 1.0

    def detectar_intent(self):
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"
        if self.contexto.get("aguardando_confirmacao"):
            if any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_CONFIRMATIVAS):
                return self.contexto.get("intent_esperada", "confirmacao")
            elif any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_NEGATIVAS):
                return "cancelar"
        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if g.lower() in self.mensagem_normalizada:
                    return intent
        self.intent_confianca = 0.5
        return "desconhecida"

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        contexto_anterior = obter_contexto(self.telefone)
        ultima_intent = contexto_anterior.get("ultima_intent", "")

        # Se a Ãºltima interaÃ§Ã£o ofereceu agendamento e a resposta atual for positiva:
        if ultima_intent == "ofereceu_agendamento" and intent in ["boas_vindas", "desconhecida"]:
            resposta = (
                "ğŸ“… Excelente! A consulta Ã© feita com especialistas em dependÃªncia quÃ­mica e saÃºde mental, "
                "onde faremos uma avaliaÃ§Ã£o cuidadosa e criaremos um plano de tratamento personalizado para vocÃªs. "
                "Para confirmar e garantir seu atendimento, acesse agora este link: "
                "https://clinicamg.com.br/agendamento"
            )
            salvar_contexto(self.telefone, {"ultima_intent": "aguardando_pagamento"})
        
        elif intent in FAQ_RESPOSTAS:
            resposta = FAQ_RESPOSTAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        elif intent == "reset_manual":
            limpar_contexto(self.telefone)
            resposta = "ğŸ”„ HistÃ³rico apagado. Inicie novamente."

        elif intent in RESPOSTAS_PREDEFINIDAS:
            resposta = RESPOSTAS_PREDEFINIDAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        else:
            prompt_final = construir_prompt(self.telefone, self.mensagem)
            resposta, _ = await chamar_ollama(prompt_final, self.telefone)
            resposta = self.limpar_resposta(resposta)

            if "agendar" in resposta.lower() or "consulta" in resposta.lower():
                salvar_contexto(self.telefone, {"ultima_intent": "ofereceu_agendamento"})

        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

   
   
    def limpar_resposta(self, texto: str) -> str:
        import re
        return re.sub(r"\(.*?\)", "", texto).strip()

    async def executar(self):
        return await self._processar_intents_e_responder()

# ConteÃºdo do arquivo: ./intents/intents_map.py
INTENTS = {
    "boas_vindas": ["oi", "olÃ¡", "bom dia", "boa tarde", "boa noite"],
    "quero_agendar": ["agendar", "marcar", "consulta", "agendamento"],
    "cancelar": ["cancelar", "desmarcar", "nÃ£o quero"],
    "duvida_geral": ["como funciona", "o que vocÃªs fazem", "ajuda", "informaÃ§Ã£o"],
    "venda": ["comprar", "pacote", "planos", "venda"],"dependencia_quimica": ["dependencia", "vÃ­cio", "dependente quÃ­mico"],
    "identificar_dependencia": ["como saber", "sinais dependencia", "identificar dependÃªncia"],
    "tipos_internacao": ["internaÃ§Ã£o", "tipos de internaÃ§Ã£o", "internar"],
    "como_funciona_tratamento": ["tratamento", "como Ã© o tratamento", "tratamento na clÃ­nica"],
    "duracao_tratamento": ["tempo tratamento", "duraÃ§Ã£o tratamento"],
    "custo_tratamento": ["preÃ§o", "valor tratamento", "quanto custa"],
    "recusa_ajuda": ["nÃ£o aceita ajuda", "recusa tratamento"],
    "apoio_familiar": ["famÃ­lia ajudar", "ajuda familiar", "apoio da famÃ­lia"],
    "sobre_caps": ["o que Ã© caps", "caps"],
    "como_agendar": ["agendar", "marcar consulta", "consulta", "avaliar"],
}
# Mapeia os intents para as respostas correspondentes


# ConteÃºdo do arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# ConteÃºdo do arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessÃ£o estÃ¡ confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# ConteÃºdo do arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from pydantic import BaseModel
from app.nlu.chatbot_router import processar_mensagem

router = APIRouter()

class MensagemEntrada(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

@router.post("/chat/nlp")
async def analisar_mensagem(payload: MensagemEntrada):
    intent, entidades, risco = processar_mensagem(payload.mensagem)

    return {
        "intent": intent,
        "entidades": entidades,
        "risco": risco
    }

# ConteÃºdo do arquivo: ./routes/stripe.py
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # ğŸ§  Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # ğŸ§  Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ğŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ğŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

# ConteÃºdo do arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda nÃ£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# ConteÃºdo do arquivo: ./routes/agendamento.py
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


# ConteÃºdo do arquivo: ./routes/whatsapp.py
from fastapi import APIRouter, Request, Response, HTTPException
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR, MONGO_URI
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from pymongo import MongoClient
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    try:
        data = await request.json()
        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]
        if "messages" not in changes or "contacts" not in changes:
            logging.info("Evento ignorado â€“ sem mensagens (status ou metadados).")
            return Response(status_code=200)
        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"].get("name", "Paciente")
        logging.info(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        logging.info(f"Mensagem: {mensagem}")

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()
        resposta = resultado["resposta"]
        logging.info(f"Resposta: {resposta}")

        await enviar_mensagem(telefone, resposta)

        if WHATSAPP_FAMILIAR and "ameaÃ§a" in mensagem.lower():
            alerta = f"âš ï¸ Alerta FAMDOMES: DetecÃ§Ã£o de risco na conversa com {telefone}. Mensagem: â€œ{mensagem}â€."
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)
    except Exception as e:
        logging.error(f"âŒ ERRO no webhook: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# ConteÃºdo do arquivo: ./routes/ia_comandos.py
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"âœ… Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando nÃ£o reconhecido.")

# ConteÃºdo do arquivo: ./routes/ia.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# âœ… FunÃ§Ã£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"âœ… Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "âŒ Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "âœ… Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "horÃ¡rio" in comando or "disponÃ­vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"ğŸ“… PrÃ³ximo horÃ¡rio disponÃ­vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ğŸ¤– Desculpe, nÃ£o entendi o que vocÃª deseja. VocÃª pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver horÃ¡rio disponÃ­vel")
        return {"status": "comando_desconhecido"}

# ConteÃºdo do arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# ConteÃºdo do arquivo: ./main.py
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel
from app.routes import nlp


API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")
app.include_router(nlp.router)
app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)

@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("ğŸ“¥ Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas pÃºblicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/nlp") or
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # ValidaÃ§Ã£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

# ConteÃºdo do arquivo: ./ia_direct.py
from fastapi import APIRouter, HTTPException, Request
from app.utils.ollama import chamar_ollama
from datetime import datetime

router = APIRouter()

# Mapa de respostas predefinidas â€“ ajuste de acordo com sua polÃ­tica de atendimento
RESPOSTAS_MAP = {
    "boas_vindas": "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que buscar ajuda Ã© difÃ­cil.",
    "quero_agendar": "ğŸ“… Ã“timo, vamos agendar sua consulta. Aguarde o link.",
    "cancelar": "âœ… Sua consulta foi cancelada. Estamos aqui se precisar retomar.",
    "duvida_geral": "ğŸ“‹ Nossa equipe estÃ¡ Ã  disposiÃ§Ã£o para ajudar. Descreva sua dÃºvida.",
    # Adicione outras chaves e respostas conforme necessÃ¡rio
}

async def processar_mensagem_ia(telefone: str, mensagem: str) -> tuple[str, list]:
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt = f"""
VocÃª Ã© um assistente especializado em atendimento humano controlado para pessoas vulnerÃ¡veis. Sua missÃ£o Ã© responder utilizando SOMENTE as respostas predefinidas abaixo e nada mais.

Mapa de Respostas:
{RESPOSTAS_MAP}

InstruÃ§Ãµes:
- Ao receber a mensagem do usuÃ¡rio, escolha a resposta mais adequada dentre as opÃ§Ãµes do mapa.
- NÃƒO crie respostas novas; retorne apenas a resposta correspondente.
- Mantenha a resposta curta, empÃ¡tica e precisa, sem textos adicionais.

Dados da RequisiÃ§Ã£o:
Data/Hora: {agora}
Telefone: {telefone}
Mensagem do UsuÃ¡rio: {mensagem}

ForneÃ§a APENAS a resposta escolhida.
    """.strip()
    resposta, tokens = await chamar_ollama(prompt, telefone)
    return resposta, tokens

@router.post("/mensagem")
async def processar_mensagem_endpoint(request: Request):
    data = await request.json()
    telefone = data.get("telefone")
    mensagem = data.get("mensagem")
    if not telefone or not mensagem:
        raise HTTPException(status_code=400, detail="Telefone e mensagem sÃ£o obrigatÃ³rios.")
    resposta, tokens = await processar_mensagem_ia(telefone, mensagem)
    return {"status": "ok", "resposta": resposta, "tokens": tokens}

# ConteÃºdo do arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# ConteÃºdo do arquivo: ./models/intents.py
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar horÃ¡rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar horÃ¡rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "jÃ¡ paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que vocÃª faz",
        "me ajuda",
        "como vocÃª pode me ajudar"
    ]
}

# ConteÃºdo do arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# ConteÃºdo do arquivo: ./config.py
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# ConteÃºdo do arquivo: ./nlu/response_generator.py
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "ğŸ§¡ VocÃª deu um passo importante ao chegar aqui. Sabemos que nÃ£o Ã© fÃ¡cil buscar ajuda.\n\n"
    "ğŸ¤ Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "ğŸ“² Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # INÃCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"ğŸ“… Ã“timo! Posso te ajudar a agendar com nosso mÃ©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"ğŸ“† O prÃ³ximo horÃ¡rio disponÃ­vel Ã©: {consultar_horario()}. Posso reservar pra vocÃª?",

    # VALORES
    "duvida_valores": "ğŸ’° Temos valores acessÃ­veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIANÃ‡A
    "duvida_geral": "ğŸ“‹ Nosso sistema conecta vocÃª com mÃ©dicos especialistas de verdade. Quer saber como funciona na prÃ¡tica?",
    "desconfianca": "ğŸ” Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPENDÃŠNCIA / RECAÃDA / SINTOMAS
    "duvida_dependencia": "ğŸ§  A dependÃªncia quÃ­mica Ã© tratÃ¡vel. Nosso mÃ©dico pode avaliar sintomas fÃ­sicos e emocionais. Quer agendar?",
    "sou_dependente": "ğŸ’¬ Reconhecer isso Ã© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "ğŸ” RecaÃ­das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "ğŸ˜“ Os sintomas de abstinÃªncia sÃ£o desafiadores. Podemos te orientar com seguranÃ§a. Posso marcar agora?",

    # CRISE / URGÃŠNCIA
    "sintomas_graves": "âš ï¸ Sinais de crise detectados. Posso encaminhar vocÃª para um atendimento urgente. Deseja ajuda agora?",
    "ameaÃ§a_vida": "ğŸš¨ Sua vida importa. Posso ativar nosso acolhimento de urgÃªncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "ğŸ‘ª VocÃª quer ajudar alguÃ©m importante. Posso te explicar como funciona e agendar uma escuta para vocÃª ou para ele(a).",
    "familia_pedindo_ajuda": "ğŸ§­ VocÃª estÃ¡ no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "ğŸš¨ SituaÃ§Ã£o familiar crÃ­tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "ğŸ˜” Ã‰ difÃ­cil quando a famÃ­lia nÃ£o apoia. Mas hÃ¡ caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "ğŸ’” Muitas famÃ­lias passam por isso. Podemos ajudar na reconstruÃ§Ã£o. Quer agendar uma orientaÃ§Ã£o especializada?",
    "familiar_violento": "âš ï¸ Em casos de violÃªncia, seguranÃ§a vem primeiro. Posso te mostrar como agir com respaldo mÃ©dico e legal.",

    # INTERNAÃ‡ÃƒO
    "duvida_internacao": "ğŸ¥ A internaÃ§Ã£o pode ser voluntÃ¡ria ou involuntÃ¡ria, sempre com avaliaÃ§Ã£o mÃ©dica. Quer saber como isso funciona?",
    "quero_internar": "âœ… Posso te mostrar o processo completo, legal e clÃ­nico. Posso agendar agora com nosso mÃ©dico?",

    # FUNIL / OBJECÃ•ES / CIRCUNSTÃ‚NCIAS
    "nao_quero_internar": "Tudo bem. InternaÃ§Ã£o nÃ£o Ã© a Ãºnica saÃ­da. Posso te explicar outras opÃ§Ãµes com orientaÃ§Ã£o mÃ©dica.",
    "meu_parente_usa_droga": "ğŸ’¬ Entendo. Posso agendar com o especialista pra avaliar a situaÃ§Ã£o de forma profissional.",
    "crise_agora": "âš ï¸ Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "ğŸ’¡ Obrigado por compartilhar. Posso te ajudar com os prÃ³ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "ğŸ˜” A resistÃªncia Ã© comum. Mesmo assim, a famÃ­lia pode iniciar a aÃ§Ã£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "ğŸ‘¥ Se a famÃ­lia nÃ£o colabora, podemos trabalhar com quem estiver disponÃ­vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "ğŸ‘ Tranquilo. Se quiser ajudar alguÃ©m ou tirar dÃºvidas, posso te explicar tudo com calma.",

    # INFORMAÃ‡Ã•ES COMPLEMENTARES
    "quero_entender": "ğŸ“˜ Posso te explicar tudo sobre o atendimento, desde a escuta atÃ© o tratamento. Quer comeÃ§ar agora?",
    "curioso": "ğŸ˜„ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simulaÃ§Ã£o real?",
    "pergunta_medico": "ğŸ‘¨â€âš•ï¸ O mÃ©dico Ã© especialista em dependÃªncia quÃ­mica e avaliaÃ§Ã£o clÃ­nica. Quer agendar a escuta?",
    "duvida_medicacao": "ğŸ’Š Medicamentos sÃ³ sÃ£o indicados apÃ³s avaliaÃ§Ã£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "ğŸ§  Temos psicÃ³logos na equipe. A avaliaÃ§Ã£o inicial Ã© mÃ©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "ğŸ” RecomeÃ§ar Ã© possÃ­vel. Estamos aqui pra isso. Quer conversar com o mÃ©dico novamente?",
    "vergonha_de_falar": "ğŸ§¡ Tudo bem. NÃ£o precisa se explicar agora. Posso sÃ³ ouvir, se quiser.",
    "culpa_familiar": "ğŸ¤ A culpa nÃ£o ajuda, mas o cuidado sim. Posso te mostrar como comeÃ§ar com leveza.",
    "busca_ajuda_emocional": "ğŸ’¬ TambÃ©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "ğŸ› Respeitamos todas as crenÃ§as. O acolhimento Ã© humano, com base Ã©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "âš–ï¸ A internaÃ§Ã£o judicial Ã© possÃ­vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "ğŸ‘¶ Tratamos casos de menores com responsabilidade. Posso te mostrar os critÃ©rios e caminhos.",
    "direitos_paciente": "ğŸ“œ Tudo Ã© feito conforme a Ã©tica mÃ©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "ğŸ“ Temos atendimento online e unidades fÃ­sicas. Quer saber se tem perto de vocÃª?",
    "duvida_profissionais": "ğŸ‘©â€âš•ï¸ Temos mÃ©dicos, terapeutas e psicÃ³logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "ğŸ”’ Todo atendimento Ã© sigiloso. Nada Ã© compartilhado sem sua autorizaÃ§Ã£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "âœ… Consulta cancelada. Se quiser retomar, Ã© sÃ³ me avisar.",
    "teste": "ğŸ§ª EstÃ¡ testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "â¤ï¸ Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na prÃ¡tica.",
    "erro": "ğŸ” Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ğŸ¤” NÃ£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "ğŸ‘ Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padrÃ£o se intent for reconhecida mas sem frase especÃ­fica
        return respostas.get(intent, "TÃ´ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

# ConteÃºdo do arquivo: ./nlu/chatbot_router.py
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "tÃ´ aqui pra isso", "pode falar", "Ã© isso", "ok", "tÃ¡", "tÃ¡ bom",
    "isso", "por favor", "sim quero", "tÃ´ dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "ğŸ”„ HistÃ³rico apagado. Pode comeÃ§ar de novo.", "risco": False}

        # ClassificaÃ§Ã£o de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se hÃ¡ contexto anterior de confirmaÃ§Ã£o pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no histÃ³rico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"âš ï¸ Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()

# ConteÃºdo do arquivo: ./nlu/nlu_classifier.py
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para comparaÃ§Ã£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontuaÃ§Ãµes bÃ¡sicas (exceto espaÃ§os) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espaÃ§os extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML nÃ£o encontrados. Usando classificaÃ§Ã£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presenÃ§a de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # ConfianÃ§a base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho estÃ¡ contido no texto
                # Usar `in` Ã© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # LÃ³gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confianÃ§a para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- ClassificaÃ§Ã£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML prÃ©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # NÃ£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, ConfianÃ§a={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classificaÃ§Ã£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confianÃ§a.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML nÃ£o estiver ativo ou como mÃ©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- MÃ©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF Ã© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar parÃ¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes Ã© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
# ConteÃºdo do arquivo: ./nlu/entidade_extractor.py
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)",
                r"([A-ZÃÃ‰ÃÃ“ÃšA-Za-zÃ¡Ã©Ã­Ã³Ãº]+)\s+(?:Ã© meu nome|meu nome Ã©|aqui Ã©)" # Novo padrÃ£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|avÃ´|avÃ³|enteado|enteada)\s+(?:Ã© meu|minha)" # Novo padrÃ£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)",
                r"(?:cidade de)\s+([A-Za-zÃ¡Ã©Ã­Ã³ÃºÃ£ÃµÃ¢ÃªÃ®Ã´Ã»Ã§\s]+)" # Novo padrÃ£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padrÃ£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|cocaÃ­na)"
            ],
            "recaida": [
                r"(reca[Ã­i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[Ã­i]da|escorregada)" # Novo padrÃ£o
            ],
            # Adicione mais entidades e padrÃµes conforme necessÃ¡rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extraÃ­da: {entidades[entidade]} (PadrÃ£o: '{padrao}')")
                    break  # Para na primeira correspondÃªncia

        return entidades
