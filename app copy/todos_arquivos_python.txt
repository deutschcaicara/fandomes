.
--------------------------------------------------------------------------------
Arquivo: ./utils/ollama.py
-------------------------------------------------------------------------------
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt constru√≠do.
    Retorna a resposta limpa e quaisquer tokens extra√≠dos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/hist√≥rico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como n√£o-streaming para simplicidade
        # Adicione outros par√¢metros do Ollama aqui se necess√°rio (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exce√ß√£o para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("‚úÖ Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necess√°rio

            resposta_bruta = dados.get("response", "ü§ñ Desculpe, n√£o consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens Extra√≠dos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "‚ö†Ô∏è Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"‚ö†Ô∏è Ocorreu um erro interno ao processar sua solicita√ß√£o ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO: Falha na conex√£o com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "‚ö†Ô∏è N√£o consegui me conectar √† minha intelig√™ncia artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("‚ùå ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "‚ö†Ô∏è Ocorreu um erro inesperado. A equipe j√° foi notificada. Tente novamente mais tarde.", []
Arquivo: ./utils/prompt_builder.py
-------------------------------------------------------------------------------
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# Configura√ß√£o do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Conex√£o MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # Cole√ß√£o para hist√≥rico de conversas
    logging.info("Conex√£o com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conex√£o adequadamente - talvez retornar erro ou usar prompt padr√£o
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necess√°rio

def carregar_prompt_mestre() -> str:
    """Carrega o conte√∫do do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"‚ùå ERRO: Arquivo de prompt mestre n√£o encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padr√£o seguro em caso de falha
        return (
            "Voc√™ √© um assistente virtual focado em sa√∫de mental e depend√™ncia qu√≠mica.\n"
            "Seja emp√°tico, claro e objetivo. Ofere√ßa apoio e informa√ß√µes sobre agendamento quando apropriado.\n"
            "Responda em portugu√™s brasileiro."
        )
    except Exception as e:
        logging.error(f"‚ùå ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padr√£o seguro
        return (
            "Voc√™ √© um assistente virtual focado em sa√∫de mental e depend√™ncia qu√≠mica.\n"
            "Seja emp√°tico, claro e objetivo. Ofere√ßa apoio e informa√ß√µes sobre agendamento quando apropriado.\n"
            "Responda em portugu√™s brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """Constr√≥i o prompt final para a IA, incluindo o mestre, hist√≥rico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as √∫ltimas N intera√ß√µes (usu√°rio + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por cria√ß√£o
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronol√≥gica

            # Formata o hist√≥rico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usu√°rio
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"Usu√°rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o pr√≥ximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"‚ùå ERRO ao buscar hist√≥rico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar hist√≥rico."
    else:
        trecho_historico = "Hist√≥rico indispon√≠vel (sem conex√£o DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
N√∫mero do Usu√°rio (ocultar na resposta final): {telefone}
---
Hist√≥rico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do Usu√°rio:
Usu√°rio: {pergunta_atual.strip()}
---
Instru√ß√µes para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom emp√°tico, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acess√≠vel, evitando jarg√µes t√©cnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 par√°grafos curtos. Max 400 caracteres se poss√≠vel.
5.  Se a conversa indicar necessidade de agendamento ou mais informa√ß√µes, ofere√ßa isso proativamente.
6.  N√ÉO inclua o hist√≥rico ou as instru√ß√µes na sua resposta final.
7.  N√ÉO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em portugu√™s brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt constru√≠do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sens√≠veis)

    return prompt_final
Arquivo: ./utils/mensageria.py
-------------------------------------------------------------------------------
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("‚ö†Ô∏è Tentativa de enviar mensagem vazia ou sem destinat√°rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url √© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razo√°vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"‚úÖ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padr√£o Cl√≠nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfa√ß√£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com bot√£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de bot√£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # √çndice do bot√£o no template
                    # "parameters": [] # Par√¢metros espec√≠ficos do bot√£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"‚úÖ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
Arquivo: ./utils/contexto.py
-------------------------------------------------------------------------------
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas ass√≠ncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # Cole√ß√£o para contextos
    logging.info("Conex√£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone espec√≠fico.
    'dados_atualizacao' deve ser um dicion√°rio com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel salvar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inv√°lido (sem telefone ou dados inv√°lidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modifica√ß√£o
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na cria√ß√£o
            },
            upsert=True # Cria o documento se n√£o existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel obter contexto para {telefone}: Sem conex√£o com DB.")
        return {} # Retorna dicion√°rio vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicion√°rio vazio se n√£o encontrar
    except Exception as e:
        logging.error(f"‚ùå ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicion√°rio vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel limpar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"‚ùå ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do √∫ltimo acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que s√≥ atualizar√° o $currentDate
Arquivo: ./utils/db.py
-------------------------------------------------------------------------------
from datetime import datetime, timedelta

# Simula pr√≥xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula grava√ß√£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} √†s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO M√âDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suic√≠dio", "morrer", "n√£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

Arquivo: ./utils/risco.py
-------------------------------------------------------------------------------
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases cr√≠ticas (ajuste conforme necess√°rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suic√≠dio", "me matar", "quero morrer", "n√£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperan√ßa", "adeus mundo", "n√£o quero viver",
    # Adicionar termos relacionados a auto-mutila√ß√£o se aplic√°vel
    # Adicionar termos relacionados a amea√ßas a terceiros se aplic√°vel
]

# Adicionar palavras/frases que indicam URG√äNCIA M√âDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
    "desmaiado", "convuls√£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emerg√™ncias m√©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suic√≠dio, urg√™ncia m√©dica).
    Retorna um dicion√°rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"üö® RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"üöë URG√äNCIA M√âDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
Arquivo: ./utils/agenda.py
-------------------------------------------------------------------------------
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configura√ß√£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias √∫teis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (n√£o agenda √†s 18:00, √∫ltimo √© 17:40)

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar √≠ndice para garantir que n√£o haja duas consultas no mesmo hor√°rio
    consultas_db.create_index("horario", unique=True)
    logging.info("Conex√£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avan√ßa o hor√°rio para o pr√≥ximo bloco de X minutos dentro do hor√°rio de opera√ß√£o."""
    horario = inicio_base

    # Arredonda para o pr√≥ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no in√≠cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o hor√°rio de opera√ß√£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (S√°bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o pr√≥ximo hor√°rio livre e agenda a consulta.
    Retorna o datetime do hor√°rio agendado ou None se n√£o encontrar.
    """
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel agendar: Sem conex√£o com DB.")
        return None

    # Usar UTC para armazenamento no DB √© uma boa pr√°tica
    agora_utc = datetime.now(timezone.utc)
    # Come√ßa a procurar X minutos √† frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se j√° existe consulta nesse hor√°rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou hor√°rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o hor√°rio em UTC
            else:
                # Hor√°rio ocupado, avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verifica√ß√£o/inser√ß√£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exce√ß√£o

    logging.warning(f"N√£o foram encontrados hor√°rios dispon√≠veis para {telefone} ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se n√£o encontrar hor√°rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel cancelar: Sem conex√£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda n√£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"üóëÔ∏è Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"‚ùå ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o pr√≥ximo hor√°rio dispon√≠vel sem agendar."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel consultar hor√°rio: Sem conex√£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Come√ßa a procurar um pouco √† frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Pr√≥ximo hor√°rio dispon√≠vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna hor√°rio em UTC
            else:
                # Avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao consultar pr√≥ximo hor√°rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum hor√°rio dispon√≠vel encontrado na consulta ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um hor√°rio UTC para uma string leg√≠vel no fuso hor√°rio local."""
    if not horario_utc:
        return "Indispon√≠vel"
    try:
        # Precisa da biblioteca pytz para fusos hor√°rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Ter√ßa-feira, 15 de Abril √†s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B √†s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz n√£o instalada. Usando formata√ß√£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar hor√°rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formata√ß√£o"
Arquivo: ./utils/ia_fallback.py
-------------------------------------------------------------------------------
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta

Arquivo: ./utils/followup.py
-------------------------------------------------------------------------------
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a fun√ß√£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a fun√ß√£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # N√£o precisa mais buscar aqui, usa agenda.py
    logging.info("Conex√£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Fun√ß√µes de Simula√ß√£o (Removidas ou Substitu√≠das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> L√≥gica est√° em agenda.py
# avisar_profissional -> Deveria ser chamado ap√≥s agendamento real
# avisar_paciente -> Deveria ser chamado ap√≥s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o in√≠cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel iniciar sess√£o de pagamento: Sem conex√£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESS√ÉO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao iniciar sess√£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sess√£o como paga, agenda a consulta e retorna o hor√°rio agendado e nome.
    Esta fun√ß√£o √© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel marcar pagamento: Sem conex√£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que s√≥ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualiza√ß√£o se n√£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, ent√£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome j√° est√° l√° do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sess√£o ser criada, ou se j√° foi processado
            logging.warning(f"Sess√£o de pagamento n√£o encontrada ou j√° processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sess√£o
        logging.info(f"[SESS√ÉO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sess√£o com o hor√°rio agendado (opcional, mas √∫til)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sess√£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para poss√≠vel notifica√ß√£o manual

    except Exception as e:
        logging.error(f"‚ùå ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Fun√ß√£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # L√≥gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo n√∫mero real ou l√≥gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"üë®‚Äç‚öïÔ∏è Nova consulta agendada: {nome_paciente} ({telefone_paciente}) √†s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("N√∫mero do m√©dico n√£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Fun√ß√£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sess√µes com pagamento pendente h√° muito tempo."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel checar followup: Sem conex√£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "voc√™")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Ol√° {nome}, notei que voc√™ iniciou um agendamento mas parece que n√£o foi conclu√≠do. üò•\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma d√∫vida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. üòä"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sess√£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"‚ùå ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
Arquivo: ./schemas/ia_comando.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

Arquivo: ./intents/router_intents.py
-------------------------------------------------------------------------------
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigat√≥rios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }
Arquivo: ./intents/__init__.py
-------------------------------------------------------------------------------

Arquivo: ./intents/intent_executor.py
-------------------------------------------------------------------------------
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o m√≥dulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que n√£o √© f√°cil buscar ajuda.\n\n"
    "ü§ù Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "üì≤ Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "t√¥ aqui pra isso", "pode falar", "√© isso", "ok", "t√°", "t√° bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "n√£o", "nao", "talvez depois", "n√£o agora", "deixa pra depois",
    "t√¥ s√≥ olhando", "s√≥ pesquisando", "agora n√£o"
]

# Limiar de confian√ßa para a intent (ajuste conforme necess√°rio)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui √© o|aqui √© a|meu nome √©|me chamo √©)\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)",
        r"nome √©\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confian√ßa alta

    def detectar_intent(self):
        # L√≥gica de detec√ß√£o de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confian√ßa para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que voc√™ precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "üîÑ Hist√≥rico de testes apagado com sucesso. Pode come√ßar uma nova simula√ß√£o.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "ol√°", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # M√©dia confian√ßa em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # IN√çCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"üìÖ √ìtimo! Posso te ajudar a agendar com nosso m√©dico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"üìÜ O pr√≥ximo hor√°rio dispon√≠vel √©: {consultar_horario()}. Posso reservar pra voc√™?",

        # VALORES
        "duvida_valores": "üí∞ Temos valores acess√≠veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIAN√áA
        "duvida_geral": "üìã Nosso sistema conecta voc√™ com m√©dicos especialistas de verdade. Quer saber como funciona na pr√°tica?",
        "desconfianca": "üîç Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPEND√äNCIA / RECA√çDA / SINTOMAS
        "duvida_dependencia": "üß† A depend√™ncia qu√≠mica √© trat√°vel. Nosso m√©dico pode avaliar sintomas f√≠sicos e emocionais. Quer agendar?",
        "sou_dependente": "üí¨ Reconhecer isso √© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "üîÅ Reca√≠das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "üòì Os sintomas de abstin√™ncia s√£o desafiadores. Podemos te orientar com seguran√ßa. Posso marcar agora?",

        # CRISE / URG√äNCIA
        "sintomas_graves": "‚ö†Ô∏è Sinais de crise detectados. Posso encaminhar voc√™ para um atendimento urgente. Deseja ajuda agora?",
        "amea√ßa_vida": "üö® Sua vida importa. Posso ativar nosso acolhimento de urg√™ncia. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "üë™ Voc√™ quer ajudar algu√©m importante. Posso te explicar como funciona e agendar uma escuta para voc√™ ou para ele(a).",
        "familia_pedindo_ajuda": "üß≠ Voc√™ est√° no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "üö® Situa√ß√£o familiar cr√≠tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "üòî √â dif√≠cil quando a fam√≠lia n√£o apoia. Mas h√° caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "üíî Muitas fam√≠lias passam por isso. Podemos ajudar na reconstru√ß√£o. Quer agendar uma orienta√ß√£o especializada?",
        "familiar_violento": "‚ö†Ô∏è Em casos de viol√™ncia, seguran√ßa vem primeiro. Posso te mostrar como agir com respaldo m√©dico e legal.",

        # INTERNA√á√ÉO
        "duvida_internacao": "üè• A interna√ß√£o pode ser volunt√°ria ou involunt√°ria, sempre com avalia√ß√£o m√©dica. Quer saber como isso funciona?",
        "quero_internar": "‚úÖ Posso te mostrar o processo completo, legal e cl√≠nico. Posso agendar agora com nosso m√©dico?",

        # FUNIL / OBJEC√ïES / CIRCUNST√ÇNCIAS
        "nao_quero_internar": "Tudo bem. Interna√ß√£o n√£o √© a √∫nica sa√≠da. Posso te explicar outras op√ß√µes com orienta√ß√£o m√©dica.",
        "meu_parente_usa_droga": "üí¨ Entendo. Posso agendar com o especialista pra avaliar a situa√ß√£o de forma profissional.",
        "crise_agora": "‚ö†Ô∏è Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "üí° Obrigado por compartilhar. Posso te ajudar com os pr√≥ximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "üòî A resist√™ncia √© comum. Mesmo assim, a fam√≠lia pode iniciar a a√ß√£o. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "üë• Se a fam√≠lia n√£o colabora, podemos trabalhar com quem estiver dispon√≠vel. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "üëç Tranquilo. Se quiser ajudar algu√©m ou tirar d√∫vidas, posso te explicar tudo com calma.",

        # INFORMA√á√ïES COMPLEMENTARES
        "quero_entender": "üìò Posso te explicar tudo sobre o atendimento, desde a escuta at√© o tratamento. Quer come√ßar agora?",
        "curioso": "üòÑ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simula√ß√£o real?",
        "pergunta_medico": "üë®‚Äç‚öïÔ∏è O m√©dico √© especialista em depend√™ncia qu√≠mica e avalia√ß√£o cl√≠nica. Quer agendar a escuta?",
        "duvida_medicacao": "üíä Medicamentos s√≥ s√£o indicados ap√≥s avalia√ß√£o. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "üß† Temos psic√≥logos na equipe. A avalia√ß√£o inicial √© m√©dica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "üîÅ Recome√ßar √© poss√≠vel. Estamos aqui pra isso. Quer conversar com o m√©dico novamente?",
        "vergonha_de_falar": "üß° Tudo bem. N√£o precisa se explicar agora. Posso s√≥ ouvir, se quiser.",
        "culpa_familiar": "ü§ù A culpa n√£o ajuda, mas o cuidado sim. Posso te mostrar como come√ßar com leveza.",
        "busca_ajuda_emocional": "üí¨ Tamb√©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "üõê Respeitamos todas as cren√ßas. O acolhimento √© humano, com base √©tica. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "‚öñÔ∏è A interna√ß√£o judicial √© poss√≠vel. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "üë∂ Tratamos casos de menores com responsabilidade. Posso te mostrar os crit√©rios e caminhos.",
        "direitos_paciente": "üìú Tudo √© feito conforme a √©tica m√©dica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "üìç Temos atendimento online e unidades f√≠sicas. Quer saber se tem perto de voc√™?",
        "duvida_profissionais": "üë©‚Äç‚öïÔ∏è Temos m√©dicos, terapeutas e psic√≥logos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "üîí Todo atendimento √© sigiloso. Nada √© compartilhado sem sua autoriza√ß√£o. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"‚úÖ Consulta cancelada. Se quiser retomar, √© s√≥ me avisar.",
        "teste": "üß™ Est√° testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "‚ù§Ô∏è Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na pr√°tica.",
        "erro": "üîÅ Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "ü§î N√£o entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "üëç Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugest√µes de pr√≥ximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou voc√™ gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou voc√™ tem alguma outra d√∫vida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou voc√™ gostaria de agendar uma consulta?",
            "sou_dependente": "\nVoc√™ gostaria de agendar uma consulta ou precisa de mais informa√ß√µes?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVoc√™ gostaria de agendar uma consulta para voc√™ ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de interna√ß√£o ou voc√™ gostaria de saber as op√ß√µes de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se voc√™ reformular a pergunta ou gostaria de ver as op√ß√µes de ajuda dispon√≠veis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padr√£o
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta
Arquivo: ./intents/intents_map.py
-------------------------------------------------------------------------------
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # üöÄ IN√çCIO DO FUNIL
    "boas_vindas": [
        "oi", "ol√°", "ola", "bom dia", "boa tarde", "boa noite", "e a√≠", "fala comigo", "tudo bem", "como vai"
    ],

    # üë§ QUERO AGENDAR / HOR√ÅRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um m√©dico", "consulta urgente", "quero ajuda m√©dica",
        "agendar", "marcar consulta", "atendimento m√©dico", "agendar consulta"
    ],
    "ver_horario": [
        "tem hor√°rio", "que horas tem", "tem agenda", "qual o pr√≥ximo hor√°rio", "quero saber os hor√°rios",
        "hor√°rios dispon√≠veis", "agenda livre", "consultar hor√°rio", "ver agenda"
    ],

    # üí∞ VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "pre√ßo", "tem plano", "√© caro", "valores da consulta", "paga quanto", "√© gratuito?",
        "aceita conv√™nio", "plano de sa√∫de", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # ‚ùì D√öVIDAS GERAIS / CONFIAN√áA
    "duvida_geral": [
        "como funciona", "me explica", "o que voc√™s fazem", "isso √© pra qu√™", "como ajudam", "qual o tratamento",
        "o que √© isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso √© real?", "posso confiar?", "√© golpe?", "tem CNPJ?", "quem s√£o voc√™s?", "√© confi√°vel?", "funciona mesmo?",
        "√© seguro?", "garantia", "√© empresa?"
    ],

    # üìö SOBRE DEPEND√äNCIA / V√çCIO
    "duvida_dependencia": [
        "o que √© depend√™ncia qu√≠mica", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "v√≠cio em drogas", "meu caso tem jeito", "isso √© doen√ßa?", "uso mas n√£o sou viciado", "tem tratamento",
        "depend√™ncia", "v√≠cio", "drogas", "alcoolismo", "sintomas de v√≠cio"
    ],
    "sou_dependente": [
        "sou viciado", "tenho v√≠cio", "sou dependente qu√≠mico", "tenho problema com droga", "uso todo dia",
        "n√£o consigo parar", "preciso parar de usar", "sou alco√≥latra", "viciado"
    ],
    "recaida": [
        "tive reca√≠da", "usei de novo", "n√£o consegui parar", "recomecei", "ca√≠ de novo",
        "reca√≠", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "t√¥ tremendo", "t√¥ suando", "n√£o t√¥ bem", "t√¥ em abstin√™ncia", "t√¥ agoniado", "t√¥ passando mal sem usar",
        "sintomas de abstin√™ncia", "fissura", "crise de abstin√™ncia"
    ],

    # üß† SINTOMAS GRAVES / CRISE / URG√äNCIA
    "sintomas_graves": [
        "t√° surtando", "alucina√ß√£o", "t√° agressivo", "n√£o dorme h√° dias", "vis√µes", "del√≠rio", "t√° em crise",
        "descontrolado", "sem no√ß√£o do que faz", "paranoia", "confus√£o mental", "surto psic√≥tico"
    ],
    "amea√ßa_vida": [ # Risco de suic√≠dio/auto-mutila√ß√£o
        "quero morrer", "vou me matar", "n√£o quero viver", "quero sumir", "vou acabar com tudo", "vida n√£o faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # Emerg√™ncia m√©dica clara
        "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
        "desmaiado", "convuls√£o", "sangrando muito", "veneno", "infarto", "avc", "emerg√™ncia"
    ],


    # üë®‚Äçüë©‚Äçüë¶ FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou m√£e", "sou pai", "sou esposa", "sou marido", "sou irm√£o", "sou irm√£", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho t√° viciado", "minha filha t√° usando", "meu marido n√£o aceita ajuda", "ele n√£o quer se tratar",
        "n√£o sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela t√° gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "t√° se machucando", "t√° em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele n√£o quer ajuda", "ela n√£o aceita", "n√£o quer tratamento", "n√£o admite que tem problema",
        "n√£o quer ser internado", "n√£o aceita m√©dico", "resiste ao tratamento"
    ],

    # üè• INTERNA√á√ÉO
    "duvida_internacao": [
        "como funciona a interna√ß√£o", "quanto tempo dura", "volta pra casa depois?", "como √© o lugar",
        "tem visita?", "fica trancado?", "interna√ß√£o involunt√°ria", "√© for√ßado?", "tem psiquiatra?",
        "interna√ß√£o", "cl√≠nica de recupera√ß√£o", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como fa√ßo pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "interna√ß√£o compuls√≥ria", "interna√ß√£o involunt√°ria"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa n√£o querer interna√ß√£o
        "n√£o quero internar", "sem interna√ß√£o", "tratamento sem internar", "n√£o precisa de cl√≠nica",
        "alternativa √† interna√ß√£o", "tratamento ambulatorial"
    ],

    # ‚öñÔ∏è QUEST√ïES LEGAIS / JUR√çDICAS
    "internacao_judicial": [
        "posso pedir pra justi√ßa?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "interna√ß√£o compuls√≥ria", "justi√ßa", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho √© menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "crian√ßa"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele √© obrigado?", "isso √© legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # üí¨ OUTRAS SITUA√á√ïES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # Usu√°rio falando sobre seu pr√≥prio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida t√° destru√≠da",
        "preciso de ajuda com meu v√≠cio"
    ],
     "resistencia_familiar": [ # Paciente relata que a fam√≠lia n√£o apoia/atrapalha
        "minha fam√≠lia n√£o me apoia", "minha esposa n√£o entende", "meus pais n√£o aceitam",
        "fam√≠lia contra o tratamento", "n√£o tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que n√£o √© o paciente
        "n√£o sou eu que uso", "√© para um amigo", "s√≥ estou pesquisando", "quero informa√ß√£o para outra pessoa",
        "n√£o sou usu√°rio"
    ],

    # ‚ÑπÔ∏è BUSCA DE INFORMA√á√ïES ADICIONAIS
     "quero_entender": [ # Pedido expl√≠cito para entender o servi√ßo/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # Demonstra√ß√£o de curiosidade ou teste
        "s√≥ testando", "kkk", "haha", "curioso", "testando sistema", "s√≥ vendo como funciona",
        "teste", "simula√ß√£o"
    ],
    "pergunta_medico": [ # D√∫vida espec√≠fica sobre o profissional m√©dico
        "quem √© o m√©dico?", "qual a especialidade?", "√© psiquiatra?", "posso escolher o m√©dico?",
        "falar com o m√©dico"
    ],
     "duvida_medicacao": [ # D√∫vida sobre rem√©dios
        "vai precisar de rem√©dio?", "usam medica√ß√£o?", "quais rem√©dios?", "tratamento com rem√©dio",
        "medica√ß√£o psiqui√°trica"
    ],
     "duvida_psicologo": [ # D√∫vida sobre psic√≥logo/terapia
        "tem psic√≥logo?", "faz terapia?", "atendimento psicol√≥gico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # D√∫vida sobre local f√≠sico/online
        "onde fica?", "tem na minha cidade?", "qual o endere√ßo?", "atende onde?", "√© presencial ou online?",
        "atendimento online", "unidade f√≠sica", "endere√ßo da cl√≠nica"
    ],
     "duvida_profissionais": [ # D√∫vida geral sobre a equipe
        "quem s√£o os profissionais?", "tem terapeuta?", "quem atende?", "√© s√≥ m√©dico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # D√∫vida sobre confidencialidade
        "isso √© sigiloso?", "meus dados est√£o protegidos?", "algu√©m vai saber?", "√© confidencial?",
        "privacidade", "segredo m√©dico"
    ],


    # ‚ù§Ô∏è INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # J√° tentou tratamento antes e parou
        "j√° tentei parar antes", "desisti do tratamento", "n√£o funcionou da outra vez",
        "j√° fiz tratamento e n√£o adiantou", "recome√ßar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ningu√©m", "√© dif√≠cil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que √© culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "t√¥ mal", "t√¥ triste", "ansiedade", "crise de p√¢nico", "sou depressivo", "t√¥ vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # Quest√µes sobre religi√£o/espiritualidade
        "√© contra religi√£o?", "tem algo espiritual?", "sou evang√©lico", "sou cat√≥lico", "tem apoio religioso?",
        "minha f√©", "igreja"
    ],

    # üõë CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar a√ß√£o atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "n√£o quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "n√£o posso ir"
    ],
    "confirmacao_positiva": [ # Confirma√ß√£o gen√©rica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "t√°", "t√° bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # Nega√ß√£o gen√©rica (n√£o, agora n√£o)
        "n√£o", "nao", "talvez depois", "n√£o agora", "deixa pra depois", "agora n√£o", "n√£o quero", "n√£o obrigado"
    ],
    "elogio": [
        "√≥timo atendimento", "gostei muito", "voc√™s s√£o bons", "obrigado", "atendimento top", "amei",
        "parab√©ns", "muito bom", "excelente"
    ],
    "erro": [ # Usu√°rio reporta um erro t√©cnico
        "link n√£o abre", "deu erro", "n√£o consegui pagar", "o site caiu", "n√£o carrega",
        "problema t√©cnico", "n√£o funciona", "bug"
    ],
    "sem_compreensao": [ # Bot n√£o entendeu ou mensagem inintelig√≠vel
        "asdfgh", "oiaueia", "????", "n√£o entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "n√£o faz sentido"
    ],

    # Adicione intents mais espec√≠ficas conforme necess√°rio
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}
Arquivo: ./routes/pagamentos.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

Arquivo: ./routes/painel.py
-------------------------------------------------------------------------------
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sess√£o est√° confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

Arquivo: ./routes/stripe.py
-------------------------------------------------------------------------------
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # üß† Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # üß† Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

Arquivo: ./routes/rocketchat.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda n√£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

Arquivo: ./routes/agendamento.py
-------------------------------------------------------------------------------
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


Arquivo: ./routes/whatsapp.py
-------------------------------------------------------------------------------
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("‚ö†Ô∏è Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # üö® Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"‚ö†Ô∏è Alerta FAMDOMES: Detec√ß√£o de risco na conversa com {telefone}. "
                f"Mensagem: ‚Äú{mensagem}‚Äù. Um profissional ser√° alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("‚ùå ERRO no webhook:", str(e))
        return {"erro": str(e)}
Arquivo: ./routes/ia_comandos.py
-------------------------------------------------------------------------------
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"‚úÖ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando n√£o reconhecido.")

Arquivo: ./routes/ia.py
-------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ‚úÖ Fun√ß√£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"‚úÖ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "‚ùå Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "‚úÖ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in comando or "dispon√≠vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ü§ñ Desculpe, n√£o entendi o que voc√™ deseja. Voc√™ pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver hor√°rio dispon√≠vel")
        return {"status": "comando_desconhecido"}

Arquivo: ./routes/followup.py
-------------------------------------------------------------------------------
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

Arquivo: ./main.py
-------------------------------------------------------------------------------
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("üì• Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas p√∫blicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Valida√ß√£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

Arquivo: ./models/pagamentos.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

Arquivo: ./models/intents.py
-------------------------------------------------------------------------------
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar hor√°rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar hor√°rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "j√° paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que voc√™ faz",
        "me ajuda",
        "como voc√™ pode me ajudar"
    ]
}

Arquivo: ./models/atendimento.py
-------------------------------------------------------------------------------
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

Arquivo: ./config.py
-------------------------------------------------------------------------------
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

Arquivo: ./nlu/response_generator.py
-------------------------------------------------------------------------------
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que n√£o √© f√°cil buscar ajuda.\n\n"
    "ü§ù Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "üì≤ Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # IN√çCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"üìÖ √ìtimo! Posso te ajudar a agendar com nosso m√©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"üìÜ O pr√≥ximo hor√°rio dispon√≠vel √©: {consultar_horario()}. Posso reservar pra voc√™?",

    # VALORES
    "duvida_valores": "üí∞ Temos valores acess√≠veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIAN√áA
    "duvida_geral": "üìã Nosso sistema conecta voc√™ com m√©dicos especialistas de verdade. Quer saber como funciona na pr√°tica?",
    "desconfianca": "üîç Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPEND√äNCIA / RECA√çDA / SINTOMAS
    "duvida_dependencia": "üß† A depend√™ncia qu√≠mica √© trat√°vel. Nosso m√©dico pode avaliar sintomas f√≠sicos e emocionais. Quer agendar?",
    "sou_dependente": "üí¨ Reconhecer isso √© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "üîÅ Reca√≠das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "üòì Os sintomas de abstin√™ncia s√£o desafiadores. Podemos te orientar com seguran√ßa. Posso marcar agora?",

    # CRISE / URG√äNCIA
    "sintomas_graves": "‚ö†Ô∏è Sinais de crise detectados. Posso encaminhar voc√™ para um atendimento urgente. Deseja ajuda agora?",
    "amea√ßa_vida": "üö® Sua vida importa. Posso ativar nosso acolhimento de urg√™ncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "üë™ Voc√™ quer ajudar algu√©m importante. Posso te explicar como funciona e agendar uma escuta para voc√™ ou para ele(a).",
    "familia_pedindo_ajuda": "üß≠ Voc√™ est√° no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "üö® Situa√ß√£o familiar cr√≠tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "üòî √â dif√≠cil quando a fam√≠lia n√£o apoia. Mas h√° caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "üíî Muitas fam√≠lias passam por isso. Podemos ajudar na reconstru√ß√£o. Quer agendar uma orienta√ß√£o especializada?",
    "familiar_violento": "‚ö†Ô∏è Em casos de viol√™ncia, seguran√ßa vem primeiro. Posso te mostrar como agir com respaldo m√©dico e legal.",

    # INTERNA√á√ÉO
    "duvida_internacao": "üè• A interna√ß√£o pode ser volunt√°ria ou involunt√°ria, sempre com avalia√ß√£o m√©dica. Quer saber como isso funciona?",
    "quero_internar": "‚úÖ Posso te mostrar o processo completo, legal e cl√≠nico. Posso agendar agora com nosso m√©dico?",

    # FUNIL / OBJEC√ïES / CIRCUNST√ÇNCIAS
    "nao_quero_internar": "Tudo bem. Interna√ß√£o n√£o √© a √∫nica sa√≠da. Posso te explicar outras op√ß√µes com orienta√ß√£o m√©dica.",
    "meu_parente_usa_droga": "üí¨ Entendo. Posso agendar com o especialista pra avaliar a situa√ß√£o de forma profissional.",
    "crise_agora": "‚ö†Ô∏è Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "üí° Obrigado por compartilhar. Posso te ajudar com os pr√≥ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "üòî A resist√™ncia √© comum. Mesmo assim, a fam√≠lia pode iniciar a a√ß√£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "üë• Se a fam√≠lia n√£o colabora, podemos trabalhar com quem estiver dispon√≠vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "üëç Tranquilo. Se quiser ajudar algu√©m ou tirar d√∫vidas, posso te explicar tudo com calma.",

    # INFORMA√á√ïES COMPLEMENTARES
    "quero_entender": "üìò Posso te explicar tudo sobre o atendimento, desde a escuta at√© o tratamento. Quer come√ßar agora?",
    "curioso": "üòÑ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simula√ß√£o real?",
    "pergunta_medico": "üë®‚Äç‚öïÔ∏è O m√©dico √© especialista em depend√™ncia qu√≠mica e avalia√ß√£o cl√≠nica. Quer agendar a escuta?",
    "duvida_medicacao": "üíä Medicamentos s√≥ s√£o indicados ap√≥s avalia√ß√£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "üß† Temos psic√≥logos na equipe. A avalia√ß√£o inicial √© m√©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "üîÅ Recome√ßar √© poss√≠vel. Estamos aqui pra isso. Quer conversar com o m√©dico novamente?",
    "vergonha_de_falar": "üß° Tudo bem. N√£o precisa se explicar agora. Posso s√≥ ouvir, se quiser.",
    "culpa_familiar": "ü§ù A culpa n√£o ajuda, mas o cuidado sim. Posso te mostrar como come√ßar com leveza.",
    "busca_ajuda_emocional": "üí¨ Tamb√©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "üõê Respeitamos todas as cren√ßas. O acolhimento √© humano, com base √©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "‚öñÔ∏è A interna√ß√£o judicial √© poss√≠vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "üë∂ Tratamos casos de menores com responsabilidade. Posso te mostrar os crit√©rios e caminhos.",
    "direitos_paciente": "üìú Tudo √© feito conforme a √©tica m√©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "üìç Temos atendimento online e unidades f√≠sicas. Quer saber se tem perto de voc√™?",
    "duvida_profissionais": "üë©‚Äç‚öïÔ∏è Temos m√©dicos, terapeutas e psic√≥logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "üîí Todo atendimento √© sigiloso. Nada √© compartilhado sem sua autoriza√ß√£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "‚úÖ Consulta cancelada. Se quiser retomar, √© s√≥ me avisar.",
    "teste": "üß™ Est√° testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "‚ù§Ô∏è Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na pr√°tica.",
    "erro": "üîÅ Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ü§î N√£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "üëç Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padr√£o se intent for reconhecida mas sem frase espec√≠fica
        return respostas.get(intent, "T√¥ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

Arquivo: ./nlu/chatbot_router.py
-------------------------------------------------------------------------------
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier  # Importe a classe
from app.nlu.entidade_extractor import EntidadeExtractor  # Importe a classe
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

# Instancie os classificadores e extratores
nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0  # Inicialmente, confian√ßa alta

    async def processar(self):
        # Reset manual
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "üîÑ Hist√≥rico apagado. Pode come√ßar de novo.", "risco": False}

        # Detectar intent e extrair entidades
        intent = nlu_classifier.classificar_intent(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Se voc√™ estiver usando um modelo de ML para classificar a intent,
        # voc√™ pode obter a confian√ßa aqui. Por exemplo:
        # intent, self.intent_confianca = nlu_classifier.classificar_com_confianca(self.mensagem)

        # Atualizar nome se extra√≠do
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Gerar resposta
        resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
        risco = analisar_risco(self.mensagem)

        # L√≥gica de baixa confian√ßa (se aplic√°vel)
        if self.intent_confianca < 0.6 and intent == "desconhecida":
            resposta = "ü§î Desculpe, n√£o entendi. Voc√™ pode reformular sua pergunta?"
            logging.warning(f"Baixa confian√ßa na intent: {intent} ({self.intent_confianca}). Mensagem: {self.mensagem}")

        # Atualizar contexto
        self._atualizar_contexto(intent)

        # Hist√≥rico
        return self._registrar_interacao(intent, resposta, risco)

    def _atualizar_contexto(self, intent):
        salvar_contexto(self.telefone, {
            "ultima_mensagem": self.mensagem,
            "ultima_intent": intent,
            "intent_esperada": None,
            "aguardando_confirmacao": False
        })

    def _registrar_interacao(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}
Arquivo: ./nlu/nlu_classifier.py
-------------------------------------------------------------------------------
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para compara√ß√£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontua√ß√µes b√°sicas (exceto espa√ßos) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espa√ßos extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML n√£o encontrados. Usando classifica√ß√£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presen√ßa de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confian√ßa base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho est√° contido no texto
                # Usar `in` √© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # L√≥gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confian√ßa para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classifica√ß√£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pr√©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # N√£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confian√ßa={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classifica√ß√£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confian√ßa.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML n√£o estiver ativo ou como m√©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- M√©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF √© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar par√¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes √© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
Arquivo: ./nlu/entidade_extractor.py
-------------------------------------------------------------------------------
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)",
                r"([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)\s+(?:√© meu nome|meu nome √©|aqui √©)" # Novo padr√£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)\s+(?:√© meu|minha)" # Novo padr√£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)",
                r"(?:cidade de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)" # Novo padr√£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padr√£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|coca√≠na)"
            ],
            "recaida": [
                r"(reca[√≠i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[√≠i]da|escorregada)" # Novo padr√£o
            ],
            # Adicione mais entidades e padr√µes conforme necess√°rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extra√≠da: {entidades[entidade]} (Padr√£o: '{padrao}')")
                    break  # Para na primeira correspond√™ncia

        return entidades
==== /home/ubuntu/famdomes_backend/app/utils/ollama.py ====
# utils/ollama.py
import httpx
from app.config import OLLAMA_API_URL, OLLAMA_MODEL
from app.utils.prompt_builder import construir_prompt # Mantido, mas pode precisar de ajuste se o prompt mudar
import re
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def limpar_resposta_ia(resposta: str) -> tuple[str, list[str]]:
    """Remove tokens internos como {TOKEN}, limpa '}' sobrando e extrai para debug."""
    # Tenta extrair tokens entre chaves
    tokens = re.findall(r"\{([^}]+)\}", resposta)
    # Remove os tokens encontrados da resposta
    resposta_limpa = re.sub(r"\{[^}]+\}", "", resposta)
    # Remove chaves fechadas que podem ter sobrado
    resposta_limpa = resposta_limpa.replace("}", "")
    return resposta_limpa.strip(), tokens

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> tuple[str, list[str]]:
    """
    Chama a API do Ollama para gerar uma resposta baseada no prompt constru√≠do.
    Retorna a resposta limpa e quaisquer tokens extra√≠dos.
    """
    prompt_final = construir_prompt(telefone, pergunta) # Usa o builder para contexto/hist√≥rico

    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt_final,
        "stream": False # Mantendo como n√£o-streaming para simplicidade
        # Adicione outros par√¢metros do Ollama aqui se necess√°rio (temperature, top_p, etc.)
    }
    headers = {"Content-Type": "application/json"}

    # Definindo um timeout um pouco maior para LLMs locais
    timeout = httpx.Timeout(60.0, connect=10.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", headers=headers, json=payload)
            response.raise_for_status() # Levanta exce√ß√£o para status HTTP 4xx/5xx

            dados = response.json()
            logging.info("‚úÖ Resposta recebida da IA (OLLAMA).")
            # logging.debug(f"Dados completos da resposta: {dados}") # Log detalhado se necess√°rio

            resposta_bruta = dados.get("response", "ü§ñ Desculpe, n√£o consegui gerar uma resposta no momento.")
            resposta_limpa, tokens = limpar_resposta_ia(resposta_bruta)

            logging.info(f"Resposta Limpa: {resposta_limpa}")
            if tokens:
                logging.info(f"Tokens Extra√≠dos: {tokens}")

            return resposta_limpa, tokens

    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao conectar com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "‚ö†Ô∏è Desculpe, demorei muito para pensar. Poderia tentar novamente?", []
    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO: Status HTTP {e.response.status_code} ao chamar Ollama: {e.response.text}")
        return f"‚ö†Ô∏è Ocorreu um erro interno ao processar sua solicita√ß√£o ({e.response.status_code}). Por favor, tente mais tarde.", []
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO: Falha na conex√£o com Ollama ({OLLAMA_API_URL}): {str(e)}")
        return "‚ö†Ô∏è N√£o consegui me conectar √† minha intelig√™ncia artificial no momento. Tente novamente em breve.", []
    except Exception as e:
        logging.exception("‚ùå ERRO desconhecido ao chamar Ollama:") # Usar logging.exception para incluir stack trace
        return "‚ö†Ô∏è Ocorreu um erro inesperado. A equipe j√° foi notificada. Tente novamente mais tarde.", []


==== /home/ubuntu/famdomes_backend/app/utils/prompt_builder.py ====
# utils/prompt_builder.py
import os
from pymongo import MongoClient
from app.config import MONGO_URI
import logging
from datetime import datetime

# Configura√ß√£o do Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Conex√£o MongoDB (Idealmente, usar Motor para async, mas mantendo pymongo por enquanto)
# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Usar o nome do seu banco de dados
    colecao_historico = db["respostas_ia"] # Cole√ß√£o para hist√≥rico de conversas
    logging.info("Conex√£o com MongoDB estabelecida para Prompt Builder.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Prompt Builder: {e}")
    # Tratar falha de conex√£o adequadamente - talvez retornar erro ou usar prompt padr√£o
    mongo = None
    colecao_historico = None

# Caminho absoluto para o arquivo de prompt mestre
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt") # Ajuste o caminho se necess√°rio

def carregar_prompt_mestre() -> str:
    """Carrega o conte√∫do do arquivo de prompt mestre."""
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        logging.error(f"‚ùå ERRO: Arquivo de prompt mestre n√£o encontrado em {CAMINHO_PROMPT_TXT}")
        # Retorna um prompt padr√£o seguro em caso de falha
        return (
            "Voc√™ √© um assistente virtual focado em sa√∫de mental e depend√™ncia qu√≠mica.\n"
            "Seja emp√°tico, claro e objetivo. Ofere√ßa apoio e informa√ß√µes sobre agendamento quando apropriado.\n"
            "Responda em portugu√™s brasileiro."
        )
    except Exception as e:
        logging.error(f"‚ùå ERRO ao carregar prompt mestre: {e}")
        # Retorna um prompt padr√£o seguro
        return (
            "Voc√™ √© um assistente virtual focado em sa√∫de mental e depend√™ncia qu√≠mica.\n"
            "Seja emp√°tico, claro e objetivo. Ofere√ßa apoio e informa√ß√µes sobre agendamento quando apropriado.\n"
            "Responda em portugu√™s brasileiro."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    """Constr√≥i o prompt final para a IA, incluindo o mestre, hist√≥rico e a pergunta atual."""
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []

    if colecao_historico:
        try:
            # Busca as √∫ltimas N intera√ß√µes (usu√°rio + resposta)
            # Limitando a 5 pares (10 documentos) e ordenando por cria√ß√£o
            historico_recente = list(
                colecao_historico.find({"telefone": telefone})
                .sort("criado_em", -1) # Mais recentes primeiro
                .limit(10) # Pegar ultimos 10 docs (5 pares user/bot)
            )
            historico_recente.reverse() # Reverter para ordem cronol√≥gica

            # Formata o hist√≥rico para o prompt
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item: # Mensagem do usu√°rio
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente: # Resposta do bot
                    pares_formatados.append(f"Usu√°rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None # Reseta para o pr√≥ximo par

            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                 trecho_historico = "Nenhuma conversa anterior registrada."

        except Exception as e:
            logging.error(f"‚ùå ERRO ao buscar hist√≥rico do MongoDB para {telefone}: {e}")
            trecho_historico = "Erro ao carregar hist√≥rico."
    else:
        trecho_historico = "Hist√≥rico indispon√≠vel (sem conex√£o DB)."

    # Obter data e hora atual para contexto (opcional)
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
N√∫mero do Usu√°rio (ocultar na resposta final): {telefone}
---
Hist√≥rico da Conversa (mais antigo para mais recente):
{trecho_historico}
---
Nova Mensagem do Usu√°rio:
Usu√°rio: {pergunta_atual.strip()}
---
Instru√ß√µes para sua Resposta:
1.  Responda como 'Assistente'.
2.  Mantenha o tom emp√°tico, acolhedor e profissional definido no prompt mestre.
3.  Use linguagem clara e acess√≠vel, evitando jarg√µes t√©cnicos excessivos.
4.  Respostas devem ser concisas: idealmente 1-3 par√°grafos curtos. Max 400 caracteres se poss√≠vel.
5.  Se a conversa indicar necessidade de agendamento ou mais informa√ß√µes, ofere√ßa isso proativamente.
6.  N√ÉO inclua o hist√≥rico ou as instru√ß√µes na sua resposta final.
7.  N√ÉO use placeholders como {{TOKEN}} ou similares. Gere a resposta final completa.
8.  Responda SEMPRE em portugu√™s brasileiro.
---

Assistente:""" # Deixa o prompt pronto para a IA completar

    logging.info(f"Prompt constru√≠do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    # logging.debug(f"Prompt Final para IA:\n{prompt_final}") # Log do prompt completo (cuidado com dados sens√≠veis)

    return prompt_final


==== /home/ubuntu/famdomes_backend/app/utils/mensageria.py ====
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("‚ö†Ô∏è Tentativa de enviar mensagem vazia ou sem destinat√°rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url √© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razo√°vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"‚úÖ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padr√£o Cl√≠nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfa√ß√£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com bot√£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de bot√£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # √çndice do bot√£o no template
                    # "parameters": [] # Par√¢metros espec√≠ficos do bot√£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"‚úÖ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/utils/contexto.py ====
# utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
# Considere usar Motor para chamadas ass√≠ncronas.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"] # Nome do DB
    contextos_db = db["contexto_conversa"] # Cole√ß√£o para contextos
    logging.info("Conex√£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Atualiza ou insere dados no contexto da conversa para um telefone espec√≠fico.
    'dados_atualizacao' deve ser um dicion√°rio com os campos a serem atualizados/adicionados.
    """
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel salvar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inv√°lido (sem telefone ou dados inv√°lidos).")
        return False

    try:
        logging.debug(f"Salvando contexto para {telefone}: {dados_atualizacao}")
        resultado = contextos_db.update_one(
            {"telefone": telefone},
            {
                "$set": dados_atualizacao,
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da modifica√ß√£o
                "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()} # Define na cria√ß√£o
            },
            upsert=True # Cria o documento se n√£o existir
        )
        logging.info(f"Contexto para {telefone} salvo. Modificado: {resultado.modified_count}, Upserted ID: {resultado.upserted_id}")
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    """Recupera o contexto atual da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel obter contexto para {telefone}: Sem conex√£o com DB.")
        return {} # Retorna dicion√°rio vazio para evitar erros

    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}

    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            logging.debug(f"Contexto encontrado para {telefone}.")
            return contexto
        else:
            logging.debug(f"Nenhum contexto encontrado para {telefone}, retornando vazio.")
            return {} # Retorna dicion√°rio vazio se n√£o encontrar
    except Exception as e:
        logging.error(f"‚ùå ERRO ao obter contexto para {telefone}: {e}")
        return {} # Retorna dicion√°rio vazio em caso de erro

def limpar_contexto(telefone: str):
    """Remove o estado salvo (contexto) da conversa para um telefone."""
    if not contextos_db:
        logging.error(f"N√£o foi poss√≠vel limpar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False

    try:
        resultado = contextos_db.delete_one({"telefone": telefone})
        if resultado.deleted_count > 0:
            logging.info(f"Contexto para {telefone} limpo com sucesso.")
            return True
        else:
            logging.warning(f"Tentativa de limpar contexto para {telefone}, mas nenhum foi encontrado.")
            return False
    except Exception as e:
        logging.error(f"‚ùå ERRO ao limpar contexto para {telefone}: {e}")
        return False

def atualizar_ultimo_acesso(telefone: str):
    """Apenas atualiza o timestamp do √∫ltimo acesso no contexto."""
    salvar_contexto(telefone, {}) # Salva um dict vazio que s√≥ atualizar√° o $currentDate


==== /home/ubuntu/famdomes_backend/app/utils/db.py ====
from datetime import datetime, timedelta

# Simula pr√≥xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula grava√ß√£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} √†s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO M√âDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suic√≠dio", "morrer", "n√£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)



==== /home/ubuntu/famdomes_backend/app/utils/risco.py ====
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases cr√≠ticas (ajuste conforme necess√°rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suic√≠dio", "me matar", "quero morrer", "n√£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperan√ßa", "adeus mundo", "n√£o quero viver",
    # Adicionar termos relacionados a auto-mutila√ß√£o se aplic√°vel
    # Adicionar termos relacionados a amea√ßas a terceiros se aplic√°vel
]

# Adicionar palavras/frases que indicam URG√äNCIA M√âDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
    "desmaiado", "convuls√£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emerg√™ncias m√©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suic√≠dio, urg√™ncia m√©dica).
    Retorna um dicion√°rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"üö® RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"üöë URG√äNCIA M√âDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }


==== /home/ubuntu/famdomes_backend/app/utils/agenda.py ====
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configura√ß√£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias √∫teis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (n√£o agenda √†s 18:00, √∫ltimo √© 17:40)

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar √≠ndice para garantir que n√£o haja duas consultas no mesmo hor√°rio
    consultas_db.create_index("horario", unique=True)
    logging.info("Conex√£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avan√ßa o hor√°rio para o pr√≥ximo bloco de X minutos dentro do hor√°rio de opera√ß√£o."""
    horario = inicio_base

    # Arredonda para o pr√≥ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no in√≠cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o hor√°rio de opera√ß√£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (S√°bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o pr√≥ximo hor√°rio livre e agenda a consulta.
    Retorna o datetime do hor√°rio agendado ou None se n√£o encontrar.
    """
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel agendar: Sem conex√£o com DB.")
        return None

    # Usar UTC para armazenamento no DB √© uma boa pr√°tica
    agora_utc = datetime.now(timezone.utc)
    # Come√ßa a procurar X minutos √† frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se j√° existe consulta nesse hor√°rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou hor√°rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o hor√°rio em UTC
            else:
                # Hor√°rio ocupado, avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verifica√ß√£o/inser√ß√£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exce√ß√£o

    logging.warning(f"N√£o foram encontrados hor√°rios dispon√≠veis para {telefone} ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se n√£o encontrar hor√°rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel cancelar: Sem conex√£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda n√£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"üóëÔ∏è Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"‚ùå ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o pr√≥ximo hor√°rio dispon√≠vel sem agendar."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel consultar hor√°rio: Sem conex√£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Come√ßa a procurar um pouco √† frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Pr√≥ximo hor√°rio dispon√≠vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna hor√°rio em UTC
            else:
                # Avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao consultar pr√≥ximo hor√°rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum hor√°rio dispon√≠vel encontrado na consulta ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um hor√°rio UTC para uma string leg√≠vel no fuso hor√°rio local."""
    if not horario_utc:
        return "Indispon√≠vel"
    try:
        # Precisa da biblioteca pytz para fusos hor√°rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Ter√ßa-feira, 15 de Abril √†s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B √†s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz n√£o instalada. Usando formata√ß√£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar hor√°rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formata√ß√£o"
def consultar_horario():
    return "amanh√£ √†s 10h"



==== /home/ubuntu/famdomes_backend/app/utils/ia_fallback.py ====
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(pergunta: str, telefone: str = "00000000000") -> str:
    resposta, _ = await chamar_ollama_completo(pergunta, telefone)
    return resposta



==== /home/ubuntu/famdomes_backend/app/utils/followup.py ====
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a fun√ß√£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a fun√ß√£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # N√£o precisa mais buscar aqui, usa agenda.py
    logging.info("Conex√£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Fun√ß√µes de Simula√ß√£o (Removidas ou Substitu√≠das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> L√≥gica est√° em agenda.py
# avisar_profissional -> Deveria ser chamado ap√≥s agendamento real
# avisar_paciente -> Deveria ser chamado ap√≥s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o in√≠cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel iniciar sess√£o de pagamento: Sem conex√£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESS√ÉO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao iniciar sess√£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sess√£o como paga, agenda a consulta e retorna o hor√°rio agendado e nome.
    Esta fun√ß√£o √© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel marcar pagamento: Sem conex√£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que s√≥ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualiza√ß√£o se n√£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, ent√£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome j√° est√° l√° do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sess√£o ser criada, ou se j√° foi processado
            logging.warning(f"Sess√£o de pagamento n√£o encontrada ou j√° processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sess√£o
        logging.info(f"[SESS√ÉO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sess√£o com o hor√°rio agendado (opcional, mas √∫til)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sess√£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para poss√≠vel notifica√ß√£o manual

    except Exception as e:
        logging.error(f"‚ùå ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Fun√ß√£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # L√≥gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo n√∫mero real ou l√≥gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"üë®‚Äç‚öïÔ∏è Nova consulta agendada: {nome_paciente} ({telefone_paciente}) √†s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("N√∫mero do m√©dico n√£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Fun√ß√£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sess√µes com pagamento pendente h√° muito tempo."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel checar followup: Sem conex√£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "voc√™")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Ol√° {nome}, notei que voc√™ iniciou um agendamento mas parece que n√£o foi conclu√≠do. üò•\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma d√∫vida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. üòä"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sess√£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"‚ùå ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # Fun√ß√£o ainda n√£o implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0




==== /home/ubuntu/famdomes_backend/app/schemas/ia_comando.py ====
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str



==== /home/ubuntu/famdomes_backend/app/intents/router_intents.py ====
# app/api/router_intents.py

from fastapi import APIRouter, Request
from app.intents.intent_executor import IntentExecutor

router = APIRouter()

@router.post("/mensagem")
async def receber_mensagem(payload: dict):
    telefone = payload.get("telefone")
    mensagem = payload.get("mensagem")
    nome = payload.get("nome", "Paciente")

    if not telefone or not mensagem:
        return {"erro": "Campos obrigat√≥rios faltando"}

    executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
    resultado = await executor.executar()

    return {
        "status": "ok",
        "mensagem": mensagem,
        "intent_detectada": resultado["intent"],
        "resposta_enviada": resultado["resposta"],
        "risco": resultado["risco"]
    }


==== /home/ubuntu/famdomes_backend/app/intents/__init__.py ====



==== /home/ubuntu/famdomes_backend/app/intents/intent_executor.py ====
# app/intents/intent_executor.py

from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.agenda import consultar_proximo_horario_disponivel as consultar_horario
from app.utils.followup import iniciar_sessao
from app.utils.mensageria import enviar_mensagem
from app.utils.ia_fallback import chamar_ollama
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.intents.intents_map import INTENTS
import unicodedata
import re
import logging  # Importe o m√≥dulo de logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

MENSAGEM_INICIAL = (
    "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que n√£o √© f√°cil buscar ajuda.\n\n"
    "ü§ù Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "üì≤ Quer saber como podemos ajudar?"
)

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim", "segue", "vai",
    "t√¥ aqui pra isso", "pode falar", "√© isso", "ok", "t√°", "t√° bom", "isso", "por favor", "sim quero"
]

RESPOSTAS_NEGATIVAS = [
    "n√£o", "nao", "talvez depois", "n√£o agora", "deixa pra depois",
    "t√¥ s√≥ olhando", "s√≥ pesquisando", "agora n√£o"
]

# Limiar de confian√ßa para a intent (ajuste conforme necess√°rio)
LIMIAR_CONFIANCA_INTENT = 0.7

def normalizar_texto(texto):
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

def extrair_nome_usuario(mensagem: str) -> str | None:
    padroes = [
        r"(?:me chamo|sou o|sou a|sou|aqui √© o|aqui √© a|meu nome √©|me chamo √©)\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)",
        r"nome √©\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)"
    ]
    for padrao in padroes:
        match = re.search(padrao, mensagem, re.IGNORECASE)
        if match:
            nome = match.group(1).strip().capitalize()
            if "melancia" not in nome.lower():
                return nome
    return None

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)  # Carregar contexto no __init__
        self.intent_confianca = 1.0  # Inicialmente, confian√ßa alta

    def detectar_intent(self):
        # L√≥gica de detec√ß√£o de intent (pode ser aprimorada com ML)
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"

        ultima_pergunta = self.contexto.get("ultima_pergunta", "").strip().lower()

        if ultima_pergunta:
            if self.mensagem_normalizada in RESPOSTAS_SIM:
                if "quer saber como podemos ajudar" in ultima_pergunta or "quer entender como funciona" in ultima_pergunta:
                    return "quero_entender"
                if "posso te mostrar como agendar" in ultima_pergunta or "agendar uma consulta" in ultima_pergunta:
                    return "quero_agendar"
            elif self.mensagem_normalizada in RESPOSTAS_NAO:
                return "cancelar"

        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if normalizar_texto(g) in self.mensagem_normalizada:
                    return intent

        logging.info(f"[FALLBACK IA] Nenhuma intent reconhecida. Mensagem: '{self.mensagem}'")
        self.intent_confianca = 0.5  # Baixa confian√ßa para fallback
        return "desconhecida"

    def limpar_resposta(self, texto: str) -> str:
        texto = re.sub(r"\(.*?\)", "", texto).strip()
        texto = re.sub(r"melancia vermelha", "", texto, flags=re.IGNORECASE)
        return texto.strip()

    def verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0

    def resposta_confirmacao(self, contexto):
        intent_desejada = contexto.get("intent_esperada")
        if intent_desejada:
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent_desejada
            })
            return self.responder_por_intent(intent_desejada)
        return "Tudo certo! Me lembra do que voc√™ precisa, que eu te ajudo agora mesmo."

    async def executar(self):
        self._extrair_informacoes_usuario()

        if self._verificar_reset():
            return self._processar_reset()

        if self._verificar_primeira_interacao():
            return self._processar_primeira_interacao()

        return await self._processar_intents_e_responder()

    def _extrair_informacoes_usuario(self):
        nome_extraido = extrair_nome_usuario(self.mensagem)
        if nome_extraido:
            self.nome = nome_extraido
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": self.nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": self.nome})

    def _verificar_reset(self):
        return self.mensagem_normalizada == "melancia vermelha"

    def _processar_reset(self):
        limpar_contexto(self.telefone)
        self.intent_confianca = 1.0
        return {"intent": "reset_manual", "resposta": "üîÑ Hist√≥rico de testes apagado com sucesso. Pode come√ßar uma nova simula√ß√£o.", "risco": False}

    def _verificar_primeira_interacao(self):
        return historico.count_documents({"telefone": self.telefone}) == 0 and \
               self.mensagem_normalizada in ["oi", "ola", "ol√°", "bom dia", "boa tarde", "boa noite"]

    def _processar_primeira_interacao(self):
        salvar_contexto(self.telefone, {
            "intent_esperada": "quero_agendar",
            "aguardando_confirmacao": True,
            "ultima_pergunta": "Quer saber como podemos ajudar?"
        })
        self.intent_confianca = 1.0
        return {"intent": "boas_vindas", "resposta": MENSAGEM_INICIAL, "risco": False}

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        if self.contexto.get("aguardando_confirmacao") and \
           (any(frase in self.mensagem_normalizada.split() for frase in RESPOSTAS_CONFIRMATIVAS) or
            any(f in self.mensagem_normalizada for f in RESPOSTAS_CONFIRMATIVAS if " " in f)):
            resposta = self.resposta_confirmacao(self.contexto)
            intent = self.contexto.get("intent_esperada") or "confirmacao_positiva"
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o

        elif intent == "desconhecida":
            resposta = await self._processar_intent_desconhecida()

        else:
            resposta = self.responder_por_intent(intent)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })

        return self._gerar_resposta(intent, resposta, risco)

    async def _processar_intent_desconhecida(self):
        if self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            resposta = self.resposta_confirmacao(self.contexto)
            self.intent_confianca = 0.9  # Alta confian√ßa na confirma√ß√£o
            return resposta
        else:
            resposta = await chamar_ollama(self.mensagem, self.telefone)
            resposta = self.limpar_resposta(resposta)
            if len(resposta) > 600:
                resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
            self.intent_confianca = 0.6  # M√©dia confian√ßa em respostas da IA
            return resposta

    def _gerar_resposta(self, intent, resposta, risco):
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })
        return {"intent": intent, "resposta": resposta, "risco": risco}

    def responder_por_intent(self, intent):
        respostas = {
        # IN√çCIO
        "boas_vindas": MENSAGEM_INICIAL,
        "quero_agendar": f"üìÖ √ìtimo! Posso te ajudar a agendar com nosso m√©dico especialista. Quer que eu envie o link agora, {self.nome}?",
        "ver_horario": f"üìÜ O pr√≥ximo hor√°rio dispon√≠vel √©: {consultar_horario()}. Posso reservar pra voc√™?",

        # VALORES
        "duvida_valores": "üí∞ Temos valores acess√≠veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

        # GERAL / CONFIAN√áA
        "duvida_geral": "üìã Nosso sistema conecta voc√™ com m√©dicos especialistas de verdade. Quer saber como funciona na pr√°tica?",
        "desconfianca": "üîç Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

        # DEPEND√äNCIA / RECA√çDA / SINTOMAS
        "duvida_dependencia": "üß† A depend√™ncia qu√≠mica √© trat√°vel. Nosso m√©dico pode avaliar sintomas f√≠sicos e emocionais. Quer agendar?",
        "sou_dependente": "üí¨ Reconhecer isso √© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
        "recaida": "üîÅ Reca√≠das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
        "abstinencia": "üòì Os sintomas de abstin√™ncia s√£o desafiadores. Podemos te orientar com seguran√ßa. Posso marcar agora?",

        # CRISE / URG√äNCIA
        "sintomas_graves": "‚ö†Ô∏è Sinais de crise detectados. Posso encaminhar voc√™ para um atendimento urgente. Deseja ajuda agora?",
        "amea√ßa_vida": "üö® Sua vida importa. Posso ativar nosso acolhimento de urg√™ncia. Quer que eu inicie agora?",

        # FAMILIAR
        "sou_familiar": "üë™ Voc√™ quer ajudar algu√©m importante. Posso te explicar como funciona e agendar uma escuta para voc√™ ou para ele(a).",
        "familia_pedindo_ajuda": "üß≠ Voc√™ est√° no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
        "familiar_em_crise": "üö® Situa√ß√£o familiar cr√≠tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
        "familia_nao_aceita": "üòî √â dif√≠cil quando a fam√≠lia n√£o apoia. Mas h√° caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
        "familia_quebrada": "üíî Muitas fam√≠lias passam por isso. Podemos ajudar na reconstru√ß√£o. Quer agendar uma orienta√ß√£o especializada?",
        "familiar_violento": "‚ö†Ô∏è Em casos de viol√™ncia, seguran√ßa vem primeiro. Posso te mostrar como agir com respaldo m√©dico e legal.",

        # INTERNA√á√ÉO
        "duvida_internacao": "üè• A interna√ß√£o pode ser volunt√°ria ou involunt√°ria, sempre com avalia√ß√£o m√©dica. Quer saber como isso funciona?",
        "quero_internar": "‚úÖ Posso te mostrar o processo completo, legal e cl√≠nico. Posso agendar agora com nosso m√©dico?",

        # FUNIL / OBJEC√ïES / CIRCUNST√ÇNCIAS
        "nao_quero_internar": "Tudo bem. Interna√ß√£o n√£o √© a √∫nica sa√≠da. Posso te explicar outras op√ß√µes com orienta√ß√£o m√©dica.",
        "meu_parente_usa_droga": "üí¨ Entendo. Posso agendar com o especialista pra avaliar a situa√ß√£o de forma profissional.",
        "crise_agora": "‚ö†Ô∏è Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
        "relato_dependencia": "üí° Obrigado por compartilhar. Posso te ajudar com os pr√≥ximos passos. Deseja conversar com o especialista?",
        "resistencia_paciente": "üòî A resist√™ncia √© comum. Mesmo assim, a fam√≠lia pode iniciar a a√ß√£o. Quer que eu te oriente sobre isso?",
        "resistencia_familiar": "üë• Se a fam√≠lia n√£o colabora, podemos trabalhar com quem estiver dispon√≠vel. Posso mostrar como agir mesmo assim?",
        "nao_sou_usuario": "üëç Tranquilo. Se quiser ajudar algu√©m ou tirar d√∫vidas, posso te explicar tudo com calma.",

        # INFORMA√á√ïES COMPLEMENTARES
        "quero_entender": "üìò Posso te explicar tudo sobre o atendimento, desde a escuta at√© o tratamento. Quer come√ßar agora?",
        "curioso": "üòÑ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simula√ß√£o real?",
        "pergunta_medico": "üë®‚Äç‚öïÔ∏è O m√©dico √© especialista em depend√™ncia qu√≠mica e avalia√ß√£o cl√≠nica. Quer agendar a escuta?",
        "duvida_medicacao": "üíä Medicamentos s√≥ s√£o indicados ap√≥s avalia√ß√£o. Posso agendar com o profissional, se quiser.",
        "duvida_psicologo": "üß† Temos psic√≥logos na equipe. A avalia√ß√£o inicial √© m√©dica. Quer seguir por esse caminho?",

        # INTENTS EMOCIONAIS / REDE DE APOIO
        "desistiu_antes": "üîÅ Recome√ßar √© poss√≠vel. Estamos aqui pra isso. Quer conversar com o m√©dico novamente?",
        "vergonha_de_falar": "üß° Tudo bem. N√£o precisa se explicar agora. Posso s√≥ ouvir, se quiser.",
        "culpa_familiar": "ü§ù A culpa n√£o ajuda, mas o cuidado sim. Posso te mostrar como come√ßar com leveza.",
        "busca_ajuda_emocional": "üí¨ Tamb√©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
        "ajuda_espiritual": "üõê Respeitamos todas as cren√ßas. O acolhimento √© humano, com base √©tica. Posso te explicar melhor?",

        # LEGAIS / CIDADANIA
        "internacao_judicial": "‚öñÔ∏è A interna√ß√£o judicial √© poss√≠vel. Posso te explicar o processo legal e como iniciar.",
        "menor_de_idade": "üë∂ Tratamos casos de menores com responsabilidade. Posso te mostrar os crit√©rios e caminhos.",
        "direitos_paciente": "üìú Tudo √© feito conforme a √©tica m√©dica e a lei. Posso esclarecer o que for preciso.",

        # INSTITUCIONAIS
        "duvida_local": "üìç Temos atendimento online e unidades f√≠sicas. Quer saber se tem perto de voc√™?",
        "duvida_profissionais": "üë©‚Äç‚öïÔ∏è Temos m√©dicos, terapeutas e psic√≥logos. Posso te mostrar como funciona cada etapa.",
        "duvida_sigilo": "üîí Todo atendimento √© sigiloso. Nada √© compartilhado sem sua autoriza√ß√£o. Pode confiar.",

        # CONTROLE DE FLUXO
        "cancelar":"‚úÖ Consulta cancelada. Se quiser retomar, √© s√≥ me avisar.",
        "teste": "üß™ Est√° testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
        "elogio": "‚ù§Ô∏è Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na pr√°tica.",
        "erro": "üîÅ Algo deu errado? Posso reenviar ou corrigir rapidinho.",
        "sem_compreensao": "ü§î N√£o entendi muito bem. Pode tentar explicar de outra forma?",
        "confirmacao_positiva": "üëç Perfeito. Vou seguir com o que propus antes.",
        "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
    }
        # Adicione sugest√µes de pr√≥ximos passos para manter o fluxo
        proximos_passos = {
            "quero_agendar": "\nPosso te enviar o link de agendamento ou voc√™ gostaria de saber mais sobre o processo?",
            "duvida_valores": "\nPosso te mostrar as formas de pagamento ou voc√™ tem alguma outra d√∫vida?",
            "duvida_geral": "\nPosso te explicar em mais detalhes ou voc√™ gostaria de agendar uma consulta?",
            "sou_dependente": "\nVoc√™ gostaria de agendar uma consulta ou precisa de mais informa√ß√µes?",
            "sintomas_graves": "\nPosso te conectar com um profissional de imediato. Deseja prosseguir?",
            "sou_familiar": "\nVoc√™ gostaria de agendar uma consulta para voc√™ ou para o seu familiar?",
            "duvida_internacao": "\nPosso te explicar o processo de interna√ß√£o ou voc√™ gostaria de saber as op√ß√µes de tratamento?",
            "desconhecida": "\nPosso tentar entender melhor se voc√™ reformular a pergunta ou gostaria de ver as op√ß√µes de ajuda dispon√≠veis?",
            "default": "\nPosso te ajudar com mais alguma coisa?"  # Um caso padr√£o
        }

        resposta += proximos_passos.get(intent, proximos_passos["default"])
        return resposta


==== /home/ubuntu/famdomes_backend/app/intents/intents_map.py ====
# intents/intents_map.py
# Mapeamento de intents para palavras-chave/gatilhos.
# Usado pelo NLUClassifier baseado em keywords.
# Considere usar um formato mais estruturado (ex: YAML) se ficar muito grande.

INTENTS = {
    # üöÄ IN√çCIO DO FUNIL
    "boas_vindas": [
        "oi", "ol√°", "ola", "bom dia", "boa tarde", "boa noite", "e a√≠", "fala comigo", "tudo bem", "como vai"
    ],

    # üë§ QUERO AGENDAR / HOR√ÅRIOS
    "quero_agendar": [
        "quero agendar", "como agendo", "quero atendimento", "quero uma consulta", "como marcar",
        "tem como agendar", "preciso de um m√©dico", "consulta urgente", "quero ajuda m√©dica",
        "agendar", "marcar consulta", "atendimento m√©dico", "agendar consulta"
    ],
    "ver_horario": [
        "tem hor√°rio", "que horas tem", "tem agenda", "qual o pr√≥ximo hor√°rio", "quero saber os hor√°rios",
        "hor√°rios dispon√≠veis", "agenda livre", "consultar hor√°rio", "ver agenda"
    ],

    # üí∞ VALORES E PAGAMENTO
    "duvida_valores": [
        "quanto custa", "qual o valor", "pre√ßo", "tem plano", "√© caro", "valores da consulta", "paga quanto", "√© gratuito?",
        "aceita conv√™nio", "plano de sa√∫de", "parcelar", "tem desconto", "formas de pagamento", "pagamento", "custo"
    ],

    # ‚ùì D√öVIDAS GERAIS / CONFIAN√áA
    "duvida_geral": [
        "como funciona", "me explica", "o que voc√™s fazem", "isso √© pra qu√™", "como ajudam", "qual o tratamento",
        "o que √© isso", "para que serve", "me fale mais", "detalhes"
    ],
    "desconfianca": [
        "isso √© real?", "posso confiar?", "√© golpe?", "tem CNPJ?", "quem s√£o voc√™s?", "√© confi√°vel?", "funciona mesmo?",
        "√© seguro?", "garantia", "√© empresa?"
    ],

    # üìö SOBRE DEPEND√äNCIA / V√çCIO
    "duvida_dependencia": [
        "o que √© depend√™ncia qu√≠mica", "quais os sintomas", "isso tem cura", "como saber se sou dependente",
        "v√≠cio em drogas", "meu caso tem jeito", "isso √© doen√ßa?", "uso mas n√£o sou viciado", "tem tratamento",
        "depend√™ncia", "v√≠cio", "drogas", "alcoolismo", "sintomas de v√≠cio"
    ],
    "sou_dependente": [
        "sou viciado", "tenho v√≠cio", "sou dependente qu√≠mico", "tenho problema com droga", "uso todo dia",
        "n√£o consigo parar", "preciso parar de usar", "sou alco√≥latra", "viciado"
    ],
    "recaida": [
        "tive reca√≠da", "usei de novo", "n√£o consegui parar", "recomecei", "ca√≠ de novo",
        "reca√≠", "voltei a usar", "escorreguei", "tive um deslize"
    ],
    "abstinencia": [
        "t√¥ tremendo", "t√¥ suando", "n√£o t√¥ bem", "t√¥ em abstin√™ncia", "t√¥ agoniado", "t√¥ passando mal sem usar",
        "sintomas de abstin√™ncia", "fissura", "crise de abstin√™ncia"
    ],

    # üß† SINTOMAS GRAVES / CRISE / URG√äNCIA
    "sintomas_graves": [
        "t√° surtando", "alucina√ß√£o", "t√° agressivo", "n√£o dorme h√° dias", "vis√µes", "del√≠rio", "t√° em crise",
        "descontrolado", "sem no√ß√£o do que faz", "paranoia", "confus√£o mental", "surto psic√≥tico"
    ],
    "amea√ßa_vida": [ # Risco de suic√≠dio/auto-mutila√ß√£o
        "quero morrer", "vou me matar", "n√£o quero viver", "quero sumir", "vou acabar com tudo", "vida n√£o faz sentido",
        "me cortar", "me machucar", "despedida", "adeus"
    ],
     "urgencia_medica": [ # Emerg√™ncia m√©dica clara
        "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
        "desmaiado", "convuls√£o", "sangrando muito", "veneno", "infarto", "avc", "emerg√™ncia"
    ],


    # üë®‚Äçüë©‚Äçüë¶ FAMILIAR EM BUSCA DE AJUDA
    "sou_familiar": [
        "sou m√£e", "sou pai", "sou esposa", "sou marido", "sou irm√£o", "sou irm√£", "sou filho", "sou filha",
        "estou procurando ajuda pra ele", "meu filho usa droga", "minha filha usa droga",
        "quero ajudar meu marido", "quero ajudar minha esposa", "meu parente", "familiar"
    ],
    "familia_pedindo_ajuda": [
        "meu filho t√° viciado", "minha filha t√° usando", "meu marido n√£o aceita ajuda", "ele n√£o quer se tratar",
        "n√£o sei mais o que fazer com ele", "ajuda para familiar", "parente com problema", "como ajudar"
    ],
    "familiar_em_crise": [
        "ele surtou agora", "ela t√° gritando", "quebrou tudo", "ele fugiu", "ela fugiu", "t√° se machucando", "t√° em crise agora",
        "parente em crise", "familiar agressivo", "preciso de ajuda urgente para ele"
    ],
     "resistencia_paciente": [ # Familiar relata que o paciente resiste
        "ele n√£o quer ajuda", "ela n√£o aceita", "n√£o quer tratamento", "n√£o admite que tem problema",
        "n√£o quer ser internado", "n√£o aceita m√©dico", "resiste ao tratamento"
    ],

    # üè• INTERNA√á√ÉO
    "duvida_internacao": [
        "como funciona a interna√ß√£o", "quanto tempo dura", "volta pra casa depois?", "como √© o lugar",
        "tem visita?", "fica trancado?", "interna√ß√£o involunt√°ria", "√© for√ßado?", "tem psiquiatra?",
        "interna√ß√£o", "cl√≠nica de recupera√ß√£o", "tratamento internado"
    ],
    "quero_internar": [
        "quero internar meu filho", "como fa√ßo pra internar", "internar contra a vontade", "internar urgente",
        "preciso internar", "interna√ß√£o compuls√≥ria", "interna√ß√£o involunt√°ria"
    ],
    "nao_quero_internar": [ # Paciente ou familiar expressa n√£o querer interna√ß√£o
        "n√£o quero internar", "sem interna√ß√£o", "tratamento sem internar", "n√£o precisa de cl√≠nica",
        "alternativa √† interna√ß√£o", "tratamento ambulatorial"
    ],

    # ‚öñÔ∏è QUEST√ïES LEGAIS / JUR√çDICAS
    "internacao_judicial": [
        "posso pedir pra justi√ßa?", "como internar judicialmente", "internar por ordem judicial", "meu advogado falou",
        "interna√ß√£o compuls√≥ria", "justi√ßa", "ordem do juiz"
    ],
    "menor_de_idade": [
        "meu filho √© menor", "ela tem 15 anos", "posso internar menor?", "menor pode ser internado?",
        "tratamento para adolescente", "menor de idade", "crian√ßa"
    ],
    "direitos_paciente": [
        "ele pode sair?", "ele √© obrigado?", "isso √© legal?", "tem que assinar algo?", "respeita os direitos?",
        "direitos humanos", "advogado", "lei"
    ],

    # üí¨ OUTRAS SITUA√á√ïES / RELATOS
     "meu_parente_usa_droga": [ # Relato mais geral sobre uso de drogas por parente
        "meu parente usa droga", "descobri que meu filho fuma", "meu marido bebe demais",
        "preocupado com familiar que usa drogas"
    ],
     "relato_dependencia": [ # Usu√°rio falando sobre seu pr√≥prio uso/dificuldades
        "uso crack faz tempo", "bebo todo dia", "gasto tudo com droga", "minha vida t√° destru√≠da",
        "preciso de ajuda com meu v√≠cio"
    ],
     "resistencia_familiar": [ # Paciente relata que a fam√≠lia n√£o apoia/atrapalha
        "minha fam√≠lia n√£o me apoia", "minha esposa n√£o entende", "meus pais n√£o aceitam",
        "fam√≠lia contra o tratamento", "n√£o tenho apoio"
    ],
     "nao_sou_usuario": [ # Deixa claro que n√£o √© o paciente
        "n√£o sou eu que uso", "√© para um amigo", "s√≥ estou pesquisando", "quero informa√ß√£o para outra pessoa",
        "n√£o sou usu√°rio"
    ],

    # ‚ÑπÔ∏è BUSCA DE INFORMA√á√ïES ADICIONAIS
     "quero_entender": [ # Pedido expl√≠cito para entender o servi√ßo/processo
        "quero entender melhor", "me explica o processo", "como funciona o atendimento",
        "quais as etapas", "o que acontece depois"
    ],
     "curioso": [ # Demonstra√ß√£o de curiosidade ou teste
        "s√≥ testando", "kkk", "haha", "curioso", "testando sistema", "s√≥ vendo como funciona",
        "teste", "simula√ß√£o"
    ],
    "pergunta_medico": [ # D√∫vida espec√≠fica sobre o profissional m√©dico
        "quem √© o m√©dico?", "qual a especialidade?", "√© psiquiatra?", "posso escolher o m√©dico?",
        "falar com o m√©dico"
    ],
     "duvida_medicacao": [ # D√∫vida sobre rem√©dios
        "vai precisar de rem√©dio?", "usam medica√ß√£o?", "quais rem√©dios?", "tratamento com rem√©dio",
        "medica√ß√£o psiqui√°trica"
    ],
     "duvida_psicologo": [ # D√∫vida sobre psic√≥logo/terapia
        "tem psic√≥logo?", "faz terapia?", "atendimento psicol√≥gico", "terapia de grupo",
        "psicoterapia"
    ],
    "duvida_local": [ # D√∫vida sobre local f√≠sico/online
        "onde fica?", "tem na minha cidade?", "qual o endere√ßo?", "atende onde?", "√© presencial ou online?",
        "atendimento online", "unidade f√≠sica", "endere√ßo da cl√≠nica"
    ],
     "duvida_profissionais": [ # D√∫vida geral sobre a equipe
        "quem s√£o os profissionais?", "tem terapeuta?", "quem atende?", "√© s√≥ m√©dico?",
        "equipe multidisciplinar"
    ],
    "duvida_sigilo": [ # D√∫vida sobre confidencialidade
        "isso √© sigiloso?", "meus dados est√£o protegidos?", "algu√©m vai saber?", "√© confidencial?",
        "privacidade", "segredo m√©dico"
    ],


    # ‚ù§Ô∏è INTENTS EMOCIONAIS / REDE DE APOIO
     "desistiu_antes": [ # J√° tentou tratamento antes e parou
        "j√° tentei parar antes", "desisti do tratamento", "n√£o funcionou da outra vez",
        "j√° fiz tratamento e n√£o adiantou", "recome√ßar tratamento"
    ],
    "vergonha_de_falar": [
        "tenho vergonha", "me sinto mal de contar", "nunca falei isso pra ningu√©m", "√© dif√≠cil falar sobre isso",
        "medo de julgamento", "constrangido"
    ],
    "culpa_familiar": [ # Familiar expressando culpa
        "acho que √© culpa minha", "fui negligente", "acho que errei como pai", "deixei isso acontecer",
        "me sinto culpado", "onde eu errei"
    ],
    "busca_ajuda_emocional": [ # Pedido de ajuda mais amplo, focado no emocional
        "preciso de ajuda emocional", "t√¥ mal", "t√¥ triste", "ansiedade", "crise de p√¢nico", "sou depressivo", "t√¥ vazio",
        "angustiado", "preciso conversar", "apoio emocional"
    ],
    "ajuda_espiritual": [ # Quest√µes sobre religi√£o/espiritualidade
        "√© contra religi√£o?", "tem algo espiritual?", "sou evang√©lico", "sou cat√≥lico", "tem apoio religioso?",
        "minha f√©", "igreja"
    ],

    # üõë CONTROLE DE FLUXO / META
    "cancelar": [ # Cancelar a√ß√£o atual (agendamento, etc.)
        "quero cancelar", "mudei de ideia", "n√£o quero mais", "cancela tudo", "desisti",
        "cancelar agendamento", "n√£o posso ir"
    ],
    "confirmacao_positiva": [ # Confirma√ß√£o gen√©rica (sim, ok, pode ser)
        "sim", "claro", "com certeza", "pode ser", "ok", "t√°", "t√° bom", "isso", "por favor", "quero sim", "pode"
    ],
    "confirmacao_negativa": [ # Nega√ß√£o gen√©rica (n√£o, agora n√£o)
        "n√£o", "nao", "talvez depois", "n√£o agora", "deixa pra depois", "agora n√£o", "n√£o quero", "n√£o obrigado"
    ],
    "elogio": [
        "√≥timo atendimento", "gostei muito", "voc√™s s√£o bons", "obrigado", "atendimento top", "amei",
        "parab√©ns", "muito bom", "excelente"
    ],
    "erro": [ # Usu√°rio reporta um erro t√©cnico
        "link n√£o abre", "deu erro", "n√£o consegui pagar", "o site caiu", "n√£o carrega",
        "problema t√©cnico", "n√£o funciona", "bug"
    ],
    "sem_compreensao": [ # Bot n√£o entendeu ou mensagem inintelig√≠vel
        "asdfgh", "oiaueia", "????", "n√£o entendi", "fala direito", "msg estranha", "...", "??",
        "o que?", "n√£o faz sentido"
    ],

    # Adicione intents mais espec√≠ficas conforme necess√°rio
    # Ex: "duvida_tipo_droga_especifica", "duvida_comorbidades", etc.
}


==== /home/ubuntu/famdomes_backend/app/routes/pagamentos.py ====
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}



==== /home/ubuntu/famdomes_backend/app/routes/painel.py ====
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sess√£o est√° confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}



==== /home/ubuntu/famdomes_backend/app/routes/stripe.py ====
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # üß† Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # üß† Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}



==== /home/ubuntu/famdomes_backend/app/routes/rocketchat.py ====
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda n√£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }



==== /home/ubuntu/famdomes_backend/app/routes/agendamento.py ====
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}




==== /home/ubuntu/famdomes_backend/app/routes/whatsapp.py ====
# routes/whatsapp.py

from fastapi import APIRouter, Request, Response
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()
mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    resposta = ""  # Initialize resposta with an empty string
    try:
        data = await request.json()

        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]

        if "messages" not in changes or "contacts" not in changes:
            print("‚ö†Ô∏è Ignorado: evento sem mensagens (pode ser status ou metadados)")
            return Response(status_code=200)

        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"]["name"]

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()

        resposta = resultado["resposta"]
        intent = resultado["intent"]
        risco = resultado["risco"]

        print(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        print(f"Mensagem: {mensagem}")
        print(f"Resposta: {resposta}")
        print(f"Intent: {intent} | Risco: {risco}")

        await enviar_mensagem(telefone, resposta)

        # üö® Alerta para familiar em caso de risco
        if risco and WHATSAPP_FAMILIAR:
            alerta = (
                f"‚ö†Ô∏è Alerta FAMDOMES: Detec√ß√£o de risco na conversa com {telefone}. "
                f"Mensagem: ‚Äú{mensagem}‚Äù. Um profissional ser√° alertado."
            )
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)

    except Exception as e:
        print("‚ùå ERRO no webhook:", str(e))
        return {"erro": str(e)}


==== /home/ubuntu/famdomes_backend/app/routes/ia_comandos.py ====
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"‚úÖ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando n√£o reconhecido.")



==== /home/ubuntu/famdomes_backend/app/routes/ia.py ====
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ‚úÖ Fun√ß√£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"‚úÖ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "‚ùå Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "‚úÖ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in comando or "dispon√≠vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ü§ñ Desculpe, n√£o entendi o que voc√™ deseja. Voc√™ pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver hor√°rio dispon√≠vel")
        return {"status": "comando_desconhecido"}



==== /home/ubuntu/famdomes_backend/app/routes/followup.py ====
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}



==== /home/ubuntu/famdomes_backend/app/main.py ====
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel



API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")

app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)
@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("üì• Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas p√∫blicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Valida√ß√£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)



==== /home/ubuntu/famdomes_backend/app/models/pagamentos.py ====
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str



==== /home/ubuntu/famdomes_backend/app/models/intents.py ====
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar hor√°rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar hor√°rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "j√° paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que voc√™ faz",
        "me ajuda",
        "como voc√™ pode me ajudar"
    ]
}



==== /home/ubuntu/famdomes_backend/app/models/atendimento.py ====
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str



==== /home/ubuntu/famdomes_backend/app/config.py ====
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")



==== /home/ubuntu/famdomes_backend/app/nlu/response_generator.py ====
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que n√£o √© f√°cil buscar ajuda.\n\n"
    "ü§ù Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "üì≤ Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # IN√çCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"üìÖ √ìtimo! Posso te ajudar a agendar com nosso m√©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"üìÜ O pr√≥ximo hor√°rio dispon√≠vel √©: {consultar_horario()}. Posso reservar pra voc√™?",

    # VALORES
    "duvida_valores": "üí∞ Temos valores acess√≠veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIAN√áA
    "duvida_geral": "üìã Nosso sistema conecta voc√™ com m√©dicos especialistas de verdade. Quer saber como funciona na pr√°tica?",
    "desconfianca": "üîç Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPEND√äNCIA / RECA√çDA / SINTOMAS
    "duvida_dependencia": "üß† A depend√™ncia qu√≠mica √© trat√°vel. Nosso m√©dico pode avaliar sintomas f√≠sicos e emocionais. Quer agendar?",
    "sou_dependente": "üí¨ Reconhecer isso √© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "üîÅ Reca√≠das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "üòì Os sintomas de abstin√™ncia s√£o desafiadores. Podemos te orientar com seguran√ßa. Posso marcar agora?",

    # CRISE / URG√äNCIA
    "sintomas_graves": "‚ö†Ô∏è Sinais de crise detectados. Posso encaminhar voc√™ para um atendimento urgente. Deseja ajuda agora?",
    "amea√ßa_vida": "üö® Sua vida importa. Posso ativar nosso acolhimento de urg√™ncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "üë™ Voc√™ quer ajudar algu√©m importante. Posso te explicar como funciona e agendar uma escuta para voc√™ ou para ele(a).",
    "familia_pedindo_ajuda": "üß≠ Voc√™ est√° no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "üö® Situa√ß√£o familiar cr√≠tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "üòî √â dif√≠cil quando a fam√≠lia n√£o apoia. Mas h√° caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "üíî Muitas fam√≠lias passam por isso. Podemos ajudar na reconstru√ß√£o. Quer agendar uma orienta√ß√£o especializada?",
    "familiar_violento": "‚ö†Ô∏è Em casos de viol√™ncia, seguran√ßa vem primeiro. Posso te mostrar como agir com respaldo m√©dico e legal.",

    # INTERNA√á√ÉO
    "duvida_internacao": "üè• A interna√ß√£o pode ser volunt√°ria ou involunt√°ria, sempre com avalia√ß√£o m√©dica. Quer saber como isso funciona?",
    "quero_internar": "‚úÖ Posso te mostrar o processo completo, legal e cl√≠nico. Posso agendar agora com nosso m√©dico?",

    # FUNIL / OBJEC√ïES / CIRCUNST√ÇNCIAS
    "nao_quero_internar": "Tudo bem. Interna√ß√£o n√£o √© a √∫nica sa√≠da. Posso te explicar outras op√ß√µes com orienta√ß√£o m√©dica.",
    "meu_parente_usa_droga": "üí¨ Entendo. Posso agendar com o especialista pra avaliar a situa√ß√£o de forma profissional.",
    "crise_agora": "‚ö†Ô∏è Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "üí° Obrigado por compartilhar. Posso te ajudar com os pr√≥ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "üòî A resist√™ncia √© comum. Mesmo assim, a fam√≠lia pode iniciar a a√ß√£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "üë• Se a fam√≠lia n√£o colabora, podemos trabalhar com quem estiver dispon√≠vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "üëç Tranquilo. Se quiser ajudar algu√©m ou tirar d√∫vidas, posso te explicar tudo com calma.",

    # INFORMA√á√ïES COMPLEMENTARES
    "quero_entender": "üìò Posso te explicar tudo sobre o atendimento, desde a escuta at√© o tratamento. Quer come√ßar agora?",
    "curioso": "üòÑ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simula√ß√£o real?",
    "pergunta_medico": "üë®‚Äç‚öïÔ∏è O m√©dico √© especialista em depend√™ncia qu√≠mica e avalia√ß√£o cl√≠nica. Quer agendar a escuta?",
    "duvida_medicacao": "üíä Medicamentos s√≥ s√£o indicados ap√≥s avalia√ß√£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "üß† Temos psic√≥logos na equipe. A avalia√ß√£o inicial √© m√©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "üîÅ Recome√ßar √© poss√≠vel. Estamos aqui pra isso. Quer conversar com o m√©dico novamente?",
    "vergonha_de_falar": "üß° Tudo bem. N√£o precisa se explicar agora. Posso s√≥ ouvir, se quiser.",
    "culpa_familiar": "ü§ù A culpa n√£o ajuda, mas o cuidado sim. Posso te mostrar como come√ßar com leveza.",
    "busca_ajuda_emocional": "üí¨ Tamb√©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "üõê Respeitamos todas as cren√ßas. O acolhimento √© humano, com base √©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "‚öñÔ∏è A interna√ß√£o judicial √© poss√≠vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "üë∂ Tratamos casos de menores com responsabilidade. Posso te mostrar os crit√©rios e caminhos.",
    "direitos_paciente": "üìú Tudo √© feito conforme a √©tica m√©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "üìç Temos atendimento online e unidades f√≠sicas. Quer saber se tem perto de voc√™?",
    "duvida_profissionais": "üë©‚Äç‚öïÔ∏è Temos m√©dicos, terapeutas e psic√≥logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "üîí Todo atendimento √© sigiloso. Nada √© compartilhado sem sua autoriza√ß√£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "‚úÖ Consulta cancelada. Se quiser retomar, √© s√≥ me avisar.",
    "teste": "üß™ Est√° testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "‚ù§Ô∏è Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na pr√°tica.",
    "erro": "üîÅ Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ü§î N√£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "üëç Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padr√£o se intent for reconhecida mas sem frase espec√≠fica
        return respostas.get(intent, "T√¥ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")



==== /home/ubuntu/famdomes_backend/app/nlu/chatbot_router.py ====
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "t√¥ aqui pra isso", "pode falar", "√© isso", "ok", "t√°", "t√° bom",
    "isso", "por favor", "sim quero", "t√¥ dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "üîÑ Hist√≥rico apagado. Pode come√ßar de novo.", "risco": False}

        # Classifica√ß√£o de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se h√° contexto anterior de confirma√ß√£o pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no hist√≥rico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"‚ö†Ô∏è Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()



==== /home/ubuntu/famdomes_backend/app/nlu/nlu_classifier.py ====
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para compara√ß√£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontua√ß√µes b√°sicas (exceto espa√ßos) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espa√ßos extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML n√£o encontrados. Usando classifica√ß√£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presen√ßa de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confian√ßa base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho est√° contido no texto
                # Usar `in` √© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # L√≥gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confian√ßa para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classifica√ß√£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pr√©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # N√£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confian√ßa={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classifica√ß√£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confian√ßa.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML n√£o estiver ativo ou como m√©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- M√©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF √© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar par√¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes √© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------


==== /home/ubuntu/famdomes_backend/app/nlu/entidade_extractor.py ====
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)",
                r"([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)\s+(?:√© meu nome|meu nome √©|aqui √©)" # Novo padr√£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)\s+(?:√© meu|minha)" # Novo padr√£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)",
                r"(?:cidade de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)" # Novo padr√£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padr√£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|coca√≠na)"
            ],
            "recaida": [
                r"(reca[√≠i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[√≠i]da|escorregada)" # Novo padr√£o
            ],
            # Adicione mais entidades e padr√µes conforme necess√°rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extra√≠da: {entidades[entidade]} (Padr√£o: '{padrao}')")
                    break  # Para na primeira correspond√™ncia

        return entidades


# Conte√∫do do arquivo: ./utils/faq_respostas.py
FAQ_RESPOSTAS = {
    "dependencia_quimica": (
        "Depend√™ncia qu√≠mica √© uma doen√ßa cr√¥nica caracterizada pelo uso compulsivo de subst√¢ncias, "
        "apesar das consequ√™ncias negativas, afetando o c√©rebro e o comportamento."
    ),
    "identificar_dependencia": (
        "Sinais incluem uso constante da subst√¢ncia, dificuldade em parar, neglig√™ncia nas responsabilidades, "
        "mudan√ßas bruscas de comportamento e sintomas de abstin√™ncia."
    ),
    "tipos_internacao": (
        "Existem tr√™s tipos principais de interna√ß√£o: volunt√°ria (com consentimento), involunt√°ria "
        "(solicitada pela fam√≠lia) e compuls√≥ria (por ordem judicial)."
    ),
    "como_funciona_tratamento": (
        "O tratamento em cl√≠nica inclui desintoxica√ß√£o supervisionada, terapias individuais e em grupo, "
        "atividades terap√™uticas e acompanhamento m√©dico constante."
    ),
    "duracao_tratamento": (
        "Normalmente, o tratamento dura entre 3 e 6 meses, podendo variar de acordo com a situa√ß√£o espec√≠fica."
    ),
    "custo_tratamento": (
        "Os valores variam dependendo dos servi√ßos e acomoda√ß√µes. Para detalhes exatos, podemos agendar uma avalia√ß√£o."
    ),
    "recusa_ajuda": (
        "Se a pessoa n√£o aceita ajuda voluntariamente, pode ser considerado o processo de interna√ß√£o involunt√°ria "
        "com suporte legal e m√©dico especializado."
    ),
    "apoio_familiar": (
        "Fam√≠lias podem ajudar oferecendo suporte emocional, participando das terapias familiares e estabelecendo limites claros."
    ),
    "sobre_caps": (
        "O CAPS √© um Centro de Aten√ß√£o Psicossocial que oferece tratamento especializado em sa√∫de mental e depend√™ncia qu√≠mica."
    ),
    "como_agendar": (
        "Voc√™ pode agendar facilmente uma consulta entrando em contato conosco pelo WhatsApp ou pelo nosso site oficial."
    ),
}

# Conte√∫do do arquivo: ./utils/ollama.py
import httpx
import logging
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    payload = {
        "model": OLLAMA_MODEL,
        "prompt": prompt,
        "stream": False
    }
    headers = {"Content-Type": "application/json"}
    try:
        async with httpx.AsyncClient(timeout=60.0) as client:
            logging.info(f"Enviando prompt para Ollama (modelo: {OLLAMA_API_URL}/{OLLAMA_MODEL})...")
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            response.raise_for_status()
            dados = response.json()
            logging.info("‚úÖ Resposta recebida da IA (OLLAMA).")
            resposta_bruta = dados.get("response", "‚ö†Ô∏è Erro interno na IA.")
            # Aqui voc√™ pode fazer qualquer limpeza necess√°ria na resposta
            tokens = []  # Se houver tokens, adicione-os
            return resposta_bruta, tokens
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå Erro: Timeout ({str(e)})")
        return "‚ö†Ô∏è Desculpe, demorei muito para pensar. Tente novamente.", []
    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå Erro: HTTP {e.response.status_code} - {e.response.text}")
        return f"‚ö†Ô∏è Ocorreu um erro interno ({e.response.status_code}). Por favor, tente mais tarde.", []
    except Exception as e:
        logging.exception("‚ùå Erro desconhecido ao chamar Ollama:")
        return "‚ö†Ô∏è Erro inesperado. Tente novamente mais tarde.", []

# Conte√∫do do arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura ‚Äì certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"‚ùå ERRO ao carregar prompt mestre: {e}")
        return (
            "Voc√™ √© um assistente virtual especializado em sa√∫de mental e depend√™ncia qu√≠mica. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"Usu√°rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"‚ùå ERRO ao buscar hist√≥rico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar hist√≥rico."
    else:
        trecho_historico = "Hist√≥rico indispon√≠vel (sem conex√£o DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
Hist√≥rico da Conversa:
{trecho_historico}
---
Nova Mensagem do Usu√°rio:
{pergunta_atual.strip()}
---
Instru√ß√µes para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no m√°ximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt constru√≠do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Conte√∫do do arquivo: ./utils/mensageria.py
# utils/mensageria.py
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """Envia uma mensagem de texto simples via WhatsApp Cloud API."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}
    if not telefone or not mensagem:
        logging.warning("‚ö†Ô∏è Tentativa de enviar mensagem vazia ou sem destinat√°rio.")
        return {"erro": "Telefone ou mensagem ausente."}

    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone,
        "type": "text",
        "text": {"preview_url": False, "body": mensagem} # Desabilitar preview_url √© geralmente bom para chatbots
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Timeout razo√°vel para APIs externas
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status() # Levanta erro para 4xx/5xx

            logging.info(f"‚úÖ Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}")
            return {"status": "enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar mensagem para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}

async def enviar_template_feedback(
    telefone: str,
    nome_template: str = "feedback", # Nome do template configurado na Meta
    nome_clinica: str = "Nome Padr√£o Cl√≠nica",
    tipo_servico: str = "Atendimento",
    tipo_pesquisa: str = "Satisfa√ß√£o",
    tipo_interacao: str = "Consulta"
):
    """Envia um template de mensagem do WhatsApp (ex: feedback com bot√£o de fluxo)."""
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("‚ùå ERRO: Configura√ß√µes da API do WhatsApp ausentes (URL ou Token).")
        return {"erro": "Configura√ß√£o da API do WhatsApp incompleta."}

    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "template",
        "template": {
            "name": nome_template,
            "language": {"code": "pt_BR"}, # Certifique-se que o idioma corresponde ao template aprovado
            "components": [
                {
                    "type": "body",
                    "parameters": [
                        {"type": "text", "text": nome_clinica},     # {{1}}
                        {"type": "text", "text": tipo_servico},     # {{2}}
                        {"type": "text", "text": tipo_pesquisa},    # {{3}}
                        {"type": "text", "text": tipo_interacao}    # {{4}}
                    ]
                },
                { # Exemplo de bot√£o de fluxo (ajuste conforme seu template)
                    "type": "button",
                    "sub_type": "flow", # Ou "quick_reply", "url", etc.
                    "index": "0", # √çndice do bot√£o no template
                    # "parameters": [] # Par√¢metros espec√≠ficos do bot√£o, se houver
                }
                # Adicione outros componentes (header, buttons) se seu template os tiver
            ]
        }
    }
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
    timeout = httpx.Timeout(15.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando template '{nome_template}' para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            response.raise_for_status()

            logging.info(f"‚úÖ Template '{nome_template}' enviado para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp (Template): {response.text}")
            return {"status": "template_enviado", "code": response.status_code, "retorno": response.text}

    except httpx.HTTPStatusError as e:
        logging.error(f"‚ùå ERRO HTTP ao enviar template para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        logging.error(f"‚ùå ERRO: Timeout ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        logging.error(f"‚ùå ERRO de Conex√£o ao enviar template para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    except Exception as e:
        logging.exception(f"‚ùå ERRO inesperado ao enviar template para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}
# Conte√∫do do arquivo: ./utils/contexto.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    contextos_db = db["contexto_conversa"]
    logging.info("Conex√£o com MongoDB estabelecida para Contexto.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Contexto: {e}")
    mongo = None
    contextos_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    if contextos_db is None:
        logging.error(f"N√£o foi poss√≠vel salvar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone or not isinstance(dados_atualizacao, dict):
        logging.error("Tentativa de salvar contexto inv√°lido.")
        return False
    try:
        contextos_db.update_one(
            {"telefone": telefone},
            {"$set": dados_atualizacao, "$currentDate": {"ultima_atualizacao": True},
             "$setOnInsert": {"telefone": telefone, "criado_em": datetime.utcnow()}},
            upsert=True
        )
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao salvar contexto para {telefone}: {e}")
        return False

def obter_contexto(telefone: str) -> dict:
    if contextos_db is None:
        logging.error(f"N√£o foi poss√≠vel obter contexto para {telefone}: Sem conex√£o com DB.")
        return {}
    if not telefone:
        logging.warning("Tentativa de obter contexto sem telefone.")
        return {}
    try:
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto is not None:
            return contexto
        return {}
    except Exception as e:
        logging.error(f"‚ùå ERRO ao obter contexto para {telefone}: {e}")
        return {}

def limpar_contexto(telefone: str):
    if contextos_db is None:
        logging.error(f"N√£o foi poss√≠vel limpar contexto para {telefone}: Sem conex√£o com DB.")
        return False
    if not telefone:
        logging.warning("Tentativa de limpar contexto sem telefone.")
        return False
    try:
        result = contextos_db.delete_one({"telefone": telefone})
        return result.deleted_count > 0
    except Exception as e:
        logging.error(f"‚ùå ERRO ao limpar contexto para {telefone}: {e}")
        return False

# Conte√∫do do arquivo: ./utils/db.py
from datetime import datetime, timedelta

# Simula pr√≥xima agenda livre
def get_agenda_disponivel():
    return datetime.now() + timedelta(days=1, hours=1)

# Simula grava√ß√£o da consulta
def registrar_consulta(telefone: str, horario):
    print(f"[DB] Consulta registrada para {telefone} √†s {horario}")

# Simula aviso ao profissional
def avisar_profissional(telefone: str, horario):
    print(f"[AVISO M√âDICO] Nova consulta agendada com {telefone} para {horario}")

# Simula resposta ao paciente
def avisar_paciente(telefone: str, horario):
    print(f"[AVISO PACIENTE] Sua consulta foi agendada para {horario}")

def analisar_risco(texto: str) -> bool:
    palavras_criticas = ["suic√≠dio", "morrer", "n√£o aguento", "acabar com tudo"]
    return any(p in texto.lower() for p in palavras_criticas)

# Conte√∫do do arquivo: ./utils/risco.py
# utils/risco.py
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Lista de palavras/frases cr√≠ticas (ajuste conforme necess√°rio)
# Cuidado: Pode gerar falsos positivos/negativos. Avalie e refine.
PALAVRAS_CRITICAS = [
    "suic√≠dio", "me matar", "quero morrer", "n√£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperan√ßa", "adeus mundo", "n√£o quero viver",
    # Adicionar termos relacionados a auto-mutila√ß√£o se aplic√°vel
    # Adicionar termos relacionados a amea√ßas a terceiros se aplic√°vel
]

# Adicionar palavras/frases que indicam URG√äNCIA M√âDICA (Overdose, etc.)
PALAVRAS_URGENCIA = [
    "overdose", "passando muito mal", "n√£o consigo respirar", "dor no peito forte",
    "desmaiado", "convuls√£o", "sangrando muito", "veneno",
    # Adicione outros termos relevantes para emerg√™ncias m√©dicas
]

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (suic√≠dio, urg√™ncia m√©dica).
    Retorna um dicion√°rio com booleanos para 'risco_vida' e 'urgencia_medica'.
    """
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    texto_lower = texto.lower()
    risco_vida_detectado = any(p in texto_lower for p in PALAVRAS_CRITICAS)
    urgencia_medica_detectada = any(u in texto_lower for u in PALAVRAS_URGENCIA)

    if risco_vida_detectado:
        logging.warning(f"üö® RISCO DE VIDA DETECTADO no texto: '{texto[:100]}...'")
    if urgencia_medica_detectada:
        logging.warning(f"üöë URG√äNCIA M√âDICA DETECTADA no texto: '{texto[:100]}...'")

    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }
# Conte√∫do do arquivo: ./utils/agenda.py
# utils/agenda.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes de configura√ß√£o da agenda
DURACAO_CONSULTA_MINUTOS = 20
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias √∫teis)
HORARIO_OPERACAO_INICIO = 9 # 9:00
HORARIO_OPERACAO_FIM = 18  # 18:00 (n√£o agenda √†s 18:00, √∫ltimo √© 17:40)

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    consultas_db = db["consultas_agendadas"]
    # Criar √≠ndice para garantir que n√£o haja duas consultas no mesmo hor√°rio
    consultas_db.create_index("horario", unique=True)
    logging.info("Conex√£o com MongoDB estabelecida para Agenda.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Agenda: {e}")
    mongo = None
    consultas_db = None

def _proximo_horario_util(inicio_base: datetime) -> datetime:
    """Avan√ßa o hor√°rio para o pr√≥ximo bloco de X minutos dentro do hor√°rio de opera√ß√£o."""
    horario = inicio_base

    # Arredonda para o pr√≥ximo bloco de N minutos (para cima)
    minutos_excedentes = horario.minute % DURACAO_CONSULTA_MINUTOS
    if minutos_excedentes > 0:
        horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS - minutos_excedentes)
    elif horario.second > 0 or horario.microsecond > 0: # Se for exatamente no in√≠cio do bloco mas tiver segundos
         horario += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    horario = horario.replace(second=0, microsecond=0) # Zera segundos e microssegundos

    # Ajusta para o hor√°rio de opera√ß√£o
    while horario.hour < HORARIO_OPERACAO_INICIO:
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
    while horario.hour >= HORARIO_OPERACAO_FIM:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    # Pula fins de semana (S√°bado=5, Domingo=6)
    while horario.weekday() >= 5:
        horario += timedelta(days=1)
        horario = horario.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)

    return horario

def agendar_consulta(telefone: str, nome: str, email: str = None) -> datetime | None:
    """
    Encontra o pr√≥ximo hor√°rio livre e agenda a consulta.
    Retorna o datetime do hor√°rio agendado ou None se n√£o encontrar.
    """
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel agendar: Sem conex√£o com DB.")
        return None

    # Usar UTC para armazenamento no DB √© uma boa pr√°tica
    agora_utc = datetime.now(timezone.utc)
    # Come√ßa a procurar X minutos √† frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Verifica se j√° existe consulta nesse hor√°rio
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                # Encontrou hor√°rio livre, tenta inserir
                consulta_doc = {
                    "telefone": telefone,
                    "nome": nome,
                    "email": email,
                    "horario": horario_tentativa_utc, # Armazena em UTC
                    "status": "agendado", # Adiciona um status
                    "criado_em": agora_utc
                }
                consultas_db.insert_one(consulta_doc)
                logging.info(f"[AGENDA] Consulta marcada para {nome} ({telefone}) em {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna o hor√°rio em UTC
            else:
                # Hor√°rio ocupado, avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao tentar agendar/verificar conflito para {horario_tentativa_utc}: {e}")
            # Se houver erro na verifica√ß√£o/inser√ß√£o, pode ser melhor parar ou logar e continuar
            return None # Ou levantar exce√ß√£o

    logging.warning(f"N√£o foram encontrados hor√°rios dispon√≠veis para {telefone} ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None # Retorna None se n√£o encontrar hor√°rio

def cancelar_consulta(telefone: str) -> int:
    """Cancela todas as consultas futuras agendadas para um telefone."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel cancelar: Sem conex√£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Deleta apenas consultas que ainda n√£o ocorreram
        resultado = consultas_db.delete_many({
            "telefone": telefone,
            "horario": {"$gt": agora_utc} # Maior que agora (futuro)
        })
        if resultado.deleted_count > 0:
            logging.info(f"üóëÔ∏è Cancelada(s) {resultado.deleted_count} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return resultado.deleted_count
    except Exception as e:
        logging.error(f"‚ùå ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """Consulta o pr√≥ximo hor√°rio dispon√≠vel sem agendar."""
    if not consultas_db:
        logging.error("N√£o √© poss√≠vel consultar hor√°rio: Sem conex√£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS) # Come√ßa a procurar um pouco √† frente

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            conflito = consultas_db.find_one({"horario": horario_tentativa_utc})
            if not conflito:
                logging.info(f"Pr√≥ximo hor√°rio dispon√≠vel encontrado: {horario_tentativa_utc.isoformat()}")
                return horario_tentativa_utc # Retorna hor√°rio em UTC
            else:
                # Avan√ßa para o pr√≥ximo bloco
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        except Exception as e:
            logging.error(f"‚ùå ERRO ao consultar pr√≥ximo hor√°rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro

    logging.warning(f"Nenhum hor√°rio dispon√≠vel encontrado na consulta ap√≥s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def formatar_horario_local(horario_utc: datetime, fuso_horario_local: str = 'America/Sao_Paulo') -> str:
    """Formata um hor√°rio UTC para uma string leg√≠vel no fuso hor√°rio local."""
    if not horario_utc:
        return "Indispon√≠vel"
    try:
        # Precisa da biblioteca pytz para fusos hor√°rios robustos: pip install pytz
        import pytz
        tz_local = pytz.timezone(fuso_horario_local)
        horario_local = horario_utc.astimezone(tz_local)
        # Ex: "15/04 14:30" (Ter√ßa-feira, 15 de Abril √†s 14:30)
        return horario_local.strftime("%d/%m %H:%M") # Formato mais comum no Brasil
        # return horario_local.strftime("%A, %d de %B √†s %H:%M") # Formato mais extenso
    except ImportError:
        logging.warning("Biblioteca pytz n√£o instalada. Usando formata√ß√£o UTC.")
        return horario_utc.strftime("%d/%m %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"Erro ao formatar hor√°rio {horario_utc} para fuso {fuso_horario_local}: {e}")
        return "Erro na formata√ß√£o"
def consultar_horario():
    return "amanh√£ √†s 10h"

# Conte√∫do do arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Conte√∫do do arquivo: ./utils/followup.py
# utils/followup.py
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.agenda import agendar_consulta # Usar a fun√ß√£o de agendamento real
from app.utils.mensageria import enviar_mensagem # Usar a fun√ß√£o real de mensagem
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
FOLLOWUP_INTERVALO_MINUTOS = 10 # Tempo para esperar antes de enviar followup de pagamento pendente

# Alerta: Opera√ß√µes s√≠ncronas de DB em rotas async podem bloquear o event loop.
try:
    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    sessoes_db = db["sessao_pagamento"] # Renomeado para clareza (era sessao_atendimentos)
    # consultas_db = db["consultas_agendadas"] # N√£o precisa mais buscar aqui, usa agenda.py
    logging.info("Conex√£o com MongoDB estabelecida para Followup.")
except Exception as e:
    logging.error(f"‚ùå ERRO ao conectar com MongoDB para Followup: {e}")
    mongo = None
    sessoes_db = None

# --- Fun√ß√µes de Simula√ß√£o (Removidas ou Substitu√≠das) ---
# get_agenda_disponivel -> Usar consultar_proximo_horario_disponivel de agenda.py
# registrar_consulta -> L√≥gica est√° em agenda.py
# avisar_profissional -> Deveria ser chamado ap√≥s agendamento real
# avisar_paciente -> Deveria ser chamado ap√≥s agendamento real
# --------------------------------------------------------

def iniciar_sessao_pagamento(telefone: str, nome: str):
    """Registra o in√≠cio de uma tentativa de pagamento/agendamento."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel iniciar sess√£o de pagamento: Sem conex√£o com DB.")
        return False

    agora_utc = datetime.now(timezone.utc)
    try:
        sessoes_db.update_one(
            {"telefone": telefone},
            {
                "$set": {
                    "nome": nome,
                    "inicio_tentativa": agora_utc,
                    "status": "pendente_pagamento", # Status inicial
                    "ultima_atualizacao": agora_utc
                },
                "$setOnInsert": {"telefone": telefone, "criado_em": agora_utc}
            },
            upsert=True
        )
        logging.info(f"[SESS√ÉO PAGAMENTO] Iniciada para {nome} ({telefone})")
        return True
    except Exception as e:
        logging.error(f"‚ùå ERRO ao iniciar sess√£o de pagamento para {telefone}: {e}")
        return False

def marcar_pagamento_confirmado(telefone: str) -> tuple[datetime | None, str | None]:
    """
    Marca a sess√£o como paga, agenda a consulta e retorna o hor√°rio agendado e nome.
    Esta fun√ß√£o √© chamada pelo webhook do Stripe.
    """
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel marcar pagamento: Sem conex√£o com DB.")
        return None, None

    agora_utc = datetime.now(timezone.utc)
    try:
        sessao = sessoes_db.find_one_and_update(
            {"telefone": telefone, "status": "pendente_pagamento"}, # Garante que s√≥ atualiza se estiver pendente
            {
                "$set": {
                    "status": "pago",
                    "pagamento_confirmado_em": agora_utc,
                    "ultima_atualizacao": agora_utc
                }
            },
            return_document=True # Retorna o documento *antes* da atualiza√ß√£o se n√£o encontrar, ou *depois* se encontrar
                                # Precisamos do nome, ent√£o talvez buscar antes seja melhor? Ou passar o nome como arg.
                                # Vamos assumir que o nome j√° est√° l√° do iniciar_sessao_pagamento
        )

        if not sessao:
            # Pode acontecer se o webhook chegar antes da sess√£o ser criada, ou se j√° foi processado
            logging.warning(f"Sess√£o de pagamento n√£o encontrada ou j√° processada para {telefone} ao marcar como pago.")
            # Tentar buscar o nome no contexto ou leads pode ser um fallback
            # Ou simplesmente retornar None e o webhook lida com isso
            return None, None

        nome_cliente = sessao.get("nome", "Cliente") # Pega o nome da sess√£o
        logging.info(f"[SESS√ÉO PAGAMENTO] Pagamento confirmado para {nome_cliente} ({telefone})")

        # 2. Agendar a consulta REALMENTE
        horario_agendado_utc = agendar_consulta(telefone, nome_cliente) # Passa o nome obtido

        if horario_agendado_utc:
            # Atualizar a sess√£o com o hor√°rio agendado (opcional, mas √∫til)
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"consulta_agendada_em": horario_agendado_utc}}
            )
            logging.info(f"Consulta agendada com sucesso para {nome_cliente} em {horario_agendado_utc.isoformat()}")

            # 3. (MOVIDO PARA ROTA STRIPE) Avisar paciente e profissional
            # await avisar_paciente(telefone, horario_agendado_utc)
            # await avisar_profissional(telefone, horario_agendado_utc, nome_cliente)
            return horario_agendado_utc, nome_cliente
        else:
            logging.error(f"Pagamento confirmado para {telefone}, MAS FALHOU AO AGENDAR CONSULTA!")
            # O que fazer aqui? Reembolso? Notificar admin? Marcar sess√£o com erro?
            sessoes_db.update_one(
                {"_id": sessao["_id"]},
                {"$set": {"status": "erro_agendamento"}}
            )
            return None, nome_cliente # Retorna nome para poss√≠vel notifica√ß√£o manual

    except Exception as e:
        logging.error(f"‚ùå ERRO ao marcar pagamento/agendar para {telefone}: {e}")
        return None, None

# Fun√ß√£o para simular aviso ao profissional (pode ser chamada pela rota do Stripe)
async def avisar_profissional(telefone_paciente: str, horario_utc: datetime, nome_paciente: str):
    try:
        # L√≥gica para encontrar o ID/contato do profissional e enviar a mensagem
        # Exemplo: buscar profissional da escala, enviar via WhatsApp, email, etc.
        telefone_medico = "NUMERO_WHATSAPP_MEDICO" # Substituir pelo n√∫mero real ou l√≥gica de busca
        if telefone_medico != "NUMERO_WHATSAPP_MEDICO": # Evitar enviar para placeholder
            horario_local_str = formatar_horario_local(horario_utc) # Formata para legibilidade
            msg_medico = f"üë®‚Äç‚öïÔ∏è Nova consulta agendada: {nome_paciente} ({telefone_paciente}) √†s {horario_local_str}."
            await enviar_mensagem(telefone_medico, msg_medico)
            logging.info(f"Aviso de agendamento enviado para o profissional sobre consulta de {nome_paciente}")
        else:
            logging.warning("N√∫mero do m√©dico n√£o configurado para envio de aviso.")
    except Exception as e:
        logging.error(f"Erro ao avisar profissional sobre consulta de {nome_paciente}: {e}")

# Fun√ß√£o para checar follow-up (pode ser chamada por uma rota/job agendado)
async def checar_followup_pagamento_pendente() -> list[dict]:
    """Verifica sess√µes com pagamento pendente h√° muito tempo."""
    if not sessoes_db:
        logging.error("N√£o √© poss√≠vel checar followup: Sem conex√£o com DB.")
        return []

    mensagens_para_enviar = []
    agora_utc = datetime.now(timezone.utc)
    limite_tempo = agora_utc - timedelta(minutes=FOLLOWUP_INTERVALO_MINUTOS)

    try:
        sessoes_pendentes = sessoes_db.find({
            "status": "pendente_pagamento",
            "inicio_tentativa": {"$lt": limite_tempo} # Iniciadas antes do limite de tempo
        })

        for sessao in sessoes_pendentes:
            telefone = sessao["telefone"]
            nome = sessao.get("nome", "voc√™")
            logging.info(f"[FOLLOW-UP] Pagamento pendente detectado para {nome} ({telefone})")
            msg = (
                f"Ol√° {nome}, notei que voc√™ iniciou um agendamento mas parece que n√£o foi conclu√≠do. üò•\n\n"
                "Precisa de ajuda com o pagamento ou tem alguma d√∫vida sobre a consulta?\n\n"
                "Estou aqui para te apoiar. üòä"
            )
            mensagens_para_enviar.append({"telefone": telefone, "mensagem": msg})

            # Opcional: Atualizar a sess√£o para indicar que o follow-up foi enviado
            # sessoes_db.update_one({"_id": sessao["_id"]}, {"$set": {"followup_enviado": agora_utc}})

    except Exception as e:
        logging.error(f"‚ùå ERRO ao checar followup de pagamentos: {e}")

    return mensagens_para_enviar
def iniciar_sessao(*args, **kwargs):
    pass  # Fun√ß√£o ainda n√£o implementada
def marcar_pagamento(telefone: str, data: str, valor: float) -> bool:
    """
    Marca o lead como pagante, registra o valor e a data do pagamento.
    """
    from app.config import MONGO_URI
    from pymongo import MongoClient
    from datetime import datetime

    mongo = MongoClient(MONGO_URI)
    db = mongo["famdomes"]
    leads = db["leads"]

    resultado = leads.update_one(
        {"telefone": telefone},
        {
            "$set": {
                "pagamento_confirmado": True,
                "valor_pago": valor,
                "data_pagamento": datetime.strptime(data, "%Y-%m-%d"),
            }
        }
    )

    return resultado.modified_count > 0


# Conte√∫do do arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Conte√∫do do arquivo: ./intents/intent_executor.py
import re
from datetime import datetime
from pymongo import MongoClient
from app.config import MONGO_URI
from app.utils.risco import analisar_risco
from app.utils.ia_fallback import chamar_ollama  # Fun√ß√£o que chama o Ollama
from app.utils.prompt_builder import construir_prompt
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.intents.intents_map import INTENTS
import logging
import unicodedata

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
historico = mongo["famdomes"]["respostas_ia"]
leads = mongo["famdomes"]["leads"]

MENSAGEM_INICIAL = "üß° Voc√™ deu um passo importante ao chegar aqui. Como posso ajudar voc√™?"

# Respostas pr√©-definidas ‚Äì ajuste conforme sua estrat√©gia de atendimento e vendas
RESPOSTAS_PREDEFINIDAS = {
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": "üìÖ √ìtimo! Vou encaminhar o link para agendar sua consulta.",
    "cancelar": "‚úÖ Sua consulta foi cancelada. Estamos √† disposi√ß√£o para retomar.",
    "duvida_geral": "üìã Nossa equipe est√° pronta para esclarecer suas d√∫vidas. Fale com a gente!",
    "venda": "üí∞ Temos planos especiais para voc√™. Gostaria de conhecer nossos pacotes?"
}

RESPOSTAS_CONFIRMATIVAS = ["sim", "claro", "com certeza", "prossiga", "quero"]
RESPOSTAS_NEGATIVAS = ["n√£o", "nao", "deixa", "cancelar"]

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')

class IntentExecutor:
    def __init__(self, telefone: str, mensagem: str, nome: str = "Paciente"):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.nome = nome
        self.mensagem_normalizada = normalizar_texto(self.mensagem)
        self.contexto = obter_contexto(self.telefone)
        self.intent_confianca = 1.0

    def detectar_intent(self):
        if self.mensagem_normalizada == "melancia vermelha":
            return "reset_manual"
        if self.contexto.get("aguardando_confirmacao"):
            if any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_CONFIRMATIVAS):
                return self.contexto.get("intent_esperada", "confirmacao")
            elif any(resp in self.mensagem_normalizada.split() for resp in RESPOSTAS_NEGATIVAS):
                return "cancelar"
        for intent, gatilhos in INTENTS.items():
            for g in gatilhos:
                if g.lower() in self.mensagem_normalizada:
                    return intent
        self.intent_confianca = 0.5
        return "desconhecida"

    async def _processar_intents_e_responder(self):
        intent = self.detectar_intent()
        risco = analisar_risco(self.mensagem)

        contexto_anterior = obter_contexto(self.telefone)
        ultima_intent = contexto_anterior.get("ultima_intent", "")

        # Se a √∫ltima intera√ß√£o ofereceu agendamento e a resposta atual for positiva:
        if ultima_intent == "ofereceu_agendamento" and intent in ["boas_vindas", "desconhecida"]:
            resposta = (
                "üìÖ Excelente! A consulta √© feita com especialistas em depend√™ncia qu√≠mica e sa√∫de mental, "
                "onde faremos uma avalia√ß√£o cuidadosa e criaremos um plano de tratamento personalizado para voc√™s. "
                "Para confirmar e garantir seu atendimento, acesse agora este link: "
                "https://clinicamg.com.br/agendamento"
            )
            salvar_contexto(self.telefone, {"ultima_intent": "aguardando_pagamento"})
        
        elif intent in FAQ_RESPOSTAS:
            resposta = FAQ_RESPOSTAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        elif intent == "reset_manual":
            limpar_contexto(self.telefone)
            resposta = "üîÑ Hist√≥rico apagado. Inicie novamente."

        elif intent in RESPOSTAS_PREDEFINIDAS:
            resposta = RESPOSTAS_PREDEFINIDAS[intent]
            salvar_contexto(self.telefone, {"ultima_intent": intent})

        else:
            prompt_final = construir_prompt(self.telefone, self.mensagem)
            resposta, _ = await chamar_ollama(prompt_final, self.telefone)
            resposta = self.limpar_resposta(resposta)

            if "agendar" in resposta.lower() or "consulta" in resposta.lower():
                salvar_contexto(self.telefone, {"ultima_intent": "ofereceu_agendamento"})

        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

   
   
    def limpar_resposta(self, texto: str) -> str:
        import re
        return re.sub(r"\(.*?\)", "", texto).strip()

    async def executar(self):
        return await self._processar_intents_e_responder()

# Conte√∫do do arquivo: ./intents/intents_map.py
INTENTS = {
    "boas_vindas": ["oi", "ol√°", "bom dia", "boa tarde", "boa noite"],
    "quero_agendar": ["agendar", "marcar", "consulta", "agendamento"],
    "cancelar": ["cancelar", "desmarcar", "n√£o quero"],
    "duvida_geral": ["como funciona", "o que voc√™s fazem", "ajuda", "informa√ß√£o"],
    "venda": ["comprar", "pacote", "planos", "venda"],"dependencia_quimica": ["dependencia", "v√≠cio", "dependente qu√≠mico"],
    "identificar_dependencia": ["como saber", "sinais dependencia", "identificar depend√™ncia"],
    "tipos_internacao": ["interna√ß√£o", "tipos de interna√ß√£o", "internar"],
    "como_funciona_tratamento": ["tratamento", "como √© o tratamento", "tratamento na cl√≠nica"],
    "duracao_tratamento": ["tempo tratamento", "dura√ß√£o tratamento"],
    "custo_tratamento": ["pre√ßo", "valor tratamento", "quanto custa"],
    "recusa_ajuda": ["n√£o aceita ajuda", "recusa tratamento"],
    "apoio_familiar": ["fam√≠lia ajudar", "ajuda familiar", "apoio da fam√≠lia"],
    "sobre_caps": ["o que √© caps", "caps"],
    "como_agendar": ["agendar", "marcar consulta", "consulta", "avaliar"],
}
# Mapeia os intents para as respostas correspondentes


# Conte√∫do do arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Conte√∫do do arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sess√£o est√° confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Conte√∫do do arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from pydantic import BaseModel
from app.nlu.chatbot_router import processar_mensagem

router = APIRouter()

class MensagemEntrada(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

@router.post("/chat/nlp")
async def analisar_mensagem(payload: MensagemEntrada):
    intent, entidades, risco = processar_mensagem(payload.mensagem)

    return {
        "intent": intent,
        "entidades": entidades,
        "risco": risco
    }

# Conte√∫do do arquivo: ./routes/stripe.py
import stripe
from fastapi import APIRouter, Request, Header
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.followup import marcar_pagamento
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request, stripe_signature: str = Header(None)):
    payload = await request.body()

    try:
        event = stripe.Webhook.construct_event(payload, stripe_signature, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")

        # üß† Marcar como pago (grava no Mongo + agenda + avisa)
        marcar_pagamento(telefone)

        # üß† Agendar consulta e enviar mensagens reais
        horario = agendar_consulta(telefone, nome, email=None)

        msg_paciente = (
            f"‚úÖ Ol√° {nome}, seu agendamento est√° confirmado!\n"
            f"üïí Hor√°rio: {horario.strftime('%d/%m %H:%M')}\n"
            "Voc√™ ser√° chamado pelo profissional nesse hor√°rio. At√© l√°!"
        )
        await enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"üë®‚Äç‚öïÔ∏è Novo agendamento: {nome} ({telefone}) √†s {horario.strftime('%d/%m %H:%M')}."
        await enviar_mensagem("MEDICO", msg_medico)

    return {"status": "ok"}

# Conte√∫do do arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda n√£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Conte√∫do do arquivo: ./routes/agendamento.py
# routes/agendamento.py

from fastapi import APIRouter
from app.utils.agenda import consultar_horario

router = APIRouter()

@router.get("/agendamento/proximo")
async def proximo_agendamento():
    horario = consultar_horario()
    return {"proximo_horario": horario}


# Conte√∫do do arquivo: ./routes/whatsapp.py
from fastapi import APIRouter, Request, Response, HTTPException
from app.config import WHATSAPP_VERIFY_TOKEN, WHATSAPP_FAMILIAR, MONGO_URI
from app.utils.mensageria import enviar_mensagem
from app.intents.intent_executor import IntentExecutor
from pymongo import MongoClient
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/webhook/whatsapp/")
async def verificar_webhook(request: Request):
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        return Response(content=challenge, media_type="text/plain")
    return Response(status_code=403)

@router.post("/webhook/whatsapp/")
async def receber_mensagem_whatsapp(request: Request):
    try:
        data = await request.json()
        entry = data["entry"][0]
        changes = entry["changes"][0]["value"]
        if "messages" not in changes or "contacts" not in changes:
            logging.info("Evento ignorado ‚Äì sem mensagens (status ou metadados).")
            return Response(status_code=200)
        mensagem = changes["messages"][0]["text"]["body"]
        telefone = changes["messages"][0]["from"]
        nome = changes["contacts"][0]["profile"].get("name", "Paciente")
        logging.info(f"[FAMDOMES] Mensagem de {nome} ({telefone})")
        logging.info(f"Mensagem: {mensagem}")

        executor = IntentExecutor(telefone=telefone, mensagem=mensagem, nome=nome)
        resultado = await executor.executar()
        resposta = resultado["resposta"]
        logging.info(f"Resposta: {resposta}")

        await enviar_mensagem(telefone, resposta)

        if WHATSAPP_FAMILIAR and "amea√ßa" in mensagem.lower():
            alerta = f"‚ö†Ô∏è Alerta FAMDOMES: Detec√ß√£o de risco na conversa com {telefone}. Mensagem: ‚Äú{mensagem}‚Äù."
            await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)

        return Response(status_code=200)
    except Exception as e:
        logging.error(f"‚ùå ERRO no webhook: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Conte√∫do do arquivo: ./routes/ia_comandos.py
# routes/ia_comandos.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando(dados: ComandoIA):
    cmd = dados.comando.lower()
    
    if "agendar" in cmd:
        iniciar_sessao(dados.telefone, dados.nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": dados.telefone,
                    "nome": dados.nome
                }
            )

            await enviar_mensagem(dados.telefone, f"‚úÖ Para agendar sua consulta, clique aqui e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in cmd:
        cancelar_consulta(dados.telefone)
        await enviar_mensagem(dados.telefone, "Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in cmd:
        horario = consultar_horario()
        await enviar_mensagem(dados.telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        raise HTTPException(status_code=400, detail="Comando n√£o reconhecido.")

# Conte√∫do do arquivo: ./routes/ia.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.utils.agenda import agendar_consulta, cancelar_consulta, consultar_horario
from app.utils.mensageria import enviar_mensagem
from app.utils.followup import iniciar_sessao
from app.config import STRIPE_SECRET_KEY
import stripe

router = APIRouter()
stripe.api_key = STRIPE_SECRET_KEY

class ComandoIA(BaseModel):
    telefone: str
    nome: str
    comando: str  # Ex: "quero agendar", "ver hor√°rio", "cancelar"

@router.post("/ia-comando")
async def processar_comando_post(dados: ComandoIA):
    return await processar_comando(dados.dict())

# ‚úÖ Fun√ß√£o exportada para uso no webhook do WhatsApp
async def processar_comando(dados: dict):
    telefone = dados["telefone"]
    nome = dados["nome"]
    comando = dados["comando"].lower()

    if "agendar" in comando:
        iniciar_sessao(telefone, nome)

        try:
            session = stripe.checkout.Session.create(
                payment_method_types=["card"],
                line_items=[{
                    "price_data": {
                        "currency": "brl",
                        "product_data": {"name": "Consulta FAMDOMES"},
                        "unit_amount": 10000  # R$100,00
                    },
                    "quantity": 1
                }],
                mode="payment",
                success_url="https://famdomes.com.br/sucesso",
                cancel_url="https://famdomes.com.br/cancelado",
                metadata={
                    "telefone": telefone,
                    "nome": nome
                }
            )

            await enviar_mensagem(telefone, f"‚úÖ Para agendar sua consulta, clique no link e realize o pagamento:\n{session.url}")
            return {"status": "link_gerado", "checkout_url": session.url}

        except Exception as e:
            await enviar_mensagem(telefone, "‚ùå Ocorreu um erro ao gerar o link de pagamento. Tente novamente mais tarde.")
            raise HTTPException(status_code=500, detail=f"Erro ao criar checkout: {str(e)}")

    elif "cancelar" in comando:
        cancelar_consulta(telefone)
        await enviar_mensagem(telefone, "‚úÖ Sua consulta foi cancelada com sucesso.")
        return {"status": "consulta_cancelada"}

    elif "hor√°rio" in comando or "dispon√≠vel" in comando:
        horario = consultar_horario()
        await enviar_mensagem(telefone, f"üìÖ Pr√≥ximo hor√°rio dispon√≠vel: {horario}")
        return {"status": "horario_enviado", "horario": horario}

    else:
        await enviar_mensagem(telefone, "ü§ñ Desculpe, n√£o entendi o que voc√™ deseja. Voc√™ pode dizer coisas como:\n- Quero agendar\n- Cancelar consulta\n- Ver hor√°rio dispon√≠vel")
        return {"status": "comando_desconhecido"}

# Conte√∫do do arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Conte√∫do do arquivo: ./main.py
from fastapi import FastAPI
from app.routes import whatsapp, ia, stripe, agendamento, painel
from fastapi import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi import Response
from app.config import WHATSAPP_VERIFY_TOKEN, API_KEY
from app.routes import ia, ia_comandos, stripe, whatsapp, agendamento, painel
from app.routes import nlp


API_KEY_HEADER = "X-API-Key"
app = FastAPI(title="FAMDOMES API")
app.include_router(nlp.router)
app.include_router(whatsapp.router, prefix="/chat")
app.include_router(ia.router)
app.include_router(stripe.router, prefix="/pagamento")
app.include_router(agendamento.router, prefix="/agenda")
app.include_router(painel.router, prefix="/paciente")
app.include_router(ia_comandos.router)

@app.post("/webhook/teste")
async def webhook_teste(request: Request):
    body = await request.json()
    print("üì• Webhook recebido:")
    print(body)
    return JSONResponse(content={"status": "ok", "mensagem": "Webhook recebido com sucesso"})

@app.middleware("http")
async def autenticar_chave(request: Request, call_next):
    path = str(request.url.path)

    # Rotas p√∫blicas permitidas
    is_webhook_externo = (
        path.startswith("/chat/nlp") or
        path.startswith("/chat/webhook/whatsapp") or 
        path.startswith("/pagamento/webhook") or
        path.startswith("/pagamento/criar_sessao") or
        path.startswith("/agenda") or
        path.startswith("/ia-in") or
        path.startswith("/docs") or
        path.startswith("/openapi.json") or
        path.startswith("/favicon.ico") or
        path == "/"
    )

    if is_webhook_externo:
        return await call_next(request)

    # Valida√ß√£o da chave
    chave = request.headers.get("X-API-Key") or request.headers.get("x-api-key")
    if chave != API_KEY:
        return JSONResponse(status_code=403, content={"erro": "Acesso negado"})

    return await call_next(request)

# Conte√∫do do arquivo: ./ia_direct.py
from fastapi import APIRouter, HTTPException, Request
from app.utils.ollama import chamar_ollama
from datetime import datetime

router = APIRouter()

# Mapa de respostas predefinidas ‚Äì ajuste de acordo com sua pol√≠tica de atendimento
RESPOSTAS_MAP = {
    "boas_vindas": "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que buscar ajuda √© dif√≠cil.",
    "quero_agendar": "üìÖ √ìtimo, vamos agendar sua consulta. Aguarde o link.",
    "cancelar": "‚úÖ Sua consulta foi cancelada. Estamos aqui se precisar retomar.",
    "duvida_geral": "üìã Nossa equipe est√° √† disposi√ß√£o para ajudar. Descreva sua d√∫vida.",
    # Adicione outras chaves e respostas conforme necess√°rio
}

async def processar_mensagem_ia(telefone: str, mensagem: str) -> tuple[str, list]:
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt = f"""
Voc√™ √© um assistente especializado em atendimento humano controlado para pessoas vulner√°veis. Sua miss√£o √© responder utilizando SOMENTE as respostas predefinidas abaixo e nada mais.

Mapa de Respostas:
{RESPOSTAS_MAP}

Instru√ß√µes:
- Ao receber a mensagem do usu√°rio, escolha a resposta mais adequada dentre as op√ß√µes do mapa.
- N√ÉO crie respostas novas; retorne apenas a resposta correspondente.
- Mantenha a resposta curta, emp√°tica e precisa, sem textos adicionais.

Dados da Requisi√ß√£o:
Data/Hora: {agora}
Telefone: {telefone}
Mensagem do Usu√°rio: {mensagem}

Forne√ßa APENAS a resposta escolhida.
    """.strip()
    resposta, tokens = await chamar_ollama(prompt, telefone)
    return resposta, tokens

@router.post("/mensagem")
async def processar_mensagem_endpoint(request: Request):
    data = await request.json()
    telefone = data.get("telefone")
    mensagem = data.get("mensagem")
    if not telefone or not mensagem:
        raise HTTPException(status_code=400, detail="Telefone e mensagem s√£o obrigat√≥rios.")
    resposta, tokens = await processar_mensagem_ia(telefone, mensagem)
    return {"status": "ok", "resposta": resposta, "tokens": tokens}

# Conte√∫do do arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Conte√∫do do arquivo: ./models/intents.py
INTENTS = {
    "ver_agendamento": [
        "quero agendar",
        "quero marcar consulta",
        "preciso agendar",
        "marcar hor√°rio",
        "quero uma consulta",
        "marcar consulta",
        "agendar atendimento",
        "quero atendimento",
        "consultar hor√°rio",
    ],
    "confirmar_pagamento": [
        "paguei",
        "j√° paguei",
        "confirmar pagamento",
        "efetuei o pagamento"
    ],
    "cancelar_atendimento": [
        "cancelar",
        "desmarcar",
        "quero cancelar",
        "cancelar agendamento",
    ],
    "duvida_geral": [
        "como funciona",
        "o que voc√™ faz",
        "me ajuda",
        "como voc√™ pode me ajudar"
    ]
}

# Conte√∫do do arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Conte√∫do do arquivo: ./config.py
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

OLLAMA_API_URL = os.getenv("OLLAMA_API_URL")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3")

API_KEY = os.getenv("API_KEY")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN")
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR")

ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL")
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN")
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID")

GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# Conte√∫do do arquivo: ./nlu/response_generator.py
# app/nlu/response_generator.py

from app.utils.agenda import consultar_horario

MENSAGEM_INICIAL = (
    "üß° Voc√™ deu um passo importante ao chegar aqui. Sabemos que n√£o √© f√°cil buscar ajuda.\n\n"
    "ü§ù Nosso time cuida de pessoas em sofrimento todos os dias. Posso te mostrar como funciona nosso atendimento.\n\n"
    "üì≤ Quer saber como podemos ajudar?"
)


class ResponseGenerator:
    def __init__(self, nome: str = "Paciente"):
        self.nome = nome

    def gerar(self, intent: str, entidades: dict = None) -> str:
        entidades = entidades or {}

        respostas = {
             
    # IN√çCIO
    "boas_vindas": MENSAGEM_INICIAL,
    "quero_agendar": f"üìÖ √ìtimo! Posso te ajudar a agendar com nosso m√©dico especialista. Quer que eu envie o link agora, {self.nome}?",
    "ver_horario": f"üìÜ O pr√≥ximo hor√°rio dispon√≠vel √©: {consultar_horario()}. Posso reservar pra voc√™?",

    # VALORES
    "duvida_valores": "üí∞ Temos valores acess√≠veis, com parcelamento. Posso te mostrar os detalhes e como agendar.",

    # GERAL / CONFIAN√áA
    "duvida_geral": "üìã Nosso sistema conecta voc√™ com m√©dicos especialistas de verdade. Quer saber como funciona na pr√°tica?",
    "desconfianca": "üîç Entendo. Somos um sistema oficial, com CRM e CNPJ. Posso te mostrar o atendimento real, se quiser.",

    # DEPEND√äNCIA / RECA√çDA / SINTOMAS
    "duvida_dependencia": "üß† A depend√™ncia qu√≠mica √© trat√°vel. Nosso m√©dico pode avaliar sintomas f√≠sicos e emocionais. Quer agendar?",
    "sou_dependente": "üí¨ Reconhecer isso √© um passo gigante. Posso agendar uma escuta com um especialista agora mesmo, se quiser.",
    "recaida": "üîÅ Reca√≠das fazem parte do processo. Quer que eu agende um atendimento pra te ajudar a retomar o cuidado?",
    "abstinencia": "üòì Os sintomas de abstin√™ncia s√£o desafiadores. Podemos te orientar com seguran√ßa. Posso marcar agora?",

    # CRISE / URG√äNCIA
    "sintomas_graves": "‚ö†Ô∏è Sinais de crise detectados. Posso encaminhar voc√™ para um atendimento urgente. Deseja ajuda agora?",
    "amea√ßa_vida": "üö® Sua vida importa. Posso ativar nosso acolhimento de urg√™ncia. Quer que eu inicie agora?",

    # FAMILIAR
    "sou_familiar": "üë™ Voc√™ quer ajudar algu√©m importante. Posso te explicar como funciona e agendar uma escuta para voc√™ ou para ele(a).",
    "familia_pedindo_ajuda": "üß≠ Voc√™ est√° no caminho certo. Posso te mostrar como nossa equipe pode avaliar e orientar esse caso.",
    "familiar_em_crise": "üö® Situa√ß√£o familiar cr√≠tica. Posso acionar nosso time de apoio agora mesmo. Posso seguir com isso?",
    "familia_nao_aceita": "üòî √â dif√≠cil quando a fam√≠lia n√£o apoia. Mas h√° caminhos. Posso te explicar como funciona, mesmo sem o consentimento total.",
    "familia_quebrada": "üíî Muitas fam√≠lias passam por isso. Podemos ajudar na reconstru√ß√£o. Quer agendar uma orienta√ß√£o especializada?",
    "familiar_violento": "‚ö†Ô∏è Em casos de viol√™ncia, seguran√ßa vem primeiro. Posso te mostrar como agir com respaldo m√©dico e legal.",

    # INTERNA√á√ÉO
    "duvida_internacao": "üè• A interna√ß√£o pode ser volunt√°ria ou involunt√°ria, sempre com avalia√ß√£o m√©dica. Quer saber como isso funciona?",
    "quero_internar": "‚úÖ Posso te mostrar o processo completo, legal e cl√≠nico. Posso agendar agora com nosso m√©dico?",

    # FUNIL / OBJEC√ïES / CIRCUNST√ÇNCIAS
    "nao_quero_internar": "Tudo bem. Interna√ß√£o n√£o √© a √∫nica sa√≠da. Posso te explicar outras op√ß√µes com orienta√ß√£o m√©dica.",
    "meu_parente_usa_droga": "üí¨ Entendo. Posso agendar com o especialista pra avaliar a situa√ß√£o de forma profissional.",
    "crise_agora": "‚ö†Ô∏è Se a crise for agora, posso acionar ajuda imediatamente. Deseja isso?",
    "relato_dependencia": "üí° Obrigado por compartilhar. Posso te ajudar com os pr√≥ximos passos. Deseja conversar com o especialista?",
    "resistencia_paciente": "üòî A resist√™ncia √© comum. Mesmo assim, a fam√≠lia pode iniciar a a√ß√£o. Quer que eu te oriente sobre isso?",
    "resistencia_familiar": "üë• Se a fam√≠lia n√£o colabora, podemos trabalhar com quem estiver dispon√≠vel. Posso mostrar como agir mesmo assim?",
    "nao_sou_usuario": "üëç Tranquilo. Se quiser ajudar algu√©m ou tirar d√∫vidas, posso te explicar tudo com calma.",

    # INFORMA√á√ïES COMPLEMENTARES
    "quero_entender": "üìò Posso te explicar tudo sobre o atendimento, desde a escuta at√© o tratamento. Quer come√ßar agora?",
    "curioso": "üòÑ Sem problema. Posso te mostrar como o sistema funciona de verdade. Quer experimentar uma simula√ß√£o real?",
    "pergunta_medico": "üë®‚Äç‚öïÔ∏è O m√©dico √© especialista em depend√™ncia qu√≠mica e avalia√ß√£o cl√≠nica. Quer agendar a escuta?",
    "duvida_medicacao": "üíä Medicamentos s√≥ s√£o indicados ap√≥s avalia√ß√£o. Posso agendar com o profissional, se quiser.",
    "duvida_psicologo": "üß† Temos psic√≥logos na equipe. A avalia√ß√£o inicial √© m√©dica. Quer seguir por esse caminho?",

    # INTENTS EMOCIONAIS / REDE DE APOIO
    "desistiu_antes": "üîÅ Recome√ßar √© poss√≠vel. Estamos aqui pra isso. Quer conversar com o m√©dico novamente?",
    "vergonha_de_falar": "üß° Tudo bem. N√£o precisa se explicar agora. Posso s√≥ ouvir, se quiser.",
    "culpa_familiar": "ü§ù A culpa n√£o ajuda, mas o cuidado sim. Posso te mostrar como come√ßar com leveza.",
    "busca_ajuda_emocional": "üí¨ Tamb√©m acolhemos sofrimento emocional. Quer conversar com um profissional agora?",
    "ajuda_espiritual": "üõê Respeitamos todas as cren√ßas. O acolhimento √© humano, com base √©tica. Posso te explicar melhor?",

    # LEGAIS / CIDADANIA
    "internacao_judicial": "‚öñÔ∏è A interna√ß√£o judicial √© poss√≠vel. Posso te explicar o processo legal e como iniciar.",
    "menor_de_idade": "üë∂ Tratamos casos de menores com responsabilidade. Posso te mostrar os crit√©rios e caminhos.",
    "direitos_paciente": "üìú Tudo √© feito conforme a √©tica m√©dica e a lei. Posso esclarecer o que for preciso.",

    # INSTITUCIONAIS
    "duvida_local": "üìç Temos atendimento online e unidades f√≠sicas. Quer saber se tem perto de voc√™?",
    "duvida_profissionais": "üë©‚Äç‚öïÔ∏è Temos m√©dicos, terapeutas e psic√≥logos. Posso te mostrar como funciona cada etapa.",
    "duvida_sigilo": "üîí Todo atendimento √© sigiloso. Nada √© compartilhado sem sua autoriza√ß√£o. Pode confiar.",

    # CONTROLE DE FLUXO
    "cancelar": "‚úÖ Consulta cancelada. Se quiser retomar, √© s√≥ me avisar.",
    "teste": "üß™ Est√° testando? Posso te mostrar o fluxo real se quiser experimentar de verdade.",
    "elogio": "‚ù§Ô∏è Obrigado! Se quiser seguir com o cuidado, posso te mostrar como funciona na pr√°tica.",
    "erro": "üîÅ Algo deu errado? Posso reenviar ou corrigir rapidinho.",
    "sem_compreensao": "ü§î N√£o entendi muito bem. Pode tentar explicar de outra forma?",
    "confirmacao_positiva": "üëç Perfeito. Vou seguir com o que propus antes.",
    "confirmacao_negativa": "Tudo bem. Estou aqui se quiser retomar depois.",
}

        # Resposta padr√£o se intent for reconhecida mas sem frase espec√≠fica
        return respostas.get(intent, "T√¥ por aqui, viu? Me conta um pouco mais pra eu poder ajudar melhor.")

# Conte√∫do do arquivo: ./nlu/chatbot_router.py
# app/nlu/chatbot_router.py

from datetime import datetime
from app.config import MONGO_URI
from pymongo import MongoClient
from app.nlu.nlu_classifier import NLUClassifier
from app.nlu.entidade_extractor import EntidadeExtractor
from app.nlu.response_generator import ResponseGenerator
from app.utils.risco import analisar_risco
from app.utils.contexto import salvar_contexto, obter_contexto, limpar_contexto
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
historico = db["respostas_ia"]
leads = db["leads"]

nlu_classifier = NLUClassifier()
entidade_extractor = EntidadeExtractor()

RESPOSTAS_CONFIRMATIVAS = [
    "sim", "claro", "com certeza", "prossiga", "quero", "vim pra isso", "pode sim",
    "segue", "vai", "t√¥ aqui pra isso", "pode falar", "√© isso", "ok", "t√°", "t√° bom",
    "isso", "por favor", "sim quero", "t√¥ dentro", "aham", "manda ver", "pode continuar"
]

class ChatbotRouter:
    def __init__(self, telefone: str, mensagem: str):
        self.telefone = telefone
        self.mensagem = mensagem.strip()
        self.contexto = obter_contexto(telefone)
        self.nome = self.contexto.get("nome", "Paciente")
        self.intent_confianca = 1.0

    def _eh_confirmacao(self) -> bool:
        normalizada = self.mensagem.lower().strip()
        return normalizada in RESPOSTAS_CONFIRMATIVAS

    async def processar(self):
        if self.mensagem.lower().strip() == "melancia vermelha":
            limpar_contexto(self.telefone)
            return {"intent": "reset_manual", "resposta": "üîÑ Hist√≥rico apagado. Pode come√ßar de novo.", "risco": False}

        # Classifica√ß√£o de intent
        intent, self.intent_confianca = nlu_classifier.classificar(self.mensagem)
        entidades = entidade_extractor.extrair(self.mensagem)

        # Atualiza nome se detectado
        if nome := entidades.get("nome"):
            self.nome = nome
            leads.update_one(
                {"telefone": self.telefone},
                {"$set": {"nome": nome}, "$setOnInsert": {"criado_em": datetime.utcnow()}},
                upsert=True
            )
            salvar_contexto(self.telefone, {"nome": nome})

        # Verifica se h√° contexto anterior de confirma√ß√£o pendente
        if self._eh_confirmacao() and self.contexto.get("aguardando_confirmacao") and self.contexto.get("intent_esperada"):
            intent = self.contexto["intent_esperada"]
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent
            })
            risco = analisar_risco(self.mensagem)

        elif self._eh_primeira_interacao():
            intent = "boas_vindas"
            resposta = ResponseGenerator(nome=self.nome).gerar(intent)
            risco = False
            salvar_contexto(self.telefone, {
                "intent_esperada": "quero_agendar",
                "aguardando_confirmacao": True,
                "ultima_intent": "boas_vindas",
                "ultima_mensagem": self.mensagem
            })

        elif self.intent_confianca < 0.6 or intent == "desconhecida":
            resposta = await self._fallback_resposta()
            risco = analisar_risco(self.mensagem)

        else:
            resposta = ResponseGenerator(nome=self.nome).gerar(intent, entidades)
            risco = analisar_risco(self.mensagem)
            salvar_contexto(self.telefone, {
                "intent_esperada": None,
                "aguardando_confirmacao": False,
                "ultima_intent": intent,
                "ultima_mensagem": self.mensagem
            })

        # Registro no hist√≥rico
        historico.insert_one({
            "telefone": self.telefone,
            "mensagem": self.mensagem,
            "resposta": resposta,
            "intent": intent,
            "confianca_intent": self.intent_confianca,
            "risco": risco,
            "nome": self.nome,
            "criado_em": datetime.utcnow()
        })

        return {"intent": intent, "resposta": resposta, "risco": risco}

    def _eh_primeira_interacao(self) -> bool:
        return historico.count_documents({"telefone": self.telefone}) == 0

    async def _fallback_resposta(self) -> str:
        from app.utils.ia_fallback import chamar_ollama
        logging.warning(f"‚ö†Ô∏è Fallback de IA ativado para a mensagem: {self.mensagem}")
        resposta = await chamar_ollama(self.mensagem, self.telefone)
        if len(resposta) > 600:
            resposta = resposta[:580].rstrip() + "... Posso te explicar melhor se quiser."
        return resposta.strip()

# Conte√∫do do arquivo: ./nlu/nlu_classifier.py
# nlu/nlu_classifier.py

import unicodedata
import re
from app.intents.intents_map import INTENTS # Usando o mapa de intents consolidado
from typing import Tuple, Dict, List
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Placeholder para bibliotecas de ML ---
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.naive_bayes import MultinomialNB
# import joblib # Para salvar/carregar modelos treinados
# MODEL_PATH = "path/to/your/trained_model.joblib"
# VECTORIZER_PATH = "path/to/your/vectorizer.joblib"
# -----------------------------------------

def normalizar_texto(texto: str) -> str:
    """Limpa e normaliza o texto para compara√ß√£o ou processamento NLU."""
    if not texto:
        return ""
    texto = str(texto).lower().strip()
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    # Remove pontua√ß√µes b√°sicas (exceto espa√ßos) - ajuste se precisar manter algo
    texto = re.sub(r'[^\w\s]', '', texto)
    # Opcional: Remover espa√ßos extras
    texto = re.sub(r'\s+', ' ', texto).strip()
    return texto

class NLUClassifier:
    def __init__(self, intents_map: Dict[str, list] = None):
        self.intents_map = intents_map if intents_map else INTENTS
        self.classifier_type = "keyword" # Ou 'ml' se carregar modelo

        # --- Carregamento de Modelo ML (Exemplo) ---
        # try:
        #     self.model = joblib.load(MODEL_PATH)
        #     self.vectorizer = joblib.load(VECTORIZER_PATH)
        #     self.classifier_type = "ml"
        #     logging.info(f"Modelo NLU carregado de {MODEL_PATH}")
        # except FileNotFoundError:
        #     logging.warning("Arquivos de modelo ML n√£o encontrados. Usando classifica√ß√£o por keyword.")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # except Exception as e:
        #     logging.error(f"Erro ao carregar modelo NLU: {e}")
        #     self.model = None
        #     self.vectorizer = None
        #     self.classifier_type = "keyword"
        # -------------------------------------------

    def _classificar_por_keyword(self, texto_normalizado: str) -> Tuple[str, float]:
        """Classifica a intent baseado na presen√ßa de keywords."""
        melhor_intent = "desconhecida"
        max_matches = 0 # Pode ser usado para desempatar ou refinar
        confianca = 0.5 # Confian√ßa base para desconhecida

        # Itera sobre intents e gatilhos
        for intent, gatilhos in self.intents_map.items():
            current_matches = 0
            for g in gatilhos:
                gatilho_normalizado = normalizar_texto(g)
                # Verifica se o gatilho est√° contido no texto
                # Usar `in` √© simples, mas pode ser melhorado (ex: regex com word boundaries \b)
                if gatilho_normalizado and gatilho_normalizado in texto_normalizado:
                    # Keyword match!
                    # L√≥gica simples: primeira intent encontrada vence.
                    # Pode ser melhorado: contar matches, usar pesos, etc.
                    logging.debug(f"Keyword match: '{gatilho_normalizado}' -> Intent: {intent}")
                    return intent, 0.9 # Alta confian√ßa para keyword match direto

        # Se nenhum gatilho foi encontrado
        return melhor_intent, confianca

    # --- Classifica√ß√£o com ML (Exemplo) ---
    # def _classificar_com_ml(self, texto_normalizado: str) -> Tuple[str, float]:
    #     """Classifica a intent usando um modelo de ML pr√©-treinado."""
    #     if not self.model or not self.vectorizer:
    #         return "desconhecida", 0.0 # N√£o pode classificar
    #     try:
    #         vetor = self.vectorizer.transform([texto_normalizado])
    #         # Obter probabilidades para todas as classes
    #         probabilidades = self.model.predict_proba(vetor)[0]
    #         # Encontrar a classe com maior probabilidade
    #         indice_melhor_classe = probabilidades.argmax()
    #         melhor_intent = self.model.classes_[indice_melhor_classe]
    #         confianca = probabilidades[indice_melhor_classe]
    #         logging.debug(f"ML classification: Intent={melhor_intent}, Confian√ßa={confianca:.2f}")
    #         return melhor_intent, float(confianca)
    #     except Exception as e:
    #         logging.error(f"Erro durante classifica√ß√£o ML: {e}")
    #         return "desconhecida", 0.0
    # --------------------------------------

    def classificar(self, texto: str) -> Tuple[str, float]:
        """
        Classifica a intent da mensagem e retorna a intent e um score de confian√ßa.
        """
        texto_normalizado = normalizar_texto(texto)
        if not texto_normalizado:
            return "vazio", 1.0 # Intent especial para mensagem vazia

        if self.classifier_type == "ml":
            # return self._classificar_com_ml(texto_normalizado) # Descomentar se usar ML
            pass # Remover este pass se usar ML
        # Fallback para keyword se ML n√£o estiver ativo ou como m√©todo principal
        return self._classificar_por_keyword(texto_normalizado)


    def listar_intents(self) -> List[str]:
        """Retorna a lista de intents conhecidas."""
        return list(self.intents_map.keys())

    # --- M√©todo de Treinamento (Exemplo - executar offline) ---
    # def treinar_e_salvar_modelo(self, dados_treino_path: str, model_out_path: str, vectorizer_out_path: str):
    #     """Carrega dados, treina um modelo simples e salva."""
    #     # 1. Carregar dados (ex: de um CSV com colunas 'texto' e 'intent')
    #     # import pandas as pd
    #     # df = pd.read_csv(dados_treino_path)
    #     # textos = df['texto'].apply(normalizar_texto).tolist()
    #     # labels = df['intent'].tolist()
    #
    #     # Usar dados do intents_map como exemplo simples
    #     textos = []
    #     labels = []
    #     for intent, gatilhos in self.intents_map.items():
    #          for g in gatilhos:
    #              textos.append(normalizar_texto(g))
    #              labels.append(intent)
    #
    #     # 2. Vetorizar (TF-IDF √© um exemplo)
    #     self.vectorizer = TfidfVectorizer(max_features=5000) # Ajustar par√¢metros
    #     vetores = self.vectorizer.fit_transform(textos)
    #
    #     # 3. Treinar Modelo (Naive Bayes √© um exemplo simples)
    #     self.model = MultinomialNB()
    #     self.model.fit(vetores, labels)
    #     self.classifier_type = "ml"
    #     logging.info("Modelo NLU treinado.")
    #
    #     # 4. Salvar Modelo e Vetorizador
    #     joblib.dump(self.model, model_out_path)
    #     joblib.dump(self.vectorizer, vectorizer_out_path)
    #     logging.info(f"Modelo salvo em {model_out_path}, Vetorizador salvo em {vectorizer_out_path}")
    # ----------------------------------------------------------
# Conte√∫do do arquivo: ./nlu/entidade_extractor.py
# app/nlu/entidade_extractor.py

import re
import unicodedata
from typing import Dict, Optional
import logging

# Configure o logging (opcional, mas recomendado)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def normalizar_texto(texto: str) -> str:
    texto = texto.lower().strip()
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto

class EntidadeExtractor:
    def __init__(self):
        self.padroes = {
            "nome": [
                r"(?:me chamo|sou o|sou a|meu nome e|nome e)\s+([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)",
                r"([A-Z√Å√â√ç√ì√öA-Za-z√°√©√≠√≥√∫]+)\s+(?:√© meu nome|meu nome √©|aqui √©)" # Novo padr√£o
            ],
            "familiar": [
                r"(?:meu|minha|sou)\s+(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)",
                r"(filho|filha|irmao|irma|pai|mae|esposo|esposa|tio|tia|primo|prima|avo|av√¥|av√≥|enteado|enteada)\s+(?:√© meu|minha)" # Novo padr√£o
            ],
            "cidade": [
                r"(?:moro em|sou de|vim de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)",
                r"(?:cidade de)\s+([A-Za-z√°√©√≠√≥√∫√£√µ√¢√™√Æ√¥√ª√ß\s]+)" # Novo padr√£o
            ],
            "uso_drogas": [
                r"(uso|uso drogas|sou viciado|sou dependente|tenho vicio|viciado em|cheiro|fumo|bebo)", # Novo padr√£o
                r"(?:dependente de|viciado em)\s+(maconha|crack|alcool|coca√≠na)"
            ],
            "recaida": [
                r"(reca[√≠i]da|voltei a usar|fracassei|escorreguei|tive um deslize|usei de novo)",
                r"(?:tive uma)\s+(reca[√≠i]da|escorregada)" # Novo padr√£o
            ],
            # Adicione mais entidades e padr√µes conforme necess√°rio
        }

    def extrair(self, texto: str) -> Dict[str, str]:
        texto_original = texto.strip()
        texto_normalizado = normalizar_texto(texto)
        entidades = {}

        for entidade, padroes in self.padroes.items():
            for padrao in padroes:
                match = re.search(padrao, texto_normalizado, re.IGNORECASE)
                if match:
                    entidades[entidade] = match.group(1).strip()
                    logging.debug(f"Entidade '{entidade}' extra√≠da: {entidades[entidade]} (Padr√£o: '{padrao}')")
                    break  # Para na primeira correspond√™ncia

        return entidades
