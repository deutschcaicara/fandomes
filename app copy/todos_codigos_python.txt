
# Arquivo: ./utils/faq_respostas.py
# ===========================================================
# Arquivo: utils/faq_respostas.py
# (Baseado no arquivo original fornecido, com chaves normalizadas)
# ===========================================================

# DicionÃ¡rio com perguntas frequentes e suas respostas.
# As chaves estÃ£o em minÃºsculas e sem acentos/pontuaÃ§Ã£o para facilitar a busca.
FAQ_RESPOSTAS = {
    "dependencia quimica": (
        "DependÃªncia quÃ­mica Ã© uma doenÃ§a crÃ´nica caracterizada pelo uso compulsivo de substÃ¢ncias, "
        "apesar das consequÃªncias negativas, afetando o cÃ©rebro e o comportamento."
    ),
    "identificar dependencia": (
        "Sinais comuns incluem: aumento da tolerÃ¢ncia (precisar de mais para o mesmo efeito), sintomas de abstinÃªncia ao parar/diminuir, "
        "perda de controle sobre o uso, gastar muito tempo obtendo/usando/recuperando-se da substÃ¢ncia, "
        "negligÃªncia de responsabilidades e continuar usando apesar dos problemas causados."
    ),
    "tipos de internacao": (
        "Existem trÃªs tipos principais de internaÃ§Ã£o previstos em lei:\n"
        "1.  **VoluntÃ¡ria:** Quando a prÃ³pria pessoa busca ajuda e concorda com a internaÃ§Ã£o.\n"
        "2.  **InvoluntÃ¡ria:** Solicitada por um familiar ou responsÃ¡vel legal, sem o consentimento da pessoa, mas *obrigatoriamente* com um laudo mÃ©dico detalhado atestando a necessidade (risco para si ou outros).\n"
        "3.  **CompulsÃ³ria:** Determinada pela JustiÃ§a, geralmente em casos mais complexos e apÃ³s avaliaÃ§Ã£o mÃ©dica."
    ),
    "como funciona o tratamento": (
        "O tratamento em uma clÃ­nica geralmente Ã© multidisciplinar e inclui:\n"
        "-   **DesintoxicaÃ§Ã£o:** Fase inicial para lidar com a abstinÃªncia fÃ­sica, com supervisÃ£o mÃ©dica.\n"
        "-   **Terapias:** Individual e em grupo (como Terapia Cognitivo-Comportamental - TCC, Entrevista Motivacional) para entender as causas, mudar comportamentos e prevenir recaÃ­das.\n"
        "-   **Acompanhamento MÃ©dico e PsiquiÃ¡trico:** Para tratar a dependÃªncia e possÃ­veis outras condiÃ§Ãµes (comorbidades).\n"
        "-   **Grupos de Apoio:** Incentivo Ã  participaÃ§Ã£o em grupos como NarcÃ³ticos AnÃ´nimos (N.A.) ou AlcoÃ³licos AnÃ´nimos (A.A.).\n"
        "-   **Atividades TerapÃªuticas:** Ocupacionais, fÃ­sicas, etc., para reestruturaÃ§Ã£o da rotina."
    ),
    "duracao do tratamento": (
        "A duraÃ§Ã£o varia muito. InternaÃ§Ãµes podem durar de 1 a 6 meses, ou atÃ© mais, dependendo da gravidade, do tipo de substÃ¢ncia e da resposta individual. O tratamento ambulatorial (consultas regulares sem internaÃ§Ã£o) pode ser mais longo. O importante Ã© entender que a recuperaÃ§Ã£o Ã© um processo contÃ­nuo, mesmo apÃ³s a alta."
    ),
    "custo do tratamento": (
        "Os valores de uma internaÃ§Ã£o ou tratamento particular variam bastante dependendo da clÃ­nica, estrutura, serviÃ§os incluÃ­dos, tipo de acomodaÃ§Ã£o e tempo de permanÃªncia. Para ter uma proposta adequada ao seu caso, precisamos primeiro entender a situaÃ§Ã£o na consulta inicial de avaliaÃ§Ã£o."
    ),
    "o que fazer se a pessoa nao aceita ajuda": (
        "Ã‰ um desafio comum e muito difÃ­cil para a famÃ­lia. Se a pessoa nÃ£o reconhece o problema ou recusa ajuda, mas estÃ¡ colocando a si mesma ou outros em risco grave, a internaÃ§Ã£o involuntÃ¡ria pode ser uma opÃ§Ã£o legal, mas requer um laudo mÃ©dico detalhado. O primeiro passo Ã© buscar orientaÃ§Ã£o profissional, como na nossa consulta inicial, para avaliar a situaÃ§Ã£o e os caminhos possÃ­veis."
    ),
    "como a familia pode ajudar": (
        "A famÃ­lia Ã© fundamental na recuperaÃ§Ã£o! Algumas formas de ajudar sÃ£o:\n"
        "-   Buscar conhecimento sobre dependÃªncia quÃ­mica para entender a doenÃ§a.\n"
        "-   Oferecer apoio emocional, mas sem facilitar o uso (evitar acobertar, dar dinheiro que possa ser usado para drogas, etc.).\n"
        "-   Estabelecer limites claros e consistentes.\n"
        "-   Participar de grupos de apoio para familiares (como Al-Anon, Nar-Anon) e/ou terapia familiar.\n"
        "-   Incentivar a busca e a manutenÃ§Ã£o do tratamento pela pessoa."
    ),
    "o que e caps": (
        "CAPS Ã© a sigla para Centro de AtenÃ§Ã£o Psicossocial. SÃ£o unidades pÃºblicas do SUS que oferecem atendimento em saÃºde mental. Existem diferentes tipos, como o CAPS AD, especializado em Ã¡lcool e outras drogas. O tratamento no CAPS Ã© gratuito e geralmente ambulatorial (a pessoa vai ao centro durante o dia), sendo uma alternativa importante, especialmente quando a internaÃ§Ã£o nÃ£o Ã© necessÃ¡ria ou viÃ¡vel."
    ),
    "como agendar consulta": (
        "Para agendar a consulta inicial online, que tem o valor de R$100, basta me confirmar seu interesse. Se vocÃª confirmar, eu te enviarei um link seguro para realizar o pagamento. ApÃ³s a confirmaÃ§Ã£o do pagamento, o horÃ¡rio serÃ¡ agendado e vocÃª receberÃ¡ todas as instruÃ§Ãµes."
    ),
    "qual o preco da consulta": (
        "A consulta inicial de avaliaÃ§Ã£o online tem o valor de R$100. Ela Ã© realizada por um profissional especializado para entender em detalhes a situaÃ§Ã£o, oferecer orientaÃ§Ãµes e, se for o caso, indicar o tratamento mais adequado, seja ele ambulatorial ou internaÃ§Ã£o."
    ),
    "consulta online funciona": (
        "Sim, a consulta online Ã© muito eficaz para a avaliaÃ§Ã£o inicial e orientaÃ§Ã£o. Ela permite que um profissional especializado analise o caso com privacidade e comodidade, entenda a necessidade, forneÃ§a direcionamento e, se necessÃ¡rio, um laudo para encaminhamento. Caso uma intervenÃ§Ã£o presencial seja indicada, como uma internaÃ§Ã£o, o profissional farÃ¡ essa recomendaÃ§Ã£o durante a consulta."
    )
    # Adicionar mais FAQs conforme necessÃ¡rio
}


# Arquivo: ./utils/questionario_pos_pagamento.py
# ===========================================================
# Arquivo: utils/questionario_pos_pagamento.py
# ===========================================================
import asyncio
# Ajuste o import se mensageria.py estiver em um diretÃ³rio diferente
from .mensageria import enviar_mensagem
import logging

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- DefiniÃ§Ã£o das Perguntas ---

# Perguntas Fatuais (Originais ou Adaptadas)
PERGUNTAS_FACTUAIS = [
    "Vamos comeÃ§ar com algumas perguntas rÃ¡pidas para ajudar nosso mÃ©dico a entender melhor. Qual o nome completo da pessoa que serÃ¡ avaliada?",
    "Qual a idade aproximada dela?",
    "Qual o seu grau de parentesco com essa pessoa (vocÃª Ã© filho(a), esposa(o), irmÃ£o(Ã£), amigo(a), ou a prÃ³pria pessoa)?",
    "Quais sÃ£o as principais substÃ¢ncias que ela estÃ¡ usando atualmente (por exemplo: Ã¡lcool, cocaÃ­na, crack, maconha, medicamentos controlados sem prescriÃ§Ã£o)?",
    "HÃ¡ quanto tempo, aproximadamente, esse uso se tornou um problema ou se intensificou?",
    "A pessoa jÃ¡ passou por algum tipo de tratamento para dependÃªncia quÃ­mica antes? Se sim, qual(is) e quando?",
    "AlÃ©m da dependÃªncia, existe alguma outra condiÃ§Ã£o de saÃºde importante, fÃ­sica ou mental (como diabetes, pressÃ£o alta, depressÃ£o, ansiedade, esquizofrenia), que devemos saber?",
    "Em qual cidade e estado a pessoa se encontra neste momento?"
]

# Perguntas Emocionais (Adicionadas para a Trilha Emocional)
PERGUNTAS_EMOCIONAIS = [
    "Pensando na situaÃ§Ã£o atual, quais sÃ£o as maiores preocupaÃ§Ãµes ou medos que vocÃª (ou a pessoa a ser avaliada, se nÃ£o for vocÃª) tem enfrentado recentemente?",
    "Olhando para frente, o que vocÃª (ou a pessoa) mais deseja ou espera alcanÃ§ar ao buscar ajuda ou iniciar um tratamento?",
    "Em relaÃ§Ã£o aos sentimentos, existe algum que tem sido muito presente ultimamente por causa dessa situaÃ§Ã£o (por exemplo: culpa, vergonha, raiva, medo, frustraÃ§Ã£o, tristeza, mas tambÃ©m esperanÃ§a ou alÃ­vio)?",
    "De que forma vocÃª percebe que essa situaÃ§Ã£o tem impactado o dia a dia, o trabalho/estudos e os relacionamentos familiares?"
]

# Combina as perguntas na ordem desejada para o questionÃ¡rio completo
# Pode ajustar a ordem se preferir intercalar fatuais e emocionais
QUESTIONARIO_COMPLETO_POS_PAGAMENTO = PERGUNTAS_FACTUAIS + PERGUNTAS_EMOCIONAIS

# --- FunÃ§Ã£o para Iniciar o QuestionÃ¡rio ---

async def iniciar_questionario_pos_pagamento(telefone: str):
    """
    Envia a primeira pergunta do questionÃ¡rio pÃ³s-pagamento.
    A lÃ³gica de salvar o questionÃ¡rio no contexto e enviar as perguntas
    subsequentes Ã© gerenciada por nlp.py.
    """
    total_perguntas = len(QUESTIONARIO_COMPLETO_POS_PAGAMENTO)
    logging.info(f"QUESTIONARIO: ðŸ“‹ Preparando para iniciar ({total_perguntas} perguntas) para {telefone}")

    # Verifica se a lista de perguntas nÃ£o estÃ¡ vazia
    if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
        # Pega a primeira pergunta da lista combinada
        primeira_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
        try:
            # Envia a primeira pergunta para o usuÃ¡rio
            await enviar_mensagem(telefone, primeira_pergunta)
            logging.info(f"QUESTIONARIO: Enviada primeira pergunta para {telefone}.")
            # A continuaÃ§Ã£o do fluxo (salvar contexto, enviar prÃ³ximas perguntas)
            # serÃ¡ tratada em nlp.py quando a resposta do usuÃ¡rio chegar.
        except Exception as e:
            logging.error(f"QUESTIONARIO: âŒ Erro ao enviar a primeira pergunta para {telefone}: {e}")
            # Considerar o que fazer neste caso: tentar novamente? Notificar? Mudar estado?
    else:
        # Loga um aviso se a lista de perguntas estiver vazia
        logging.warning(f"QUESTIONARIO: âš ï¸ Nenhuma pergunta definida. QuestionÃ¡rio nÃ£o iniciado para {telefone}.")


# Arquivo: ./utils/ollama.py
# ===========================================================
# Arquivo: utils/ollama.py
# ===========================================================
import httpx
import logging
import json
import re
# Ajuste o import se config.py estiver em um diretÃ³rio diferente
from app.config import OLLAMA_API_URL, OLLAMA_MODEL

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str | None, dict | None, list | None]:
    """
    Chama a API do Ollama com o prompt fornecido.
    Tenta extrair um JSON do final da resposta.

    Args:
        prompt (str): O prompt completo a ser enviado para a IA.
        telefone (str): O nÃºmero de telefone do usuÃ¡rio (para logging).

    Returns:
        tuple[str | None, dict | None, list | None]:
            - resposta_textual (str | None): A parte textual da resposta da IA.
            - json_extraido (dict | None): O dicionÃ¡rio JSON extraÃ­do do final, ou None.
            - tokens (list | None): InformaÃ§Ãµes sobre tokens (se a API retornar, atualmente None).
    """
    # ValidaÃ§Ã£o inicial
    if not OLLAMA_API_URL or not OLLAMA_MODEL:
        logging.error("âŒ OLLAMA: ConfiguraÃ§Ãµes (OLLAMA_API_URL ou OLLAMA_MODEL) ausentes.")
        return "âš ï¸ Desculpe, estou com problemas tÃ©cnicos para acessar minha inteligÃªncia. Tente novamente mais tarde.", None, None

    # Payload para a API do Ollama
    payload = {
        "model": OLLAMA_MODEL, # Modelo configurado
        "prompt": prompt,
        "stream": False, # NÃ£o usar streaming para facilitar extraÃ§Ã£o do JSON
        # "options": {"temperature": 0.7} # Exemplo de opÃ§Ãµes de geraÃ§Ã£o
        # Tenta forÃ§ar JSON se o prompt explicitamente pedir (pode ser ajustado)
        "format": "json" if "json" in prompt.lower()[-150:] else None # Verifica sÃ³ o final do prompt por "json"
    }
    # Remove format se for None para nÃ£o enviar chave vazia
    if payload["format"] is None:
        del payload["format"]

    headers = {"Content-Type": "application/json"}
    resposta_textual = None
    json_extraido = None
    tokens = None # Placeholder para informaÃ§Ãµes de tokens

    try:
        # Usar httpx para chamadas HTTP assÃ­ncronas
        # Timeout aumentado para 45 segundos para dar tempo Ã  IA
        async with httpx.AsyncClient(timeout=45.0) as client:
            logging.info(f"OLLAMA: Enviando prompt (modelo: {OLLAMA_MODEL}) para {telefone}...")
            # Faz a requisiÃ§Ã£o POST para a API do Ollama
            response = await client.post(f"{OLLAMA_API_URL}/api/generate", json=payload, headers=headers)
            # Levanta uma exceÃ§Ã£o para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            dados = response.json()
            logging.info(f"OLLAMA: âœ… Resposta recebida da IA para {telefone}.")
            # logging.debug(f"OLLAMA: Resposta completa: {dados}") # Log detalhado opcional

            # Extrai a resposta principal do JSON retornado pela API
            resposta_bruta = dados.get("response", "").strip()
            # TODO: Extrair informaÃ§Ãµes de tokens se disponÃ­veis em 'dados' (ex: dados.get("eval_count"), etc.)
            # tokens = {"eval_count": dados.get("eval_count"), ...}

            # Verifica se a resposta nÃ£o estÃ¡ vazia
            if not resposta_bruta:
                logging.warning(f"OLLAMA: âš ï¸ Resposta vazia para {telefone}.")
                return None, None, tokens

            # Tenta extrair JSON do final da resposta bruta
            # Primeiro tenta com ```json ... ``` (com ou sem espaÃ§o antes do {)
            match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```$", resposta_bruta, re.IGNORECASE | re.DOTALL)
            if not match: # Se nÃ£o encontrar, tenta apenas com { ... } no final
                 match = re.search(r"(\{[\s\S]*?\})$", resposta_bruta, re.DOTALL)

            if match:
                # Se encontrou um padrÃ£o JSON, extrai o conteÃºdo
                json_str = match.group(1)
                try:
                    # Tenta converter a string JSON em um dicionÃ¡rio Python
                    json_extraido = json.loads(json_str)
                    # Remove a parte JSON (e os ``` se presentes) da resposta textual
                    resposta_textual = resposta_bruta[:match.start()].strip()
                    logging.info(f"OLLAMA: JSON extraÃ­do com sucesso para {telefone}.")
                except json.JSONDecodeError as json_err:
                    # Se o JSON for invÃ¡lido, loga um aviso e trata a resposta inteira como texto
                    logging.warning(f"OLLAMA: âš ï¸ JSON invÃ¡lido no final da resposta para {telefone}: {json_err}. Retornando resposta bruta como textual.")
                    resposta_textual = resposta_bruta
                    json_extraido = None
            else:
                # Se nÃ£o encontrou JSON no final, toda a resposta Ã© considerada textual
                logging.info(f"OLLAMA: Nenhum JSON encontrado no final da resposta para {telefone}.")
                resposta_textual = resposta_bruta
                json_extraido = None

            # Garante que a resposta textual nÃ£o seja vazia se o JSON foi extraÃ­do com sucesso
            if not resposta_textual and json_extraido is not None:
                 resposta_textual = "Ok." # Retorna um texto mÃ­nimo

            return resposta_textual, json_extraido, tokens

    # Tratamento de exceÃ§Ãµes especÃ­ficas do httpx e genÃ©ricas
    except httpx.TimeoutException as e:
        logging.error(f"OLLAMA: âŒ Erro: Timeout ao chamar para {telefone} ({str(e)})")
        # Retorna uma mensagem de erro amigÃ¡vel para o usuÃ¡rio
        return "âš ï¸ Desculpe, demorei muito para pensar. Poderia tentar de novo?", None, None
    except httpx.HTTPStatusError as e:
        # Loga o erro HTTP e retorna mensagem de erro
        logging.error(f"OLLAMA: âŒ Erro HTTP {e.response.status_code} para {telefone}: {e.response.text}")
        return f"âš ï¸ Ocorreu um erro de comunicaÃ§Ã£o com a inteligÃªncia artificial ({e.response.status_code}). Por favor, tente mais tarde.", None, None
    except Exception as e:
        # Loga qualquer outro erro inesperado
        logging.exception(f"OLLAMA: âŒ Erro desconhecido ao chamar para {telefone}:")
        return "âš ï¸ Ocorreu um erro inesperado ao processar sua solicitaÃ§Ã£o. Tente novamente mais tarde.", None, None


# Arquivo: ./utils/prompt_builder.py
import os
from datetime import datetime
import logging
from pymongo import MongoClient
from app.config import MONGO_URI

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

mongo = MongoClient(MONGO_URI)
db = mongo["famdomes"]
colecao_historico = db["respostas_ia"]

# Ajuste o caminho conforme sua estrutura â€“ certifique-se de que o arquivo existe ou use o fallback
CAMINHO_PROMPT_TXT = os.path.join(os.path.dirname(__file__), "..", "PROMPT_MESTRE_FAMDOMES_CORRIGIDO.txt")

def carregar_prompt_mestre() -> str:
    try:
        with open(CAMINHO_PROMPT_TXT, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception as e:
        logging.error(f"âŒ ERRO ao carregar prompt mestre: {e}")
        return (
            "VocÃª Ã© um assistente virtual especializado em saÃºde mental e dependÃªncia quÃ­mica. "
            "Responda com empatia, clareza e objetividade, seguindo as diretrizes de atendimento."
        )

def construir_prompt(telefone: str, pergunta_atual: str) -> str:
    prompt_mestre = carregar_prompt_mestre()
    trecho_historico = ""
    historico_recente = []
    if colecao_historico is not None:
        try:
            historico_recente = list(
                colecao_historico.find({"telefone": telefone}).sort("criado_em", -1).limit(10)
            )
            historico_recente.reverse()
            pares_formatados = []
            mensagem_usuario_pendente = None
            for item in historico_recente:
                if 'mensagem' in item:
                    mensagem_usuario_pendente = item['mensagem']
                elif 'resposta' in item and mensagem_usuario_pendente:
                    pares_formatados.append(f"UsuÃ¡rio: {mensagem_usuario_pendente}\nAssistente: {item['resposta']}")
                    mensagem_usuario_pendente = None
            trecho_historico = "\n".join(pares_formatados)
            if not trecho_historico:
                trecho_historico = "Nenhuma conversa anterior registrada."
        except Exception as e:
            logging.error(f"âŒ ERRO ao buscar histÃ³rico para {telefone}: {e}")
            trecho_historico = "Erro ao carregar histÃ³rico."
    else:
        trecho_historico = "HistÃ³rico indisponÃ­vel (sem conexÃ£o DB)."
    
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    prompt_final = f"""{prompt_mestre}

---
Contexto Atual:
Data/Hora: {agora}
Telefone: {telefone}
---
HistÃ³rico da Conversa:
{trecho_historico}
---
Nova Mensagem do UsuÃ¡rio:
{pergunta_atual.strip()}
---
InstruÃ§Ãµes para sua Resposta:
1. Responda com empatia, clareza e objetividade.
2. Se apropriado, sugira o agendamento.
3. Use no mÃ¡ximo 400 caracteres.
---
Assistente:"""
    logging.info(f"Prompt construÃ­do para {telefone}. Tamanho: {len(prompt_final)} caracteres.")
    return prompt_final

# Arquivo: ./utils/mensageria.py
# ===========================================================
# Arquivo: utils/mensageria.py
# ===========================================================
import httpx
# Ajuste o import se config.py estiver em um diretÃ³rio diferente
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN
import logging

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

async def enviar_mensagem(telefone: str, mensagem: str) -> dict:
    """
    Envia uma mensagem de texto simples via WhatsApp Cloud API.

    Args:
        telefone (str): NÃºmero de telefone do destinatÃ¡rio (formato internacional, ex: 55119XXXXXXXX).
        mensagem (str): O texto da mensagem a ser enviada.

    Returns:
        dict: Um dicionÃ¡rio com o status do envio ('enviado', 'erro_api', etc.) e detalhes.
    """
    # Verifica se as configuraÃ§Ãµes essenciais da API estÃ£o presentes
    if not WHATSAPP_API_URL or not WHATSAPP_TOKEN:
        logging.error("âŒ ERRO MENSAGERIA: ConfiguraÃ§Ãµes da API do WhatsApp ausentes (URL ou Token).")
        return {"status": "erro_config", "erro": "ConfiguraÃ§Ã£o da API do WhatsApp incompleta."}
    # Verifica se telefone e mensagem nÃ£o estÃ£o vazios
    if not telefone or not mensagem:
        logging.warning("âš ï¸ MENSAGERIA: Tentativa de enviar mensagem vazia ou sem destinatÃ¡rio.")
        return {"status": "erro_input", "erro": "Telefone ou mensagem ausente."}

    # Payload da requisiÃ§Ã£o para a API do WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": telefone, # NÃºmero do destinatÃ¡rio
        "type": "text",
        "text": {
            "preview_url": False, # Desabilita preview de links (geralmente bom para bots)
            "body": mensagem # O conteÃºdo da mensagem
        }
    }
    # CabeÃ§alhos da requisiÃ§Ã£o, incluindo o token de autorizaÃ§Ã£o
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }

    # Define um timeout razoÃ¡vel para a chamada da API externa
    timeout = httpx.Timeout(20.0, connect=5.0) # Timeout aumentado ligeiramente

    try:
        # Usa httpx para fazer a chamada POST assÃ­ncrona
        async with httpx.AsyncClient(timeout=timeout) as client:
            logging.info(f"Enviando mensagem para {telefone}...")
            response = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)
            # Levanta uma exceÃ§Ã£o para respostas com erro (status 4xx ou 5xx)
            response.raise_for_status()

            # Log de sucesso
            logging.info(f"âœ… Mensagem enviada para {telefone}. Status: {response.status_code}")
            # logging.debug(f"Resposta da API WhatsApp: {response.text}") # Log detalhado opcional
            # Retorna status de sucesso e detalhes da resposta da API
            return {"status": "enviado", "code": response.status_code, "retorno": response.json()} # Retorna JSON

    # Tratamento de exceÃ§Ãµes especÃ­ficas do httpx
    except httpx.HTTPStatusError as e:
        # Erro retornado pela API do WhatsApp (ex: nÃºmero invÃ¡lido, token expirado)
        logging.error(f"âŒ ERRO HTTP MENSAGERIA para {telefone}: Status {e.response.status_code}, Resposta: {e.response.text}")
        return {"status": "erro_api", "code": e.response.status_code, "erro": e.response.text}
    except httpx.TimeoutException as e:
        # Erro de timeout ao tentar conectar ou receber resposta da API
        logging.error(f"âŒ ERRO MENSAGERIA: Timeout ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_timeout", "erro": str(e)}
    except httpx.RequestError as e:
        # Erro de conexÃ£o (ex: DNS, rede)
        logging.error(f"âŒ ERRO MENSAGERIA: Erro de ConexÃ£o ao enviar mensagem para {telefone}: {str(e)}")
        return {"status": "erro_conexao", "erro": str(e)}
    # Tratamento de qualquer outra exceÃ§Ã£o inesperada
    except Exception as e:
        logging.exception(f"âŒ ERRO MENSAGERIA: Erro inesperado ao enviar mensagem para {telefone}:")
        return {"status": "erro_desconhecido", "erro": str(e)}


# Arquivo: ./utils/contexto.py
# ===========================================================
# Arquivo: utils/contexto.py
# (v5 - Adicionado estado AGUARDANDO_RESPOSTA_QUALIFICACAO)
# ===========================================================
from pymongo import MongoClient
# Ajuste o import se config.py estiver em um diretÃ³rio diferente
from app.config import MONGO_URI
from datetime import datetime
import logging

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Estados PossÃ­veis da Conversa (Baseado no Mapeamento) ---
ESTADOS_CONVERSA = [
    "INICIAL",
    "IDENTIFICANDO_NECESSIDADE", # Recebe a 1a resposta do usuÃ¡rio
    "AGUARDANDO_RESPOSTA_QUALIFICACAO", # Estado apÃ³s enviar a pergunta combinada (emocional + para quem)
    "EXPLICANDO_CONSULTA",
    "CONFIRMANDO_INTERESSE_AGENDAMENTO",
    "GERANDO_LINK_PAGAMENTO",
    "AGUARDANDO_PAGAMENTO",
    "PAGAMENTO_CONFIRMADO",
    "CONFIRMANDO_AGENDAMENTO",
    "INICIANDO_QUESTIONARIO",
    "COLETANDO_RESPOSTA_QUESTIONARIO",
    "FINALIZANDO_ONBOARDING",
    "SUPORTE_FAQ",
    "RESPONDENDO_COM_IA",
    "VERIFICANDO_SATISFACAO_RESPOSTA",
    "RISCO_DETECTADO",
    "PEDIDO_ATENDENTE_HUMANO",
    "NOTIFICANDO_EQUIPE", # Estado transitÃ³rio antes de AGUARDANDO_ATENDENTE
    "AGUARDANDO_ATENDENTE"
]
# -------------------------------------------------------------

# VariÃ¡veis globais para conexÃ£o com DB (inicializadas no bloco try)
mongo = None
db = None
contextos_db = None
respostas_ia_db = None

try:
    # Estabelece conexÃ£o com MongoDB
    if MONGO_URI:
        mongo = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000) # Timeout de conexÃ£o
        # ForÃ§a a conexÃ£o para verificar se estÃ¡ funcionando
        mongo.server_info()
        db = mongo["famdomes"] # Nome do banco de dados
        contextos_db = db["contexto_conversa"] # ColeÃ§Ã£o para contextos
        respostas_ia_db = db["respostas_ia"] # ColeÃ§Ã£o para histÃ³rico de interaÃ§Ãµes
        # Cria Ã­ndices se nÃ£o existirem (melhora performance de busca)
        contextos_db.create_index("telefone", unique=True)
        respostas_ia_db.create_index("telefone")
        respostas_ia_db.create_index("criado_em")
        logging.info("ConexÃ£o com MongoDB estabelecida e Ã­ndices verificados/criados.")
    else:
        logging.error("âŒ MONGO_URI nÃ£o definido. NÃ£o foi possÃ­vel conectar ao MongoDB.")
except Exception as e:
    # Loga erro se a conexÃ£o falhar
    logging.error(f"âŒ ERRO ao conectar com MongoDB ou criar Ã­ndices: {e}")
    mongo = None
    db = None
    contextos_db = None
    respostas_ia_db = None

def salvar_contexto(telefone: str, dados_atualizacao: dict):
    """
    Salva ou atualiza o contexto da conversa para um telefone.
    Inclui o estado atual da conversa e metadados.
    """
    # ValidaÃ§Ã£o inicial
    if contextos_db is None or not telefone or not isinstance(dados_atualizacao, dict):
        logging.error(f"âŒ Falha ao salvar contexto para {telefone}: DB indisponÃ­vel ou dados invÃ¡lidos.")
        return False
    try:
        # Garante que o estado seja vÃ¡lido, se fornecido
        if "estado" in dados_atualizacao and dados_atualizacao["estado"] not in ESTADOS_CONVERSA:
            logging.warning(f"âš ï¸ Tentativa de salvar estado invÃ¡lido '{dados_atualizacao['estado']}' para {telefone}. Usando estado anterior ou INICIAL.")
            contexto_atual = obter_contexto(telefone) # Busca contexto atual para pegar estado vÃ¡lido
            dados_atualizacao["estado"] = contexto_atual.get("estado", "INICIAL") # MantÃ©m o atual ou vai para INICIAL

        # Recupera o contexto anterior para mesclar metadados
        contexto_anterior = contextos_db.find_one({"telefone": telefone}) or {}

        # ðŸ” Fundir metadados (meta_conversa) de forma inteligente
        meta_conversa_atualizada = contexto_anterior.get("meta_conversa", {})
        if "meta_conversa" in dados_atualizacao:
            meta_nova = dados_atualizacao["meta_conversa"]
            meta_conversa_atualizada = atualizar_meta_conversa(meta_conversa_atualizada, meta_nova)
        # Garante que a meta_conversa final esteja nos dados a serem salvos
        dados_atualizacao["meta_conversa"] = meta_conversa_atualizada


        # Prepara o $set, garantindo que nÃ£o sobrescreva campos imutÃ¡veis como telefone ou _id
        update_set = {k: v for k, v in dados_atualizacao.items() if k not in ['telefone', '_id', 'criado_em']}

        # OperaÃ§Ã£o de update/insert (upsert) no MongoDB
        result = contextos_db.update_one(
            {"telefone": telefone}, # Filtro para encontrar o documento
            {
                "$set": update_set, # Campos a serem atualizados ou adicionados
                "$currentDate": {"ultima_atualizacao": True}, # Atualiza timestamp da Ãºltima modificaÃ§Ã£o
                # Define campos apenas na inserÃ§Ã£o (se o documento nÃ£o existir)
                "$setOnInsert": {
                    "telefone": telefone,
                    "criado_em": datetime.utcnow(), # Timestamp de criaÃ§Ã£o
                    "estado": dados_atualizacao.get("estado", "INICIAL") # Garante estado inicial no upsert
                 }
            },
            upsert=True # Cria o documento se nÃ£o existir
        )
        # Log de sucesso
        if result.upserted_id:
            logging.info(f"ðŸ“Œ Novo contexto criado para {telefone}. Estado inicial: {dados_atualizacao.get('estado', 'INICIAL')}")
        elif result.modified_count > 0:
            logging.info(f"ðŸ“Œ Contexto atualizado para {telefone}. Novo estado: {dados_atualizacao.get('estado', 'N/A')}")
        else:
            # Se nÃ£o modificou, pode ser que os dados sejam os mesmos
            logging.info(f"ðŸ“Œ Contexto para {telefone} nÃ£o modificado (dados iguais?). Estado: {dados_atualizacao.get('estado', 'N/A')}")

        return True
    except Exception as e:
        # Log de erro crÃ­tico com traceback
        logging.exception(f"âŒ ERRO CRÃTICO ao salvar contexto para {telefone}:")
        return False

def atualizar_meta_conversa(meta_antiga: dict, meta_nova: dict) -> dict:
    """
    Mescla campos do novo JSON (meta_nova) com os anteriores (meta_antiga).
    Prioriza dados novos, mas nÃ£o sobrescreve dados antigos com valores vazios ou nulos.
    Listas sÃ£o concatenadas e duplicatas removidas (se possÃ­vel).
    """
    # Garante que ambos sejam dicionÃ¡rios
    if not isinstance(meta_antiga, dict): meta_antiga = {}
    if not isinstance(meta_nova, dict): meta_nova = {}

    resultado = meta_antiga.copy() # ComeÃ§a com os dados antigos

    for chave, valor_novo in meta_nova.items():
        # Ignora chaves com valores nulos ou vazios no novo dict,
        # a menos que a chave nÃ£o exista no antigo (para permitir adicionar chaves vazias)
        if valor_novo is None or valor_novo == "" or (isinstance(valor_novo, list) and not valor_novo):
             if chave not in resultado: # Se a chave Ã© nova, adiciona mesmo se vazia/nula
                 resultado[chave] = valor_novo
             continue # Caso contrÃ¡rio (chave jÃ¡ existe), ignora para nÃ£o sobrescrever dado existente com vazio

        valor_antigo = resultado.get(chave)

        # Se for uma lista, combina e remove duplicatas (se os itens forem hashable)
        if isinstance(valor_novo, list):
            lista_antiga = valor_antigo if isinstance(valor_antigo, list) else []
            try:
                # Tenta converter para set para remover duplicatas (pode falhar se lista contiver dicts)
                resultado[chave] = list(set(lista_antiga + valor_novo))
            except TypeError:
                # Se nÃ£o puder usar set (ex: lista de dicts), apenas concatena itens Ãºnicos
                resultado[chave] = lista_antiga + [item for item in valor_novo if item not in lista_antiga] # Evita duplicatas simples
        # Se o valor antigo nÃ£o existe, ou Ã© considerado "vazio", atualiza com o novo
        elif valor_antigo is None or valor_antigo == "" or valor_antigo == "desconhecido":
             resultado[chave] = valor_novo
        # Se ambos existem e nÃ£o sÃ£o listas, o novo valor geralmente prevalece
        # ExceÃ§Ã£o: nÃ£o sobrescrever um valor especÃ­fico com 'desconhecido'
        elif valor_novo != "desconhecido":
             resultado[chave] = valor_novo
        # Se valor_novo Ã© 'desconhecido' e jÃ¡ existe um valor antigo, mantÃ©m o antigo

    return resultado


def obter_contexto(telefone: str) -> dict:
    """ObtÃ©m o contexto completo da conversa para um telefone."""
    # ValidaÃ§Ã£o inicial
    if contextos_db is None or not telefone:
        logging.warning(f"Tentativa de obter contexto sem DB ou telefone para {telefone}.")
        return {"estado": "INICIAL", "meta_conversa": {}} # Retorna um contexto padrÃ£o mÃ­nimo
    try:
        # Busca o contexto no MongoDB
        contexto = contextos_db.find_one({"telefone": telefone})
        if contexto:
            # Garante que sempre tenha 'estado' e 'meta_conversa' para evitar erros posteriores
            if "estado" not in contexto or not contexto["estado"]:
                contexto["estado"] = "INICIAL"
            if "meta_conversa" not in contexto or not isinstance(contexto["meta_conversa"], dict):
                contexto["meta_conversa"] = {}
            # Remove o _id do MongoDB para evitar problemas de serializaÃ§Ã£o se necessÃ¡rio
            contexto.pop('_id', None)
            return contexto
        else:
            # Se nÃ£o encontrou, retorna um contexto inicial padrÃ£o
            logging.info(f"Nenhum contexto encontrado para {telefone}, retornando padrÃ£o INICIAL.")
            return {"estado": "INICIAL", "meta_conversa": {}, "telefone": telefone}
    except Exception as e:
        # Log de erro e retorna padrÃ£o seguro
        logging.error(f"âŒ ERRO ao obter contexto para {telefone}: {e}")
        return {"estado": "INICIAL", "meta_conversa": {}, "erro": "Falha ao buscar contexto"}

def limpar_contexto(telefone: str) -> bool:
    """Remove o contexto de conversa e histÃ³rico de IA para um telefone."""
    deleted_context = False
    deleted_history = False

    # Limpa contexto da conversa
    if contextos_db is not None and telefone:
        try:
            result_context = contextos_db.delete_one({"telefone": telefone})
            deleted_context = result_context.deleted_count > 0
            if deleted_context:
                 logging.info(f"ðŸ—‘ï¸ Contexto da conversa limpo para {telefone}.")
            else:
                 logging.info(f"Nenhum contexto de conversa encontrado para limpar para {telefone}.")
        except Exception as e:
            logging.error(f"âŒ ERRO ao limpar contexto da conversa para {telefone}: {e}")

    # Limpa histÃ³rico de IA associado
    if respostas_ia_db is not None and telefone:
        try:
            result_history = respostas_ia_db.delete_many({"telefone": telefone})
            deleted_history = result_history.deleted_count > 0
            if deleted_history:
                 logging.info(f"ðŸ—‘ï¸ HistÃ³rico de IA ({result_history.deleted_count} registros) limpo para {telefone}.")
        except Exception as e:
            logging.error(f"âŒ ERRO ao limpar histÃ³rico de IA para {telefone}: {e}")

    # Retorna True se pelo menos um dos dois foi limpo com sucesso
    return deleted_context or deleted_history


def salvar_resposta_ia(telefone: str, canal: str, mensagem_usuario: str, resposta_gerada: str, intent: str, entidades: dict, risco: bool, sentimento: str | None = None):
    """Salva a interaÃ§Ã£o (mensagem do usuÃ¡rio e resposta da IA) no histÃ³rico."""
    # ValidaÃ§Ã£o inicial
    if respostas_ia_db is None:
        logging.error("âŒ Falha ao salvar resposta IA: DB indisponÃ­vel.")
        return
    try:
        # Garante que entidades seja um dicionÃ¡rio, mesmo que vazio
        entidades_validas = entidades if isinstance(entidades, dict) else {}

        # Cria o documento para inserir no histÃ³rico
        doc = {
            "telefone": telefone,
            "canal": canal,
            "mensagem_usuario": mensagem_usuario,
            "resposta_gerada": resposta_gerada,
            "intent": intent,
            "entidades": entidades_validas, # Dados extraÃ­dos pela IA (ex: nome, substÃ¢ncia)
            "risco": risco, # Resultado da anÃ¡lise de risco
            "sentimento_detectado": sentimento, # [Trilha Emocional] Sentimento da mensagem do usuÃ¡rio
            "criado_em": datetime.utcnow() # Timestamp da interaÃ§Ã£o
        }
        # Insere o documento na coleÃ§Ã£o de histÃ³rico
        respostas_ia_db.insert_one(doc)
        logging.info(f"ðŸ’¾ InteraÃ§Ã£o salva no histÃ³rico de IA para {telefone}.")
    except Exception as e:
        # Log de erro
        logging.error(f"âŒ ERRO ao salvar resposta IA no histÃ³rico: {e}")


# Arquivo: ./utils/nlp.py
# ===========================================================
# Arquivo: utils/nlp.py
# (v7 - Implementada a nova estratÃ©gia de fluxo inicial)
# ===========================================================
import logging
import json
import re
import os # Importado para carregar prompt
from datetime import datetime

# Ajuste os imports conforme a estrutura do seu projeto
from app.utils.ollama import chamar_ollama
# Acesso direto Ã s variÃ¡veis globais de contexto.py para DB
from app.utils.contexto import (
    obter_contexto, salvar_contexto, salvar_resposta_ia,
    respostas_ia_db # Acesso Ã  coleÃ§Ã£o do histÃ³rico
)
from app.utils.faq_respostas import FAQ_RESPOSTAS
from app.utils.risco import analisar_risco
from app.routes.ia import processar_comando # Para aÃ§Ãµes como agendar
from app.config import (
    WHATSAPP_FAMILIAR, BASE_DIR, # Importa o nÃºmero para notificaÃ§Ã£o e diretÃ³rio base
    ROCKETCHAT_URL, ROCKETCHAT_TOKEN, ROCKETCHAT_USER_ID, # Configs para RocketChat
    OLLAMA_API_URL # NecessÃ¡rio para checar se Ollama estÃ¡ configurado
)
from app.utils.mensageria import enviar_mensagem # Para enviar notificaÃ§Ãµes
from app.utils.questionario_pos_pagamento import QUESTIONARIO_COMPLETO_POS_PAGAMENTO # Importa a lista correta
import httpx # Para notificaÃ§Ã£o RocketChat

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes e Textos PadrÃ£o ---
# MENSAGEM_INICIAL = '''ðŸ§  OlÃ¡! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Nova versÃ£o da estratÃ©gia
MENSAGEM_INICIAL = '''ðŸ§  OlÃ¡! Eu sou a Domo, da FAMDOMES. Estou aqui para escutar e ajudar. Como posso te auxiliar hoje?''' # Mantendo a original por enquanto, ajustar se necessÃ¡rio
# Mensagem combinada (ValidaÃ§Ã£o + Emocional + QualificaÃ§Ã£o) - A validaÃ§Ã£o serÃ¡ adicionada dinamicamente
PERGUNTA_COMBINADA_TEMPLATE = "Como vocÃª estÃ¡ se sentindo com toda essa situaÃ§Ã£o neste momento? E sÃ³ para eu direcionar melhor, a ajuda que vocÃª busca Ã© para vocÃª mesmo ou para outra pessoa (ex: filho, esposa, irmÃ£o)?"
RESPOSTA_EXPLICACAO_CONSULTA = '''ðŸ‘¨â€âš•ï¸ A consulta mÃ©dica do FAMDOMES Ã© online, com um profissional que entende profundamente casos de dependÃªncia quÃ­mica e sofrimento familiar.

ðŸ“Œ Ela serve para avaliar a situaÃ§Ã£o, oferecer um laudo se necessÃ¡rio, orientar o melhor caminho e â€” se for o caso â€” encaminhar para uma clÃ­nica parceira com seguranÃ§a e sigilo.

ðŸ’³ O valor Ã© R$100 e pode ser pago online de forma rÃ¡pida.

Posso te enviar o link para agendar agora?'''
MENSAGEM_AGRADECIMENTO_ONBOARDING = "Obrigado por compartilhar essas informaÃ§Ãµes, elas sÃ£o muito importantes para a consulta."
MENSAGEM_ERRO_PADRAO = "ðŸ¤– Desculpe, nÃ£o consegui processar sua mensagem agora. Poderia tentar novamente ou reformular?"
MENSAGEM_ERRO_IA = "ðŸ¤– Oi! Houve um erro aqui ao pensar. Tenta de novo por favor?"
MENSAGEM_RISCO_DIRECIONAMENTO = "Percebi que vocÃª pode estar passando por um momento muito difÃ­cil. Se precisar de ajuda urgente, ligue para o CVV (188) ou SAMU (192). NÃ£o hesite em buscar apoio."
MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO = "Entendido. JÃ¡ notifiquei nossa equipe. AlguÃ©m entrarÃ¡ em contato com vocÃª por aqui assim que possÃ­vel."

RESPOSTAS_AFIRMATIVAS = ["sim", "claro", "quero", "vamos", "ok", "pode ser", "tÃ¡ bom", "aceito", "sim por favor", "sim quero", "com certeza", "tÃ´ dentro", "pode sim", "por favor", "gostaria", "desejo"]
RESPOSTAS_NEGATIVAS = ["nÃ£o", "nao", "agora nÃ£o", "talvez depois", "ainda nÃ£o", "obrigado nÃ£o", "nÃ£o quero", "nao quero"]
PALAVRAS_CHAVE_HUMANO = ["humano", "atendente", "pessoa", "falar com alguem", "alguÃ©m", "falar com um especialista", "falar com vc", "falar contigo"]
# ----------------------------------

# --- FunÃ§Ãµes Auxiliares Implementadas ---

async def analisar_sentimento(texto: str, telefone: str) -> str | None:
    """
    [Trilha Emocional] Analisa o sentimento do texto usando Ollama.
    Retorna 'positivo', 'negativo', 'neutro' ou None em caso de erro.
    """
    if not OLLAMA_API_URL:
        logging.warning("NLP: AnÃ¡lise de sentimento pulada - OLLAMA_API_URL nÃ£o configurado.")
        return "neutro"

    logging.info(f"NLP: [Trilha Emocional] Analisando sentimento para {telefone}: '{texto[:30]}...'")
    prompt_sentimento = f"""
    Analise o sentimento predominante na seguinte mensagem do usuÃ¡rio.
    Responda APENAS com uma das seguintes palavras: 'positivo', 'negativo', 'neutro'.

    Mensagem: "{texto}"

    Sentimento:"""
    try:
        resposta_txt, _, _ = await chamar_ollama(prompt_sentimento, telefone)
        if resposta_txt:
            sentimento_retornado = resposta_txt.strip().lower().replace(".", "")
            if sentimento_retornado in ["positivo", "negativo", "neutro"]:
                logging.info(f"NLP: Sentimento detectado pela IA para {telefone}: {sentimento_retornado}")
                return sentimento_retornado
            else:
                logging.warning(f"NLP: Sentimento retornado pela IA nÃ£o reconhecido ('{sentimento_retornado}'). Usando 'neutro'.")
                return "neutro"
        else:
            logging.warning(f"NLP: IA nÃ£o retornou resposta para anÃ¡lise de sentimento de {telefone}. Usando 'neutro'.")
            return "neutro"
    except Exception as e:
        logging.error(f"NLP: Erro ao chamar IA para anÃ¡lise de sentimento de {telefone}: {e}")
        return None

async def buscar_historico_formatado(telefone: str, limite: int = 5) -> str:
     """ Busca e formata o histÃ³rico recente do MongoDB para o prompt da IA. """
     if respostas_ia_db is None:
         logging.warning(f"NLP: HistÃ³rico indisponÃ­vel para {telefone} (DB nÃ£o conectado).")
         return "HistÃ³rico indisponÃ­vel (DB nÃ£o conectado)."
     logging.debug(f"NLP: Buscando histÃ³rico para {telefone} (limite: {limite})")
     try:
         historico_cursor = respostas_ia_db.find(
             {"telefone": telefone},
             {"mensagem_usuario": 1, "resposta_gerada": 1, "_id": 0}
         ).sort("criado_em", -1).limit(limite)
         historico_lista = list(historico_cursor)
         historico_lista.reverse()
         if not historico_lista:
             return "Nenhuma conversa anterior registrada."
         historico_formatado = ""
         for item in historico_lista:
             if msg_usr := item.get("mensagem_usuario"):
                 historico_formatado += f"UsuÃ¡rio: {msg_usr}\n"
             if msg_bot := item.get("resposta_gerada"):
                 if len(msg_bot) > 150:
                      msg_bot = msg_bot[:150] + "..."
                 historico_formatado += f"Assistente: {msg_bot}\n"
         return historico_formatado.strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao buscar histÃ³rico para {telefone}: {e}")
         return "Erro ao carregar histÃ³rico."

async def construir_prompt_para_ia(telefone: str, pergunta_atual: str, estado: str, meta_conversa: dict) -> str:
     """
     ConstrÃ³i o prompt para o Ollama, incorporando estado, histÃ³rico e contexto emocional.
     Carrega o prompt mestre do arquivo PROMPT_MESTRE.txt.
     """
     historico_recente_formatado = await buscar_historico_formatado(telefone)
     sentimento_anterior = meta_conversa.get("ultimo_sentimento_detectado", None)
     prompt_mestre_path = os.path.join(BASE_DIR, "PROMPT_MESTRE.txt")
     try:
         with open(prompt_mestre_path, "r", encoding="utf-8") as f:
             PROMPT_MESTRE = f.read().strip()
     except Exception as e:
         logging.error(f"NLP: Erro ao carregar prompt mestre de {prompt_mestre_path}: {e}. Usando prompt padrÃ£o.")
         PROMPT_MESTRE = """VocÃª Ã© Domo, um assistente virtual empÃ¡tico da FAMDOMES. Responda com clareza e empatia."""

     meta_filtrada = {
         k: v for k, v in meta_conversa.items()
         if k not in ['questionario_completo', 'historico_recente_formatado'] and not k.startswith('sentimento_q')
     }

     prompt_final = f"""{PROMPT_MESTRE}

     ---
     Contexto da Conversa Atual:
     Telefone: {telefone}
     Estado da Conversa: {estado}
     Sentimento Percebido na Ãšltima InteraÃ§Ã£o: {sentimento_anterior or 'N/A'}
     Dados Conhecidos (meta_conversa): {json.dumps(meta_filtrada, indent=2, ensure_ascii=False, default=str)}
     ---
     HistÃ³rico Recente da Conversa:
     {historico_recente_formatado}
     ---
     Nova Mensagem do UsuÃ¡rio:
     {pergunta_atual.strip()}
     ---
     InstruÃ§Ãµes para sua Resposta OBRIGATÃ“RIAS:
     1. Analise a 'Nova Mensagem do UsuÃ¡rio' considerando o 'Contexto da Conversa Atual'.
     2. Responda em portuguÃªs brasileiro, de forma EMPÃTICA e ACOLHEDORA, especialmente se o sentimento detectado for negativo.
     3. Mantenha o foco nos serviÃ§os da FAMDOMES (consulta, tratamento de dependÃªncia quÃ­mica).
     4. Siga o fluxo indicado pelo 'Estado da Conversa'. Se for 'SUPORTE_FAQ', responda a dÃºvida. Se for 'AGUARDANDO_RESPOSTA_QUALIFICACAO', processe a resposta e siga para explicar a consulta ou responder dÃºvidas. Se for outro estado, guie o usuÃ¡rio para o prÃ³ximo passo lÃ³gico.
     5. Use no mÃ¡ximo 400 caracteres na sua resposta textual.
     6. AO FINAL DA SUA RESPOSTA DE TEXTO, inclua OBRIGATORIAMENTE um JSON VÃLIDO contendo:
        - "intent": A intenÃ§Ã£o principal que vocÃª identificou na mensagem do usuÃ¡rio (ex: "duvida_preco", "confirmou_agendamento", "relato_sentimento", "pergunta_tratamento", "resposta_qualificacao", "desconhecida").
        - "sentimento_detectado": O sentimento predominante na mensagem do usuÃ¡rio (ex: "positivo", "negativo", "neutro", "ansioso", "esperanÃ§oso", "frustrado", "confuso").
        - "entidades": Um dicionÃ¡rio com quaisquer entidades relevantes extraÃ­das (ex: {{"nome_paciente": "Carlos", "substancia": "Ã¡lcool", "para_quem": "filho"}}). Se nÃ£o houver, use {{}}.
     Exemplo de JSON OBRIGATÃ“RIO no final:
     ```json
     {{"intent": "duvida_preco", "sentimento_detectado": "ansioso", "entidades": {{}} }}
     ```
     Outro Exemplo:
     ```json
     {{"intent": "resposta_qualificacao", "sentimento_detectado": "negativo", "entidades": {{"para_quem": "filho"}} }}
     ```
     ---
     Assistente (responda aqui e adicione o JSON obrigatÃ³rio no final):"""
     logging.info(f"NLP: Prompt construÃ­do para {telefone} (Estado: {estado}). Tamanho: {len(prompt_final)} chars.")
     return prompt_final

async def notificar_risco(telefone: str, mensagem: str, analise: dict):
    """ Envia notificaÃ§Ã£o de risco para o nÃºmero configurado. """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    alerta = f"âš ï¸ ALERTA DE RISCO ({timestamp}) âš ï¸\n\nTelefone: {telefone}\nMensagem: \"{mensagem}\"\nAnÃ¡lise: {analise}\n\nRevisÃ£o humana URGENTE necessÃ¡ria."
    logging.warning(f"NLP: Enviando alerta de risco para {WHATSAPP_FAMILIAR}...")
    if WHATSAPP_FAMILIAR:
        try:
            resultado_envio = await enviar_mensagem(WHATSAPP_FAMILIAR, alerta)
            if resultado_envio.get("status") == "enviado" or resultado_envio.get("code") == 200:
                 logging.info(f"NLP: âœ… Alerta de risco enviado com sucesso para {WHATSAPP_FAMILIAR}.")
            else:
                 logging.error(f"NLP: âŒ Falha ao enviar alerta de risco para {WHATSAPP_FAMILIAR}: {resultado_envio.get('erro', resultado_envio)}")
        except Exception as e:
            logging.error(f"NLP: âŒ ExceÃ§Ã£o ao tentar enviar alerta de risco: {e}")
    else:
        logging.warning("NLP: WHATSAPP_FAMILIAR nÃ£o configurado. NÃ£o foi possÃ­vel enviar alerta de risco.")

async def notificar_escalacao_humana(telefone: str, contexto: dict):
    """ Envia notificaÃ§Ã£o para a equipe sobre pedido de atendente humano via RocketChat. """
    if not ROCKETCHAT_URL or not ROCKETCHAT_TOKEN or not ROCKETCHAT_USER_ID:
        logging.error("NLP: âŒ ConfiguraÃ§Ãµes do RocketChat incompletas. NÃ£o Ã© possÃ­vel notificar a equipe.")
        return

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    estado_anterior = contexto.get("estado", "N/A")
    nome_contato = contexto.get("meta_conversa", {}).get("nome_paciente", contexto.get("nome", "Desconhecido"))
    respostas_recentes = {k: v for k, v in contexto.get('meta_conversa', {}).items() if k.startswith('resposta_q')}
    contexto_resumido = json.dumps(respostas_recentes, indent=2, ensure_ascii=False, default=str)
    if len(contexto_resumido) > 1000:
        contexto_resumido = contexto_resumido[:1000] + "\n... (truncado)"

    mensagem_notificacao = (
        f"ðŸ™‹ **Pedido de Atendimento Humano** ({timestamp}) ðŸ™‹\n\n"
        f"**Telefone:** {telefone}\n"
        f"**Nome Contato:** {nome_contato}\n"
        f"**Estado Anterior:** {estado_anterior}\n\n"
        f"**Ãšltimas Respostas (QuestionÃ¡rio/Meta):**\n"
        f"```json\n{contexto_resumido}\n```\n\n"
        f"Por favor, assumir a conversa."
    )
    logging.warning(f"NLP: ðŸ™‹ PEDIDO HUMANO ({timestamp}) - Telefone: {telefone} | Notificando equipe via RocketChat...")

    headers = {
        "X-Auth-Token": ROCKETCHAT_TOKEN,
        "X-User-Id": ROCKETCHAT_USER_ID,
        "Content-Type": "application/json"
    }
    room_id_destino = os.getenv("ROCKETCHAT_ROOM_ID_SUPORTE", "GENERAL")
    payload = {"message": {"rid": room_id_destino, "msg": mensagem_notificacao}}
    post_message_url = f"{ROCKETCHAT_URL}/api/v1/chat.postMessage"

    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            response = await client.post(post_message_url, headers=headers, json=payload)
            response.raise_for_status()
            resposta_api = response.json()
            if resposta_api.get("success"):
                logging.info(f"NLP: âœ… NotificaÃ§Ã£o de escalaÃ§Ã£o enviada com sucesso para RocketChat (Sala: {room_id_destino}).")
            else:
                logging.error(f"NLP: âŒ Falha ao enviar notificaÃ§Ã£o para RocketChat (Sala: {room_id_destino}). Resposta API: {resposta_api}")
    except httpx.HTTPStatusError as e:
        logging.error(f"NLP: âŒ Erro HTTP {e.response.status_code} ao enviar para RocketChat: {e.response.text}")
    except httpx.RequestError as e:
        logging.error(f"NLP: âŒ Erro de conexÃ£o ao enviar para RocketChat: {e}")
    except Exception as e:
        logging.exception("NLP: âŒ Erro inesperado ao enviar notificaÃ§Ã£o para RocketChat:")


# --- FunÃ§Ã£o Principal de Processamento ---

async def processar_mensagem(mensagem: str, telefone: str, canal: str) -> dict:
    """
    Processa a mensagem do usuÃ¡rio com base no estado atual da conversa,
    realiza anÃ¡lise de sentimento/risco, atualiza o estado e retorna a resposta.
    """
    global meta_conversa
    logging.info(f"NLP: ðŸ”„ Processando mensagem de {telefone}...")
    contexto = obter_contexto(telefone)
    estado_atual = contexto.get("estado", "INICIAL")
    meta_conversa = contexto.get("meta_conversa", {})
    texto_mensagem = mensagem.strip()
    texto_lower = texto_mensagem.lower()

    if not isinstance(meta_conversa, dict):
        logging.warning(f"NLP: Meta conversa para {telefone} nÃ£o era um dicionÃ¡rio. Resetando para {{}}.")
        meta_conversa = {}

    logging.info(f"NLP: ðŸ“ž Telefone: {telefone} | Estado Atual: {estado_atual} | Mensagem: '{texto_mensagem[:50]}...'")

    # --- 1. AnÃ¡lise de Risco ---
    analise_risco_resultado = analisar_risco(texto_mensagem)
    risco_detectado = analise_risco_resultado.get("risco_vida") or analise_risco_resultado.get("urgencia_medica")

    if risco_detectado:
        logging.warning(f"NLP: ðŸš¨ RISCO DETECTADO para {telefone}! AnÃ¡lise: {analise_risco_resultado}")
        novo_estado = "RISCO_DETECTADO"
        resposta_final = MENSAGEM_RISCO_DIRECIONAMENTO
        meta_conversa["ultimo_risco"] = datetime.utcnow().isoformat()
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "risco_detectado", meta_conversa, True, None)
        await notificar_risco(telefone, texto_mensagem, analise_risco_resultado)
        return {"resposta": resposta_final, "estado": novo_estado}

    # --- 2. VerificaÃ§Ã£o de Comandos Especiais ---
    if texto_lower == "melancia vermelha":
        logging.info(f"NLP: Comando 'melancia vermelha' recebido de {telefone}. Resetando contexto.")
        limpar_contexto(telefone)
        resposta_final = MENSAGEM_INICIAL # Envia apenas a saudaÃ§Ã£o inicial apÃ³s reset
        novo_estado = "IDENTIFICANDO_NECESSIDADE" # Espera a primeira resposta do usuÃ¡rio
        intent = "reset_comando_e_inicio"
        meta_conversa = {}
        salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": {}})
        salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, {}, False, None)
        return {"resposta": resposta_final, "estado": novo_estado}

    if any(palavra in texto_lower for palavra in PALAVRAS_CHAVE_HUMANO):
         logging.info(f"NLP: Pedido de atendente humano detectado para {telefone}.")
         estado_antes_pedido = estado_atual
         novo_estado = "AGUARDANDO_ATENDENTE"
         resposta_final = MENSAGEM_PEDIDO_HUMANO_CONFIRMACAO
         contexto_para_notificacao = contexto.copy()
         contexto_para_notificacao["estado"] = estado_antes_pedido
         salvar_contexto(telefone, {"estado": novo_estado, "meta_conversa": meta_conversa})
         salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, "pedido_humano", meta_conversa, False, None)
         await notificar_escalacao_humana(telefone, contexto_para_notificacao)
         return {"resposta": resposta_final, "estado": novo_estado}

    # --- 3. LÃ³gica Baseada no Estado Atual ---
    resposta_final = MENSAGEM_ERRO_PADRAO
    novo_estado = estado_atual
    intent = "desconhecida"
    entidades = {}
    sentimento = await analisar_sentimento(texto_mensagem, telefone)
    if meta_conversa is not None:
        meta_conversa["ultimo_sentimento_detectado"] = sentimento
    else:
        meta_conversa = {"ultimo_sentimento_detectado": sentimento}

    try:
        # LÃ³gica para estado INICIAL (Bot acabou de enviar a saudaÃ§Ã£o)
        # NÃ£o deveria receber mensagem do usuÃ¡rio neste estado, mas por seguranÃ§a:
        if estado_atual == "INICIAL":
            logging.warning(f"NLP: Mensagem recebida no estado INICIAL de {telefone}. Tratando como IDENTIFICANDO_NECESSIDADE.")
            estado_atual = "IDENTIFICANDO_NECESSIDADE" # ForÃ§a a transiÃ§Ã£o

        # LÃ³gica para IDENTIFICANDO_NECESSIDADE (UsuÃ¡rio respondeu Ã  saudaÃ§Ã£o inicial)
        if estado_atual == "IDENTIFICANDO_NECESSIDADE":
            # ValidaÃ§Ã£o simples (pode ser melhorada com IA se necessÃ¡rio)
            validacao = "Entendi. " # ValidaÃ§Ã£o genÃ©rica inicial
            if sentimento == "negativo":
                validacao = "Sinto muito que esteja se sentindo assim. "
            elif sentimento == "positivo":
                 validacao = "Que bom ouvir isso. "

            # ConstrÃ³i a pergunta combinada
            resposta_final = validacao + PERGUNTA_COMBINADA_TEMPLATE
            novo_estado = "AGUARDANDO_RESPOSTA_QUALIFICACAO"
            intent = "primeira_resposta_usuario" # Intent da mensagem recebida (pode ser refinado)

        # LÃ³gica para AGUARDANDO_RESPOSTA_QUALIFICACAO (UsuÃ¡rio respondeu Ã  pergunta combinada)
        elif estado_atual == "AGUARDANDO_RESPOSTA_QUALIFICACAO":
            logging.info(f"NLP: Processando resposta de qualificaÃ§Ã£o de {telefone}.")
            meta_conversa["sentimento_resposta_qualificacao"] = sentimento
            # Tenta extrair para quem Ã© a ajuda usando IA ou regras simples
            # Exemplo com regras simples (melhorar com IA/extraÃ§Ã£o de entidades no prompt)
            para_quem = "desconhecido"
            if "filho" in texto_lower or "filha" in texto_lower:
                para_quem = "filho(a)"
            elif "esposo" in texto_lower or "marido" in texto_lower:
                para_quem = "esposo"
            elif "esposa" in texto_lower or "mulher" in texto_lower:
                 para_quem = "esposa"
            elif "irmÃ£o" in texto_lower or "irma" in texto_lower:
                 para_quem = "irmao(a)"
            elif "amigo" in texto_lower or "amiga" in texto_lower:
                 para_quem = "amigo(a)"
            elif "para mim" in texto_lower or "eu mesmo" in texto_lower or "pra mim" in texto_lower:
                 para_quem = "proprio_usuario"
            meta_conversa["para_quem"] = para_quem
            entidades["para_quem"] = para_quem # Salva entidade especÃ­fica desta interaÃ§Ã£o

            # ValidaÃ§Ã£o da resposta emocional
            agradecimento = "Obrigado por compartilhar." if sentimento != "negativo" else "AgradeÃ§o a confianÃ§a em compartilhar."

            # Decide o prÃ³ximo passo
            # Se perguntou preÃ§o especificamente, responde primeiro
            if "preÃ§o" in texto_lower or "valor" in texto_lower or "custo" in texto_lower:
                 resposta_final = f"{agradecimento} A consulta inicial online tem o valor de R$100. Ela Ã© importante para avaliar o caso e definir o melhor caminho. Gostaria que eu explicasse mais sobre como ela funciona?"
                 novo_estado = "SUPORTE_FAQ" # Fica em suporte apÃ³s responder preÃ§o
                 intent = "resposta_qualificacao_com_preco"
            else:
                 # Se nÃ£o pediu preÃ§o, explica a consulta
                 if para_quem != "desconhecido" and para_quem != "proprio_usuario":
                      resposta_final = f"{agradecimento} Entendi que a busca Ã© para {para_quem}. Para esses casos, o primeiro passo recomendado Ã© a nossa consulta inicial online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 else: # Se for para o prÃ³prio usuÃ¡rio ou desconhecido
                      resposta_final = f"{agradecimento} Sabendo que a ajuda Ã© para vocÃª (ou se ainda nÃ£o tiver certeza, a consulta ajuda a definir), o caminho inicial que oferecemos Ã© a consulta de avaliaÃ§Ã£o online.\n\n" + RESPOSTA_EXPLICACAO_CONSULTA
                 novo_estado = "EXPLICANDO_CONSULTA"
                 intent = "resposta_qualificacao_segue_fluxo"


        # LÃ³gica para EXPLICANDO_CONSULTA (UsuÃ¡rio respondeu Ã  explicaÃ§Ã£o da consulta)
        elif estado_atual == "EXPLICANDO_CONSULTA":
             if texto_lower in RESPOSTAS_AFIRMATIVAS:
                 logging.info(f"NLP: UsuÃ¡rio {telefone} confirmou interesse em agendar.")
                 meta_conversa["sentimento_confirmacao_agendamento"] = sentimento
                 try:
                     nome_cliente = contexto.get("nome", meta_conversa.get("nome_paciente", "Cliente"))
                     resultado_comando = await processar_comando({
                         "telefone": telefone,
                         "nome": nome_cliente,
                         "comando": "quero agendar"
                     })
                     resposta_final = resultado_comando.get("mensagem", "Link para pagamento enviado!")
                     if resultado_comando.get("status") == "link_gerado":
                          novo_estado = "AGUARDANDO_PAGAMENTO"
                          intent = "confirmou_agendamento"
                     else:
                          resposta_final = resultado_comando.get("mensagem", MENSAGEM_ERRO_PADRAO)
                          novo_estado = "EXPLICANDO_CONSULTA"
                          intent = "erro_gerar_link"
                 except Exception as e:
                     logging.error(f"NLP: Erro ao processar comando 'quero agendar' para {telefone}: {e}")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     novo_estado = "EXPLICANDO_CONSULTA"
                     intent = "erro_processar_comando"

             elif texto_lower in RESPOSTAS_NEGATIVAS:
                 logging.info(f"NLP: UsuÃ¡rio {telefone} recusou o agendamento por enquanto.")
                 meta_conversa["sentimento_recusa_agendamento"] = sentimento
                 resposta_final = "Entendido. Sem problemas. Se mudar de ideia ou tiver mais alguma dÃºvida, estou Ã  disposiÃ§Ã£o!"
                 novo_estado = "SUPORTE_FAQ"
                 intent = "recusou_agendamento"
             else:
                 logging.info(f"NLP: Resposta nÃ£o conclusiva em EXPLICANDO_CONSULTA para {telefone}. Usando IA.")
                 novo_estado = "SUPORTE_FAQ"
                 # IA serÃ¡ chamada no fallback

        # LÃ³gica para AGUARDANDO_PAGAMENTO
        elif estado_atual == "AGUARDANDO_PAGAMENTO":
             logging.info(f"NLP: Mensagem recebida de {telefone} enquanto aguarda pagamento. Encaminhando para IA.")
             resposta_final = "Recebi sua mensagem enquanto aguardo a confirmaÃ§Ã£o do pagamento. Se tiver alguma dÃºvida sobre o processo ou outra questÃ£o, pode perguntar."
             novo_estado = "SUPORTE_FAQ"
             # IA serÃ¡ chamada no fallback

        # LÃ³gica para CONFIRMANDO_AGENDAMENTO
        elif estado_atual == "CONFIRMANDO_AGENDAMENTO":
             logging.info(f"NLP: Iniciando questionÃ¡rio pÃ³s-pagamento para {telefone}")
             meta_conversa["questionario_completo"] = QUESTIONARIO_COMPLETO_POS_PAGAMENTO
             meta_conversa["num_pergunta_atual"] = 0
             if QUESTIONARIO_COMPLETO_POS_PAGAMENTO:
                 proxima_pergunta = QUESTIONARIO_COMPLETO_POS_PAGAMENTO[0]
                 resposta_final = proxima_pergunta
                 novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                 intent = "iniciou_questionario"
                 salvar_contexto(telefone, {
                     "estado": novo_estado,
                     "meta_conversa": meta_conversa,
                     "ultima_resposta_bot": resposta_final
                 })
                 salvar_resposta_ia(telefone, canal, "Sistema: Iniciou QuestionÃ¡rio", resposta_final, intent, meta_conversa, False, None)
                 return {"resposta": resposta_final, "estado": novo_estado}
             else:
                 logging.warning(f"NLP: QuestionÃ¡rio pÃ³s-pagamento vazio para {telefone}. Finalizando onboarding.")
                 resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                 novo_estado = "FINALIZANDO_ONBOARDING"
                 intent = "questionario_vazio"


        # LÃ³gica para COLETANDO_RESPOSTA_QUESTIONARIO
        elif estado_atual == "COLETANDO_RESPOSTA_QUESTIONARIO":
             num_pergunta_respondida_idx = meta_conversa.get("num_pergunta_atual", 0)
             perguntas_questionario = meta_conversa.get("questionario_completo", [])

             if not isinstance(perguntas_questionario, list):
                 logging.error(f"NLP: Erro: 'questionario_completo' nÃ£o Ã© uma lista no contexto de {telefone}")
                 perguntas_questionario = []

             if num_pergunta_respondida_idx < len(perguntas_questionario):
                 pergunta_respondida_texto = perguntas_questionario[num_pergunta_respondida_idx]
                 chave_resposta = f"resposta_q{num_pergunta_respondida_idx+1}"
                 chave_sentimento = f"sentimento_q{num_pergunta_respondida_idx+1}"
                 meta_conversa[chave_resposta] = texto_mensagem
                 meta_conversa[chave_sentimento] = sentimento
                 logging.info(f"NLP: Resposta Q{num_pergunta_respondida_idx+1} ('{pergunta_respondida_texto[:30]}...') salva para {telefone}. Sentimento: {sentimento}")

                 num_proxima_pergunta_idx = num_pergunta_respondida_idx + 1
                 meta_conversa["num_pergunta_atual"] = num_proxima_pergunta_idx

                 if num_proxima_pergunta_idx < len(perguntas_questionario):
                     proxima_pergunta_texto = perguntas_questionario[num_proxima_pergunta_idx]
                     resposta_final = proxima_pergunta_texto
                     novo_estado = "COLETANDO_RESPOSTA_QUESTIONARIO"
                     intent = f"respondeu_questionario_{num_pergunta_respondida_idx+1}"
                 else:
                     resposta_final = MENSAGEM_AGRADECIMENTO_ONBOARDING
                     novo_estado = "FINALIZANDO_ONBOARDING"
                     intent = "finalizou_questionario"
                     meta_conversa.pop("num_pergunta_atual", None)
                     meta_conversa.pop("questionario_completo", None)
                     logging.info(f"NLP: QuestionÃ¡rio finalizado para {telefone}.")
             else:
                 logging.error(f"NLP: Erro de lÃ³gica no questionÃ¡rio para {telefone}. Estado: {estado_atual}, Contador: {num_pergunta_respondida_idx}, Total Perguntas: {len(perguntas_questionario)}")
                 resposta_final = MENSAGEM_ERRO_PADRAO
                 novo_estado = "SUPORTE_FAQ"
                 intent = "erro_logica_questionario"


        # --- 4. Fallback com IA ---
        if novo_estado == estado_atual and estado_atual not in ["RISCO_DETECTADO", "AGUARDANDO_ATENDENTE", "FINALIZANDO_ONBOARDING", "CONFIRMANDO_AGENDAMENTO"]:
            logging.info(f"NLP: Nenhuma regra especÃ­fica tratou a mensagem de {telefone} no estado {estado_atual}. Usando IA como fallback.")

            faq_key_norm = texto_lower.replace("?", "").replace(".", "").replace("!", "").strip()
            matched_faq_key = None
            if faq_key_norm in FAQ_RESPOSTAS:
                matched_faq_key = faq_key_norm
            else:
                for key in FAQ_RESPOSTAS:
                    if key in faq_key_norm:
                        matched_faq_key = key
                        break

            if matched_faq_key:
                 logging.info(f"NLP: Respondendo com FAQ para chave: {matched_faq_key}")
                 resposta_final = FAQ_RESPOSTAS[matched_faq_key]
                 novo_estado = "SUPORTE_FAQ"
                 intent = f"faq_{matched_faq_key.replace(' ', '_')}"
            else:
                 if not OLLAMA_API_URL:
                     logging.error("NLP: âŒ Fallback para IA falhou - OLLAMA_API_URL nÃ£o configurado.")
                     resposta_final = MENSAGEM_ERRO_PADRAO
                     intent = "erro_config_ia"
                     novo_estado = "SUPORTE_FAQ"
                 else:
                     logging.info(f"NLP: Chamando Ollama para {telefone}...")
                     prompt = await construir_prompt_para_ia(telefone, texto_mensagem, estado_atual, meta_conversa)
                     resposta_textual_ia, json_extraido_ia, tokens_ollama = await chamar_ollama(prompt, telefone)

                     if resposta_textual_ia is None or "âš ï¸" in resposta_textual_ia:
                         resposta_final = resposta_textual_ia or MENSAGEM_ERRO_IA
                         intent = "erro_ia_fallback"
                         novo_estado = "SUPORTE_FAQ"
                     else:
                         resposta_final = resposta_textual_ia

                         if json_extraido_ia and isinstance(json_extraido_ia, dict):
                             logging.info(f"NLP: JSON extraÃ­do da IA: {json_extraido_ia}")
                             intent = json_extraido_ia.get("intent", "ia_generica")
                             entidades_ia = json_extraido_ia.get("entidades", {})
                             if isinstance(entidades_ia, dict):
                                  meta_conversa = atualizar_meta_conversa(meta_conversa, entidades_ia)
                                  entidades = entidades_ia
                             else:
                                  logging.warning(f"NLP: Entidades retornadas pela IA nÃ£o sÃ£o um dicionÃ¡rio: {entidades_ia}")

                             sentimento_ia = json_extraido_ia.get("sentimento_detectado")
                             if sentimento_ia and isinstance(sentimento_ia, str):
                                  sentimento = sentimento_ia
                                  meta_conversa["ultimo_sentimento_detectado"] = sentimento
                             else:
                                  logging.warning(f"NLP: Sentimento retornado pela IA invÃ¡lido ou ausente: {sentimento_ia}. Usando sentimento analisado anteriormente: {sentimento}")
                         else:
                              logging.warning("NLP: âš ï¸ IA nÃ£o retornou JSON reconhecÃ­vel no final da resposta.")
                              intent = "ia_generica_sem_json"

                         novo_estado = "SUPORTE_FAQ"

    except Exception as e:
        logging.exception(f"NLP: âŒ ERRO INESPERADO durante processamento da mensagem para {telefone}:")
        resposta_final = MENSAGEM_ERRO_PADRAO
        intent = "erro_processamento_geral"
        novo_estado = estado_atual

    # --- 5. Atualizar Contexto e Salvar HistÃ³rico ---
    meta_conversa_final = meta_conversa if isinstance(meta_conversa, dict) else {}
    contexto_para_salvar = {
        "estado": novo_estado,
        "ultima_resposta_bot": resposta_final,
        "meta_conversa": meta_conversa_final
    }

    salvar_contexto(telefone, contexto_para_salvar)
    salvar_resposta_ia(telefone, canal, texto_mensagem, resposta_final, intent, entidades, risco_detectado, sentimento)

    logging.info(f"NLP: âœ… Processamento concluÃ­do para {telefone}. Novo estado: {novo_estado}. Resposta: '{resposta_final[:50]}...'")
    return {"resposta": resposta_final, "estado": novo_estado}


# Arquivo: ./utils/risco.py
# ===========================================================
# Arquivo: utils/risco.py
# ===========================================================
import logging

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Listas de Palavras-Chave para DetecÃ§Ã£o de Risco ---

# Lista de palavras/frases crÃ­ticas indicando risco de vida (suicÃ­dio, automutilaÃ§Ã£o)
# ATENÃ‡ÃƒO: Esta lista Ã© um ponto de partida e deve ser refinada com cuidado.
PALAVRAS_CRITICAS_VIDA = [
    "suicÃ­dio", "me matar", "quero morrer", "nÃ£o aguento mais", "acabar com tudo",
    "sumir", "desaparecer", "sem esperanÃ§a", "adeus mundo", "nÃ£o quero viver",
    "me cortar", "me machucar", "automutilaÃ§Ã£o", "tirar minha vida", "fim da linha",
    "nÃ£o vejo saÃ­da", "desistir de tudo"
]

# Lista de palavras/frases que indicam URGÃŠNCIA MÃ‰DICA (Overdose, sintomas graves)
PALAVRAS_URGENCIA_MEDICA = [
    "overdose", "passando muito mal", "nÃ£o consigo respirar", "dor no peito forte",
    "desmaiado", "convulsÃ£o", "sangrando muito", "veneno", "infarto", "avc",
    "muita dor", "sem ar", "falta de ar", "alucinaÃ§Ã£o grave", "delÃ­rio intenso",
    "tomou muito remÃ©dio", "ingeriu substÃ¢ncia"
]

# --- FunÃ§Ã£o de AnÃ¡lise de Risco ---

def analisar_risco(texto: str) -> dict:
    """
    Analisa o texto em busca de indicadores de risco (risco de vida, urgÃªncia mÃ©dica).
    Retorna um dicionÃ¡rio com booleanos para 'risco_vida' e 'urgencia_medica'.

    Args:
        texto (str): O texto da mensagem do usuÃ¡rio a ser analisada.

    Returns:
        dict: DicionÃ¡rio contendo:
            - 'risco_vida' (bool): True se detectar palavras crÃ­ticas de risco de vida.
            - 'urgencia_medica' (bool): True se detectar palavras de urgÃªncia mÃ©dica.
    """
    # Retorna False para ambos se o texto for vazio ou nulo
    if not texto:
        return {"risco_vida": False, "urgencia_medica": False}

    # Converte o texto para minÃºsculas para comparaÃ§Ã£o case-insensitive
    texto_lower = texto.lower()

    # Verifica se alguma palavra/frase da lista de risco de vida estÃ¡ presente no texto
    # Usar busca de substring para pegar variaÃ§Ãµes (ex: "quero me matar agora")
    risco_vida_detectado = any(palavra in texto_lower for palavra in PALAVRAS_CRITICAS_VIDA)

    # Verifica se alguma palavra/frase da lista de urgÃªncia mÃ©dica estÃ¡ presente no texto
    urgencia_medica_detectada = any(palavra in texto_lower for palavra in PALAVRAS_URGENCIA_MEDICA)

    # Loga um aviso se algum risco for detectado (o log principal serÃ¡ feito em nlp.py)
    # if risco_vida_detectado:
    #     logging.debug(f"RISCO: Risco de vida potencialmente detectado em '{texto[:50]}...'")
    # if urgencia_medica_detectada:
    #     logging.debug(f"RISCO: UrgÃªncia mÃ©dica potencialmente detectada em '{texto[:50]}...'")

    # Retorna o dicionÃ¡rio com os resultados da anÃ¡lise
    return {
        "risco_vida": risco_vida_detectado,
        "urgencia_medica": urgencia_medica_detectada
    }

# Arquivo: ./utils/agenda.py
# ===========================================================
# Arquivo: utils/agenda.py
# (ImplementaÃ§Ã£o das funÃ§Ãµes de agendamento com DB)
# ===========================================================
from datetime import datetime, timedelta, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure, DuplicateKeyError
# Ajuste o import se config.py estiver em um diretÃ³rio diferente
from app.config import MONGO_URI
import logging
import pytz # Para lidar com fusos horÃ¡rios corretamente

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Constantes de ConfiguraÃ§Ã£o da Agenda ---
DURACAO_CONSULTA_MINUTOS = 20 # DuraÃ§Ã£o de cada bloco de consulta
MAX_TENTATIVAS_AGENDAMENTO = 500 # Limite de blocos a procurar (~6 dias Ãºteis)
HORARIO_OPERACAO_INICIO = 9 # HorÃ¡rio de inÃ­cio das consultas (9:00)
HORARIO_OPERACAO_FIM = 18  # HorÃ¡rio de fim (nÃ£o agenda Ã s 18:00, Ãºltimo bloco comeÃ§a antes)
DIAS_UTEIS = [0, 1, 2, 3, 4] # 0=Segunda, 1=TerÃ§a, ..., 4=Sexta
FUSO_HORARIO_LOCAL = 'America/Sao_Paulo' # Fuso horÃ¡rio de operaÃ§Ã£o

# --- ConexÃ£o com MongoDB ---
mongo_agenda = None
db_agenda = None
consultas_db = None

try:
    # Estabelece conexÃ£o com MongoDB
    if MONGO_URI:
        mongo_agenda = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_agenda.server_info() # Testa a conexÃ£o
        db_agenda = mongo_agenda["famdomes"] # Nome do banco de dados
        consultas_db = db_agenda["consultas_agendadas"] # ColeÃ§Ã£o para agendamentos
        # Cria Ã­ndice Ãºnico para garantir que nÃ£o haja duas consultas no mesmo horÃ¡rio (UTC)
        consultas_db.create_index("horario_utc", unique=True)
        consultas_db.create_index("telefone") # Ãndice para busca por telefone
        consultas_db.create_index([("status", 1), ("horario_utc", 1)]) # Ãndice composto
        logging.info("AGENDA: ConexÃ£o com MongoDB estabelecida e Ã­ndices verificados/criados.")
    else:
        logging.error("AGENDA: âŒ MONGO_URI nÃ£o definido. NÃ£o foi possÃ­vel conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"AGENDA: âŒ Falha na conexÃ£o com MongoDB: {e}")
except Exception as e:
    logging.error(f"AGENDA: âŒ ERRO ao conectar com MongoDB ou criar Ã­ndices: {e}")
    mongo_agenda = None
    db_agenda = None
    consultas_db = None

# --- FunÃ§Ãµes Auxiliares ---

def _proximo_horario_util(inicio_base_utc: datetime) -> datetime:
    """
    AvanÃ§a o horÃ¡rio UTC para o prÃ³ximo bloco de X minutos disponÃ­vel
    dentro do horÃ¡rio de operaÃ§Ã£o e dias Ãºteis definidos.
    """
    horario_utc = inicio_base_utc.replace(tzinfo=timezone.utc) # Garante que estÃ¡ ciente do fuso UTC
    tz_local = pytz.timezone(FUSO_HORARIO_LOCAL)

    while True:
        # Arredonda para o inÃ­cio do prÃ³ximo bloco de N minutos (para cima)
        minutos_atuais = horario_utc.minute
        minutos_para_proximo_bloco = (DURACAO_CONSULTA_MINUTOS - (minutos_atuais % DURACAO_CONSULTA_MINUTOS)) % DURACAO_CONSULTA_MINUTOS
        if minutos_para_proximo_bloco == 0 and (horario_utc.second > 0 or horario_utc.microsecond > 0):
            # Se jÃ¡ estÃ¡ no inÃ­cio do bloco mas tem segundos, avanÃ§a um bloco inteiro
             horario_utc += timedelta(minutes=DURACAO_CONSULTA_MINUTOS)
        elif minutos_para_proximo_bloco > 0 :
            # AvanÃ§a para o inÃ­cio do prÃ³ximo bloco
            horario_utc += timedelta(minutes=minutos_para_proximo_bloco)

        # Zera segundos e microssegundos
        horario_utc = horario_utc.replace(second=0, microsecond=0)

        # Converte para o fuso local para verificar horÃ¡rio de operaÃ§Ã£o e dia da semana
        horario_local = horario_utc.astimezone(tz_local)

        # Verifica se estÃ¡ dentro do horÃ¡rio de operaÃ§Ã£o
        if horario_local.hour < HORARIO_OPERACAO_INICIO:
            # Se for antes do inÃ­cio, ajusta para o inÃ­cio do dia no fuso local e converte de volta para UTC
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horÃ¡rio

        if horario_local.hour >= HORARIO_OPERACAO_FIM:
            # Se for depois do fim, avanÃ§a para o dia seguinte e ajusta para o inÃ­cio
            horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horÃ¡rio

        # Verifica se Ã© dia Ãºtil (no fuso local)
        if horario_local.weekday() not in DIAS_UTEIS:
            # Se nÃ£o for dia Ãºtil, avanÃ§a para o prÃ³ximo dia e ajusta para o inÃ­cio
            # Loop para garantir que caia em um dia Ãºtil
            while horario_local.weekday() not in DIAS_UTEIS:
                 horario_local += timedelta(days=1)
            horario_local = horario_local.replace(hour=HORARIO_OPERACAO_INICIO, minute=0)
            horario_utc = horario_local.astimezone(timezone.utc)
            continue # Reavalia o novo horÃ¡rio

        # Se passou por todas as verificaÃ§Ãµes, o horÃ¡rio Ã© vÃ¡lido
        return horario_utc

def formatar_horario_local(horario_utc: datetime | None, fuso_destino: str = FUSO_HORARIO_LOCAL) -> str:
    """Formata um horÃ¡rio UTC para uma string legÃ­vel no fuso horÃ¡rio local."""
    if not horario_utc or not isinstance(horario_utc, datetime):
        return "IndisponÃ­vel"
    try:
        # Garante que o datetime de entrada estÃ¡ ciente do fuso (UTC)
        if horario_utc.tzinfo is None:
            horario_utc = pytz.utc.localize(horario_utc)

        tz_destino = pytz.timezone(fuso_destino)
        horario_local = horario_utc.astimezone(tz_destino)
        # Formato: DD/MM/AAAA HH:MM (ex: 05/08/2025 14:30)
        return horario_local.strftime("%d/%m/%Y %H:%M")
    except ImportError:
        logging.warning("AGENDA: Biblioteca pytz nÃ£o instalada. Usando formataÃ§Ã£o UTC.")
        return horario_utc.strftime("%d/%m/%Y %H:%M (UTC)") # Fallback para UTC
    except Exception as e:
        logging.error(f"AGENDA: Erro ao formatar horÃ¡rio {horario_utc} para fuso {fuso_destino}: {e}")
        return "Erro na formataÃ§Ã£o"

# --- FunÃ§Ãµes Principais da Agenda ---

def agendar_consulta(telefone: str, nome: str, email: str | None = None) -> datetime | None:
    """
    Encontra o prÃ³ximo horÃ¡rio livre e tenta agendar a consulta.
    Retorna o datetime UTC do horÃ¡rio agendado ou None se nÃ£o conseguir.
    """
    if consultas_db is None:
        logging.error("AGENDA: âŒ NÃ£o Ã© possÃ­vel agendar: Sem conexÃ£o com DB.")
        return None

    # Usar UTC para armazenamento e lÃ³gica interna
    agora_utc = datetime.now(timezone.utc)
    # ComeÃ§a a procurar X minutos Ã  frente para dar tempo de processamento/pagamento
    inicio_procura_utc = agora_utc + timedelta(minutes=DURACAO_CONSULTA_MINUTOS)

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        # Encontra o prÃ³ximo bloco de horÃ¡rio vÃ¡lido (dia Ãºtil, horÃ¡rio de operaÃ§Ã£o)
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)

        # Tenta inserir o agendamento no horÃ¡rio encontrado
        consulta_doc = {
            "telefone": telefone,
            "nome": nome,
            "email": email,
            "horario_utc": horario_tentativa_utc, # Armazena em UTC
            "status": "agendado", # Status inicial
            "criado_em": agora_utc
        }
        try:
            # Tenta inserir o documento. Se o horÃ¡rio jÃ¡ estiver ocupado,
            # o Ã­ndice Ãºnico ("horario_utc") causarÃ¡ um DuplicateKeyError.
            result = consultas_db.insert_one(consulta_doc)
            if result.inserted_id:
                horario_formatado = formatar_horario_local(horario_tentativa_utc)
                logging.info(f"AGENDA: âœ… Consulta marcada para {nome} ({telefone}) em {horario_formatado} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna o horÃ¡rio em UTC
            else:
                # Caso improvÃ¡vel de falha na inserÃ§Ã£o sem exceÃ§Ã£o
                logging.error(f"AGENDA: âŒ Falha desconhecida ao inserir agendamento para {horario_tentativa_utc}.")
                return None

        except DuplicateKeyError:
            # HorÃ¡rio ocupado, avanÃ§a a procura para depois deste bloco
            logging.debug(f"AGENDA: HorÃ¡rio {horario_tentativa_utc.isoformat()} UTC ocupado. Tentando prÃ³ximo.")
            inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # AvanÃ§a 1 min para recalcular prÃ³ximo bloco
            continue # Tenta o prÃ³ximo horÃ¡rio

        except Exception as e:
            # Outro erro durante a inserÃ§Ã£o
            logging.error(f"AGENDA: âŒ ERRO ao tentar inserir agendamento para {horario_tentativa_utc}: {e}")
            return None # Falha no agendamento

    # Se o loop terminar sem encontrar horÃ¡rio
    logging.warning(f"AGENDA: âš ï¸ NÃ£o foram encontrados horÃ¡rios disponÃ­veis para {telefone} ({nome}) apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

def cancelar_consulta(telefone: str) -> int:
    """
    Cancela todas as consultas futuras com status 'agendado' para um telefone.
    Retorna o nÃºmero de consultas canceladas.
    """
    if consultas_db is None:
        logging.error("AGENDA: âŒ NÃ£o Ã© possÃ­vel cancelar: Sem conexÃ£o com DB.")
        return 0

    agora_utc = datetime.now(timezone.utc)
    try:
        # Filtro para encontrar consultas futuras e agendadas do telefone
        filtro = {
            "telefone": telefone,
            "horario_utc": {"$gt": agora_utc}, # Apenas horÃ¡rios futuros
            "status": "agendado" # Apenas consultas que ainda estÃ£o agendadas
        }
        # Atualiza o status para 'cancelado_usuario' em vez de deletar (mantÃ©m histÃ³rico)
        resultado = consultas_db.update_many(
            filtro,
            {"$set": {"status": "cancelado_usuario", "cancelado_em": agora_utc}}
        )

        canceladas = resultado.modified_count
        if canceladas > 0:
            logging.info(f"AGENDA: ðŸ—‘ï¸ Cancelada(s) {canceladas} consulta(s) futura(s) de {telefone}")
        else:
            logging.info(f"AGENDA: Nenhuma consulta futura encontrada para cancelar para {telefone}")
        return canceladas
    except Exception as e:
        logging.error(f"AGENDA: âŒ ERRO ao cancelar consulta(s) para {telefone}: {e}")
        return 0

def consultar_proximo_horario_disponivel() -> datetime | None:
    """
    Consulta o prÃ³ximo horÃ¡rio disponÃ­vel sem agendar.
    Retorna o datetime UTC do horÃ¡rio ou None se nÃ£o encontrar/erro.
    """
    if consultas_db is None:
        logging.error("AGENDA: âŒ NÃ£o Ã© possÃ­vel consultar horÃ¡rio: Sem conexÃ£o com DB.")
        return None

    agora_utc = datetime.now(timezone.utc)
    # ComeÃ§a a procurar um pouco Ã  frente
    inicio_procura_utc = agora_utc + timedelta(minutes=5) # Pequena margem

    for i in range(MAX_TENTATIVAS_AGENDAMENTO):
        horario_tentativa_utc = _proximo_horario_util(inicio_procura_utc)
        try:
            # Verifica se existe alguma consulta agendada ou confirmada para este horÃ¡rio
            filtro_conflito = {
                "horario_utc": horario_tentativa_utc,
                "status": {"$in": ["agendado", "confirmado"]} # Considera ambos como ocupados
            }
            conflito = consultas_db.find_one(filtro_conflito)
            if not conflito:
                # Encontrou horÃ¡rio livre
                logging.info(f"AGENDA: PrÃ³ximo horÃ¡rio disponÃ­vel encontrado: {formatar_horario_local(horario_tentativa_utc)} ({horario_tentativa_utc.isoformat()} UTC)")
                return horario_tentativa_utc # Retorna horÃ¡rio em UTC
            else:
                # HorÃ¡rio ocupado, avanÃ§a para o prÃ³ximo bloco
                logging.debug(f"AGENDA: HorÃ¡rio {horario_tentativa_utc.isoformat()} UTC ocupado (Status: {conflito.get('status')}). Tentando prÃ³ximo.")
                inicio_procura_utc = horario_tentativa_utc + timedelta(minutes=1) # AvanÃ§a 1 min
                continue
        except Exception as e:
            logging.error(f"AGENDA: âŒ ERRO ao consultar prÃ³ximo horÃ¡rio ({horario_tentativa_utc}): {e}")
            return None # Retorna None em caso de erro na consulta

    # Se o loop terminar
    logging.warning(f"AGENDA: âš ï¸ Nenhum horÃ¡rio disponÃ­vel encontrado na consulta apÃ³s {MAX_TENTATIVAS_AGENDAMENTO} tentativas.")
    return None

# Arquivo: ./utils/leads.py
from pymongo import MongoClient
from app.config import MONGO_URI
from datetime import datetime

mongo = MongoClient(MONGO_URI)
leads = mongo["famdomes"]["leads"]

def salvar_lead(paciente_id: str, canal: str, mensagem: str, intent: str, entidades: dict, risco: bool, tipo: str = "desconhecido"):
    leads.update_one(
        {"paciente_id": paciente_id},
        {
            "$set": {
                "mensagem_original": mensagem,
                "intent": intent,
                "entidades": entidades,
                "risco": risco,
                "canal": canal,
                "tipo": tipo,
                "ultima_interacao": datetime.utcnow()
            },
            "$setOnInsert": {
                "paciente_id": paciente_id,
                "criado_em": datetime.utcnow()
            }
        },
        upsert=True
    )

# Arquivo: ./utils/ia_fallback.py
from app.utils.ollama import chamar_ollama as chamar_ollama_completo

async def chamar_ollama(prompt: str, telefone: str) -> tuple[str, list]:
    resposta, tokens = await chamar_ollama_completo(prompt, telefone)
    return resposta, tokens

# Arquivo: ./utils/followup.py
# ===========================================================
# Arquivo: utils/followup.py
# (ImplementaÃ§Ã£o das funÃ§Ãµes de acompanhamento de pagamento)
# ===========================================================
from datetime import datetime, timezone
from pymongo import MongoClient, ReturnDocument
from pymongo.errors import ConnectionFailure
# Ajuste o import se config.py estiver em um diretÃ³rio diferente
from app.config import MONGO_URI
# Importa a funÃ§Ã£o de agendamento para ser chamada apÃ³s o pagamento
# Ajuste o import se agenda.py estiver em um diretÃ³rio diferente
from app.utils.agenda import agendar_consulta, formatar_horario_local
import logging

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- ConexÃ£o com MongoDB ---
mongo_followup = None
db_followup = None
pagamentos_db = None # ColeÃ§Ã£o para rastrear status de pagamento

try:
    # Estabelece conexÃ£o com MongoDB
    if MONGO_URI:
        mongo_followup = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_followup.server_info() # Testa a conexÃ£o
        db_followup = mongo_followup["famdomes"] # Nome do banco de dados
        pagamentos_db = db_followup["pagamentos"] # ColeÃ§Ã£o para pagamentos
        # Cria Ã­ndices se nÃ£o existirem
        pagamentos_db.create_index("telefone")
        pagamentos_db.create_index("id_sessao_stripe", sparse=True, unique=True) # ID da sessÃ£o deve ser Ãºnico
        pagamentos_db.create_index("status")
        pagamentos_db.create_index("criado_em")
        logging.info("FOLLOWUP: ConexÃ£o com MongoDB estabelecida para Pagamentos.")
    else:
        logging.error("FOLLOWUP: âŒ MONGO_URI nÃ£o definido. NÃ£o foi possÃ­vel conectar ao MongoDB.")
except ConnectionFailure as e:
     logging.error(f"FOLLOWUP: âŒ Falha na conexÃ£o com MongoDB: {e}")
except Exception as e:
    logging.error(f"FOLLOWUP: âŒ ERRO ao conectar com MongoDB ou criar Ã­ndices: {e}")
    mongo_followup = None
    db_followup = None
    pagamentos_db = None

# --- FunÃ§Ãµes de Follow-up ---

def iniciar_sessao(telefone: str, nome: str, id_sessao_stripe: str | None = None):
    """
    Registra o inÃ­cio de uma tentativa de pagamento no banco de dados.
    Chamado quando o link de pagamento Ã© gerado. Usa update_one com upsert=True
    para criar ou atualizar o registro baseado no id_sessao_stripe, se fornecido.

    Args:
        telefone (str): Telefone do usuÃ¡rio.
        nome (str): Nome do usuÃ¡rio.
        id_sessao_stripe (str | None): ID da sessÃ£o de checkout do Stripe.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: âŒ Falha ao iniciar sessÃ£o: DB indisponÃ­vel.")
        return

    try:
        agora = datetime.now(timezone.utc)
        # Filtro: usa id_sessao_stripe se disponÃ­vel, senÃ£o cria um novo (ou atualiza baseado em telefone?)
        # Ã‰ mais seguro basear no id_sessao_stripe para evitar sobrescrever sessÃµes ativas
        filtro = {"id_sessao_stripe": id_sessao_stripe} if id_sessao_stripe else {"telefone": telefone, "status": "link_gerado"} # Se sem ID, atualiza Ãºltimo link gerado

        update_data = {
            "$set": {
                "telefone": telefone,
                "nome": nome,
                "status": "link_gerado", # Garante o status correto
                "ultima_atualizacao": agora
            },
            "$setOnInsert": { # Define apenas na criaÃ§Ã£o
                 "id_sessao_stripe": id_sessao_stripe, # SÃ³ define ID na criaÃ§Ã£o se filtro nÃ£o o usou
                 "criado_em": agora
            }
        }
        # Se o filtro usou id_sessao_stripe, garante que ele seja definido no $set tambÃ©m
        if id_sessao_stripe:
            update_data["$set"]["id_sessao_stripe"] = id_sessao_stripe


        result = pagamentos_db.update_one(filtro, update_data, upsert=True)

        if result.upserted_id:
            logging.info(f"FOLLOWUP: ðŸ“ Nova sessÃ£o de pagamento iniciada para {telefone} ({nome}). SessÃ£o: {id_sessao_stripe or 'N/A'}.")
        elif result.modified_count > 0:
             logging.info(f"FOLLOWUP: ðŸ“ SessÃ£o de pagamento atualizada para {telefone} ({nome}). SessÃ£o: {id_sessao_stripe or 'N/A'}.")
        else:
             logging.info(f"FOLLOWUP: ðŸ“ SessÃ£o de pagamento para {telefone} ({nome}) nÃ£o modificada (SessÃ£o: {id_sessao_stripe or 'N/A'}).")

    except Exception as e:
        logging.exception(f"FOLLOWUP: âŒ ERRO ao iniciar/atualizar sessÃ£o de pagamento para {telefone}:")

def marcar_pagamento(
    telefone: str | None = None,
    id_sessao_stripe: str | None = None,
    email_cliente: str | None = None,
    nome_cliente: str | None = None
) -> tuple[datetime | None, str | None]:
    """
    Marca um pagamento como concluÃ­do no banco de dados e tenta agendar a consulta.
    Chamado pelo webhook do Stripe apÃ³s 'checkout.session.completed'.

    Args:
        telefone (str | None): Telefone do usuÃ¡rio (vindo dos metadados do Stripe).
        id_sessao_stripe (str | None): ID da sessÃ£o de checkout do Stripe.
        email_cliente (str | None): Email do cliente (vindo da sessÃ£o Stripe).
        nome_cliente (str | None): Nome do cliente (vindo da sessÃ£o Stripe ou metadados).

    Returns:
        tuple[datetime | None, str | None]:
            - horario_agendado_utc: O horÃ¡rio UTC da consulta agendada, ou None se falhar.
            - nome_final: O nome usado para o agendamento.
    """
    if pagamentos_db is None:
        logging.error("FOLLOWUP: âŒ Falha ao marcar pagamento: DB indisponÃ­vel.")
        return None, None

    # Precisa do id_sessao para garantir que estamos atualizando o pagamento correto
    if not id_sessao_stripe:
        logging.error("FOLLOWUP: âŒ Falha ao marcar pagamento: ID da sessÃ£o Stripe ausente.")
        # Poderia tentar buscar por telefone, mas Ã© arriscado se houver links antigos
        return None, None

    # Monta o filtro para encontrar o registro da sessÃ£o de pagamento pelo ID
    filtro = {"id_sessao_stripe": id_sessao_stripe}

    try:
        agora_utc = datetime.now(timezone.utc)
        # Dados para atualizar o registro
        update_data = {
            "$set": {
                "status": "pago", # Marca como pago
                "pago_em": agora_utc,
                "ultima_atualizacao": agora_utc,
                "email_stripe": email_cliente,
                # Atualiza telefone e nome se vieram do Stripe (podem ter sido preenchidos lÃ¡)
                "telefone": telefone if telefone else "$telefone", # MantÃ©m o original se nÃ£o veio
                "nome": nome_cliente if nome_cliente else "$nome" # MantÃ©m o original se nÃ£o veio
            }
        }

        # Encontra e atualiza o registro do pagamento
        # Retorna o documento APÃ“S a atualizaÃ§Ã£o para pegar os dados mais recentes
        pagamento_atualizado = pagamentos_db.find_one_and_update(
            filtro,
            update_data,
            return_document=ReturnDocument.AFTER # Pega o documento atualizado
        )

        if pagamento_atualizado:
            logging.info(f"FOLLOWUP: ðŸ’° Pagamento confirmado para sessÃ£o {id_sessao_stripe} (Telefone: {pagamento_atualizado.get('telefone')}).")
            # Usa os dados atualizados para agendar
            tel_para_agendar = pagamento_atualizado.get('telefone')
            nome_para_agendar = pagamento_atualizado.get('nome', 'Cliente')
            email_para_agendar = pagamento_atualizado.get('email_stripe') # Usa o email do Stripe

            # Verifica se temos telefone para agendar
            if not tel_para_agendar:
                 logging.error(f"FOLLOWUP: âŒ Telefone ausente no registro de pagamento {id_sessao_stripe} apÃ³s atualizaÃ§Ã£o. NÃ£o Ã© possÃ­vel agendar.")
                 return None, nome_para_agendar # Retorna nome para possÃ­vel notificaÃ§Ã£o

            # --- Tenta Agendar a Consulta ---
            logging.info(f"FOLLOWUP: Tentando agendar consulta para {nome_para_agendar} ({tel_para_agendar})...")
            horario_agendado_utc = agendar_consulta(
                telefone=tel_para_agendar,
                nome=nome_para_agendar,
                email=email_para_agendar
            )

            if horario_agendado_utc:
                logging.info(f"FOLLOWUP: âœ… Consulta agendada com sucesso para {tel_para_agendar} em {formatar_horario_local(horario_agendado_utc)}.")
                # Salva o horÃ¡rio agendado no registro de pagamento
                pagamentos_db.update_one(
                    {"_id": pagamento_atualizado["_id"]},
                    {"$set": {"horario_consulta_agendada_utc": horario_agendado_utc, "status": "agendado"}} # Atualiza status final
                )
                return horario_agendado_utc, nome_para_agendar
            else:
                logging.error(f"FOLLOWUP: âŒ Falha ao agendar consulta para {tel_para_agendar} apÃ³s pagamento.")
                # O pagamento foi marcado, mas o agendamento falhou. Requer atenÃ§Ã£o manual.
                pagamentos_db.update_one(
                     {"_id": pagamento_atualizado["_id"]},
                     {"$set": {"status": "pago_erro_agendamento"}} # Marca status especial
                )
                return None, nome_para_agendar # Retorna None para horÃ¡rio, mas nome para possÃ­vel notificaÃ§Ã£o
        else:
            logging.warning(f"FOLLOWUP: âš ï¸ Nenhum registro de pagamento encontrado para ID SessÃ£o Stripe: {id_sessao_stripe}. Pagamento pode jÃ¡ ter sido processado ou ID invÃ¡lido.")
            return None, None

    except Exception as e:
        logging.exception(f"FOLLOWUP: âŒ ERRO CRÃTICO ao marcar pagamento/agendar para ID SessÃ£o {id_sessao_stripe}:")
        return None, None

# TODO: Adicionar funÃ§Ã£o para checar follow-ups (ex: pagamentos com link_gerado > X horas) se necessÃ¡rio.
# async def checar_followups(): ...


# Arquivo: ./schemas/ia_comando.py
from pydantic import BaseModel

class IAComandoInput(BaseModel):
    telefone: str
    nome: str
    comando: str

# Arquivo: ./routes/resetar.py
from fastapi import APIRouter, HTTPException
from app.utils.contexto import limpar_contexto

router = APIRouter()

@router.post("/painel/resetar-contexto/{telefone}")
def resetar_contexto(telefone: str):
    if not telefone:
        raise HTTPException(status_code=400, detail="Telefone Ã© obrigatÃ³rio.")
    
    try:
        sucesso = limpar_contexto(telefone)
        if sucesso:
            return {"status": "resetado", "telefone": telefone}
        else:
            raise HTTPException(status_code=500, detail="Falha ao tentar limpar o contexto.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro inesperado: {str(e)}")

# Arquivo: ./routes/pagamentos.py
from fastapi import APIRouter, Request
from app.models.pagamentos import PagamentoRequest
import stripe
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
from app.utils.agenda import agendar_consulta
from app.utils.mensageria import enviar_mensagem

stripe.api_key = STRIPE_SECRET_KEY
router = APIRouter()

@router.post("/webhook")
async def stripe_webhook(request: Request):
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return {"erro": str(e)}

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        telefone = session["metadata"].get("telefone")
        nome = session["metadata"].get("nome", "Paciente")
        email = session["metadata"].get("email")

        horario = agendar_consulta(telefone, nome, email)

        msg_paciente = (
            f"âœ… OlÃ¡ {nome}, seu agendamento estÃ¡ confirmado!\n"
            f"ðŸ•’ HorÃ¡rio: {horario.strftime('%d/%m %H:%M')}\n"
            "VocÃª serÃ¡ chamado pelo profissional nesse horÃ¡rio. AtÃ© lÃ¡!"
        )
        enviar_mensagem(telefone, msg_paciente)

        msg_medico = f"ðŸ‘¨â€âš•ï¸ Novo agendamento: {nome} ({telefone}) Ã s {horario.strftime('%d/%m %H:%M')}."
        enviar_mensagem("MEDICO", msg_medico)

        return {"status": "confirmado"}

    return {"status": "ignorado"}

# Arquivo: ./routes/painel.py
from fastapi import APIRouter
from pymongo import MongoClient
from app.config import MONGO_URI

router = APIRouter()

mongo = MongoClient(MONGO_URI)
colecao = mongo["famdomes"]["respostas_ia"]

@router.get("/consulta/{token}")
async def status_consulta(token: str):
    return {
        "token": token,
        "status": "confirmado",
        "mensagem": "Sua sessÃ£o estÃ¡ confirmada com um profissional."
    }

@router.get("/historico/{telefone}")
async def historico_respostas(telefone: str):
    resultados = colecao.find({"telefone": telefone}).sort("criado_em", -1)
    historico = []
    for doc in resultados:
        historico.append({
            "mensagem": doc.get("mensagem"),
            "resposta": doc.get("resposta"),
            "intent": doc.get("intent"),
            "risco": doc.get("risco"),
            "criado_em": doc.get("criado_em").isoformat()
        })
    return {"historico": historico}

# Arquivo: ./routes/nlp.py
from fastapi import APIRouter, Request
from app.utils.nlp import processar_mensagem  
from app.utils.leads import salvar_lead
from datetime import datetime

router = APIRouter()

@router.post("/chat/nlp")
async def chat_nlp(request: Request):
    dados = await request.json()
    mensagem = dados.get("mensagem")
    paciente_id = dados.get("paciente_id")
    canal = dados.get("canal")

    if not mensagem or not paciente_id:
        return {"erro": "Dados incompletos"}

    resultado = await processar_mensagem(mensagem, paciente_id, canal)

    salvar_lead(
        paciente_id=paciente_id,
        canal=canal,
        mensagem=mensagem,
        intent=resultado["intent"],
        entidades=resultado["entidades"],
        risco=resultado["risco"]
    )

    return resultado

# Arquivo: ./routes/stripe.py
# ===========================================================
# Arquivo: routes/stripe.py
# (ImplementaÃ§Ã£o do webhook do Stripe)
# ===========================================================
from fastapi import APIRouter, Request, Header, HTTPException, BackgroundTasks
import stripe # Importa a biblioteca do Stripe
import logging

# Ajuste os imports conforme a estrutura do seu projeto
from app.config import STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
# Importa funÃ§Ãµes de followup e agenda
from app.utils.followup import marcar_pagamento
from app.utils.agenda import formatar_horario_local
# Importa funÃ§Ã£o para salvar contexto e enviar mensagem
from app.utils.contexto import salvar_contexto
from app.utils.mensageria import enviar_mensagem

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este mÃ³dulo
router = APIRouter(prefix="/webhook", tags=["Stripe"]) # Adiciona prefixo e tag

# Define a chave secreta do Stripe (carregada da configuraÃ§Ã£o)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("STRIPE Route: Chave secreta do Stripe configurada.")
else:
    logging.error("STRIPE Route: âŒ Chave secreta do Stripe (STRIPE_SECRET_KEY) nÃ£o configurada. Webhook nÃ£o funcionarÃ¡.")
    # A aplicaÃ§Ã£o pode iniciar, mas o webhook falharÃ¡

@router.post("/stripe/", summary="Recebe eventos do webhook do Stripe")
async def stripe_webhook(request: Request, background_tasks: BackgroundTasks, stripe_signature: str = Header(None)):
    """
    Endpoint para receber eventos do Stripe via webhook.
    Verifica a assinatura e processa eventos relevantes (ex: checkout.session.completed).
    Processa a lÃ³gica principal em background.
    """
    # Verifica se a chave do webhook estÃ¡ configurada
    if not STRIPE_WEBHOOK_SECRET:
        logging.error("STRIPE Route: âŒ Chave secreta do webhook Stripe (STRIPE_WEBHOOK_SECRET) nÃ£o configurada.")
        raise HTTPException(status_code=500, detail="ConfiguraÃ§Ã£o de webhook incompleta no servidor.")

    # ObtÃ©m o corpo bruto da requisiÃ§Ã£o
    payload = await request.body()

    # Verifica a assinatura do webhook para garantir que veio do Stripe
    try:
        event = stripe.Webhook.construct_event(
            payload, stripe_signature, STRIPE_WEBHOOK_SECRET
        )
        logging.info(f"STRIPE Route: Evento recebido tipo: {event['type']} (ID: {event['id']})")
    except ValueError as e:
        # Payload invÃ¡lido
        logging.error(f"STRIPE Route: âŒ Erro ao decodificar payload do webhook: {e}")
        raise HTTPException(status_code=400, detail="Payload invÃ¡lido.")
    except stripe.error.SignatureVerificationError as e:
        # Assinatura invÃ¡lida
        logging.error(f"STRIPE Route: âŒ Erro na verificaÃ§Ã£o da assinatura do webhook: {e}")
        raise HTTPException(status_code=400, detail="Assinatura invÃ¡lida.")
    except Exception as e:
        logging.exception("STRIPE Route: âŒ Erro inesperado ao construir evento do webhook:")
        raise HTTPException(status_code=500, detail="Erro interno ao processar webhook.")

    # --- Processamento do Evento (em Background) ---
    # Adiciona a tarefa de processar o evento em background
    background_tasks.add_task(processar_evento_stripe, event)

    # Retorna 200 OK imediatamente para o Stripe
    return {"status": "recebido"}

async def processar_evento_stripe(event: dict):
    """
    FunÃ§Ã£o executada em background para processar o evento do Stripe.
    """
    event_type = event["type"]
    session = event["data"]["object"] # O objeto da sessÃ£o de checkout

    logging.info(f"STRIPE BG Task: Processando evento tipo: {event_type} (SessÃ£o ID: {session.get('id', 'N/A')})")

    # --- Evento: Checkout ConcluÃ­do com Sucesso ---
    if event_type == "checkout.session.completed":
        # Extrai metadados e informaÃ§Ãµes do cliente da sessÃ£o Stripe
        metadata = session.get("metadata", {})
        telefone_cliente = metadata.get("telefone")
        nome_cliente_meta = metadata.get("nome") # Nome dos metadados (pode ser mais confiÃ¡vel)

        customer_details = session.get("customer_details", {})
        email_cliente = customer_details.get("email")
        nome_cliente_stripe = customer_details.get("name") # Nome direto do Stripe

        # Usa o nome dos metadados como prioridade, senÃ£o o do Stripe
        nome_final = nome_cliente_meta or nome_cliente_stripe or "Cliente"

        id_sessao_stripe = session.get("id")

        # Verifica se temos o telefone (essencial para continuar)
        if not telefone_cliente:
            logging.error(f"STRIPE BG Task: âŒ Evento {event_type} (SessÃ£o: {id_sessao_stripe}) sem 'telefone' nos metadados. NÃ£o Ã© possÃ­vel prosseguir.")
            return # Aborta o processamento

        logging.info(f"STRIPE BG Task: Checkout concluÃ­do para {nome_final} ({telefone_cliente}). SessÃ£o: {id_sessao_stripe}")

        # Tenta marcar o pagamento e agendar a consulta
        horario_agendado_utc, nome_agendado = await asyncio.to_thread(
             marcar_pagamento, # Executa a funÃ§Ã£o sÃ­ncrona em uma thread separada
             telefone=telefone_cliente,
             id_sessao_stripe=id_sessao_stripe,
             email_cliente=email_cliente,
             nome_cliente=nome_final
        )
        # horario_agendado_utc, nome_agendado = marcar_pagamento( # Se marcar_pagamento fosse async
        #     telefone=telefone_cliente,
        #     id_sessao_stripe=id_sessao_stripe,
        #     email_cliente=email_cliente,
        #     nome_cliente=nome_final
        # )


        if horario_agendado_utc:
            # Agendamento bem-sucedido!
            horario_formatado = formatar_horario_local(horario_agendado_utc)
            # Monta mensagem de confirmaÃ§Ã£o para o paciente
            msg_paciente = (
                f"âœ… OlÃ¡ {nome_agendado}, pagamento confirmado!\n\n"
                f"Sua consulta inicial estÃ¡ agendada para:\n"
                f"ðŸ—“ï¸ **{horario_formatado}** (HorÃ¡rio de BrasÃ­lia).\n\n"
                f"O profissional entrarÃ¡ em contato com vocÃª por aqui neste horÃ¡rio. AtÃ© lÃ¡!"
            )
            # Envia a confirmaÃ§Ã£o para o paciente
            await enviar_mensagem(telefone_cliente, msg_paciente)

            # Monta notificaÃ§Ã£o para o mÃ©dico/equipe (opcional)
            # TODO: Definir nÃºmero/canal do mÃ©dico em config.py
            numero_medico = os.getenv("WHATSAPP_MEDICO_AVISO")
            if numero_medico:
                msg_medico = f"ðŸ‘¨â€âš•ï¸ Novo agendamento confirmado:\n\nPaciente: {nome_agendado}\nTelefone: {telefone_cliente}\nHorÃ¡rio: {horario_formatado}"
                await enviar_mensagem(numero_medico, msg_medico)

            # --- ATUALIZA O ESTADO DA CONVERSA ---
            # Muda o estado para iniciar o questionÃ¡rio na prÃ³xima interaÃ§Ã£o
            logging.info(f"STRIPE BG Task: Atualizando estado para CONFIRMANDO_AGENDAMENTO para {telefone_cliente}")
            salvar_contexto(telefone_cliente, {
                "estado": "CONFIRMANDO_AGENDAMENTO",
                "nome": nome_agendado, # Salva/Atualiza o nome no contexto
                "meta_conversa": {"email_cliente": email_cliente} # Salva email na meta
            })

        else:
            # Falha no agendamento apÃ³s pagamento
            logging.error(f"STRIPE BG Task: âŒ Pagamento confirmado para {telefone_cliente}, mas FALHA AO AGENDAR consulta.")
            # Envia mensagem de erro para o paciente
            msg_erro_agendamento = (
                f"âš ï¸ OlÃ¡ {nome_agendado}, seu pagamento foi confirmado, mas houve um problema ao agendar automaticamente sua consulta.\n\n"
                f"NÃ£o se preocupe, nossa equipe jÃ¡ foi notificada e entrarÃ¡ em contato em breve para finalizar o agendamento manualmente. Obrigado pela compreensÃ£o."
            )
            await enviar_mensagem(telefone_cliente, msg_erro_agendamento)
            # TODO: Notificar equipe interna sobre a falha no agendamento automÃ¡tico

    # --- Outros Eventos (Opcional) ---
    # elif event_type == "checkout.session.async_payment_failed":
    #     logging.warning(f"STRIPE BG Task: Pagamento assÃ­ncrono falhou para sessÃ£o {session.get('id')}")
    #     # LÃ³gica para lidar com falha (ex: notificar usuÃ¡rio)
    # elif event_type == "checkout.session.expired":
    #      logging.info(f"STRIPE BG Task: SessÃ£o de checkout expirada: {session.get('id')}")
         # LÃ³gica para lidar com expiraÃ§Ã£o (ex: marcar no DB)

    else:
        # Evento nÃ£o tratado
        logging.info(f"STRIPE BG Task: Evento tipo '{event_type}' nÃ£o tratado.")

    logging.info(f"STRIPE BG Task: Processamento do evento concluÃ­do.")

# Importar asyncio e json se nÃ£o estiverem importados
import asyncio
import json
import os # Para getenv

# Arquivo: ./routes/rocketchat.py
from fastapi import APIRouter, Request
import httpx
from app.config import WHATSAPP_API_URL, WHATSAPP_TOKEN, MONGO_URI
from pymongo import MongoClient
from datetime import datetime

router = APIRouter()

mongo = MongoClient(MONGO_URI)
acompanhamentos = mongo["famdomes"]["acompanhamentos"]

@router.post("/webhook/rocketchat/")
async def receber_rocketchat(request: Request):
    body = await request.json()
    mensagem = body.get("message", {}).get("msg")
    telefone = body.get("message", {}).get("metadata", {}).get("phone")

    if not mensagem or not telefone:
        return {"erro": "mensagem ou telefone ausente"}

    # 1. Marcar como acompanhado, se ainda nÃ£o tiver sido
    existente = acompanhamentos.find_one({"telefone": telefone})
    if not existente:
        acompanhamentos.insert_one({
            "telefone": telefone,
            "mensagem_inicial": mensagem,
            "assumido_em": datetime.utcnow()
        })

    # 2. Enviar ao WhatsApp
    payload = {
        "messaging_product": "whatsapp",
        "to": telefone,
        "type": "text",
        "text": {
            "body": mensagem
        }
    }

    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}"
    }

    async with httpx.AsyncClient() as client:
        r = await client.post(WHATSAPP_API_URL, json=payload, headers=headers)

    return {
        "status": "enviado",
        "whatsapp_code": r.status_code,
        "acompanhamento_registrado": not existente
    }

# Arquivo: ./routes/agendamento.py
# ===========================================================
# Arquivo: routes/agendamento.py
# (Corrigido para importar a funÃ§Ã£o correta de agenda.py)
# ===========================================================
from fastapi import APIRouter, HTTPException
import logging

# Ajuste o import conforme a estrutura do seu projeto
# Importa a funÃ§Ã£o correta para consultar o prÃ³ximo horÃ¡rio
from app.utils.agenda import consultar_proximo_horario_disponivel, formatar_horario_local

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este mÃ³dulo
router = APIRouter(prefix="/agenda", tags=["Agendamento"]) # Adiciona prefixo e tag

@router.get("/proximo", summary="Consulta o prÃ³ximo horÃ¡rio de agendamento disponÃ­vel")
async def proximo_agendamento_disponivel():
    """
    Endpoint para verificar o prÃ³ximo horÃ¡rio livre na agenda.
    Retorna o horÃ¡rio formatado ou uma mensagem indicando indisponibilidade.
    """
    logging.info("AGENDAMENTO Route: Consultando prÃ³ximo horÃ¡rio disponÃ­vel...")
    try:
        # Chama a funÃ§Ã£o correta para obter o prÃ³ximo horÃ¡rio UTC
        horario_utc = consultar_proximo_horario_disponivel()

        if horario_utc:
            # Formata o horÃ¡rio para o fuso local
            horario_formatado = formatar_horario_local(horario_utc)
            logging.info(f"AGENDAMENTO Route: PrÃ³ximo horÃ¡rio encontrado: {horario_formatado}")
            return {"proximo_horario_disponivel": horario_formatado, "horario_utc": horario_utc.isoformat()}
        else:
            # Se a funÃ§Ã£o retornar None (sem horÃ¡rio ou erro no DB)
            logging.info("AGENDAMENTO Route: Nenhum horÃ¡rio disponÃ­vel encontrado.")
            return {"proximo_horario_disponivel": None, "mensagem": "Nenhum horÃ¡rio disponÃ­vel encontrado no momento."}
    except Exception as e:
        # Captura qualquer erro inesperado durante a consulta
        logging.exception("AGENDAMENTO Route: âŒ Erro inesperado ao consultar prÃ³ximo horÃ¡rio:")
        raise HTTPException(status_code=500, detail="Erro interno ao consultar a agenda.")


# Arquivo: ./routes/whatsapp.py
# ===========================================================
# Arquivo: routes/whatsapp.py
# (Recebe webhooks do WhatsApp e chama nlp.py)
# ===========================================================
from fastapi import APIRouter, Request, Response, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
import logging

# Ajuste os imports conforme a estrutura do seu projeto
# Assume que estÃ£o em app/
from app.config import WHATSAPP_VERIFY_TOKEN
from app.utils.mensageria import enviar_mensagem
from app.utils.nlp import processar_mensagem # FunÃ§Ã£o principal de processamento
from app.utils.contexto import limpar_contexto # Para o comando de reset

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este mÃ³dulo
router = APIRouter(prefix="/chat", tags=["WhatsApp"]) # Adiciona prefixo e tag

@router.get("/webhook/whatsapp/", summary="Verifica o webhook do WhatsApp")
async def verificar_webhook(request: Request):
    """
    Endpoint GET para verificar o webhook do WhatsApp durante a configuraÃ§Ã£o na plataforma Meta.
    Responde ao desafio 'hub.challenge'.
    """
    args = request.query_params
    mode = args.get("hub.mode")
    token = args.get("hub.verify_token")
    challenge = args.get("hub.challenge")

    # Verifica se o modo e o token de verificaÃ§Ã£o correspondem ao esperado
    if mode == "subscribe" and token == WHATSAPP_VERIFY_TOKEN:
        logging.info("WHATSAPP Route: âœ… Webhook verificado com sucesso!")
        # Retorna o desafio para confirmar a verificaÃ§Ã£o
        return Response(content=challenge, media_type="text/plain", status_code=200)
    else:
        # Se a verificaÃ§Ã£o falhar, retorna um erro 403 (Proibido)
        logging.warning("WHATSAPP Route: âš ï¸ Falha na verificaÃ§Ã£o do webhook. Token invÃ¡lido ou modo incorreto.")
        return Response(content="Falha na verificaÃ§Ã£o", status_code=403)

@router.post("/webhook/whatsapp/", summary="Recebe mensagens do WhatsApp")
async def receber_mensagem_whatsapp(request: Request, background_tasks: BackgroundTasks):
    """
    Endpoint POST para receber notificaÃ§Ãµes de mensagens do WhatsApp via webhook.
    Processa a mensagem em background para responder rapidamente Ã  Meta.
    """
    try:
        # ObtÃ©m o corpo JSON da requisiÃ§Ã£o de forma assÃ­ncrona
        data = await request.json()
        # logging.debug(f"WHATSAPP Route: Webhook recebido: {json.dumps(data, indent=2)}") # Log detalhado opcional

        # Extrai as informaÃ§Ãµes relevantes da estrutura do webhook
        # Adapte essa extraÃ§Ã£o se a estrutura do payload do webhook mudar
        entry = data.get("entry", [])
        if not entry:
            logging.info("WHATSAPP Route: Webhook recebido sem 'entry'. Ignorando.")
            return Response(status_code=200) # Responde OK para Meta

        changes = entry[0].get("changes", [])
        if not changes:
            logging.info("WHATSAPP Route: Webhook recebido sem 'changes'. Ignorando.")
            return Response(status_code=200)

        value = changes[0].get("value", {})
        messages = value.get("messages", [])
        contacts = value.get("contacts", [])
        statuses = value.get("statuses", []) # Captura eventos de status

        # Prioriza o processamento de mensagens de texto
        if messages and "text" in messages[0] and contacts:
            # Extrai os dados da mensagem e do contato
            mensagem_atual = messages[0]["text"]["body"]
            telefone_usuario = messages[0]["from"]
            # Tenta pegar o nome do perfil, se nÃ£o existir usa o telefone
            nome_usuario = contacts[0].get("profile", {}).get("name", telefone_usuario)

            logging.info(f"WHATSAPP Route: Recebida mensagem de {nome_usuario} ({telefone_usuario})")
            logging.debug(f"WHATSAPP Route: Mensagem: {mensagem_atual}") # Debug para ver a msg

            # Adiciona o processamento da mensagem Ã  fila de background tasks
            # Isso permite retornar 200 OK rapidamente para a Meta
            background_tasks.add_task(processar_e_responder, telefone_usuario, nome_usuario, mensagem_atual)

            # Retorna 200 OK imediatamente
            return Response(status_code=200)

        # Loga eventos de status (entrega, leitura) - opcional
        elif statuses:
            for status_info in statuses:
                status_type = status_info.get("status")
                recipient_id = status_info.get("recipient_id")
                message_id = status_info.get("id")
                timestamp = status_info.get("timestamp")
                logging.debug(f"WHATSAPP Route: Status recebido para {recipient_id} (Msg ID: {message_id}): {status_type} @ {timestamp}")
            return Response(status_code=200)

        else:
            # Se nÃ£o for mensagem de texto ou status conhecido, ignora
            logging.info("WHATSAPP Route: ðŸ“­ Evento ignorado â€“ sem mensagem de texto vÃ¡lida ou status conhecido.")
            return Response(status_code=200)

    # Tratamento de exceÃ§Ãµes gerais durante o processamento inicial do webhook
    except json.JSONDecodeError:
        logging.error("WHATSAPP Route: âŒ Erro ao decodificar JSON do webhook.")
        # Retorna 400 Bad Request se o JSON for invÃ¡lido
        return Response(content="JSON invÃ¡lido", status_code=400)
    except Exception as e:
        # Loga o erro detalhado que causou a falha
        logging.exception(f"WHATSAPP Route: âŒ ERRO CRÃTICO inicial no webhook:")
        # Retorna um erro 500 (Internal Server Error) para a API do WhatsApp
        # Isso pode fazer com que a Meta tente reenviar o webhook
        return Response(content="Erro interno no servidor", status_code=500)


async def processar_e_responder(telefone: str, nome: str, mensagem: str):
    """
    FunÃ§Ã£o executada em background para processar a mensagem e enviar a resposta.
    """
    try:
        logging.info(f"WHATSAPP BG Task: Iniciando processamento para {telefone}...")
        # --- Tratamento de Comando Especial (Reset) ---
        if mensagem.strip().lower() == "melancia vermelha":
            logging.info(f"WHATSAPP BG Task: Comando de reset 'melancia vermelha' recebido de {telefone}. Limpando contexto...")
            sucesso_limpeza = limpar_contexto(telefone)
            if sucesso_limpeza:
                # Envia confirmaÃ§Ã£o de reset (opcional)
                await enviar_mensagem(telefone, "ðŸ”„ Sua conversa foi reiniciada. Pode comeÃ§ar de novo quando quiser.")
            else:
                # Envia mensagem de erro se a limpeza falhar (opcional)
                await enviar_mensagem(telefone, "âš ï¸ Ocorreu um erro ao tentar reiniciar a conversa. Por favor, tente novamente.")
            logging.info(f"WHATSAPP BG Task: Reset concluÃ­do para {telefone}.")
            return # Finaliza a task de background

        # --- Processamento Normal da Mensagem ---
        # Chama a funÃ§Ã£o principal em nlp.py para processar a mensagem
        resultado_processamento = await processar_mensagem(
            mensagem=mensagem,
            telefone=telefone,
            canal="whatsapp" # Define o canal
        )

        # ObtÃ©m a resposta a ser enviada ao usuÃ¡rio
        resposta_para_usuario = resultado_processamento.get("resposta")

        # Envia a resposta de volta ao usuÃ¡rio via WhatsApp
        if resposta_para_usuario:
            logging.info(f"WHATSAPP BG Task: Enviando resposta para {telefone}...")
            await enviar_mensagem(telefone, resposta_para_usuario)
        else:
            # Se nlp.py nÃ£o retornar uma resposta (o que nÃ£o deveria acontecer)
            logging.warning(f"WHATSAPP BG Task: FunÃ§Ã£o processar_mensagem nÃ£o retornou 'resposta' para {telefone}. Enviando erro padrÃ£o.")
            await enviar_mensagem(telefone, "Desculpe, nÃ£o consegui processar sua solicitaÃ§Ã£o no momento.")

        logging.info(f"WHATSAPP BG Task: Processamento e resposta concluÃ­dos para {telefone}.")

    except Exception as e:
        # Loga qualquer erro que ocorra durante o processamento em background
        logging.exception(f"WHATSAPP BG Task: âŒ ERRO durante processamento para {telefone}:")
        # Considerar enviar uma mensagem de erro para o usuÃ¡rio aqui tambÃ©m?
        # await enviar_mensagem(telefone, "Desculpe, ocorreu um erro interno ao processar sua mensagem.")

# Importar json se nÃ£o estiver importado
import json

# Arquivo: ./routes/ia.py
# ===========================================================
# Arquivo: routes/ia.py
# (ContÃ©m a lÃ³gica para processar comandos especÃ­ficos como agendar)
# ===========================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import logging
import stripe # Importa a biblioteca do Stripe
from datetime import datetime, timedelta # Para expiraÃ§Ã£o da sessÃ£o

# Ajuste os imports das funÃ§Ãµes utilitÃ¡rias conforme a estrutura do seu projeto
# Assume que estÃ£o em app/utils/
from app.utils.agenda import (
    agendar_consulta,
    cancelar_consulta,
    consultar_proximo_horario_disponivel,
    formatar_horario_local
)
from app.utils.mensageria import enviar_mensagem
# Assume que followup.py existe e tem iniciar_sessao (se usado)
# from app.utils.followup import iniciar_sessao
# Assume que config.py existe e tem a chave do Stripe
from app.config import STRIPE_SECRET_KEY

# ConfiguraÃ§Ã£o bÃ¡sica de logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cria um roteador FastAPI para este mÃ³dulo
router = APIRouter()

# Define a chave secreta do Stripe (carregada da configuraÃ§Ã£o)
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logging.info("IA Route: Chave secreta do Stripe configurada.")
else:
    logging.warning("IA Route: âš ï¸ Chave secreta do Stripe (STRIPE_SECRET_KEY) nÃ£o configurada.")
    # Considerar levantar um erro ou desabilitar funcionalidade de pagamento

# Modelo Pydantic para validar a entrada da API /ia-comando (se usada)
class ComandoIAInput(BaseModel):
    telefone: str
    nome: str
    comando: str # Ex: "quero agendar", "ver horÃ¡rio", "cancelar"

# --- Endpoint da API (Opcional) ---
@router.post("/ia-comando", summary="Processa comandos especÃ­ficos da IA", tags=["IA"])
async def processar_comando_post(dados: ComandoIAInput):
    """
    Recebe um comando especÃ­fico (agendar, cancelar, ver horÃ¡rio)
    e executa a aÃ§Ã£o correspondente. (Endpoint HTTP opcional)
    """
    # Verifica se a API do Stripe estÃ¡ configurada antes de prosseguir com agendamento
    if "agendar" in dados.comando.lower() and not STRIPE_SECRET_KEY:
         logging.error("IA Route: âŒ Tentativa de agendamento via API sem STRIPE_SECRET_KEY.")
         raise HTTPException(status_code=503, detail="Funcionalidade de pagamento indisponÃ­vel.")

    # Chama a funÃ§Ã£o principal que processa o comando
    resultado = await processar_comando(dados.dict())
    # Retorna o resultado da funÃ§Ã£o
    return resultado

# --- FunÃ§Ã£o Principal de Processamento de Comandos ---
# Esta funÃ§Ã£o Ã© chamada pelo endpoint acima e tambÃ©m diretamente por nlp.py

async def processar_comando(dados: dict) -> dict:
    """
    Processa comandos especÃ­ficos vindos da interaÃ§Ã£o do usuÃ¡rio ou da IA.

    Args:
        dados (dict): DicionÃ¡rio contendo 'telefone', 'nome' e 'comando'.

    Returns:
        dict: DicionÃ¡rio com o status da operaÃ§Ã£o e mensagens relevantes.
    """
    telefone = dados.get("telefone")
    nome = dados.get("nome", "Cliente") # Usa 'Cliente' como nome padrÃ£o
    comando = dados.get("comando", "").lower() # Pega o comando e converte para minÃºsculas

    # ValidaÃ§Ã£o bÃ¡sica de entrada
    if not telefone or not comando:
        logging.warning("IA Route: Comando recebido sem telefone ou comando.")
        # Retorna um erro ou uma resposta padrÃ£o indicando falha
        # NÃ£o levanta HTTPException aqui pois pode ser chamado internamente por nlp.py
        return {"status": "erro_input", "mensagem": "Dados insuficientes para processar comando."}

    logging.info(f"IA Route: Processando comando '{comando}' para {telefone} ({nome})...")

    # --- LÃ³gica para Comando "agendar" ---
    if "agendar" in comando:
        # Verifica novamente se Stripe estÃ¡ configurado
        if not STRIPE_SECRET_KEY:
            logging.error("IA Route: âŒ Tentativa de agendamento sem STRIPE_SECRET_KEY configurada.")
            msg_erro = "Desculpe, a opÃ§Ã£o de agendamento online nÃ£o estÃ¡ disponÃ­vel no momento."
            # NÃ£o envia mensagem aqui, pois nlp.py tratarÃ¡ a resposta
            # await enviar_mensagem(telefone, msg_erro)
            return {"status": "erro_config_stripe", "mensagem": msg_erro}

        # TODO: Descomentar se a funÃ§Ã£o iniciar_sessao for usada para tracking
        # Inicia a sessÃ£o de pagamento/follow-up (se aplicÃ¡vel)
        # iniciar_sessao(telefone, nome) # Registra a tentativa no DB de follow-up

        try:
            # Cria uma sessÃ£o de checkout no Stripe
            logging.info(f"IA Route: Criando sessÃ£o Stripe Checkout para {telefone}...")
            # Define o URL base (pode vir do .env)
            base_url = os.getenv("APP_BASE_URL", "[https://famdomes.com.br](https://famdomes.com.br)") # Exemplo
            success_url = f"{base_url}/sucesso?session_id={{CHECKOUT_SESSION_ID}}"
            cancel_url = f"{base_url}/cancelado"

            session = stripe.checkout.Session.create(
                payment_method_types=["card", "boleto"], # Aceita cartÃ£o e boleto
                line_items=[{
                    "price_data": {
                        "currency": "brl", # Moeda brasileira
                        "product_data": {"name": "Consulta Inicial FAMDOMES"}, # Nome do produto
                        "unit_amount": 10000, # PreÃ§o em centavos (R$ 100,00)
                    },
                    "quantity": 1, # Quantidade
                }],
                mode="payment", # Modo de pagamento Ãºnico
                # URLs para redirecionamento apÃ³s sucesso ou cancelamento
                success_url=success_url,
                cancel_url=cancel_url,
                # Metadados para identificar o cliente no webhook
                metadata={
                    "telefone": telefone,
                    "nome": nome
                },
                # ConfiguraÃ§Ã£o para Boleto (opcional, mas recomendada)
                payment_intent_data={
                     # 'setup_future_usage': 'off_session' # Pode nÃ£o ser necessÃ¡rio para pagamentos Ãºnicos
                },
                # ExpiraÃ§Ã£o da sessÃ£o de checkout (ex: 2 horas)
                expires_at=int((datetime.now() + timedelta(hours=2)).timestamp())
            )
            logging.info(f"IA Route: SessÃ£o Stripe criada com ID: {session.id} para {telefone}")

            # Monta a mensagem com o link de pagamento para o usuÃ¡rio
            msg_link = f"âœ… Ã“timo! Para agendar sua consulta inicial (valor R$100,00), por favor, realize o pagamento seguro atravÃ©s deste link:\n{session.url}\n\nO link expira em breve."
            # A mensagem serÃ¡ enviada por nlp.py, aqui apenas retornamos os dados
            # await enviar_mensagem(telefone, msg_link)
            # Retorna o status e a URL de checkout
            return {"status": "link_gerado", "checkout_url": session.url, "mensagem": msg_link}

        except stripe.error.StripeError as e:
             # Erro especÃ­fico do Stripe
             logging.error(f"IA Route: âŒ Erro Stripe ao criar checkout para {telefone}: {e}")
             msg_erro = "âŒ Desculpe, ocorreu um erro ao tentar gerar o link de pagamento com nosso parceiro. Por favor, tente novamente mais tarde ou entre em contato conosco."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_stripe", "mensagem": msg_erro}
        except Exception as e:
             # Outro erro inesperado
             logging.exception(f"IA Route: âŒ Erro inesperado ao criar checkout para {telefone}:")
             msg_erro = "âŒ Desculpe, ocorreu um erro inesperado ao gerar seu link de pagamento. Tente novamente mais tarde."
             # await enviar_mensagem(telefone, msg_erro)
             return {"status": "erro_desconhecido", "mensagem": msg_erro}

    # --- LÃ³gica para Comando "cancelar" ---
    elif "cancelar" in comando:
        logging.info(f"IA Route: Processando cancelamento de consulta para {telefone}...")
        # Chama a funÃ§Ã£o para cancelar consultas futuras
        # TODO: Implementar a funÃ§Ã£o cancelar_consulta em utils/agenda.py
        consultas_canceladas = cancelar_consulta(telefone) # Assume que retorna int
        if consultas_canceladas > 0:
            msg = f"âœ… Sua(s) {consultas_canceladas} consulta(s) futura(s) foi(ram) cancelada(s) com sucesso."
            # await enviar_mensagem(telefone, msg)
            return {"status": "consulta_cancelada", "quantidade": consultas_canceladas, "mensagem": msg}
        else:
            msg = "NÃ£o encontrei nenhuma consulta futura agendada para cancelar em seu nome."
            # await enviar_mensagem(telefone, msg)
            return {"status": "nenhuma_consulta_encontrada", "mensagem": msg}

    # --- LÃ³gica para Comando "horÃ¡rio" ou "disponÃ­vel" ---
    elif "horÃ¡rio" in comando or "disponÃ­vel" in comando or "disponivel" in comando:
        logging.info(f"IA Route: Consultando prÃ³ximo horÃ¡rio disponÃ­vel para {telefone}...")
        # Chama a funÃ§Ã£o para consultar o prÃ³ximo horÃ¡rio livre
        # TODO: Implementar consultar_proximo_horario_disponivel e formatar_horario_local em utils/agenda.py
        proximo_horario_utc = consultar_proximo_horario_disponivel() # Assume que retorna datetime UTC ou None
        if proximo_horario_utc:
            # Formata o horÃ¡rio para o fuso local antes de enviar
            horario_formatado = formatar_horario_local(proximo_horario_utc, 'America/Sao_Paulo') # Exemplo de fuso
            msg = f"ðŸ“… O prÃ³ximo horÃ¡rio disponÃ­vel para agendamento Ã©: {horario_formatado} (HorÃ¡rio de BrasÃ­lia)."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_enviado", "horario_utc": proximo_horario_utc.isoformat(), "horario_formatado": horario_formatado, "mensagem": msg}
        else:
            msg = "ðŸ“… Desculpe, nÃ£o consegui encontrar um horÃ¡rio disponÃ­vel no momento. Por favor, tente novamente mais tarde."
            # await enviar_mensagem(telefone, msg)
            return {"status": "horario_indisponivel", "mensagem": msg}

    # --- Comando Desconhecido ---
    else:
        logging.warning(f"IA Route: Comando IA desconhecido recebido de {telefone}: '{comando}'")
        # Mensagem padrÃ£o para comandos nÃ£o reconhecidos
        msg = "ðŸ¤– Desculpe, nÃ£o entendi o que vocÃª deseja fazer. VocÃª pode me pedir para 'agendar consulta', 'cancelar consulta' ou 'ver prÃ³ximo horÃ¡rio disponÃ­vel'."
        # await enviar_mensagem(telefone, msg)
        return {"status": "comando_desconhecido", "mensagem": msg}

# Adicionar import timedelta se nÃ£o estiver presente
from datetime import timedelta


# Arquivo: ./routes/followup.py
# routes/followup.py

from fastapi import APIRouter
from utils.followup import checar_followup

router = APIRouter()

@router.get("/verificar-followup")
def verificar():
    mensagens = checar_followup()
    return {"mensagens": mensagens}

# Arquivo: ./main.py
# ===========================================================
# Arquivo: main.py
# (Ponto de entrada da aplicaÃ§Ã£o FastAPI - Corrigido)
# ===========================================================
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
import time # Para medir tempo de resposta
import sys # Para verificar o caminho

# Adiciona o diretÃ³rio pai ao sys.path para garantir imports corretos
# Isso Ã© Ãºtil se vocÃª executar uvicorn de dentro do diretÃ³rio 'app'
# import os
# sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Importa configuraÃ§Ãµes (executa o logging inicial de config.py)
# Assume que config.py estÃ¡ em app/config.py ou ajusta o import
try:
    from app.config import API_KEY
except ModuleNotFoundError:
     # Tenta importar como se estivesse na raiz
     from config import API_KEY


# Importa os roteadores dos diferentes mÃ³dulos
# Garante que todos os roteadores usados estÃ£o importados
try:
    from app.routes import whatsapp, ia, stripe, agendamento #, painel, resetar # Adicionar outros conforme necessÃ¡rio
except ModuleNotFoundError:
    # Tenta importar como se estivesse na raiz
    from routes import whatsapp, ia, stripe, agendamento

# ConfiguraÃ§Ã£o do Logging (pode ser feita aqui centralmente)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s')
# Define um logger especÃ­fico para a aplicaÃ§Ã£o principal
logger = logging.getLogger(__name__)

# Cria a instÃ¢ncia da aplicaÃ§Ã£o FastAPI
app = FastAPI(
    title="FAMDOMES API",
    description="API para gerenciar o chatbot FAMDOMES via WhatsApp, IA e pagamentos.",
    version="1.0.0"
)

# --- Middlewares ---

# Middleware CORS (Cross-Origin Resource Sharing) - Permite acesso de diferentes origens (ex: frontend)
# Ajuste as origins permitidas conforme necessÃ¡rio
origins = [
    "http://localhost",
    "http://localhost:3000", # Exemplo para frontend React/Vue
    "https://famdomes.com.br", # DomÃ­nio de produÃ§Ã£o
    # Adicionar outros domÃ­nios permitidos
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"], # Permite todos os mÃ©todos (GET, POST, etc.)
    allow_headers=["*"], # Permite todos os cabeÃ§alhos
)

# Middleware para logar requisiÃ§Ãµes e medir tempo de resposta
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    logger.info(f"RequisiÃ§Ã£o recebida: {request.method} {request.url.path}")
    try:
        response = await call_next(request)
        process_time = time.time() - start_time
        logger.info(f"RequisiÃ§Ã£o concluÃ­da: {request.method} {request.url.path} - Status: {response.status_code} - Tempo: {process_time:.4f}s")
    except Exception as e:
         process_time = time.time() - start_time
         logger.exception(f"Erro durante requisiÃ§Ã£o {request.method} {request.url.path} apÃ³s {process_time:.4f}s:")
         # Retorna uma resposta de erro genÃ©rica para nÃ£o expor detalhes
         response = JSONResponse(status_code=500, content={"detail": "Erro interno no servidor"})
    return response


# Middleware de AutenticaÃ§Ã£o por Chave de API (Opcional - Descomentar para ativar)
# @app.middleware("http")
# async def autenticar_chave_api(request: Request, call_next):
#     path = str(request.url.path)
#     # Lista de rotas pÃºblicas que nÃ£o exigem chave de API
#     rotas_publicas = [
#         "/docs", # DocumentaÃ§Ã£o Swagger/OpenAPI
#         "/openapi.json",
#         "/chat/webhook/whatsapp/", # Webhook do WhatsApp
#         "/webhook/stripe/", # Webhook do Stripe
#         "/agenda/proximo", # Endpoint pÃºblico de agendamento
#         # Adicionar outras rotas pÃºblicas se houver (ex: /health)
#     ]
#     # Verifica se a rota atual comeÃ§a com algum dos prefixos pÃºblicos
#     is_public = any(path.startswith(public_path) for public_path in rotas_publicas)
#     is_root = path == "/"
#     # Se for rota pÃºblica ou a raiz, permite o acesso sem chave
#     if is_public or is_root:
#         response = await call_next(request)
#         return response
#     # Para rotas nÃ£o pÃºblicas, verifica a chave de API no cabeÃ§alho
#     chave_recebida = request.headers.get("X-API-Key") # Nome do cabeÃ§alho
#     if not API_KEY:
#          logger.warning("API_KEY nÃ£o configurada no servidor, mas autenticaÃ§Ã£o estÃ¡ ativa.")
#          response = await call_next(request) # Permite por enquanto, mas loga
#          return response
#     if chave_recebida != API_KEY:
#         logger.warning(f"Acesso negado para {request.method} {path}. Chave API invÃ¡lida ou ausente.")
#         return JSONResponse(status_code=403, content={"detail": "Acesso nÃ£o autorizado"})
#     # Se a chave for vÃ¡lida, processa a requisiÃ§Ã£o
#     logger.debug(f"Acesso autorizado com chave API para {request.method} {path}")
#     response = await call_next(request)
#     return response

# --- InclusÃ£o dos Roteadores ---
# Inclui os roteadores definidos nos arquivos de rotas
# Garante que todos os roteadores necessÃ¡rios estÃ£o incluÃ­dos
logger.info("Incluindo roteadores...")
try:
    app.include_router(whatsapp.router) # Roteador para /chat/webhook/whatsapp/
    logger.info(" - Roteador WhatsApp incluÃ­do.")
    app.include_router(ia.router)       # Roteador para /ia-comando (e outros de IA)
    logger.info(" - Roteador IA incluÃ­do.")
    app.include_router(stripe.router)   # Roteador para /webhook/stripe/
    logger.info(" - Roteador Stripe incluÃ­do.")
    app.include_router(agendamento.router) # Roteador para /agenda/proximo
    logger.info(" - Roteador Agendamento incluÃ­do.")
    # Adicione outros roteadores aqui, se criados e importados:
    # app.include_router(painel.router)
    # logger.info(" - Roteador Painel incluÃ­do.")
    # app.include_router(resetar.router)
    # logger.info(" - Roteador Resetar incluÃ­do.")
    logger.info("Roteadores incluÃ­dos com sucesso.")
except NameError as e:
     logger.error(f"Erro ao incluir roteadores: Roteador nÃ£o importado corretamente? {e}")
     # Levantar exceÃ§Ã£o pode ser apropriado aqui para impedir inicializaÃ§Ã£o incompleta
     # raise e
except Exception as e:
     logger.exception("Erro inesperado ao incluir roteadores:")
     # raise e


# --- Rota Raiz (Opcional) ---
@app.get("/", tags=["Root"], summary="Verifica status da API")
async def read_root():
    """ Rota raiz simples para verificar se a API estÃ¡ online. """
    return {"message": "Bem-vindo Ã  API FAMDOMES!"}

# --- ExecuÃ§Ã£o (se rodar diretamente com uvicorn main:app) ---
# if __name__ == "__main__":
#     import uvicorn
#     logger.info("Iniciando servidor Uvicorn diretamente...")
#     uvicorn.run(app, host="0.0.0.0", port=8000)


# Arquivo: ./models/pagamentos.py
from pydantic import BaseModel

class PagamentoRequest(BaseModel):
    produto_id: str
    email: str
    telefone: str
    redirect_url: str

# Arquivo: ./models/atendimento.py
from pydantic import BaseModel

class MensagemIA(BaseModel):
    mensagem: str
    paciente_id: str
    canal: str

# Arquivo: ./models/leads.py
from pydantic import BaseModel
from typing import Optional, Dict
from datetime import datetime

class Lead(BaseModel):
    paciente_id: str
    canal: str
    mensagem_original: str
    intent: str
    entidades: Dict
    risco: bool
    timestamp: datetime
    tipo: Optional[str] = "desconhecido"

# Arquivo: ./config.py
# ===========================================================
# Arquivo: config.py
# (Baseado no arquivo original fornecido)
# ===========================================================
import os
from dotenv import load_dotenv
import logging # Adicionado para logar carregamento

# Carrega variÃ¡veis de ambiente do arquivo .env
load_dotenv()

# --- ConfiguraÃ§Ãµes do Banco de Dados ---
MONGO_URI = os.getenv("MONGO_URI") # String de conexÃ£o do MongoDB

# --- ConfiguraÃ§Ãµes de Pagamento (Stripe) ---
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY") # Chave secreta do Stripe
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET") # Chave secreta do webhook do Stripe

# --- ConfiguraÃ§Ãµes da IA (Ollama) ---
OLLAMA_API_URL = os.getenv("OLLAMA_API_URL", "http://localhost:11434") # URL base da API do Ollama (com default)
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "gemma3") # Modelo padrÃ£o do Ollama a ser usado

# --- ConfiguraÃ§Ãµes da API Interna ---
API_KEY = os.getenv("API_KEY") # Chave para proteger endpoints internos da API (se houver)

# --- ConfiguraÃ§Ãµes do WhatsApp Cloud API ---
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL") # URL da API do WhatsApp (ex: https://graph.facebook.com/v19.0/MEU_PHONE_ID/messages)
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN") # Token de acesso permanente ou temporÃ¡rio da API
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN") # Token de verificaÃ§Ã£o do webhook do WhatsApp
WHATSAPP_FAMILIAR = os.getenv("WHATSAPP_FAMILIAR") # NÃºmero de telefone para receber alertas de risco (formato internacional)

# --- ConfiguraÃ§Ãµes do RocketChat (Opcional, se usado para escalaÃ§Ã£o) ---
ROCKETCHAT_URL = os.getenv("ROCKETCHAT_URL") # URL da instÃ¢ncia do RocketChat
ROCKETCHAT_TOKEN = os.getenv("ROCKETCHAT_TOKEN") # Token de API do RocketChat
ROCKETCHAT_USER_ID = os.getenv("ROCKETCHAT_USER_ID") # ID do usuÃ¡rio bot no RocketChat

# --- ConfiguraÃ§Ãµes do Google (Opcional, se usado para OAuth ou outras APIs) ---
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

# --- DiretÃ³rio Base da AplicaÃ§Ã£o ---
# ObtÃ©m o diretÃ³rio onde este arquivo config.py estÃ¡ localizado
# Ãštil para construir caminhos para outros arquivos (ex: prompts)
# Ajuste o __file__ se a estrutura for diferente (ex: app/config.py)
try:
    # Assume que este arquivo estÃ¡ em app/config.py
    # BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # DiretÃ³rio pai (app)
    # Ou se estiver na raiz do projeto:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
except NameError:
    # Fallback se __file__ nÃ£o estiver definido (ex: execuÃ§Ã£o interativa)
    BASE_DIR = os.getcwd()


# --- ValidaÃ§Ãµes e Logging ---
# ConfiguraÃ§Ã£o bÃ¡sica de logging (pode ser movida para main.py)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

print("Carregando configuraÃ§Ãµes...") # Usar logging.info seria melhor
logging.info("Carregando configuraÃ§Ãµes...")

# ValidaÃ§Ãµes essenciais
essential_vars = {
    "MONGO_URI": MONGO_URI,
    "OLLAMA_API_URL": OLLAMA_API_URL,
    "WHATSAPP_API_URL": WHATSAPP_API_URL,
    "WHATSAPP_TOKEN": WHATSAPP_TOKEN,
    "WHATSAPP_VERIFY_TOKEN": WHATSAPP_VERIFY_TOKEN,
    "STRIPE_SECRET_KEY": STRIPE_SECRET_KEY,
    "STRIPE_WEBHOOK_SECRET": STRIPE_WEBHOOK_SECRET,
}

missing_vars = [name for name, value in essential_vars.items() if not value]
if missing_vars:
    logging.error(f"âŒ ERRO FATAL: VariÃ¡veis de ambiente essenciais nÃ£o definidas: {', '.join(missing_vars)}")
    # Considerar levantar uma exceÃ§Ã£o para impedir a inicializaÃ§Ã£o da aplicaÃ§Ã£o
    # raise ValueError(f"VariÃ¡veis de ambiente essenciais nÃ£o definidas: {', '.join(missing_vars)}")
else:
    logging.info("âœ… VariÃ¡veis de ambiente essenciais carregadas.")

# Log informativo das configuraÃ§Ãµes (sem expor segredos completos)
logging.info(f" - MONGO_URI: {'Definido' if MONGO_URI else 'NÃ£o definido'}")
logging.info(f" - OLLAMA_API_URL: {OLLAMA_API_URL}")
logging.info(f" - OLLAMA_MODEL: {OLLAMA_MODEL}")
logging.info(f" - WHATSAPP_API_URL: {'Definido' if WHATSAPP_API_URL else 'NÃ£o definido'}")
logging.info(f" - WHATSAPP_TOKEN: {'Definido' if WHATSAPP_TOKEN else 'NÃ£o definido'}")
logging.info(f" - WHATSAPP_VERIFY_TOKEN: {'Definido' if WHATSAPP_VERIFY_TOKEN else 'NÃ£o definido'}")
logging.info(f" - WHATSAPP_FAMILIAR: {WHATSAPP_FAMILIAR if WHATSAPP_FAMILIAR else 'NÃ£o definido'}")
logging.info(f" - STRIPE_SECRET_KEY: {'Definido' if STRIPE_SECRET_KEY else 'NÃ£o definido'}")
logging.info(f" - STRIPE_WEBHOOK_SECRET: {'Definido' if STRIPE_WEBHOOK_SECRET else 'NÃ£o definido'}")
logging.info(f" - BASE_DIR: {BASE_DIR}")

